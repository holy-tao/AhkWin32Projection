#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.UI.WindowsAndMessaging
 * @version v4.0.30319
 */
class WindowsAndMessaging {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CONTEXTMENU => 123

    /**
     * @type {Integer (UInt32)}
     */
    static WM_UNICHAR => 265

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PRINTCLIENT => 792

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NOTIFY => 78

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_CHANGE => "{7373654a-812a-11d0-bec7-08002be2092f}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_DISMOUNT => "{d16a55e8-1059-11d2-8ffd-00a0c9a06d32}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_DISMOUNT_FAILED => "{e3c5b178-105d-11d2-8ffd-00a0c9a06d32}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_MOUNT => "{b5804878-1a96-11d2-8ffd-00a0c9a06d32}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_LOCK => "{50708874-c9af-11d1-8fef-00a0c9a06d32}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_LOCK_FAILED => "{ae2eed10-0ba8-11d2-8ffb-00a0c9a06d32}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_UNLOCK => "{9a8c3d68-d0cb-11d1-8fef-00a0c9a06d32}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_NAME_CHANGE => "{2de97f83-4c06-11d2-a532-00609713055a}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_NEED_CHKDSK => "{799a0960-0a0b-4e03-ad88-2fa7c6ce748a}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_WORM_NEAR_FULL => "{f3bfff82-f3de-48d2-af95-457f80b763f2}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_WEARING_OUT => "{873113ca-1486-4508-82ac-c3b2e5297aaa}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_FORCE_CLOSED => "{411ad84f-433e-4dc2-a5ae-4a2d1a2de654}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_INFO_MAKE_COMPAT => "{3ab9a0d2-ef80-45cf-8cdc-cbe02a212906}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_PREPARING_EJECT => "{c79eb16e-0dac-4e7a-a86c-b25ceeaa88f6}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_BACKGROUND_FORMAT => "{a2e5fc86-d5cd-4038-b2e3-4445065c2377}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE => "{2de97f84-4c06-11d2-a532-00609713055a}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_UNIQUE_ID_CHANGE => "{af39da42-6622-41f5-970b-139d092fa3d9}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_FVE_STATUS_CHANGE => "{062998b2-ee1f-4b6a-b857-e76cbbe9a6da}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_DEVICE_INTERFACE => "{53f5630d-b6bf-11d0-94f2-00a0c91efb8b}"

    /**
     * @type {String}
     */
    static GUID_IO_VOLUME_CHANGE_SIZE => "{3a1625be-ad03-49f1-8ef8-6bbac182d1fd}"

    /**
     * @type {String}
     */
    static GUID_IO_MEDIA_ARRIVAL => "{d07433c0-a98e-11d2-917a-00a0c9068ff3}"

    /**
     * @type {String}
     */
    static GUID_IO_MEDIA_REMOVAL => "{d07433c1-a98e-11d2-917a-00a0c9068ff3}"

    /**
     * @type {String}
     */
    static GUID_IO_CDROM_EXCLUSIVE_LOCK => "{bc56c139-7a10-47ee-a294-4c6a38f0149a}"

    /**
     * @type {String}
     */
    static GUID_IO_CDROM_EXCLUSIVE_UNLOCK => "{a3b6d27d-5e35-4885-81e5-ee18c00ed779}"

    /**
     * @type {String}
     */
    static GUID_IO_DEVICE_BECOMING_READY => "{d07433f0-a98e-11d2-917a-00a0c9068ff3}"

    /**
     * @type {String}
     */
    static GUID_IO_DEVICE_EXTERNAL_REQUEST => "{d07433d0-a98e-11d2-917a-00a0c9068ff3}"

    /**
     * @type {String}
     */
    static GUID_IO_MEDIA_EJECT_REQUEST => "{d07433d1-a98e-11d2-917a-00a0c9068ff3}"

    /**
     * @type {String}
     */
    static GUID_IO_DRIVE_REQUIRES_CLEANING => "{7207877c-90ed-44e5-a000-81428d4c79bb}"

    /**
     * @type {String}
     */
    static GUID_IO_TAPE_ERASE => "{852d11eb-4bb8-4507-9d9b-417cc2b1b438}"

    /**
     * @type {String}
     */
    static GUID_DEVICE_EVENT_RBC => "{d0744792-a98e-11d2-917a-00a0c9068ff3}"

    /**
     * @type {String}
     */
    static GUID_IO_DISK_CLONE_ARRIVAL => "{6a61885b-7c39-43dd-9b56-b8ac22a549aa}"

    /**
     * @type {String}
     */
    static GUID_IO_DISK_LAYOUT_CHANGE => "{11dff54c-8469-41f9-b3de-ef836487c54a}"

    /**
     * @type {String}
     */
    static GUID_IO_DISK_HEALTH_NOTIFICATION => "{0f1bd644-3916-49c5-b063-991940118fb2}"

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_USE_SECURE_CRT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_MAX_CCH => 2147483647

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_MAX_LENGTH => 2147483646

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_IGNORE_NULLS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_FILL_BEHIND_NULL => 512

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_FILL_ON_FAILURE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_NULL_ON_FAILURE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static STRSAFE_NO_TRUNCATION => 4096

    /**
     * @type {Integer (Int32)}
     */
    static STRSAFE_E_INSUFFICIENT_BUFFER => -2147024774

    /**
     * @type {Integer (Int32)}
     */
    static STRSAFE_E_INVALID_PARAMETER => -2147024809

    /**
     * @type {Integer (Int32)}
     */
    static STRSAFE_E_END_OF_FILE => -2147024858

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_CYCLOMATIC_COMPLEXITY => 28734

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_USING_UNINIT_VAR => 6001

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_RETURN_UNINIT_VAR => 6101

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_DEREF_NULL_PTR => 6011

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_MISSING_ZERO_TERMINATION2 => 6054

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_INVALID_PARAM_VALUE_1 => 6387

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_INCORRECT_ANNOTATION => 26007

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_POTENTIAL_BUFFER_OVERFLOW_HIGH_PRIORITY => 26015

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_PRECONDITION_NULLTERMINATION_VIOLATION => 26035

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_POSTCONDITION_NULLTERMINATION_VIOLATION => 26036

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION => 26045

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_RANGE_POSTCONDITION_VIOLATION => 26061

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION => 26071

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_INVALID_PARAM_VALUE_3 => 28183

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_RETURNING_BAD_RESULT => 28196

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_BANNED_API_USAGE => 28719

    /**
     * @type {Integer (UInt32)}
     */
    static __WARNING_POST_EXPECTED => 28210

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DEVICECHANGE => 537

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_MSGSRV32ISOK => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static BSF_MSGSRV32ISOK_BIT => 31

    /**
     * @type {Integer (UInt32)}
     */
    static BSM_VXDS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BSM_NETDRIVER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BSM_INSTALLABLEDRIVERS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_APPYBEGIN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_APPYEND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVNODES_CHANGED => 7

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_QUERYCHANGECONFIG => 23

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_CONFIGCHANGED => 24

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_CONFIGCHANGECANCELED => 25

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_MONITORCHANGE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_SHELLLOGGEDON => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_CONFIGMGAPI32 => 34

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VXDINITCOMPLETE => 35

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VOLLOCKQUERYLOCK => 32833

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VOLLOCKLOCKTAKEN => 32834

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VOLLOCKLOCKFAILED => 32835

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VOLLOCKQUERYUNLOCK => 32836

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VOLLOCKLOCKRELEASED => 32837

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VOLLOCKUNLOCKFAILED => 32838

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKP_ALLOW_WRITES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKP_FAIL_WRITES => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKP_FAIL_MEM_MAPPING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKP_ALLOW_MEM_MAPPING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKP_USER_MASK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKP_LOCK_FOR_FORMAT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKF_LOGICAL_LOCK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LOCKF_PHYSICAL_LOCK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_NO_DISK_SPACE => 71

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_LOW_DISK_SPACE => 72

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_CONFIGMGPRIVATE => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVICEARRIVAL => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVICEQUERYREMOVE => 32769

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVICEQUERYREMOVEFAILED => 32770

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVICEREMOVEPENDING => 32771

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVICEREMOVECOMPLETE => 32772

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVICETYPESPECIFIC => 32773

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_CUSTOMEVENT => 32774

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVTYP_DEVNODE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_DEVTYP_NET => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBTF_RESOURCE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DBTF_XPORT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DBTF_SLOWNET => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_VPOWERDAPI => 33024

    /**
     * @type {Integer (UInt32)}
     */
    static DBT_USERDEFINED => 65535

    /**
     * @type {Integer (UInt16)}
     */
    static RT_CURSOR => 1

    /**
     * @type {Integer (UInt16)}
     */
    static RT_BITMAP => 2

    /**
     * @type {Integer (UInt16)}
     */
    static RT_ICON => 3

    /**
     * @type {Integer (UInt16)}
     */
    static RT_MENU => 4

    /**
     * @type {Integer (UInt16)}
     */
    static RT_DIALOG => 5

    /**
     * @type {Integer (UInt16)}
     */
    static RT_FONTDIR => 7

    /**
     * @type {Integer (UInt16)}
     */
    static RT_FONT => 8

    /**
     * @type {Integer (UInt16)}
     */
    static RT_ACCELERATOR => 9

    /**
     * @type {Integer (UInt16)}
     */
    static RT_MESSAGETABLE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static DIFFERENCE => 11

    /**
     * @type {Integer (UInt16)}
     */
    static RT_VERSION => 16

    /**
     * @type {Integer (UInt16)}
     */
    static RT_DLGINCLUDE => 17

    /**
     * @type {Integer (UInt16)}
     */
    static RT_PLUGPLAY => 19

    /**
     * @type {Integer (UInt16)}
     */
    static RT_VXD => 20

    /**
     * @type {Integer (UInt16)}
     */
    static RT_ANICURSOR => 21

    /**
     * @type {Integer (UInt16)}
     */
    static RT_ANIICON => 22

    /**
     * @type {Integer (UInt16)}
     */
    static RT_HTML => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CREATEPROCESS_MANIFEST_RESOURCE_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISOLATIONAWARE_MANIFEST_RESOURCE_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ISOLATIONPOLICY_MANIFEST_RESOURCE_ID => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ISOLATIONPOLICY_BROWSER_MANIFEST_RESOURCE_ID => 5

    /**
     * @type {Integer (UInt32)}
     */
    static MINIMUM_RESERVED_MANIFEST_RESOURCE_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static HIDE_WINDOW => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SHOW_OPENWINDOW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHOW_ICONWINDOW => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SHOW_FULLSCREEN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SHOW_OPENNOACTIVATE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static KF_EXTENDED => 256

    /**
     * @type {Integer (UInt32)}
     */
    static KF_DLGMODE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static KF_MENUMODE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static KF_ALTDOWN => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static KF_REPEAT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static KF_UP => 32768

    /**
     * @type {Integer (Int32)}
     */
    static WH_MIN => -1

    /**
     * @type {Integer (UInt32)}
     */
    static WH_HARDWARE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static WH_MAX => 14

    /**
     * @type {Integer (Int32)}
     */
    static WH_MINHOOK => -1

    /**
     * @type {Integer (UInt32)}
     */
    static WH_MAXHOOK => 14

    /**
     * @type {Integer (UInt32)}
     */
    static HC_ACTION => 0

    /**
     * @type {Integer (UInt32)}
     */
    static HC_GETNEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static HC_SKIP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HC_NOREMOVE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static HC_NOREM => 3

    /**
     * @type {Integer (UInt32)}
     */
    static HC_SYSMODALON => 4

    /**
     * @type {Integer (UInt32)}
     */
    static HC_SYSMODALOFF => 5

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_MOVESIZE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_MINMAX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_QS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_CREATEWND => 3

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_DESTROYWND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_ACTIVATE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_CLICKSKIPPED => 6

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_KEYSKIPPED => 7

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_SYSCOMMAND => 8

    /**
     * @type {Integer (UInt32)}
     */
    static HCBT_SETFOCUS => 9

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_CONSOLE_CONNECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_CONSOLE_DISCONNECT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_REMOTE_CONNECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_REMOTE_DISCONNECT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_SESSION_LOGON => 5

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_SESSION_LOGOFF => 6

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_SESSION_LOCK => 7

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_SESSION_UNLOCK => 8

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_SESSION_REMOTE_CONTROL => 9

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_SESSION_CREATE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static WTS_SESSION_TERMINATE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static MSGF_DIALOGBOX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MSGF_MESSAGEBOX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MSGF_MENU => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MSGF_SCROLLBAR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static MSGF_NEXTWINDOW => 6

    /**
     * @type {Integer (UInt32)}
     */
    static MSGF_MAX => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MSGF_USER => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_WINDOWCREATED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_WINDOWDESTROYED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_ACTIVATESHELLWINDOW => 3

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_WINDOWACTIVATED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_GETMINRECT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_REDRAW => 6

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_TASKMAN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_LANGUAGE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_SYSMENU => 9

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_ENDTASK => 10

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_ACCESSIBILITYSTATE => 11

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_APPCOMMAND => 12

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_WINDOWREPLACED => 13

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_WINDOWREPLACING => 14

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_MONITORCHANGED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static HSHELL_HIGHBIT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FAPPCOMMAND_MOUSE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static FAPPCOMMAND_KEY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FAPPCOMMAND_OEM => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static FAPPCOMMAND_MASK => 61440

    /**
     * @type {Integer (UInt32)}
     */
    static LLMHF_INJECTED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LLMHF_LOWER_IL_INJECTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HKL_PREV => 0

    /**
     * @type {Integer (UInt32)}
     */
    static HKL_NEXT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INPUTLANGCHANGE_SYSCHARSET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INPUTLANGCHANGE_FORWARD => 2

    /**
     * @type {Integer (UInt32)}
     */
    static INPUTLANGCHANGE_BACKWARD => 4

    /**
     * @type {Integer (UInt32)}
     */
    static KL_NAMELENGTH => 9

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_ENUMDESKTOPS => 1

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_READATTRIBUTES => 2

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_ACCESSCLIPBOARD => 4

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_CREATEDESKTOP => 8

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_WRITEATTRIBUTES => 16

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_ACCESSGLOBALATOMS => 32

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_EXITWINDOWS => 64

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_ENUMERATE => 256

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_READSCREEN => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CWF_CREATE_ONLY => 1

    /**
     * @type {Integer (Int32)}
     */
    static WSF_VISIBLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UOI_TIMERPROC_EXCEPTION_SUPPRESSION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NULL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CREATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DESTROY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOVE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SIZE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ACTIVATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static WA_INACTIVE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WA_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WA_CLICKACTIVE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETFOCUS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static WM_KILLFOCUS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ENABLE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETREDRAW => 11

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETTEXT => 12

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETTEXT => 13

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETTEXTLENGTH => 14

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PAINT => 15

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CLOSE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static WM_QUERYENDSESSION => 17

    /**
     * @type {Integer (UInt32)}
     */
    static WM_QUERYOPEN => 19

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ENDSESSION => 22

    /**
     * @type {Integer (UInt32)}
     */
    static WM_QUIT => 18

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ERASEBKGND => 20

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SYSCOLORCHANGE => 21

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SHOWWINDOW => 24

    /**
     * @type {Integer (UInt32)}
     */
    static WM_WININICHANGE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETTINGCHANGE => 26

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DEVMODECHANGE => 27

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ACTIVATEAPP => 28

    /**
     * @type {Integer (UInt32)}
     */
    static WM_FONTCHANGE => 29

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TIMECHANGE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CANCELMODE => 31

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETCURSOR => 32

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOUSEACTIVATE => 33

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CHILDACTIVATE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static WM_QUEUESYNC => 35

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETMINMAXINFO => 36

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PAINTICON => 38

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ICONERASEBKGND => 39

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NEXTDLGCTL => 40

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SPOOLERSTATUS => 42

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DRAWITEM => 43

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MEASUREITEM => 44

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DELETEITEM => 45

    /**
     * @type {Integer (UInt32)}
     */
    static WM_VKEYTOITEM => 46

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CHARTOITEM => 47

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETFONT => 48

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETFONT => 49

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETHOTKEY => 50

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETHOTKEY => 51

    /**
     * @type {Integer (UInt32)}
     */
    static WM_QUERYDRAGICON => 55

    /**
     * @type {Integer (UInt32)}
     */
    static WM_COMPAREITEM => 57

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETOBJECT => 61

    /**
     * @type {Integer (UInt32)}
     */
    static WM_COMPACTING => 65

    /**
     * @type {Integer (UInt32)}
     */
    static WM_COMMNOTIFY => 68

    /**
     * @type {Integer (UInt32)}
     */
    static WM_WINDOWPOSCHANGING => 70

    /**
     * @type {Integer (UInt32)}
     */
    static WM_WINDOWPOSCHANGED => 71

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POWER => 72

    /**
     * @type {Integer (UInt32)}
     */
    static PWR_OK => 1

    /**
     * @type {Integer (Int32)}
     */
    static PWR_FAIL => -1

    /**
     * @type {Integer (UInt32)}
     */
    static PWR_SUSPENDREQUEST => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PWR_SUSPENDRESUME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PWR_CRITICALRESUME => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WM_COPYDATA => 74

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CANCELJOURNAL => 75

    /**
     * @type {Integer (UInt32)}
     */
    static WM_INPUTLANGCHANGEREQUEST => 80

    /**
     * @type {Integer (UInt32)}
     */
    static WM_INPUTLANGCHANGE => 81

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TCARD => 82

    /**
     * @type {Integer (UInt32)}
     */
    static WM_HELP => 83

    /**
     * @type {Integer (UInt32)}
     */
    static WM_USERCHANGED => 84

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NOTIFYFORMAT => 85

    /**
     * @type {Integer (UInt32)}
     */
    static NFR_ANSI => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NFR_UNICODE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NF_QUERY => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NF_REQUERY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WM_STYLECHANGING => 124

    /**
     * @type {Integer (UInt32)}
     */
    static WM_STYLECHANGED => 125

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DISPLAYCHANGE => 126

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETICON => 127

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SETICON => 128

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCCREATE => 129

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCDESTROY => 130

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCCALCSIZE => 131

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCHITTEST => 132

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCPAINT => 133

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCACTIVATE => 134

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETDLGCODE => 135

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SYNCPAINT => 136

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCMOUSEMOVE => 160

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCLBUTTONDOWN => 161

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCLBUTTONUP => 162

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCLBUTTONDBLCLK => 163

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCRBUTTONDOWN => 164

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCRBUTTONUP => 165

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCRBUTTONDBLCLK => 166

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCMBUTTONDOWN => 167

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCMBUTTONUP => 168

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCMBUTTONDBLCLK => 169

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCXBUTTONDOWN => 171

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCXBUTTONUP => 172

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCXBUTTONDBLCLK => 173

    /**
     * @type {Integer (UInt32)}
     */
    static WM_INPUT_DEVICE_CHANGE => 254

    /**
     * @type {Integer (UInt32)}
     */
    static WM_INPUT => 255

    /**
     * @type {Integer (UInt32)}
     */
    static WM_KEYFIRST => 256

    /**
     * @type {Integer (UInt32)}
     */
    static WM_KEYDOWN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static WM_KEYUP => 257

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CHAR => 258

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DEADCHAR => 259

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SYSKEYDOWN => 260

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SYSKEYUP => 261

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SYSCHAR => 262

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SYSDEADCHAR => 263

    /**
     * @type {Integer (UInt32)}
     */
    static WM_KEYLAST => 265

    /**
     * @type {Integer (UInt32)}
     */
    static UNICODE_NOCHAR => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_STARTCOMPOSITION => 269

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_ENDCOMPOSITION => 270

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_COMPOSITION => 271

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_KEYLAST => 271

    /**
     * @type {Integer (UInt32)}
     */
    static WM_INITDIALOG => 272

    /**
     * @type {Integer (UInt32)}
     */
    static WM_COMMAND => 273

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SYSCOMMAND => 274

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TIMER => 275

    /**
     * @type {Integer (UInt32)}
     */
    static WM_HSCROLL => 276

    /**
     * @type {Integer (UInt32)}
     */
    static WM_VSCROLL => 277

    /**
     * @type {Integer (UInt32)}
     */
    static WM_INITMENU => 278

    /**
     * @type {Integer (UInt32)}
     */
    static WM_INITMENUPOPUP => 279

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GESTURE => 281

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GESTURENOTIFY => 282

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MENUSELECT => 287

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MENUCHAR => 288

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ENTERIDLE => 289

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MENURBUTTONUP => 290

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MENUDRAG => 291

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MENUGETOBJECT => 292

    /**
     * @type {Integer (UInt32)}
     */
    static WM_UNINITMENUPOPUP => 293

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MENUCOMMAND => 294

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CHANGEUISTATE => 295

    /**
     * @type {Integer (UInt32)}
     */
    static WM_UPDATEUISTATE => 296

    /**
     * @type {Integer (UInt32)}
     */
    static WM_QUERYUISTATE => 297

    /**
     * @type {Integer (UInt32)}
     */
    static UIS_SET => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UIS_CLEAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UIS_INITIALIZE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UISF_HIDEFOCUS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static UISF_HIDEACCEL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static UISF_ACTIVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CTLCOLORMSGBOX => 306

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CTLCOLOREDIT => 307

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CTLCOLORLISTBOX => 308

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CTLCOLORBTN => 309

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CTLCOLORDLG => 310

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CTLCOLORSCROLLBAR => 311

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CTLCOLORSTATIC => 312

    /**
     * @type {Integer (UInt32)}
     */
    static MN_GETHMENU => 481

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOUSEFIRST => 512

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOUSEMOVE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static WM_LBUTTONDOWN => 513

    /**
     * @type {Integer (UInt32)}
     */
    static WM_LBUTTONUP => 514

    /**
     * @type {Integer (UInt32)}
     */
    static WM_LBUTTONDBLCLK => 515

    /**
     * @type {Integer (UInt32)}
     */
    static WM_RBUTTONDOWN => 516

    /**
     * @type {Integer (UInt32)}
     */
    static WM_RBUTTONUP => 517

    /**
     * @type {Integer (UInt32)}
     */
    static WM_RBUTTONDBLCLK => 518

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MBUTTONDOWN => 519

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MBUTTONUP => 520

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MBUTTONDBLCLK => 521

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOUSEWHEEL => 522

    /**
     * @type {Integer (UInt32)}
     */
    static WM_XBUTTONDOWN => 523

    /**
     * @type {Integer (UInt32)}
     */
    static WM_XBUTTONUP => 524

    /**
     * @type {Integer (UInt32)}
     */
    static WM_XBUTTONDBLCLK => 525

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOUSEHWHEEL => 526

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOUSELAST => 526

    /**
     * @type {Integer (UInt32)}
     */
    static WHEEL_DELTA => 120

    /**
     * @type {Integer (UInt16)}
     */
    static XBUTTON1 => 1

    /**
     * @type {Integer (UInt16)}
     */
    static XBUTTON2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PARENTNOTIFY => 528

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ENTERMENULOOP => 529

    /**
     * @type {Integer (UInt32)}
     */
    static WM_EXITMENULOOP => 530

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NEXTMENU => 531

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SIZING => 532

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CAPTURECHANGED => 533

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MOVING => 534

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POWERBROADCAST => 536

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMQUERYSUSPEND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMQUERYSTANDBY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMQUERYSUSPENDFAILED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMQUERYSTANDBYFAILED => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMSUSPEND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMSTANDBY => 5

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMRESUMECRITICAL => 6

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMRESUMESUSPEND => 7

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMRESUMESTANDBY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PBTF_APMRESUMEFROMFAILURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMBATTERYLOW => 9

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMPOWERSTATUSCHANGE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMOEMEVENT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_APMRESUMEAUTOMATIC => 18

    /**
     * @type {Integer (UInt32)}
     */
    static PBT_POWERSETTINGCHANGE => 32787

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDICREATE => 544

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDIDESTROY => 545

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDIACTIVATE => 546

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDIRESTORE => 547

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDINEXT => 548

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDIMAXIMIZE => 549

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDITILE => 550

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDICASCADE => 551

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDIICONARRANGE => 552

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDIGETACTIVE => 553

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDISETMENU => 560

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ENTERSIZEMOVE => 561

    /**
     * @type {Integer (UInt32)}
     */
    static WM_EXITSIZEMOVE => 562

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DROPFILES => 563

    /**
     * @type {Integer (UInt32)}
     */
    static WM_MDIREFRESHMENU => 564

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERDEVICECHANGE => 568

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERDEVICEINRANGE => 569

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERDEVICEOUTOFRANGE => 570

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TOUCH => 576

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCPOINTERUPDATE => 577

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCPOINTERDOWN => 578

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCPOINTERUP => 579

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERUPDATE => 581

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERDOWN => 582

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERUP => 583

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERENTER => 585

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERLEAVE => 586

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERACTIVATE => 587

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERCAPTURECHANGED => 588

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TOUCHHITTESTING => 589

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERWHEEL => 590

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERHWHEEL => 591

    /**
     * @type {Integer (UInt32)}
     */
    static DM_POINTERHITTEST => 592

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERROUTEDTO => 593

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERROUTEDAWAY => 594

    /**
     * @type {Integer (UInt32)}
     */
    static WM_POINTERROUTEDRELEASED => 595

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_SETCONTEXT => 641

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_NOTIFY => 642

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_CONTROL => 643

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_COMPOSITIONFULL => 644

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_SELECT => 645

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_CHAR => 646

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_REQUEST => 648

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_KEYDOWN => 656

    /**
     * @type {Integer (UInt32)}
     */
    static WM_IME_KEYUP => 657

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCMOUSEHOVER => 672

    /**
     * @type {Integer (UInt32)}
     */
    static WM_NCMOUSELEAVE => 674

    /**
     * @type {Integer (UInt32)}
     */
    static WM_WTSSESSION_CHANGE => 689

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TABLET_FIRST => 704

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TABLET_LAST => 735

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DPICHANGED => 736

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DPICHANGED_BEFOREPARENT => 738

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DPICHANGED_AFTERPARENT => 739

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETDPISCALEDSIZE => 740

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CUT => 768

    /**
     * @type {Integer (UInt32)}
     */
    static WM_COPY => 769

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PASTE => 770

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CLEAR => 771

    /**
     * @type {Integer (UInt32)}
     */
    static WM_UNDO => 772

    /**
     * @type {Integer (UInt32)}
     */
    static WM_RENDERFORMAT => 773

    /**
     * @type {Integer (UInt32)}
     */
    static WM_RENDERALLFORMATS => 774

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DESTROYCLIPBOARD => 775

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DRAWCLIPBOARD => 776

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PAINTCLIPBOARD => 777

    /**
     * @type {Integer (UInt32)}
     */
    static WM_VSCROLLCLIPBOARD => 778

    /**
     * @type {Integer (UInt32)}
     */
    static WM_SIZECLIPBOARD => 779

    /**
     * @type {Integer (UInt32)}
     */
    static WM_ASKCBFORMATNAME => 780

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CHANGECBCHAIN => 781

    /**
     * @type {Integer (UInt32)}
     */
    static WM_HSCROLLCLIPBOARD => 782

    /**
     * @type {Integer (UInt32)}
     */
    static WM_QUERYNEWPALETTE => 783

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PALETTEISCHANGING => 784

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PALETTECHANGED => 785

    /**
     * @type {Integer (UInt32)}
     */
    static WM_HOTKEY => 786

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PRINT => 791

    /**
     * @type {Integer (UInt32)}
     */
    static WM_APPCOMMAND => 793

    /**
     * @type {Integer (UInt32)}
     */
    static WM_THEMECHANGED => 794

    /**
     * @type {Integer (UInt32)}
     */
    static WM_CLIPBOARDUPDATE => 797

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DWMCOMPOSITIONCHANGED => 798

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DWMNCRENDERINGCHANGED => 799

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DWMCOLORIZATIONCOLORCHANGED => 800

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DWMWINDOWMAXIMIZEDCHANGE => 801

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DWMSENDICONICTHUMBNAIL => 803

    /**
     * @type {Integer (UInt32)}
     */
    static WM_DWMSENDICONICLIVEPREVIEWBITMAP => 806

    /**
     * @type {Integer (UInt32)}
     */
    static WM_GETTITLEBARINFOEX => 831

    /**
     * @type {Integer (UInt32)}
     */
    static WM_HANDHELDFIRST => 856

    /**
     * @type {Integer (UInt32)}
     */
    static WM_HANDHELDLAST => 863

    /**
     * @type {Integer (UInt32)}
     */
    static WM_AFXFIRST => 864

    /**
     * @type {Integer (UInt32)}
     */
    static WM_AFXLAST => 895

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PENWINFIRST => 896

    /**
     * @type {Integer (UInt32)}
     */
    static WM_PENWINLAST => 911

    /**
     * @type {Integer (UInt32)}
     */
    static WM_APP => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static WM_USER => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_LEFT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_RIGHT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_TOP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_TOPLEFT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_TOPRIGHT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_BOTTOM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_BOTTOMLEFT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static WMSZ_BOTTOMRIGHT => 8

    /**
     * @type {Integer (Int32)}
     */
    static HTERROR => -2

    /**
     * @type {Integer (Int32)}
     */
    static HTTRANSPARENT => -1

    /**
     * @type {Integer (UInt32)}
     */
    static HTNOWHERE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static HTCLIENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static HTCAPTION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static HTSYSMENU => 3

    /**
     * @type {Integer (UInt32)}
     */
    static HTGROWBOX => 4

    /**
     * @type {Integer (UInt32)}
     */
    static HTSIZE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static HTMENU => 5

    /**
     * @type {Integer (UInt32)}
     */
    static HTHSCROLL => 6

    /**
     * @type {Integer (UInt32)}
     */
    static HTVSCROLL => 7

    /**
     * @type {Integer (UInt32)}
     */
    static HTMINBUTTON => 8

    /**
     * @type {Integer (UInt32)}
     */
    static HTMAXBUTTON => 9

    /**
     * @type {Integer (UInt32)}
     */
    static HTLEFT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static HTRIGHT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static HTTOP => 12

    /**
     * @type {Integer (UInt32)}
     */
    static HTTOPLEFT => 13

    /**
     * @type {Integer (UInt32)}
     */
    static HTTOPRIGHT => 14

    /**
     * @type {Integer (UInt32)}
     */
    static HTBOTTOM => 15

    /**
     * @type {Integer (UInt32)}
     */
    static HTBOTTOMLEFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static HTBOTTOMRIGHT => 17

    /**
     * @type {Integer (UInt32)}
     */
    static HTBORDER => 18

    /**
     * @type {Integer (UInt32)}
     */
    static HTREDUCE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static HTZOOM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static HTSIZEFIRST => 10

    /**
     * @type {Integer (UInt32)}
     */
    static HTSIZELAST => 17

    /**
     * @type {Integer (UInt32)}
     */
    static HTOBJECT => 19

    /**
     * @type {Integer (UInt32)}
     */
    static HTCLOSE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static HTHELP => 21

    /**
     * @type {Integer (UInt32)}
     */
    static MA_ACTIVATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MA_ACTIVATEANDEAT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MA_NOACTIVATE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static MA_NOACTIVATEANDEAT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ICON_SMALL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ICON_BIG => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ICON_SMALL2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SIZE_RESTORED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SIZE_MINIMIZED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIZE_MAXIMIZED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SIZE_MAXSHOW => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SIZE_MAXHIDE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIZENORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEICONIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEFULLSCREEN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEZOOMSHOW => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEZOOMHIDE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_ALIGNTOP => 16

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_ALIGNLEFT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_ALIGNBOTTOM => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_ALIGNRIGHT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_HREDRAW => 256

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_VREDRAW => 512

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_VALIDRECTS => 1024

    /**
     * @type {Integer (Int32)}
     */
    static PRF_CHECKVISIBLE => 1

    /**
     * @type {Integer (Int32)}
     */
    static PRF_NONCLIENT => 2

    /**
     * @type {Integer (Int32)}
     */
    static PRF_CLIENT => 4

    /**
     * @type {Integer (Int32)}
     */
    static PRF_ERASEBKGND => 8

    /**
     * @type {Integer (Int32)}
     */
    static PRF_CHILDREN => 16

    /**
     * @type {Integer (Int32)}
     */
    static PRF_OWNED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static IDANI_OPEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IDANI_CAPTION => 3

    /**
     * @type {Integer (Int32)}
     */
    static IDHOT_SNAPWINDOW => -1

    /**
     * @type {Integer (Int32)}
     */
    static IDHOT_SNAPDESKTOP => -2

    /**
     * @type {Integer (UInt32)}
     */
    static ENDSESSION_CLOSEAPP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ENDSESSION_CRITICAL => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static ENDSESSION_LOGOFF => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static BROADCAST_QUERY_DENY => 1112363332

    /**
     * @type {Integer (Int32)}
     */
    static HWND_BROADCAST => 65535

    /**
     * @type {Integer (Int32)}
     */
    static HWND_MESSAGE => -3

    /**
     * @type {Integer (UInt32)}
     */
    static ISMEX_NOSEND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ISMEX_SEND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISMEX_NOTIFY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ISMEX_CALLBACK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ISMEX_REPLIED => 8

    /**
     * @type {Integer (Int32)}
     */
    static HWND_DESKTOP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PW_RENDERFULLCONTENT => 2

    /**
     * @type {Integer (Int32)}
     */
    static HWND_TOP => 0

    /**
     * @type {Integer (Int32)}
     */
    static HWND_BOTTOM => 1

    /**
     * @type {Integer (Int32)}
     */
    static HWND_TOPMOST => -1

    /**
     * @type {Integer (Int32)}
     */
    static HWND_NOTOPMOST => -2

    /**
     * @type {Integer (UInt32)}
     */
    static DLGWINDOWEXTRA => 30

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MOD_SHIFT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MOD_CTRL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_FLAG_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_MASK_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_MASK_CONTACTAREA => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_MASK_ORIENTATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_MASK_PRESSURE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_FLAG_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_FLAG_BARREL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_FLAG_INVERTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_FLAG_ERASER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_MASK_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_MASK_PRESSURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_MASK_ROTATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_MASK_TILT_X => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PEN_MASK_TILT_Y => 8

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_NEW => 1

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_INRANGE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_INCONTACT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_FIRSTBUTTON => 16

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_SECONDBUTTON => 32

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_THIRDBUTTON => 64

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_FOURTHBUTTON => 128

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_FIFTHBUTTON => 256

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_PRIMARY => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_CONFIDENCE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_MESSAGE_FLAG_CANCELED => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static PA_ACTIVATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PA_NOACTIVATE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_TOUCH_COUNT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_HIT_TESTING_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_HIT_TESTING_CLIENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_HIT_TESTING_NONE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_HIT_TESTING_PROXIMITY_CLOSEST => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCH_HIT_TESTING_PROXIMITY_FARTHEST => 4095

    /**
     * @type {Integer (UInt32)}
     */
    static GWFS_INCLUDE_ANCESTORS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static QS_TOUCH => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static QS_POINTER => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static USER_TIMER_MAXIMUM => 2147483647

    /**
     * @type {Integer (UInt32)}
     */
    static USER_TIMER_MINIMUM => 10

    /**
     * @type {Integer (UInt32)}
     */
    static TIMERV_DEFAULT_COALESCING => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TIMERV_NO_COALESCING => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static TIMERV_COALESCING_MIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TIMERV_COALESCING_MAX => 2147483637

    /**
     * @type {Integer (UInt32)}
     */
    static SM_RESERVED1 => 24

    /**
     * @type {Integer (UInt32)}
     */
    static SM_RESERVED2 => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SM_RESERVED3 => 26

    /**
     * @type {Integer (UInt32)}
     */
    static SM_RESERVED4 => 27

    /**
     * @type {Integer (UInt32)}
     */
    static SM_CMETRICS => 76

    /**
     * @type {Integer (UInt32)}
     */
    static SM_CARETBLINKINGENABLED => 8194

    /**
     * @type {Integer (UInt32)}
     */
    static PMB_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MNC_IGNORE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MNC_CLOSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MNC_EXECUTE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MNC_SELECT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static MND_CONTINUE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MND_ENDMENU => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MNGO_NOINTERFACE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MNGO_NOERROR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DOF_EXECUTABLE => 32769

    /**
     * @type {Integer (UInt32)}
     */
    static DOF_DOCUMENT => 32770

    /**
     * @type {Integer (UInt32)}
     */
    static DOF_DIRECTORY => 32771

    /**
     * @type {Integer (UInt32)}
     */
    static DOF_MULTIPLE => 32772

    /**
     * @type {Integer (UInt32)}
     */
    static DOF_PROGMAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DOF_SHELLDATA => 2

    /**
     * @type {Integer (Int32)}
     */
    static DO_DROPFILE => 1162627398

    /**
     * @type {Integer (Int32)}
     */
    static DO_PRINTFILE => 1414419024

    /**
     * @type {Integer (UInt32)}
     */
    static ASFW_ANY => 4294967295

    /**
     * @type {Integer (Int32)}
     */
    static DCX_EXCLUDEUPDATE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_MSGBOX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_EDIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_LISTBOX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_BTN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_DLG => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_SCROLLBAR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_STATIC => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CTLCOLOR_MAX => 7

    /**
     * @type {Integer (UInt32)}
     */
    static GW_MAX => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SC_SIZE => 61440

    /**
     * @type {Integer (UInt32)}
     */
    static SC_MOVE => 61456

    /**
     * @type {Integer (UInt32)}
     */
    static SC_MINIMIZE => 61472

    /**
     * @type {Integer (UInt32)}
     */
    static SC_MAXIMIZE => 61488

    /**
     * @type {Integer (UInt32)}
     */
    static SC_NEXTWINDOW => 61504

    /**
     * @type {Integer (UInt32)}
     */
    static SC_PREVWINDOW => 61520

    /**
     * @type {Integer (UInt32)}
     */
    static SC_CLOSE => 61536

    /**
     * @type {Integer (UInt32)}
     */
    static SC_VSCROLL => 61552

    /**
     * @type {Integer (UInt32)}
     */
    static SC_HSCROLL => 61568

    /**
     * @type {Integer (UInt32)}
     */
    static SC_MOUSEMENU => 61584

    /**
     * @type {Integer (UInt32)}
     */
    static SC_KEYMENU => 61696

    /**
     * @type {Integer (UInt32)}
     */
    static SC_ARRANGE => 61712

    /**
     * @type {Integer (UInt32)}
     */
    static SC_RESTORE => 61728

    /**
     * @type {Integer (UInt32)}
     */
    static SC_TASKLIST => 61744

    /**
     * @type {Integer (UInt32)}
     */
    static SC_HOTKEY => 61776

    /**
     * @type {Integer (UInt32)}
     */
    static SC_DEFAULT => 61792

    /**
     * @type {Integer (UInt32)}
     */
    static SC_MONITORPOWER => 61808

    /**
     * @type {Integer (UInt32)}
     */
    static SC_CONTEXTHELP => 61824

    /**
     * @type {Integer (UInt32)}
     */
    static SC_SEPARATOR => 61455

    /**
     * @type {Integer (UInt32)}
     */
    static SCF_ISSECURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SC_ICON => 61472

    /**
     * @type {Integer (UInt32)}
     */
    static SC_ZOOM => 61488

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_ARROW => 32512

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_IBEAM => 32513

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_WAIT => 32514

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_CROSS => 32515

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_UPARROW => 32516

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_SIZE => 32640

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_ICON => 32641

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_SIZENWSE => 32642

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_SIZENESW => 32643

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_SIZEWE => 32644

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_SIZENS => 32645

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_SIZEALL => 32646

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_NO => 32648

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_HAND => 32649

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_APPSTARTING => 32650

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_HELP => 32651

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_PIN => 32671

    /**
     * @type {Integer (UInt16)}
     */
    static IDC_PERSON => 32672

    /**
     * @type {Integer (UInt32)}
     */
    static CURSOR_CREATION_SCALING_NONE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CURSOR_CREATION_SCALING_DEFAULT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IMAGE_ENHMETAFILE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LR_COLOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RES_ICON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RES_CURSOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_CLOSE => 32754

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_UPARROW => 32753

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_DNARROW => 32752

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_RGARROW => 32751

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_LFARROW => 32750

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_REDUCE => 32749

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_ZOOM => 32748

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_RESTORE => 32747

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_REDUCED => 32746

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_ZOOMD => 32745

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_RESTORED => 32744

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_UPARROWD => 32743

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_DNARROWD => 32742

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_RGARROWD => 32741

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_LFARROWD => 32740

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_MNARROW => 32739

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_COMBO => 32738

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_UPARROWI => 32737

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_DNARROWI => 32736

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_RGARROWI => 32735

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_LFARROWI => 32734

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_CLOSE => 32767

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_SIZE => 32766

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_UPARROW => 32765

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_DNARROW => 32764

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_RGARROW => 32763

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_LFARROW => 32762

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_BTSIZE => 32761

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_CHECK => 32760

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_CHECKBOXES => 32759

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_BTNCORNERS => 32758

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_REDUCE => 32757

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_ZOOM => 32756

    /**
     * @type {Integer (UInt32)}
     */
    static OBM_OLD_RESTORE => 32755

    /**
     * @type {Integer (UInt32)}
     */
    static OCR_SIZE => 32640

    /**
     * @type {Integer (UInt32)}
     */
    static OCR_ICON => 32641

    /**
     * @type {Integer (UInt32)}
     */
    static OCR_ICOCUR => 32647

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_SAMPLE => 32512

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_HAND => 32513

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_QUES => 32514

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_BANG => 32515

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_NOTE => 32516

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_WINLOGO => 32517

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_WARNING => 32515

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_ERROR => 32513

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_INFORMATION => 32516

    /**
     * @type {Integer (UInt32)}
     */
    static OIC_SHIELD => 32518

    /**
     * @type {Integer (UInt32)}
     */
    static ORD_LANGDRIVER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_APPLICATION => 32512

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_HAND => 32513

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_QUESTION => 32514

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_EXCLAMATION => 32515

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_ASTERISK => 32516

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_WINLOGO => 32517

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_SHIELD => 32518

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_WARNING => 32515

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_ERROR => 32513

    /**
     * @type {Integer (UInt32)}
     */
    static IDI_INFORMATION => 32516

    /**
     * @type {Integer (Int32)}
     */
    static ES_LEFT => 0

    /**
     * @type {Integer (Int32)}
     */
    static ES_CENTER => 1

    /**
     * @type {Integer (Int32)}
     */
    static ES_RIGHT => 2

    /**
     * @type {Integer (Int32)}
     */
    static ES_MULTILINE => 4

    /**
     * @type {Integer (Int32)}
     */
    static ES_UPPERCASE => 8

    /**
     * @type {Integer (Int32)}
     */
    static ES_LOWERCASE => 16

    /**
     * @type {Integer (Int32)}
     */
    static ES_PASSWORD => 32

    /**
     * @type {Integer (Int32)}
     */
    static ES_AUTOVSCROLL => 64

    /**
     * @type {Integer (Int32)}
     */
    static ES_AUTOHSCROLL => 128

    /**
     * @type {Integer (Int32)}
     */
    static ES_NOHIDESEL => 256

    /**
     * @type {Integer (Int32)}
     */
    static ES_OEMCONVERT => 1024

    /**
     * @type {Integer (Int32)}
     */
    static ES_READONLY => 2048

    /**
     * @type {Integer (Int32)}
     */
    static ES_WANTRETURN => 4096

    /**
     * @type {Integer (Int32)}
     */
    static ES_NUMBER => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static EN_SETFOCUS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static EN_KILLFOCUS => 512

    /**
     * @type {Integer (UInt32)}
     */
    static EN_CHANGE => 768

    /**
     * @type {Integer (UInt32)}
     */
    static EN_UPDATE => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static EN_ERRSPACE => 1280

    /**
     * @type {Integer (UInt32)}
     */
    static EN_MAXTEXT => 1281

    /**
     * @type {Integer (UInt32)}
     */
    static EN_HSCROLL => 1537

    /**
     * @type {Integer (UInt32)}
     */
    static EN_VSCROLL => 1538

    /**
     * @type {Integer (UInt32)}
     */
    static EN_ALIGN_LTR_EC => 1792

    /**
     * @type {Integer (UInt32)}
     */
    static EN_ALIGN_RTL_EC => 1793

    /**
     * @type {Integer (UInt32)}
     */
    static EN_BEFORE_PASTE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static EN_AFTER_PASTE => 2049

    /**
     * @type {Integer (UInt32)}
     */
    static EC_LEFTMARGIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EC_RIGHTMARGIN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EC_USEFONTINFO => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static EMSIS_COMPOSITIONSTRING => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EIMES_GETCOMPSTRATONCE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EIMES_CANCELCOMPSTRINFOCUS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EIMES_COMPLETECOMPSTRKILLFOCUS => 4

    /**
     * @type {Integer (Int32)}
     */
    static BS_PUSHBUTTON => 0

    /**
     * @type {Integer (Int32)}
     */
    static BS_DEFPUSHBUTTON => 1

    /**
     * @type {Integer (Int32)}
     */
    static BS_CHECKBOX => 2

    /**
     * @type {Integer (Int32)}
     */
    static BS_AUTOCHECKBOX => 3

    /**
     * @type {Integer (Int32)}
     */
    static BS_RADIOBUTTON => 4

    /**
     * @type {Integer (Int32)}
     */
    static BS_3STATE => 5

    /**
     * @type {Integer (Int32)}
     */
    static BS_AUTO3STATE => 6

    /**
     * @type {Integer (Int32)}
     */
    static BS_GROUPBOX => 7

    /**
     * @type {Integer (Int32)}
     */
    static BS_USERBUTTON => 8

    /**
     * @type {Integer (Int32)}
     */
    static BS_AUTORADIOBUTTON => 9

    /**
     * @type {Integer (Int32)}
     */
    static BS_PUSHBOX => 10

    /**
     * @type {Integer (Int32)}
     */
    static BS_OWNERDRAW => 11

    /**
     * @type {Integer (Int32)}
     */
    static BS_TYPEMASK => 15

    /**
     * @type {Integer (Int32)}
     */
    static BS_LEFTTEXT => 32

    /**
     * @type {Integer (Int32)}
     */
    static BS_TEXT => 0

    /**
     * @type {Integer (Int32)}
     */
    static BS_ICON => 64

    /**
     * @type {Integer (Int32)}
     */
    static BS_BITMAP => 128

    /**
     * @type {Integer (Int32)}
     */
    static BS_LEFT => 256

    /**
     * @type {Integer (Int32)}
     */
    static BS_RIGHT => 512

    /**
     * @type {Integer (Int32)}
     */
    static BS_CENTER => 768

    /**
     * @type {Integer (Int32)}
     */
    static BS_TOP => 1024

    /**
     * @type {Integer (Int32)}
     */
    static BS_BOTTOM => 2048

    /**
     * @type {Integer (Int32)}
     */
    static BS_VCENTER => 3072

    /**
     * @type {Integer (Int32)}
     */
    static BS_PUSHLIKE => 4096

    /**
     * @type {Integer (Int32)}
     */
    static BS_MULTILINE => 8192

    /**
     * @type {Integer (Int32)}
     */
    static BS_NOTIFY => 16384

    /**
     * @type {Integer (Int32)}
     */
    static BS_FLAT => 32768

    /**
     * @type {Integer (Int32)}
     */
    static BS_RIGHTBUTTON => 32

    /**
     * @type {Integer (UInt32)}
     */
    static BN_CLICKED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static BN_PAINT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BN_HILITE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BN_UNHILITE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static BN_DISABLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BN_DOUBLECLICKED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static BN_PUSHED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BN_UNPUSHED => 3

    /**
     * @type {Integer (UInt32)}
     */
    static BN_DBLCLK => 5

    /**
     * @type {Integer (UInt32)}
     */
    static BN_SETFOCUS => 6

    /**
     * @type {Integer (UInt32)}
     */
    static BN_KILLFOCUS => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BM_GETCHECK => 240

    /**
     * @type {Integer (UInt32)}
     */
    static BM_SETCHECK => 241

    /**
     * @type {Integer (UInt32)}
     */
    static BM_GETSTATE => 242

    /**
     * @type {Integer (UInt32)}
     */
    static BM_SETSTATE => 243

    /**
     * @type {Integer (UInt32)}
     */
    static BM_SETSTYLE => 244

    /**
     * @type {Integer (UInt32)}
     */
    static BM_CLICK => 245

    /**
     * @type {Integer (UInt32)}
     */
    static BM_GETIMAGE => 246

    /**
     * @type {Integer (UInt32)}
     */
    static BM_SETIMAGE => 247

    /**
     * @type {Integer (UInt32)}
     */
    static BM_SETDONTCLICK => 248

    /**
     * @type {Integer (UInt32)}
     */
    static BST_PUSHED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BST_FOCUS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static STM_SETICON => 368

    /**
     * @type {Integer (UInt32)}
     */
    static STM_GETICON => 369

    /**
     * @type {Integer (UInt32)}
     */
    static STM_SETIMAGE => 370

    /**
     * @type {Integer (UInt32)}
     */
    static STM_GETIMAGE => 371

    /**
     * @type {Integer (UInt32)}
     */
    static STN_CLICKED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static STN_DBLCLK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static STN_ENABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static STN_DISABLE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static STM_MSGMAX => 372

    /**
     * @type {Integer (UInt32)}
     */
    static DWL_MSGRESULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DWL_DLGPROC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DWL_USER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DWLP_MSGRESULT => 0

    /**
     * @type {Integer (Int32)}
     */
    static DS_ABSALIGN => 1

    /**
     * @type {Integer (Int32)}
     */
    static DS_SYSMODAL => 2

    /**
     * @type {Integer (Int32)}
     */
    static DS_LOCALEDIT => 32

    /**
     * @type {Integer (Int32)}
     */
    static DS_SETFONT => 64

    /**
     * @type {Integer (Int32)}
     */
    static DS_MODALFRAME => 128

    /**
     * @type {Integer (Int32)}
     */
    static DS_NOIDLEMSG => 256

    /**
     * @type {Integer (Int32)}
     */
    static DS_SETFOREGROUND => 512

    /**
     * @type {Integer (Int32)}
     */
    static DS_3DLOOK => 4

    /**
     * @type {Integer (Int32)}
     */
    static DS_FIXEDSYS => 8

    /**
     * @type {Integer (Int32)}
     */
    static DS_NOFAILCREATE => 16

    /**
     * @type {Integer (Int32)}
     */
    static DS_CONTROL => 1024

    /**
     * @type {Integer (Int32)}
     */
    static DS_CENTER => 2048

    /**
     * @type {Integer (Int32)}
     */
    static DS_CENTERMOUSE => 4096

    /**
     * @type {Integer (Int32)}
     */
    static DS_CONTEXTHELP => 8192

    /**
     * @type {Integer (Int32)}
     */
    static DS_USEPIXELS => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static DM_GETDEFID => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static DM_SETDEFID => 1025

    /**
     * @type {Integer (UInt32)}
     */
    static DM_REPOSITION => 1026

    /**
     * @type {Integer (UInt32)}
     */
    static DC_HASDEFID => 21323

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_WANTARROWS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_WANTTAB => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_WANTALLKEYS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_WANTMESSAGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_HASSETSEL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_DEFPUSHBUTTON => 16

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_UNDEFPUSHBUTTON => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_RADIOBUTTON => 64

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_WANTCHARS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_STATIC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static DLGC_BUTTON => 8192

    /**
     * @type {Integer (Int32)}
     */
    static LB_CTLCODE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LB_OKAY => 0

    /**
     * @type {Integer (Int32)}
     */
    static LB_ERR => -1

    /**
     * @type {Integer (Int32)}
     */
    static LB_ERRSPACE => -2

    /**
     * @type {Integer (Int32)}
     */
    static LBN_ERRSPACE => -2

    /**
     * @type {Integer (UInt32)}
     */
    static LBN_SELCHANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LBN_DBLCLK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LBN_SELCANCEL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LBN_SETFOCUS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LBN_KILLFOCUS => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LB_ADDSTRING => 384

    /**
     * @type {Integer (UInt32)}
     */
    static LB_INSERTSTRING => 385

    /**
     * @type {Integer (UInt32)}
     */
    static LB_DELETESTRING => 386

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SELITEMRANGEEX => 387

    /**
     * @type {Integer (UInt32)}
     */
    static LB_RESETCONTENT => 388

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETSEL => 389

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETCURSEL => 390

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETSEL => 391

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETCURSEL => 392

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETTEXT => 393

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETTEXTLEN => 394

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETCOUNT => 395

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SELECTSTRING => 396

    /**
     * @type {Integer (UInt32)}
     */
    static LB_DIR => 397

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETTOPINDEX => 398

    /**
     * @type {Integer (UInt32)}
     */
    static LB_FINDSTRING => 399

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETSELCOUNT => 400

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETSELITEMS => 401

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETTABSTOPS => 402

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETHORIZONTALEXTENT => 403

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETHORIZONTALEXTENT => 404

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETCOLUMNWIDTH => 405

    /**
     * @type {Integer (UInt32)}
     */
    static LB_ADDFILE => 406

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETTOPINDEX => 407

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETITEMRECT => 408

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETITEMDATA => 409

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETITEMDATA => 410

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SELITEMRANGE => 411

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETANCHORINDEX => 412

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETANCHORINDEX => 413

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETCARETINDEX => 414

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETCARETINDEX => 415

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETITEMHEIGHT => 416

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETITEMHEIGHT => 417

    /**
     * @type {Integer (UInt32)}
     */
    static LB_FINDSTRINGEXACT => 418

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETLOCALE => 421

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETLOCALE => 422

    /**
     * @type {Integer (UInt32)}
     */
    static LB_SETCOUNT => 423

    /**
     * @type {Integer (UInt32)}
     */
    static LB_INITSTORAGE => 424

    /**
     * @type {Integer (UInt32)}
     */
    static LB_ITEMFROMPOINT => 425

    /**
     * @type {Integer (UInt32)}
     */
    static LB_MULTIPLEADDSTRING => 433

    /**
     * @type {Integer (UInt32)}
     */
    static LB_GETLISTBOXINFO => 434

    /**
     * @type {Integer (UInt32)}
     */
    static LB_MSGMAX => 435

    /**
     * @type {Integer (Int32)}
     */
    static LBS_NOTIFY => 1

    /**
     * @type {Integer (Int32)}
     */
    static LBS_SORT => 2

    /**
     * @type {Integer (Int32)}
     */
    static LBS_NOREDRAW => 4

    /**
     * @type {Integer (Int32)}
     */
    static LBS_MULTIPLESEL => 8

    /**
     * @type {Integer (Int32)}
     */
    static LBS_OWNERDRAWFIXED => 16

    /**
     * @type {Integer (Int32)}
     */
    static LBS_OWNERDRAWVARIABLE => 32

    /**
     * @type {Integer (Int32)}
     */
    static LBS_HASSTRINGS => 64

    /**
     * @type {Integer (Int32)}
     */
    static LBS_USETABSTOPS => 128

    /**
     * @type {Integer (Int32)}
     */
    static LBS_NOINTEGRALHEIGHT => 256

    /**
     * @type {Integer (Int32)}
     */
    static LBS_MULTICOLUMN => 512

    /**
     * @type {Integer (Int32)}
     */
    static LBS_WANTKEYBOARDINPUT => 1024

    /**
     * @type {Integer (Int32)}
     */
    static LBS_EXTENDEDSEL => 2048

    /**
     * @type {Integer (Int32)}
     */
    static LBS_DISABLENOSCROLL => 4096

    /**
     * @type {Integer (Int32)}
     */
    static LBS_NODATA => 8192

    /**
     * @type {Integer (Int32)}
     */
    static LBS_NOSEL => 16384

    /**
     * @type {Integer (Int32)}
     */
    static LBS_COMBOBOX => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static CB_OKAY => 0

    /**
     * @type {Integer (Int32)}
     */
    static CB_ERR => -1

    /**
     * @type {Integer (Int32)}
     */
    static CB_ERRSPACE => -2

    /**
     * @type {Integer (Int32)}
     */
    static CBN_ERRSPACE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_SELCHANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_DBLCLK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_SETFOCUS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_KILLFOCUS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_EDITCHANGE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_EDITUPDATE => 6

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_DROPDOWN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_CLOSEUP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_SELENDOK => 9

    /**
     * @type {Integer (UInt32)}
     */
    static CBN_SELENDCANCEL => 10

    /**
     * @type {Integer (Int32)}
     */
    static CBS_SIMPLE => 1

    /**
     * @type {Integer (Int32)}
     */
    static CBS_DROPDOWN => 2

    /**
     * @type {Integer (Int32)}
     */
    static CBS_DROPDOWNLIST => 3

    /**
     * @type {Integer (Int32)}
     */
    static CBS_OWNERDRAWFIXED => 16

    /**
     * @type {Integer (Int32)}
     */
    static CBS_OWNERDRAWVARIABLE => 32

    /**
     * @type {Integer (Int32)}
     */
    static CBS_AUTOHSCROLL => 64

    /**
     * @type {Integer (Int32)}
     */
    static CBS_OEMCONVERT => 128

    /**
     * @type {Integer (Int32)}
     */
    static CBS_SORT => 256

    /**
     * @type {Integer (Int32)}
     */
    static CBS_HASSTRINGS => 512

    /**
     * @type {Integer (Int32)}
     */
    static CBS_NOINTEGRALHEIGHT => 1024

    /**
     * @type {Integer (Int32)}
     */
    static CBS_DISABLENOSCROLL => 2048

    /**
     * @type {Integer (Int32)}
     */
    static CBS_UPPERCASE => 8192

    /**
     * @type {Integer (Int32)}
     */
    static CBS_LOWERCASE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETEDITSEL => 320

    /**
     * @type {Integer (UInt32)}
     */
    static CB_LIMITTEXT => 321

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETEDITSEL => 322

    /**
     * @type {Integer (UInt32)}
     */
    static CB_ADDSTRING => 323

    /**
     * @type {Integer (UInt32)}
     */
    static CB_DELETESTRING => 324

    /**
     * @type {Integer (UInt32)}
     */
    static CB_DIR => 325

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETCOUNT => 326

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETCURSEL => 327

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETLBTEXT => 328

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETLBTEXTLEN => 329

    /**
     * @type {Integer (UInt32)}
     */
    static CB_INSERTSTRING => 330

    /**
     * @type {Integer (UInt32)}
     */
    static CB_RESETCONTENT => 331

    /**
     * @type {Integer (UInt32)}
     */
    static CB_FINDSTRING => 332

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SELECTSTRING => 333

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETCURSEL => 334

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SHOWDROPDOWN => 335

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETITEMDATA => 336

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETITEMDATA => 337

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETDROPPEDCONTROLRECT => 338

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETITEMHEIGHT => 339

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETITEMHEIGHT => 340

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETEXTENDEDUI => 341

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETEXTENDEDUI => 342

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETDROPPEDSTATE => 343

    /**
     * @type {Integer (UInt32)}
     */
    static CB_FINDSTRINGEXACT => 344

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETLOCALE => 345

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETLOCALE => 346

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETTOPINDEX => 347

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETTOPINDEX => 348

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETHORIZONTALEXTENT => 349

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETHORIZONTALEXTENT => 350

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETDROPPEDWIDTH => 351

    /**
     * @type {Integer (UInt32)}
     */
    static CB_SETDROPPEDWIDTH => 352

    /**
     * @type {Integer (UInt32)}
     */
    static CB_INITSTORAGE => 353

    /**
     * @type {Integer (UInt32)}
     */
    static CB_MULTIPLEADDSTRING => 355

    /**
     * @type {Integer (UInt32)}
     */
    static CB_GETCOMBOBOXINFO => 356

    /**
     * @type {Integer (UInt32)}
     */
    static CB_MSGMAX => 357

    /**
     * @type {Integer (Int32)}
     */
    static SBS_HORZ => 0

    /**
     * @type {Integer (Int32)}
     */
    static SBS_VERT => 1

    /**
     * @type {Integer (Int32)}
     */
    static SBS_TOPALIGN => 2

    /**
     * @type {Integer (Int32)}
     */
    static SBS_LEFTALIGN => 2

    /**
     * @type {Integer (Int32)}
     */
    static SBS_BOTTOMALIGN => 4

    /**
     * @type {Integer (Int32)}
     */
    static SBS_RIGHTALIGN => 4

    /**
     * @type {Integer (Int32)}
     */
    static SBS_SIZEBOXTOPLEFTALIGN => 2

    /**
     * @type {Integer (Int32)}
     */
    static SBS_SIZEBOXBOTTOMRIGHTALIGN => 4

    /**
     * @type {Integer (Int32)}
     */
    static SBS_SIZEBOX => 8

    /**
     * @type {Integer (Int32)}
     */
    static SBS_SIZEGRIP => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_SETPOS => 224

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_GETPOS => 225

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_SETRANGE => 226

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_SETRANGEREDRAW => 230

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_GETRANGE => 227

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_ENABLE_ARROWS => 228

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_SETSCROLLINFO => 233

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_GETSCROLLINFO => 234

    /**
     * @type {Integer (UInt32)}
     */
    static SBM_GETSCROLLBARINFO => 235

    /**
     * @type {Integer (UInt32)}
     */
    static MDIS_ALLCHILDSTYLES => 1

    /**
     * @type {Integer (Int32)}
     */
    static HELP_CONTEXT => 1

    /**
     * @type {Integer (Int32)}
     */
    static HELP_QUIT => 2

    /**
     * @type {Integer (Int32)}
     */
    static HELP_INDEX => 3

    /**
     * @type {Integer (Int32)}
     */
    static HELP_CONTENTS => 3

    /**
     * @type {Integer (Int32)}
     */
    static HELP_HELPONHELP => 4

    /**
     * @type {Integer (Int32)}
     */
    static HELP_SETINDEX => 5

    /**
     * @type {Integer (Int32)}
     */
    static HELP_SETCONTENTS => 5

    /**
     * @type {Integer (Int32)}
     */
    static HELP_CONTEXTPOPUP => 8

    /**
     * @type {Integer (Int32)}
     */
    static HELP_FORCEFILE => 9

    /**
     * @type {Integer (Int32)}
     */
    static HELP_KEY => 257

    /**
     * @type {Integer (Int32)}
     */
    static HELP_COMMAND => 258

    /**
     * @type {Integer (Int32)}
     */
    static HELP_PARTIALKEY => 261

    /**
     * @type {Integer (Int32)}
     */
    static HELP_MULTIKEY => 513

    /**
     * @type {Integer (Int32)}
     */
    static HELP_SETWINPOS => 515

    /**
     * @type {Integer (UInt32)}
     */
    static HELP_CONTEXTMENU => 10

    /**
     * @type {Integer (UInt32)}
     */
    static HELP_FINDER => 11

    /**
     * @type {Integer (UInt32)}
     */
    static HELP_WM_HELP => 12

    /**
     * @type {Integer (UInt32)}
     */
    static HELP_SETPOPUP_POS => 13

    /**
     * @type {Integer (UInt32)}
     */
    static HELP_TCARD => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static HELP_TCARD_DATA => 16

    /**
     * @type {Integer (UInt32)}
     */
    static HELP_TCARD_OTHER_CALLER => 17

    /**
     * @type {Integer (UInt32)}
     */
    static IDH_NO_HELP => 28440

    /**
     * @type {Integer (UInt32)}
     */
    static IDH_MISSING_CONTEXT => 28441

    /**
     * @type {Integer (UInt32)}
     */
    static IDH_GENERIC_HELP_BUTTON => 28442

    /**
     * @type {Integer (UInt32)}
     */
    static IDH_OK => 28443

    /**
     * @type {Integer (UInt32)}
     */
    static IDH_CANCEL => 28444

    /**
     * @type {Integer (UInt32)}
     */
    static IDH_HELP => 28445

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_TOUCH_PREDICTION_FILTER_TAPS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_LATENCY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_SAMPLETIME => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_USE_HW_TIMESTAMP => 1

    /**
     * @type {Integer (Single)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_DELTA => 0.001

    /**
     * @type {Integer (Single)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MIN => 0.9

    /**
     * @type {Integer (Single)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MAX => 0.999

    /**
     * @type {Integer (Single)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_LEARNING_RATE => 0.001

    /**
     * @type {Integer (Single)}
     */
    static TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_EXPO_SMOOTH_ALPHA => 0.99

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_LOGICALDPIOVERRIDE => 2

    /**
     * @type {Integer (Int32)}
     */
    static MIN_LOGICALDPIOVERRIDE => -2

    /**
     * @type {Integer (UInt32)}
     */
    static FE_FONTSMOOTHINGSTANDARD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FE_FONTSMOOTHINGCLEARTYPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FE_FONTSMOOTHINGORIENTATIONBGR => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FE_FONTSMOOTHINGORIENTATIONRGB => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CONTACTVISUALIZATION_OFF => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CONTACTVISUALIZATION_ON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CONTACTVISUALIZATION_PRESENTATIONMODE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GESTUREVISUALIZATION_OFF => 0

    /**
     * @type {Integer (UInt32)}
     */
    static GESTUREVISUALIZATION_ON => 31

    /**
     * @type {Integer (UInt32)}
     */
    static GESTUREVISUALIZATION_TAP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GESTUREVISUALIZATION_DOUBLETAP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GESTUREVISUALIZATION_PRESSANDTAP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GESTUREVISUALIZATION_PRESSANDHOLD => 8

    /**
     * @type {Integer (UInt32)}
     */
    static GESTUREVISUALIZATION_RIGHTTAP => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MOUSEWHEEL_ROUTING_FOCUS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static MOUSEWHEEL_ROUTING_HYBRID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MOUSEWHEEL_ROUTING_MOUSE_POS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PENVISUALIZATION_ON => 35

    /**
     * @type {Integer (UInt32)}
     */
    static PENVISUALIZATION_OFF => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PENVISUALIZATION_TAP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PENVISUALIZATION_DOUBLETAP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PENVISUALIZATION_CURSOR => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PENARBITRATIONTYPE_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PENARBITRATIONTYPE_WIN8 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PENARBITRATIONTYPE_FIS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PENARBITRATIONTYPE_SPT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static PENARBITRATIONTYPE_MAX => 4

    /**
     * @type {Integer (Int32)}
     */
    static METRICS_USEDEFAULT => -1

    /**
     * @type {Integer (Int32)}
     */
    static ARW_STARTMASK => 3

    /**
     * @type {Integer (Int32)}
     */
    static ARW_STARTRIGHT => 1

    /**
     * @type {Integer (Int32)}
     */
    static ARW_STARTTOP => 2

    /**
     * @type {Integer (Int32)}
     */
    static ARW_LEFT => 0

    /**
     * @type {Integer (Int32)}
     */
    static ARW_RIGHT => 0

    /**
     * @type {Integer (Int32)}
     */
    static ARW_UP => 4

    /**
     * @type {Integer (Int32)}
     */
    static ARW_DOWN => 4

    /**
     * @type {Integer (Int32)}
     */
    static ARW_HIDE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static HCF_LOGONDESKTOP => 256

    /**
     * @type {Integer (UInt32)}
     */
    static HCF_DEFAULTDESKTOP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static EDD_GET_DEVICE_INTERFACE_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FKF_FILTERKEYSON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FKF_AVAILABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FKF_HOTKEYACTIVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FKF_CONFIRMHOTKEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FKF_HOTKEYSOUND => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FKF_INDICATOR => 32

    /**
     * @type {Integer (UInt32)}
     */
    static FKF_CLICKON => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_MOUSEKEYSON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_AVAILABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_HOTKEYACTIVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_CONFIRMHOTKEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_HOTKEYSOUND => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_INDICATOR => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_MODIFIERS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_REPLACENUMBERS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_LEFTBUTTONSEL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_RIGHTBUTTONSEL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_LEFTBUTTONDOWN => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_RIGHTBUTTONDOWN => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static MKF_MOUSEMODE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static TKF_TOGGLEKEYSON => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TKF_AVAILABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TKF_HOTKEYACTIVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TKF_CONFIRMHOTKEY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TKF_HOTKEYSOUND => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TKF_INDICATOR => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MONITORINFOF_PRIMARY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WINEVENT_OUTOFCONTEXT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WINEVENT_SKIPOWNTHREAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WINEVENT_SKIPOWNPROCESS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WINEVENT_INCONTEXT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CHILDID_SELF => 0

    /**
     * @type {Integer (UInt32)}
     */
    static INDEXID_OBJECT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static INDEXID_CONTAINER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_MIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_MAX => 2147483647

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SOUND => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_ALERT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_FOREGROUND => 3

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MENUSTART => 4

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MENUEND => 5

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MENUPOPUPSTART => 6

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MENUPOPUPEND => 7

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_CAPTURESTART => 8

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_CAPTUREEND => 9

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MOVESIZESTART => 10

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MOVESIZEEND => 11

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_CONTEXTHELPSTART => 12

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_CONTEXTHELPEND => 13

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_DRAGDROPSTART => 14

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_DRAGDROPEND => 15

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_DIALOGSTART => 16

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_DIALOGEND => 17

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SCROLLINGSTART => 18

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SCROLLINGEND => 19

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SWITCHSTART => 20

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SWITCHEND => 21

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MINIMIZESTART => 22

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_MINIMIZEEND => 23

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_DESKTOPSWITCH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SWITCHER_APPGRABBED => 36

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SWITCHER_APPOVERTARGET => 37

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SWITCHER_APPDROPPED => 38

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_SWITCHER_CANCELLED => 39

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_IME_KEY_NOTIFICATION => 41

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_END => 255

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OEM_DEFINED_START => 257

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OEM_DEFINED_END => 511

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_UIA_EVENTID_START => 19968

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_UIA_EVENTID_END => 20223

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_UIA_PROPID_START => 29952

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_UIA_PROPID_END => 30207

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_CARET => 16385

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_UPDATE_REGION => 16386

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_UPDATE_SIMPLE => 16387

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_UPDATE_SCROLL => 16388

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_LAYOUT => 16389

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_START_APPLICATION => 16390

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_END_APPLICATION => 16391

    /**
     * @type {Integer (UInt32)}
     */
    static CONSOLE_APPLICATION_16BIT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CONSOLE_CARET_SELECTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CONSOLE_CARET_VISIBLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_CONSOLE_END => 16639

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_CREATE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DESTROY => 32769

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_SHOW => 32770

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_HIDE => 32771

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_REORDER => 32772

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_FOCUS => 32773

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_SELECTION => 32774

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_SELECTIONADD => 32775

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_SELECTIONREMOVE => 32776

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_SELECTIONWITHIN => 32777

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_STATECHANGE => 32778

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_LOCATIONCHANGE => 32779

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_NAMECHANGE => 32780

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DESCRIPTIONCHANGE => 32781

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_VALUECHANGE => 32782

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_PARENTCHANGE => 32783

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_HELPCHANGE => 32784

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DEFACTIONCHANGE => 32785

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_ACCELERATORCHANGE => 32786

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_INVOKED => 32787

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_TEXTSELECTIONCHANGED => 32788

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_CONTENTSCROLLED => 32789

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_SYSTEM_ARRANGMENTPREVIEW => 32790

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_CLOAKED => 32791

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_UNCLOAKED => 32792

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_LIVEREGIONCHANGED => 32793

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED => 32800

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DRAGSTART => 32801

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DRAGCANCEL => 32802

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DRAGCOMPLETE => 32803

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DRAGENTER => 32804

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DRAGLEAVE => 32805

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_DRAGDROPPED => 32806

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_IME_SHOW => 32807

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_IME_HIDE => 32808

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_IME_CHANGE => 32809

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED => 32816

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_OBJECT_END => 33023

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_AIA_START => 40960

    /**
     * @type {Integer (UInt32)}
     */
    static EVENT_AIA_END => 45055

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_STARTUP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_SHUTDOWN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_BEEP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_ERROR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_QUESTION => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_WARNING => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_INFORMATION => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_MAXIMIZE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_MINIMIZE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_RESTOREUP => 10

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_RESTOREDOWN => 11

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_APPSTART => 12

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_FAULT => 13

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_APPEND => 14

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_MENUCOMMAND => 15

    /**
     * @type {Integer (UInt32)}
     */
    static SOUND_SYSTEM_MENUPOPUP => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CSOUND_SYSTEM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CALERT_SYSTEM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static GUI_16BITTASK => 0

    /**
     * @type {Integer (UInt32)}
     */
    static USER_DEFAULT_SCREEN_DPI => 96

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_SELECTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_FOCUSED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_CHECKED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_MIXED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_INDETERMINATE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_READONLY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_HOTTRACKED => 128

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_DEFAULT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_EXPANDED => 512

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_COLLAPSED => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_BUSY => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_FLOATING => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_MARQUEED => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_ANIMATED => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_SIZEABLE => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_MOVEABLE => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_SELFVOICING => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_SELECTABLE => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_LINKED => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_TRAVERSED => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_MULTISELECTABLE => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_EXTSELECTABLE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_ALERT_LOW => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_ALERT_MEDIUM => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_ALERT_HIGH => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_PROTECTED => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static STATE_SYSTEM_VALID => 1073741823

    /**
     * @type {Integer (UInt32)}
     */
    static CCHILDREN_TITLEBAR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CCHILDREN_SCROLLBAR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static RIM_INPUT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RIM_INPUTSINK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RIM_TYPEMAX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_LEFT_BUTTON_DOWN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_LEFT_BUTTON_UP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_RIGHT_BUTTON_DOWN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_RIGHT_BUTTON_UP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_MIDDLE_BUTTON_DOWN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_MIDDLE_BUTTON_UP => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_1_DOWN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_1_UP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_2_DOWN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_2_UP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_3_DOWN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_3_UP => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_4_DOWN => 64

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_4_UP => 128

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_5_DOWN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_BUTTON_5_UP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_WHEEL => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static RI_MOUSE_HWHEEL => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static RI_KEY_MAKE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RI_KEY_BREAK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RI_KEY_E0 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RI_KEY_E1 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RI_KEY_TERMSRV_SET_LED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RI_KEY_TERMSRV_SHADOW => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RIDEV_EXMODEMASK => 240

    /**
     * @type {Integer (UInt32)}
     */
    static GIDC_ARRIVAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GIDC_REMOVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static POINTER_DEVICE_PRODUCT_STRING_MAX => 520

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_ARRIVAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_REMOVAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_ORIENTATION_0 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_ORIENTATION_90 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_ORIENTATION_180 => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_ORIENTATION_270 => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_MODE_DEFAULT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_MODE_CENTERED => 128

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_MAPPING_CHANGE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_RESOLUTION => 512

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_ORIGIN => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static PDC_MODE_ASPECTRATIOPRESERVED => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static GF_BEGIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static GF_INERTIA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static GF_END => 4

    /**
     * @type {Integer (UInt32)}
     */
    static GESTURECONFIGMAXCOUNT => 256

    /**
     * @type {Integer (UInt32)}
     */
    static GCF_INCLUDE_ANCESTORS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NID_INTEGRATED_TOUCH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NID_EXTERNAL_TOUCH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NID_INTEGRATED_PEN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NID_EXTERNAL_PEN => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NID_MULTI_INPUT => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NID_READY => 128

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_STR_BLOCKREASON => 256

    /**
     * @type {Integer (UInt32)}
     */
    static WM_TOOLTIPDISMISS => 837

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_CALLBACK => -1

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_SYSTEM => 1

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_MBAR_RESTORE => 2

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_MBAR_MINIMIZE => 3

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_MBAR_CLOSE => 5

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_MBAR_CLOSE_D => 6

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_MBAR_MINIMIZE_D => 7

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_POPUP_CLOSE => 8

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_POPUP_RESTORE => 9

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_POPUP_MAXIMIZE => 10

    /**
     * @type {Integer (Int32)}
     */
    static HBMMENU_POPUP_MINIMIZE => 11

    /**
     * @type {Integer (Int32)}
     */
    static CW_USEDEFAULT => -2147483648

    /**
     * @type {Integer (Int32)}
     */
    static LBS_STANDARD => 10485763

    /**
     * @type {Integer (Int32)}
     */
    static WINSTA_ALL_ACCESS => 895

    /**
     * @type {Integer (UInt32)}
     */
    static WVR_REDRAW => 768

    /**
     * @type {Integer (UInt16)}
     */
    static RT_GROUP_CURSOR => 12

    /**
     * @type {Integer (UInt16)}
     */
    static RT_GROUP_ICON => 14

    /**
     * @type {Integer (UInt16)}
     */
    static RT_MANIFEST => 24

    /**
     * @type {Integer (Int32)}
     */
    static IDC_STATIC => -1
;@endregion Constants

;@region Methods
    /**
     * Loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends a terminating null character. (ANSI)
     * @remarks
     * If you pass 0 to *cchBufferMax* to return a read-only pointer to the string resource in the *lpBuffer* parameter, use the number of characters in the return value to determine the length of the string resource. String resources are not guaranteed to be null-terminated in the module's resource table. However, resource tables can contain null characters. String resources are stored in blocks of 16 strings, and any empty slots within a block are indicated by null characters. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * Using this function incorrectly can compromise the security of your application. Incorrect use includes specifying the wrong size in the <i>nBufferMax</i> parameter. For example, if <i>lpBuffer</i> points to a buffer <i>szBuffer</i> which is declared as <c>TCHAR szBuffer[100]</code>, then sizeof(szBuffer) gives the size of the buffer in bytes, which could lead to a buffer overflow for the Unicode version of the function. Buffer overflow situations are the cause of many security problems in applications. In this case, using <code>sizeof(szBuffer)/sizeof(TCHAR)</code> or <code>sizeof(szBuffer)/sizeof(szBuffer[0])</c> would give the proper size of the buffer.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to an instance of the module whose executable file contains the string resource. To get the handle to the application itself, call the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function with <b>NULL</b>.
     * @param {Integer} uID Type: <b>UINT</b>
     * 
     * The identifier of the string to be loaded.
     * @param {Pointer<Byte>} lpBuffer Type: <b>LPTSTR</b>
     * 
     * The buffer to receive the string (if *cchBufferMax* is non-zero) or a read-only pointer to the string resource itself (if *cchBufferMax* is zero). Must be of sufficient length to hold a pointer (8 bytes).
     * @param {Integer} cchBufferMax Type: <b>int</b>
     * 
     * The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters specified. If this parameter is 0, then <i>lpBuffer</i> receives a read-only pointer to the string resource itself.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is one of the following:
     * 
     * - The number of characters copied into the buffer (if *cchBufferMax* is non-zero), not including the terminating null character.
     * - The number of characters in the string resource that *lpBuffer* points to (if *cchBufferMax* is zero). The string resource is not guaranteed to be null-terminated in the module's resource table, and you can use this value to determine where the string resource ends.
     * - Zero if the string resource does not exist. 
     *  
     * To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadstringa
     * @since windows5.0
     */
    static LoadStringA(hInstance, uID, lpBuffer, cchBufferMax) {
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("USER32.dll\LoadStringA", "ptr", hInstance, "uint", uID, "ptr", lpBuffer, "int", cchBufferMax)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends a terminating null character. (Unicode)
     * @remarks
     * If you pass 0 to *cchBufferMax* to return a read-only pointer to the string resource in the *lpBuffer* parameter, use the number of characters in the return value to determine the length of the string resource. String resources are not guaranteed to be null-terminated in the module's resource table. However, resource tables can contain null characters. String resources are stored in blocks of 16 strings, and any empty slots within a block are indicated by null characters. 
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * Using this function incorrectly can compromise the security of your application. Incorrect use includes specifying the wrong size in the <i>nBufferMax</i> parameter. For example, if <i>lpBuffer</i> points to a buffer <i>szBuffer</i> which is declared as <c>TCHAR szBuffer[100]</code>, then sizeof(szBuffer) gives the size of the buffer in bytes, which could lead to a buffer overflow for the Unicode version of the function. Buffer overflow situations are the cause of many security problems in applications. In this case, using <code>sizeof(szBuffer)/sizeof(TCHAR)</code> or <code>sizeof(szBuffer)/sizeof(szBuffer[0])</c> would give the proper size of the buffer.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to an instance of the module whose executable file contains the string resource. To get the handle to the application itself, call the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function with <b>NULL</b>.
     * @param {Integer} uID Type: <b>UINT</b>
     * 
     * The identifier of the string to be loaded.
     * @param {Pointer<Char>} lpBuffer Type: <b>LPTSTR</b>
     * 
     * The buffer to receive the string (if *cchBufferMax* is non-zero) or a read-only pointer to the string resource itself (if *cchBufferMax* is zero). Must be of sufficient length to hold a pointer (8 bytes).
     * @param {Integer} cchBufferMax Type: <b>int</b>
     * 
     * The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters specified. If this parameter is 0, then <i>lpBuffer</i> receives a read-only pointer to the string resource itself.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is one of the following:
     * 
     * - The number of characters copied into the buffer (if *cchBufferMax* is non-zero), not including the terminating null character.
     * - The number of characters in the string resource that *lpBuffer* points to (if *cchBufferMax* is zero). The string resource is not guaranteed to be null-terminated in the module's resource table, and you can use this value to determine where the string resource ends.
     * - Zero if the string resource does not exist. 
     *  
     * To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadstringw
     * @since windows5.0
     */
    static LoadStringW(hInstance, uID, lpBuffer, cchBufferMax) {
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("USER32.dll\LoadStringW", "ptr", hInstance, "uint", uID, "ptr", lpBuffer, "int", cchBufferMax)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory. (ANSI)
     * @remarks
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetWindowLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Pointer} Type: <b>LONG_PTR</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlongptra">SetWindowLongPtr</a> has not been called previously, <b>GetWindowLongPtr</b> returns zero for values in the extra window or class memory.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongptra
     * @since windows5.0
     */
    static GetWindowLongPtrA(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowLongPtrA", "ptr", hWnd, "int", nIndex, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory. (Unicode)
     * @remarks
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetWindowLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Pointer} Type: <b>LONG_PTR</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlongptra">SetWindowLongPtr</a> has not been called previously, <b>GetWindowLongPtr</b> returns zero for values in the extra window or class memory.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongptrw
     * @since windows5.0
     */
    static GetWindowLongPtrW(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowLongPtrW", "ptr", hWnd, "int", nIndex, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes an attribute of the specified window. (ANSI)
     * @remarks
     * Certain window data is cached, so changes you make using <b>SetWindowLongPtr</b> will not take effect until you call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function.
     * 
     * If you use <b>SetWindowLongPtr</b> with the <b>GWLP_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * If you use <b>SetWindowLongPtr</b> with the <b>DWLP_MSGRESULT</b> index to set the return value for a message processed by a dialog box procedure, the dialog box procedure should return <b>TRUE</b> directly afterward. Otherwise, if you call any function that results in your dialog box procedure receiving a window message, the nested window message could overwrite the return value you set by using <b>DWLP_MSGRESULT</b>. 
     * 
     * Calling <b>SetWindowLongPtr</b> with the <b>GWLP_WNDPROC</b> index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The <b>SetWindowLongPtr</b> function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>. This allows the application to create a chain of window procedures. 
     * 
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Do not call <b>SetWindowLongPtr</b> with the <b>GWLP_HWNDPARENT</b> index to change the parent of a child window. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setparent">SetParent</a> function. 
     * 
     * If the window has a class style of <b>CS_CLASSDC</b> or <b>CS_PARENTDC</b>, do not set the extended window styles <b>WS_EX_COMPOSITED</b> or <b>WS_EX_LAYERED</b>.
     * 
     *  Calling <b>SetWindowLongPtr</b> to set the style on a progressbar will reset its position.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SetWindowLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs. The <b>SetWindowLongPtr</b> function fails if the process that owns the window specified by the <i>hWnd</i> parameter is at a higher process privilege in the UIPI hierarchy than the process the calling thread resides in.
     * 
     * <b>WindowsXP/2000:</b> The <b>SetWindowLongPtr</b> function fails if the window specified by the <i>hWnd</i> parameter does not belong to the same process as the calling thread.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Pointer} dwNewLong Type: <b>LONG_PTR</b>
     * 
     * The replacement value.
     * @returns {Pointer} Type: <b>LONG_PTR</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified offset.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error information. To determine success or failure, clear the last error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0, then call <b>SetWindowLongPtr</b>. Function failure will be indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongptra
     * @since windows5.0
     */
    static SetWindowLongPtrA(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowLongPtrA", "ptr", hWnd, "int", nIndex, "ptr", dwNewLong, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes an attribute of the specified window. (Unicode)
     * @remarks
     * Certain window data is cached, so changes you make using <b>SetWindowLongPtr</b> will not take effect until you call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function.
     * 
     * If you use <b>SetWindowLongPtr</b> with the <b>GWLP_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * If you use <b>SetWindowLongPtr</b> with the <b>DWLP_MSGRESULT</b> index to set the return value for a message processed by a dialog box procedure, the dialog box procedure should return <b>TRUE</b> directly afterward. Otherwise, if you call any function that results in your dialog box procedure receiving a window message, the nested window message could overwrite the return value you set by using <b>DWLP_MSGRESULT</b>. 
     * 
     * Calling <b>SetWindowLongPtr</b> with the <b>GWLP_WNDPROC</b> index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The <b>SetWindowLongPtr</b> function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>. This allows the application to create a chain of window procedures. 
     * 
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Do not call <b>SetWindowLongPtr</b> with the <b>GWLP_HWNDPARENT</b> index to change the parent of a child window. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setparent">SetParent</a> function. 
     * 
     * If the window has a class style of <b>CS_CLASSDC</b> or <b>CS_PARENTDC</b>, do not set the extended window styles <b>WS_EX_COMPOSITED</b> or <b>WS_EX_LAYERED</b>.
     * 
     *  Calling <b>SetWindowLongPtr</b> to set the style on a progressbar will reset its position.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SetWindowLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs. The <b>SetWindowLongPtr</b> function fails if the process that owns the window specified by the <i>hWnd</i> parameter is at a higher process privilege in the UIPI hierarchy than the process the calling thread resides in.
     * 
     * <b>WindowsXP/2000:</b> The <b>SetWindowLongPtr</b> function fails if the window specified by the <i>hWnd</i> parameter does not belong to the same process as the calling thread.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Pointer} dwNewLong Type: <b>LONG_PTR</b>
     * 
     * The replacement value.
     * @returns {Pointer} Type: <b>LONG_PTR</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified offset.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the previous value is zero and the function succeeds, the return value is zero, but the function does not clear the last error information. To determine success or failure, clear the last error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0, then call <b>SetWindowLongPtr</b>. Function failure will be indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongptrw
     * @since windows5.0
     */
    static SetWindowLongPtrW(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowLongPtrW", "ptr", hWnd, "int", nIndex, "ptr", dwNewLong, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the specified value from the WNDCLASSEX structure associated with the specified window. (ANSI)
     * @remarks
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetClassLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Pointer} Type: <b>ULONG_PTR</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclasslongptra
     * @since windows5.0
     */
    static GetClassLongPtrA(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetClassLongPtrA", "ptr", hWnd, "int", nIndex, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the specified value from the WNDCLASSEX structure associated with the specified window. (Unicode)
     * @remarks
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetClassLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Pointer} Type: <b>ULONG_PTR</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclasslongptrw
     * @since windows5.0
     */
    static GetClassLongPtrW(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetClassLongPtrW", "ptr", hWnd, "int", nIndex, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces the specified value at the specified offset in the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs. (ANSI)
     * @remarks
     * If you use the <b>SetClassLongPtr</b> function and the <b>GCLP_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * Calling <b>SetClassLongPtr</b> with the <b>GCLP_WNDPROC</b> index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process. 
     * 
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Use the <b>SetClassLongPtr</b> function with care. For example, it is possible to change the background color for a class by using <b>SetClassLongPtr</b>, but this change does not immediately repaint all windows belonging to the class. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SetClassLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Pointer} dwNewLong Type: <b>LONG_PTR</b>
     * 
     * The replacement value.
     * @returns {Pointer} Type: <b>ULONG_PTR</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified offset. If this was not previously set, the return value is zero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setclasslongptra
     * @since windows5.0
     */
    static SetClassLongPtrA(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetClassLongPtrA", "ptr", hWnd, "int", nIndex, "ptr", dwNewLong, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces the specified value at the specified offset in the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs. (Unicode)
     * @remarks
     * If you use the <b>SetClassLongPtr</b> function and the <b>GCLP_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * Calling <b>SetClassLongPtr</b> with the <b>GCLP_WNDPROC</b> index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process. 
     * 
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Use the <b>SetClassLongPtr</b> function with care. For example, it is possible to change the background color for a class by using <b>SetClassLongPtr</b>, but this change does not immediately repaint all windows belonging to the class. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SetClassLongPtr as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Pointer} dwNewLong Type: <b>LONG_PTR</b>
     * 
     * The replacement value.
     * @returns {Pointer} Type: <b>ULONG_PTR</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified offset. If this was not previously set, the return value is zero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setclasslongptrw
     * @since windows5.0
     */
    static SetClassLongPtrW(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetClassLongPtrW", "ptr", hWnd, "int", nIndex, "ptr", dwNewLong, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes formatted data to the specified buffer using a pointer to a list of arguments. (ANSI)
     * @remarks
     * The function copies the format-control string into the output buffer character by character, starting with the first character in the string. When it encounters a format specification in the string, the function retrieves the value of the next available argument (starting with the first argument in the list), converts that value into the specified format, and copies the result to the output buffer. The function continues to copy characters and expand format specifications in this way until it reaches the end of the format-control string. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines wvsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} param0 
     * @param {Pointer<Byte>} param1 
     * @param {Pointer<SByte>} arglist Type: <b>va_list</b>
     * 
     * Each element of this list specifies an argument for the format-control string. The number, type, and interpretation of the arguments depend on the corresponding format-control specifications in the 
     * 					<i>lpFmt</i> parameter.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the number of characters stored in the buffer, not counting the terminating null character.
     * 
     * If the function fails, the return value is less than the length of the expected output. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-wvsprintfa
     * @since windows5.0
     */
    static wvsprintfA(param0, param1, arglist) {
        param0 := param0 is String? StrPtr(param0) : param0
        param1 := param1 is String? StrPtr(param1) : param1

        A_LastError := 0

        result := DllCall("USER32.dll\wvsprintfA", "ptr", param0, "ptr", param1, "char*", arglist)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes formatted data to the specified buffer using a pointer to a list of arguments. (Unicode)
     * @remarks
     * The function copies the format-control string into the output buffer character by character, starting with the first character in the string. When it encounters a format specification in the string, the function retrieves the value of the next available argument (starting with the first argument in the list), converts that value into the specified format, and copies the result to the output buffer. The function continues to copy characters and expand format specifications in this way until it reaches the end of the format-control string. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines wvsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} param0 
     * @param {Pointer<Char>} param1 
     * @param {Pointer<SByte>} arglist Type: <b>va_list</b>
     * 
     * Each element of this list specifies an argument for the format-control string. The number, type, and interpretation of the arguments depend on the corresponding format-control specifications in the 
     * 					<i>lpFmt</i> parameter.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the number of characters stored in the buffer, not counting the terminating null character.
     * 
     * If the function fails, the return value is less than the length of the expected output. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-wvsprintfw
     * @since windows5.0
     */
    static wvsprintfW(param0, param1, arglist) {
        param0 := param0 is String? StrPtr(param0) : param0
        param1 := param1 is String? StrPtr(param1) : param1

        A_LastError := 0

        result := DllCall("USER32.dll\wvsprintfW", "ptr", param0, "ptr", param1, "char*", arglist)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes formatted data to the specified buffer. (ANSI)
     * @remarks
     * The format-control string contains format specifications that determine the output format for the arguments following the <i>lpFmt</i> parameter. Format specifications, discussed below, always begin with a percent sign (%). If a percent sign is followed by a character that has no meaning as a format field, the character is not formatted (for example, %% produces a single percent-sign character).
     * 
     * The format-control string is read from left to right. When the first format specification (if any) is encountered, it causes the value of the first argument after the format-control string to be converted and copied to the output buffer according to the format specification. The second format specification causes the second argument to be converted and copied, and so on. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined. 
     * 
     * A format specification has the following form:
     * 
     * <b>%</b>[<b>-</b>][<b>#</b>][<b>0</b>][<i>width</i>][<i>.precision</i>]<i>type</i>
     * 
     * Each field is a single character or a number signifying a particular format option. The <i>type</i> characters that appear after the last optional format field determine whether the associated argument is interpreted as a character, a string, or a number. The simplest format specification contains only the percent sign and a type character (for example, %s). The optional fields control other aspects of the formatting. Following are the optional and required fields and their meanings.
     * 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Field</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>-</td>
     * <td>
     * Pad the output with blanks or zeros to the right to fill the field width, justifying output to the left. If this field is omitted, the output is padded to the left, justifying it to the right.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>#</td>
     * <td>
     * Prefix hexadecimal values with 0x (lowercase) or 0X (uppercase).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>
     * Pad the output value with zeros to fill the field width. If this field is omitted, the output value is padded with blank spaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><i>width</i></td>
     * <td>
     * Copy the specified minimum number of characters to the output buffer. The <i>width</i> field is a nonnegative integer. The width specification never causes a value to be truncated; if the number of characters in the output value is greater than the specified width, or if the <i>width</i> field is not present, all characters of the value are printed, subject to the precision specification.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>.<i>precision</i></td>
     * <td>
     * For numbers, copy the specified minimum number of digits to the output buffer. If the number of digits in the argument is less than the specified precision, the output value is padded on the left with zeros. The value is not truncated when the number of digits exceeds the specified precision. If the specified precision is 0 or omitted entirely, or if the period (.) appears without a number following it, the precision is set to 1.
     * 
     * For strings, copy the specified maximum number of characters to the output buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><i>type</i></td>
     * <td>
     * Output the corresponding argument as a character, a string, or a number. This field can be any of the following values.
     * 
     * 
     * 
     * <dl>
     * <dt><a id="c"></a><c>c</c></dt>
     * <dd>
     * Single character. This value is interpreted as type <b>CHAR</b>.
     * 
     * </dd>
     * <dt><a id="C"></a></a><c>C</c></dt>
     * <dd>
     * Single character. This value is interpreted as type <b>WCHAR</b>.
     * 
     * </dd>
     * <dt><a id="d"></a><a id="D"></a><c>d</c></dt>
     * <dd>
     * Signed decimal integer. This value is equivalent to <c>i</c>.
     * 
     * </dd>
     * <dt><a id="hc__hC"></a><a id="hc__hc"></a><a id="HC__HC"></a><c>hc</code>, <code>hC</c></dt>
     * <dd>
     * Single character. The <b>wsprintf</b> function ignores character arguments with a numeric value of zero. This value is always interpreted as type <b>CHAR</b>, even when the calling application defines Unicode.
     * 
     * </dd>
     * <dt><a id="hd"></a><a id="HD"></a><c>hd</c></dt>
     * <dd>
     * Signed short integer argument.
     * 
     * </dd>
     * <dt><a id="hs__hS"></a><a id="hs__hs"></a><a id="HS__HS"></a><c>hs</code>, <code>hS</c></dt>
     * <dd>
     * String. This value is always interpreted as type <b>LPSTR</b>, even when the calling application defines Unicode.
     * 
     * </dd>
     * <dt><a id="hu"></a><a id="HU"></a><c>hu</c></dt>
     * <dd>
     * Unsigned short integer.
     * 
     * </dd>
     * <dt><a id="i"></a><a id="I"></a><c>i</c></dt>
     * <dd>
     * Signed decimal integer. This value is equivalent to <c>d</c>.
     * 
     * </dd>
     * <dt><a id="Ix__IX"></a><a id="ix__ix"></a><a id="IX__IX"></a><c>Ix</code>, <code>IX</c></dt>
     * <dd>
     * 64-bit unsigned hexadecimal integer in lowercase or uppercase on 64-bit platforms, 32-bit unsigned hexadecimal integer in lowercase or uppercase on 32-bit platforms.
     * 
     * </dd>
     * <dt><a id="lc__lC"></a><a id="lc__lc"></a><a id="LC__LC"></a><c>lc</code>, <code>lC</c></dt>
     * <dd>
     * Single character. The <b>wsprintf</b> function ignores character arguments with a numeric value of zero. This value is always interpreted as type <b>WCHAR</b>, even when the calling application does not define Unicode.
     * 
     * </dd>
     * <dt><a id="ld"></a><a id="LD"></a><c>ld</c></dt>
     * <dd>
     * Long signed integer. This value is equivalent to <c>li</c>.
     * 
     * </dd>
     * <dt><a id="li"></a><a id="LI"></a><c>li</c></dt>
     * <dd>
     * Long signed integer. This value is equivalent to <c>ld</c>.
     * 
     * </dd>
     * <dt><a id="ls__lS"></a><a id="ls__ls"></a><a id="LS__LS"></a><c>ls</code>, <code>lS</c></dt>
     * <dd>
     * String. This value is always interpreted as type <b>LPWSTR</b>, even when the calling application does not define Unicode. This value is equivalent to <c>ws</c>.
     * 
     * </dd>
     * <dt><a id="lu"></a><a id="LU"></a><c>lu</c></dt>
     * <dd>
     * Long unsigned integer.
     * 
     * </dd>
     * <dt><a id="lx__lX"></a><a id="lx__lx"></a><a id="LX__LX"></a><c>lx</code>, <code>lX</c></dt>
     * <dd>
     * Long unsigned hexadecimal integer in lowercase or uppercase.
     * 
     * </dd>
     * <dt><a id="p"></a><a id="P"></a><c>p</c></dt>
     * <dd>
     * Pointer. The address is printed using hexadecimal.
     * 
     * </dd>
     * <dt><a id="s"></a><a id="S"></a><c>s</c></dt>
     * <dd>
     * String. This value is interpreted as type <b>LPWSTR</b> when the calling application defines Unicode and as type <b>LPSTR</b> otherwise.
     * 
     * </dd>
     * <dt><a id="S"></a><a id="s"></a><c>S</c></dt>
     * <dd>
     * String. This value is interpreted as type <b>LPSTR</b> when the calling application defines Unicode and as type <b>LPWSTR</b> otherwise.
     * 
     * </dd>
     * <dt><a id="u"></a><a id="U"></a><c>u</c></dt>
     * <dd>
     * Unsigned integer argument.
     * 
     * </dd>
     * <dt><a id="x__X"></a><a id="x__x"></a><a id="X__X"></a><c>x</code>, <code>X</c></dt>
     * <dd>
     * Unsigned hexadecimal integer in lowercase or uppercase.
     * 
     * </dd>
     * </dl>
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>It is important to note that <b>wsprintf</b> uses the C calling convention (<b>_cdecl</b>), rather than the standard call (<b>_stdcall</b>) calling convention. As a result, it is the responsibility of the calling process to pop arguments off the stack, and arguments are pushed on the stack from right to left. In C-language modules, the C compiler performs this task.</div>
     * <div></div>
     * To use buffers larger than 1024 bytes, use <b>_snwprintf</b>. For more information, see the documentation for the C run-time library. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines wsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} param0 
     * @param {Pointer<Byte>} param1 
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the number of characters stored in the output buffer, not counting the terminating null character.
     * 
     * If the function fails, the return value is less than the length of the expected output. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-wsprintfa
     * @since windows5.0
     */
    static wsprintfA(param0, param1) {
        param0 := param0 is String? StrPtr(param0) : param0
        param1 := param1 is String? StrPtr(param1) : param1

        A_LastError := 0

        result := DllCall("USER32.dll\wsprintfA", "ptr", param0, "ptr", param1, "CDecl ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes formatted data to the specified buffer. (Unicode)
     * @remarks
     * The format-control string contains format specifications that determine the output format for the arguments following the <i>lpFmt</i> parameter. Format specifications, discussed below, always begin with a percent sign (%). If a percent sign is followed by a character that has no meaning as a format field, the character is not formatted (for example, %% produces a single percent-sign character).
     * 
     * The format-control string is read from left to right. When the first format specification (if any) is encountered, it causes the value of the first argument after the format-control string to be converted and copied to the output buffer according to the format specification. The second format specification causes the second argument to be converted and copied, and so on. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined. 
     * 
     * A format specification has the following form:
     * 
     * <b>%</b>[<b>-</b>][<b>#</b>][<b>0</b>][<i>width</i>][<i>.precision</i>]<i>type</i>
     * 
     * Each field is a single character or a number signifying a particular format option. The <i>type</i> characters that appear after the last optional format field determine whether the associated argument is interpreted as a character, a string, or a number. The simplest format specification contains only the percent sign and a type character (for example, %s). The optional fields control other aspects of the formatting. Following are the optional and required fields and their meanings.
     * 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Field</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>-</td>
     * <td>
     * Pad the output with blanks or zeros to the right to fill the field width, justifying output to the left. If this field is omitted, the output is padded to the left, justifying it to the right.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>#</td>
     * <td>
     * Prefix hexadecimal values with 0x (lowercase) or 0X (uppercase).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>
     * Pad the output value with zeros to fill the field width. If this field is omitted, the output value is padded with blank spaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><i>width</i></td>
     * <td>
     * Copy the specified minimum number of characters to the output buffer. The <i>width</i> field is a nonnegative integer. The width specification never causes a value to be truncated; if the number of characters in the output value is greater than the specified width, or if the <i>width</i> field is not present, all characters of the value are printed, subject to the precision specification.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>.<i>precision</i></td>
     * <td>
     * For numbers, copy the specified minimum number of digits to the output buffer. If the number of digits in the argument is less than the specified precision, the output value is padded on the left with zeros. The value is not truncated when the number of digits exceeds the specified precision. If the specified precision is 0 or omitted entirely, or if the period (.) appears without a number following it, the precision is set to 1.
     * 
     * For strings, copy the specified maximum number of characters to the output buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><i>type</i></td>
     * <td>
     * Output the corresponding argument as a character, a string, or a number. This field can be any of the following values.
     * 
     * 
     * 
     * <dl>
     * <dt><a id="c"></a></a><c>c</c></dt>
     * <dd>
     * Single character. This value is interpreted as type <b>WCHAR</b>.
     * 
     * </dd>
     * <dt><a id="C"></a></a><c>C</c></dt>
     * <dd>
     * Single character. This value is interpreted as type <b>CHAR</b>.
     * 
     * </dd>
     * <dt><a id="d"></a><a id="D"></a><c>d</c></dt>
     * <dd>
     * Signed decimal integer. This value is equivalent to <c>i</c>.
     * 
     * </dd>
     * <dt><a id="hc__hC"></a><a id="hc__hc"></a><a id="HC__HC"></a><c>hc</code>, <code>hC</c></dt>
     * <dd>
     * Single character. The <b>wsprintf</b> function ignores character arguments with a numeric value of zero. This value is always interpreted as type <b>CHAR</b>, even when the calling application defines Unicode.
     * 
     * </dd>
     * <dt><a id="hd"></a><a id="HD"></a><c>hd</c></dt>
     * <dd>
     * Signed short integer argument.
     * 
     * </dd>
     * <dt><a id="hs__hS"></a><a id="hs__hs"></a><a id="HS__HS"></a><c>hs</code>, <code>hS</c></dt>
     * <dd>
     * String. This value is always interpreted as type <b>LPSTR</b>, even when the calling application defines Unicode.
     * 
     * </dd>
     * <dt><a id="hu"></a><a id="HU"></a><c>hu</c></dt>
     * <dd>
     * Unsigned short integer.
     * 
     * </dd>
     * <dt><a id="i"></a><a id="I"></a><c>i</c></dt>
     * <dd>
     * Signed decimal integer. This value is equivalent to <c>d</c>.
     * 
     * </dd>
     * <dt><a id="Ix__IX"></a><a id="ix__ix"></a><a id="IX__IX"></a><c>Ix</code>, <code>IX</c></dt>
     * <dd>
     * 64-bit unsigned hexadecimal integer in lowercase or uppercase on 64-bit platforms, 32-bit unsigned hexadecimal integer in lowercase or uppercase on 32-bit platforms.
     * 
     * </dd>
     * <dt><a id="lc__lC"></a><a id="lc__lc"></a><a id="LC__LC"></a><c>lc</code>, <code>lC</c></dt>
     * <dd>
     * Single character. The <b>wsprintf</b> function ignores character arguments with a numeric value of zero. This value is always interpreted as type <b>WCHAR</b>, even when the calling application does not define Unicode.
     * 
     * </dd>
     * <dt><a id="ld"></a><a id="LD"></a><c>ld</c></dt>
     * <dd>
     * Long signed integer. This value is equivalent to <c>li</c>.
     * 
     * </dd>
     * <dt><a id="li"></a><a id="LI"></a><c>li</c></dt>
     * <dd>
     * Long signed integer. This value is equivalent to <c>ld</c>.
     * 
     * </dd>
     * <dt><a id="ls__lS"></a><a id="ls__ls"></a><a id="LS__LS"></a><c>ls</code>, <code>lS</c></dt>
     * <dd>
     * String. This value is always interpreted as type <b>LPWSTR</b>, even when the calling application does not define Unicode. This value is equivalent to <c>ws</c>.
     * 
     * </dd>
     * <dt><a id="lu"></a><a id="LU"></a><c>lu</c></dt>
     * <dd>
     * Long unsigned integer.
     * 
     * </dd>
     * <dt><a id="lx__lX"></a><a id="lx__lx"></a><a id="LX__LX"></a><c>lx</code>, <code>lX</c></dt>
     * <dd>
     * Long unsigned hexadecimal integer in lowercase or uppercase.
     * 
     * </dd>
     * <dt><a id="p"></a><a id="P"></a><c>p</c></dt>
     * <dd>
     * Pointer. The address is printed using hexadecimal.
     * 
     * </dd>
     * <dt><a id="s"></a><a id="S"></a><c>s</c></dt>
     * <dd>
     * String. This value is interpreted as type <b>LPWSTR</b> when the calling application defines Unicode and as type <b>LPSTR</b> otherwise.
     * 
     * </dd>
     * <dt><a id="S"></a><a id="s"></a><c>S</c></dt>
     * <dd>
     * String. This value is interpreted as type <b>LPSTR</b> when the calling application defines Unicode and as type <b>LPWSTR</b> otherwise.
     * 
     * </dd>
     * <dt><a id="u"></a><a id="U"></a><c></c>u</dt>
     * <dd>
     * Unsigned integer argument.
     * 
     * </dd>
     * <dt><a id="x__X"></a><a id="x__x"></a><a id="X__X"></a><c>x</code>, <code>X</c></dt>
     * <dd>
     * Unsigned hexadecimal integer in lowercase or uppercase.
     * 
     * </dd>
     * </dl>
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>It is important to note that <b>wsprintf</b> uses the C calling convention (<b>_cdecl</b>), rather than the standard call (<b>_stdcall</b>) calling convention. As a result, it is the responsibility of the calling process to pop arguments off the stack, and arguments are pushed on the stack from right to left. In C-language modules, the C compiler performs this task.</div>
     * <div></div>
     * To use buffers larger than 1024 bytes, use <b>_snwprintf</b>. For more information, see the documentation for the C run-time library. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines wsprintf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} param0 
     * @param {Pointer<Char>} param1 
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the number of characters stored in the output buffer, not counting the terminating null character.
     * 
     * If the function fails, the return value is less than the length of the expected output. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-wsprintfw
     * @since windows5.0
     */
    static wsprintfW(param0, param1) {
        param0 := param0 is String? StrPtr(param0) : param0
        param1 := param1 is String? StrPtr(param1) : param1

        A_LastError := 0

        result := DllCall("USER32.dll\wsprintfW", "ptr", param0, "ptr", param1, "CDecl ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the system considers that a specified application is not responding.
     * @remarks
     * The Windows timeout criteria of 5 seconds is subject to change.
     * 
     * This function was not included in the SDK headers and libraries until WindowsXPService Pack1 (SP1) and Windows Server2003. If you do not have a header file and import library for this function, you can call the function using <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is <b>TRUE</b> if the window stops responding; otherwise, it is <b>FALSE</b>.  Ghost windows always return
     *         <b>TRUE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ishungappwindow
     * @since windows5.0
     */
    static IsHungAppWindow(hwnd) {
        result := DllCall("USER32.dll\IsHungAppWindow", "ptr", hwnd, "int")
        return result
    }

    /**
     * Disables the window ghosting feature for the calling GUI process. Window ghosting is a Windows Manager feature that lets the user minimize, move, or close the main window of an application that is not responding.
     * @remarks
     * After calling <b>DisableProcessWindowsGhosting</b>, the ghosting feature is disabled for the duration of the process.
     * @returns {Pointer} 
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting
     * @since windows5.1.2600
     */
    static DisableProcessWindowsGhosting() {
        result := DllCall("USER32.dll\DisableProcessWindowsGhosting")
        return result
    }

    /**
     * Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting messages. (ANSI)
     * @remarks
     * The <b>RegisterWindowMessage</b> function is typically used to register messages for communicating between two cooperating applications. 
     * 
     * If two different applications register the same message string, the applications return the same message value. The message remains registered until the session ends. 
     * 
     * Only use <b>RegisterWindowMessage</b> when more than one application must process the same message. For sending private messages within a window class, an application can use any integer in the range <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> through 0x7FFF. (Messages in this range are private to a window class, not to an application. For example, predefined control classes such as <b>BUTTON</b>, <b>EDIT</b>, <b>LISTBOX</b>, and <b>COMBOBOX</b> may use values in this range.)
     * @param {Pointer<Byte>} lpString Type: <b>LPCTSTR</b>
     * 
     * The message to be registered.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerwindowmessagea
     * @since windows5.0
     */
    static RegisterWindowMessageA(lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\RegisterWindowMessageA", "ptr", lpString)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting messages. (Unicode)
     * @remarks
     * The <b>RegisterWindowMessage</b> function is typically used to register messages for communicating between two cooperating applications. 
     * 
     * If two different applications register the same message string, the applications return the same message value. The message remains registered until the session ends. 
     * 
     * Only use <b>RegisterWindowMessage</b> when more than one application must process the same message. For sending private messages within a window class, an application can use any integer in the range <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> through 0x7FFF. (Messages in this range are private to a window class, not to an application. For example, predefined control classes such as <b>BUTTON</b>, <b>EDIT</b>, <b>LISTBOX</b>, and <b>COMBOBOX</b> may use values in this range.)
     * @param {Pointer<Char>} lpString Type: <b>LPCTSTR</b>
     * 
     * The message to be registered.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerwindowmessagew
     * @since windows5.0
     */
    static RegisterWindowMessageW(lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\RegisterWindowMessageW", "ptr", lpString)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval. (GetMessageA)
     * @remarks
     * An application typically uses the return value to determine whether to end the main message loop and exit the program. 
     * 
     * The <b>GetMessage</b> function retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children, as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system.
     * 
     * Note that <b>GetMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>.
     * 
     * During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order: 
     * 				
     * 
     * <ul>
     * <li>Sent messages </li>
     * <li>Posted messages </li>
     * <li>Input (hardware) messages and system internal events </li>
     * <li>Sent messages (again) </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> messages </li>
     * </ul>
     * To retrieve input messages before posted messages, use the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. 
     * 
     * <b>GetMessage</b> does not remove <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages from the queue. The messages remain in the queue until processed. 
     * 
     * If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window.
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output is in the mode of the window that the message is targeting. The calling thread is not taken into consideration.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information from the thread's message queue.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose messages are to be retrieved. The window must belong to the current thread. 
     * 
     * 
     * If <i>hWnd</i> is <b>NULL</b>, <b>GetMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed.
     * 
     *  If <i>hWnd</i> is -1, <b>GetMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>,  that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.
     * @param {Integer} wMsgFilterMin Type: <b>UINT</b>
     * 
     * The integer value of the lowest message value to be retrieved. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message. 
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMax</i> to specify only the <b>WM_INPUT</b> messages.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).
     * @param {Integer} wMsgFilterMax Type: <b>UINT</b>
     * 
     * The integer value of the highest message value to be retrieved. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message. 
     * 					
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMin</i> to specify only the <b>WM_INPUT</b> messages.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function retrieves a message other than <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a>, the return value is nonzero.
     * 
     * If the function retrieves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message, the return value is zero. 
     * 
     * If there is an error, the return value is -1. For example, the function fails if <i>hWnd</i> is an invalid window handle or <i>lpMsg</i> is an invalid pointer. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Because the return value can be nonzero, zero, or -1, avoid code like this:
     * 
     * 
     * ```
     * while (GetMessage( lpMsg, hWnd, 0, 0)) ...
     * ```
     * 
     * 
     * The possibility of a -1 return value in the case that hWnd is an invalid parameter (such as referring to a window that has already been destroyed) means that such code can lead to fatal application errors. Instead, use code like this:
     * 
     * 
     * ```
     * BOOL bRet;
     * 
     * while( (bRet = GetMessage( &msg, hWnd, 0, 0 )) != 0)
     * { 
     *     if (bRet == -1)
     *     {
     *         // handle the error and possibly exit
     *     }
     *     else
     *     {
     *         TranslateMessage(&msg); 
     *         DispatchMessage(&msg); 
     *     }
     * }
     * ```
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagea
     * @since windows5.0
     */
    static GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMessageA", "ptr", lpMsg, "ptr", hWnd, "uint", wMsgFilterMin, "uint", wMsgFilterMax, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval. (GetMessageW)
     * @remarks
     * An application typically uses the return value to determine whether to end the main message loop and exit the program. 
     * 
     * The <b>GetMessage</b> function retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children, as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system.
     * 
     * Note that <b>GetMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>.
     * 
     * During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order: 
     * 				
     * 
     * <ul>
     * <li>Sent messages </li>
     * <li>Posted messages </li>
     * <li>Input (hardware) messages and system internal events </li>
     * <li>Sent messages (again) </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> messages </li>
     * </ul>
     * To retrieve input messages before posted messages, use the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. 
     * 
     * <b>GetMessage</b> does not remove <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages from the queue. The messages remain in the queue until processed. 
     * 
     * If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When in the debugger mode, the system does not generate a ghost window.
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output is in the mode of the window that the message is targeting. The calling thread is not taken into consideration.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information from the thread's message queue.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose messages are to be retrieved. The window must belong to the current thread. 
     * 
     * 
     * If <i>hWnd</i> is <b>NULL</b>, <b>GetMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed.
     * 
     *  If <i>hWnd</i> is -1, <b>GetMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>,  that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.
     * @param {Integer} wMsgFilterMin Type: <b>UINT</b>
     * 
     * The integer value of the lowest message value to be retrieved. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message. 
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMax</i> to specify only the <b>WM_INPUT</b> messages.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).
     * @param {Integer} wMsgFilterMax Type: <b>UINT</b>
     * 
     * The integer value of the highest message value to be retrieved. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message. 
     * 					
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-input">WM_INPUT</a> here and in <i>wMsgFilterMin</i> to specify only the <b>WM_INPUT</b> messages.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>GetMessage</b> returns all available messages (that is, no range filtering is performed).
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function retrieves a message other than <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a>, the return value is nonzero.
     * 
     * If the function retrieves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message, the return value is zero. 
     * 
     * If there is an error, the return value is -1. For example, the function fails if <i>hWnd</i> is an invalid window handle or <i>lpMsg</i> is an invalid pointer. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * Because the return value can be nonzero, zero, or -1, avoid code like this:
     * 
     * 
     * ```
     * while (GetMessage( lpMsg, hWnd, 0, 0)) ...
     * ```
     * 
     * 
     * The possibility of a -1 return value in the case that hWnd is an invalid parameter (such as referring to a window that has already been destroyed) means that such code can lead to fatal application errors. Instead, use code like this:
     * 
     * 
     * ```
     * BOOL bRet;
     * 
     * while( (bRet = GetMessage( &msg, hWnd, 0, 0 )) != 0)
     * { 
     *     if (bRet == -1)
     *     {
     *         // handle the error and possibly exit
     *     }
     *     else
     *     {
     *         TranslateMessage(&msg); 
     *         DispatchMessage(&msg); 
     *     }
     * }
     * ```
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagew
     * @since windows5.0
     */
    static GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMessageW", "ptr", lpMsg, "ptr", hWnd, "uint", wMsgFilterMin, "uint", wMsgFilterMax, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.
     * @remarks
     * The <b>TranslateMessage</b> function does not modify the message pointed to by the <i>lpMsg</i> parameter. 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-deadchar">WM_DEADCHAR</a> message. <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a> combinations produce a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syschar">WM_SYSCHAR</a> or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-sysdeadchar">WM_SYSDEADCHAR</a> message. 
     * 
     * <b>TranslateMessage</b> produces <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-char">WM_CHAR</a> messages only for keys that are mapped to ASCII characters by the keyboard driver. 
     * 
     * If applications process virtual-key messages for some other purpose, they should not call <b>TranslateMessage</b>. For instance, an application should not call <b>TranslateMessage</b> if the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translateacceleratora">TranslateAccelerator</a> function returns a nonzero value. Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see  <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.
     * @param {Pointer<MSG>} lpMsg Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero.
     * 
     * If the message is <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a>, <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a>, or <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a>, the return value is nonzero, regardless of the translation. 
     * 
     * If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemessage
     * @since windows5.0
     */
    static TranslateMessage(lpMsg) {
        result := DllCall("USER32.dll\TranslateMessage", "ptr", lpMsg, "int")
        return result
    }

    /**
     * Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function. (DispatchMessageA)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure must contain valid message values. If the <i>lpmsg</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message and the <i>lParam</i> parameter of the <b>WM_TIMER</b> message is not <b>NULL</b>, <i>lParam</i> points to a function that is called instead of the window procedure. 
     * 
     * Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.
     * @param {Pointer<MSG>} lpMsg Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b>
     * 
     * A pointer to a structure that contains the message.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagea
     * @since windows5.0
     */
    static DispatchMessageA(lpMsg) {
        result := DllCall("USER32.dll\DispatchMessageA", "ptr", lpMsg, "ptr")
        return result
    }

    /**
     * Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function. (DispatchMessageW)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure must contain valid message values. If the <i>lpmsg</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message and the <i>lParam</i> parameter of the <b>WM_TIMER</b> message is not <b>NULL</b>, <i>lParam</i> points to a function that is called instead of the window procedure. 
     * 
     * Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">Dialog Box Keyboard Interface</a>.
     * @param {Pointer<MSG>} lpMsg Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a>*</b>
     * 
     * A pointer to a structure that contains the message.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessagew
     * @since windows5.0
     */
    static DispatchMessageW(lpMsg) {
        result := DllCall("USER32.dll\DispatchMessageW", "ptr", lpMsg, "ptr")
        return result
    }

    /**
     * 
     * @param {Integer} cMessagesMax 
     * @returns {Integer} 
     */
    static SetMessageQueue(cMessagesMax) {
        result := DllCall("USER32.dll\SetMessageQueue", "int", cMessagesMax, "int")
        return result
    }

    /**
     * Dispatches incoming nonqueued messages, checks the thread message queue for a posted message, and retrieves the message (if any exist). (ANSI)
     * @remarks
     * <b>PeekMessage</b> retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system.
     * 
     * Note that <b>PeekMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>.
     * 
     * During this call, the system dispatches (<a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a>) pending,  nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:
     * 
     * <ul>
     * <li>Sent messages </li>
     * <li>Posted messages </li>
     * <li>Input (hardware) messages and system internal events </li>
     * <li>Sent messages (again) </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> messages </li>
     * </ul>
     * To retrieve input messages before posted messages, use the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. 
     * 
     * The <b>PeekMessage</b> function normally does not remove <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages from the queue. <b>WM_PAINT</b> messages remain in the queue until they are processed. However, if a <b>WM_PAINT</b> message has a <b>NULL</b> update region, <b>PeekMessage</b> does remove it from the queue.
     * 
     *  If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When an application is being debugged, the system does not generate a ghost window. 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output is in the mode of the window that the message is targeting. The calling thread is not taken into consideration.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose messages are to be retrieved. The window must belong to the current thread. 
     * 
     * 
     * 
     * If <i>hWnd</i> is <b>NULL</b>, <b>PeekMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed.
     * 
     *  If <i>hWnd</i> is -1, <b>PeekMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>, that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.
     * @param {Integer} wMsgFilterMin Type: <b>UINT</b>
     * 
     * The value of the first message in the range of messages to be examined. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).
     * @param {Integer} wMsgFilterMax Type: <b>UINT</b>
     * 
     * The value of the last message in the range of messages to be examined. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).
     * @param {Integer} wRemoveMsg Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If a message is available, the return value is nonzero.
     * 
     * If no messages are available, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagea
     * @since windows5.0
     */
    static PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg) {
        result := DllCall("USER32.dll\PeekMessageA", "ptr", lpMsg, "ptr", hWnd, "uint", wMsgFilterMin, "uint", wMsgFilterMax, "uint", wRemoveMsg, "int")
        return result
    }

    /**
     * Dispatches incoming nonqueued messages, checks the thread message queue for a posted message, and retrieves the message (if any exist). (Unicode)
     * @remarks
     * <b>PeekMessage</b> retrieves messages associated with the window identified by the <i>hWnd</i> parameter or any of its children as specified by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-ischild">IsChild</a> function, and within the range of message values given by the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. Note that an application can only use the low word in the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters; the high word is reserved for the system.
     * 
     * Note that <b>PeekMessage</b> always retrieves <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> messages, no matter which values you specify for <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i>.
     * 
     * During this call, the system dispatches (<a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a>) pending,  nonqueued messages, that is, messages sent to windows owned by the calling thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no filter is specified, messages are processed in the following order:
     * 
     * <ul>
     * <li>Sent messages </li>
     * <li>Posted messages </li>
     * <li>Input (hardware) messages and system internal events </li>
     * <li>Sent messages (again) </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> messages </li>
     * </ul>
     * To retrieve input messages before posted messages, use the <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> parameters. 
     * 
     * The <b>PeekMessage</b> function normally does not remove <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> messages from the queue. <b>WM_PAINT</b> messages remain in the queue until they are processed. However, if a <b>WM_PAINT</b> message has a <b>NULL</b> update region, <b>PeekMessage</b> does remove it from the queue.
     * 
     *  If a top-level window stops responding to messages for more than several seconds, the system considers the window to be not responding and replaces it with a ghost window that has the same z-order, location, size, and visual attributes. This allows the user to move it, resize it, or even close the application. However, these are the only actions available because the application is actually not responding. When an application is being debugged, the system does not generate a ghost window. 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output is in the mode of the window that the message is targeting. The calling thread is not taken into consideration.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that receives message information.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose messages are to be retrieved. The window must belong to the current thread. 
     * 
     * 
     * 
     * If <i>hWnd</i> is <b>NULL</b>, <b>PeekMessage</b> retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b> (see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure). Therefore if hWnd is <b>NULL</b>, both window messages and thread messages are processed.
     * 
     *  If <i>hWnd</i> is -1, <b>PeekMessage</b> retrieves only messages on the current thread's message queue whose <b>hwnd</b> value is <b>NULL</b>, that is, thread messages as posted by  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a> (when the <i>hWnd</i> parameter is <b>NULL</b>) or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a>.
     * @param {Integer} wMsgFilterMin Type: <b>UINT</b>
     * 
     * The value of the first message in the range of messages to be examined. Use <b>WM_KEYFIRST</b> (0x0100) to specify the first keyboard message or <b>WM_MOUSEFIRST</b> (0x0200) to specify the first mouse message.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).
     * @param {Integer} wMsgFilterMax Type: <b>UINT</b>
     * 
     * The value of the last message in the range of messages to be examined. Use <b>WM_KEYLAST</b> to specify the last keyboard message or <b>WM_MOUSELAST</b> to specify the last mouse message.
     * 
     * If <i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are both zero, <b>PeekMessage</b> returns all available messages (that is, no range filtering is performed).
     * @param {Integer} wRemoveMsg Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If a message is available, the return value is nonzero.
     * 
     * If no messages are available, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-peekmessagew
     * @since windows5.0
     */
    static PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg) {
        result := DllCall("USER32.dll\PeekMessageW", "ptr", lpMsg, "ptr", hWnd, "uint", wMsgFilterMin, "uint", wMsgFilterMax, "uint", wRemoveMsg, "int")
        return result
    }

    /**
     * Retrieves the cursor position for the last message retrieved by the GetMessage function.
     * @remarks
     * As noted above, the x-coordinate is in the low-order <b>short</b> of the return value; the y-coordinate is in the high-order <b>short</b> (both represent <i>signed</i> values because they can take negative values on systems with multiple monitors). If the return value is assigned to a variable, you can use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-makepoints">MAKEPOINTS</a> macro to obtain a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-points">POINTS</a> structure from the return value. You can also use the <a href="https://docs.microsoft.com/windows/desktop/api/windowsx/nf-windowsx-get_x_lparam">GET_X_LPARAM</a> or <a href="https://docs.microsoft.com/windows/desktop/api/windowsx/nf-windowsx-get_y_lparam">GET_Y_LPARAM</a> macro to extract the x- or y-coordinate. 
     * 
     * <div class="alert"><b>Important</b>Do not use the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632659(v=vs.85)">LOWORD</a> or <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms632657(v=vs.85)">HIWORD</a> macros to extract the x- and y- coordinates of the cursor position because these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have negative x- and y- coordinates, and <b>LOWORD</b> and <b>HIWORD</b> treat the coordinates as unsigned quantities.</div>
     * <div></div>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value specifies the x- and y-coordinates of the cursor position. The x-coordinate is the low order <b>short</b> and the y-coordinate is the high-order <b>short</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagepos
     * @since windows5.0
     */
    static GetMessagePos() {
        result := DllCall("USER32.dll\GetMessagePos", "uint")
        return result
    }

    /**
     * Retrieves the message time for the last message retrieved by the GetMessage function.
     * @remarks
     * The return value from the <b>GetMessageTime</b> function does not necessarily increase between subsequent messages, because the value wraps to the minimum value for a long integer if the timer count exceeds the maximum value for a long integer.
     * 
     * To calculate time delays between messages, subtract the time of the first message from the time of the second message (ignoring overflow) and compare the result of the subtraction against the desired delay amount.
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * The return value specifies the message time.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessagetime
     * @since windows5.0
     */
    static GetMessageTime() {
        result := DllCall("USER32.dll\GetMessageTime", "int")
        return result
    }

    /**
     * Retrieves the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with the current thread's message queue.
     * @remarks
     * To set a thread's extra message information, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setmessageextrainfo">SetMessageExtraInfo</a> function.
     * @returns {Pointer} Type: <b>LPARAM</b>
     * 
     * The return value specifies the extra information. The meaning of the extra information is device specific.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmessageextrainfo
     * @since windows5.0
     */
    static GetMessageExtraInfo() {
        result := DllCall("USER32.dll\GetMessageExtraInfo", "ptr")
        return result
    }

    /**
     * Determines whether the last message read from the current thread's queue originated from a WOW64 process.
     * @remarks
     * This function  is useful to helping you develop 64-bit native applications that can receive private messages sent from  32-bit client applications, if the messages are associated with data structures that contain pointer-dependent data. In these situations, you can call this function in your 64-bit native application to determine if the message originated from a WOW64 process and then thunk the message appropriately.
     * @returns {Integer} The function returns TRUE if the last message read from the current thread's queue originated from a WOW64 process, and FALSE otherwise.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iswow64message
     * @since windows6.0.6000
     */
    static IsWow64Message() {
        result := DllCall("USER32.dll\IsWow64Message", "int")
        return result
    }

    /**
     * Sets the extra message information for the current thread.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * The value to be associated with the current thread.
     * @returns {Pointer} Type: <b>LPARAM</b>
     * 
     * The return value is the previous value associated with the current thread.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmessageextrainfo
     * @since windows5.0
     */
    static SetMessageExtraInfo(lParam) {
        result := DllCall("USER32.dll\SetMessageExtraInfo", "ptr", lParam, "ptr")
        return result
    }

    /**
     * Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message. (SendMessageA)
     * @remarks
     * When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied).
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a> with SMTO_BLOCK set. For more information on nonqueued messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">Nonqueued Messages</a>.
     * 
     *  An accessibility application can use <b>SendMessage</b> to send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
     * 
     *  Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing; it depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagea
     * @since windows5.0
     */
    static SendMessageA(hWnd, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendMessageA", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the specified window and does not return until the window procedure has processed the message. (SendMessageW)
     * @remarks
     * When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied).
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to be processed. To prevent this, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a> with SMTO_BLOCK set. For more information on nonqueued messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">Nonqueued Messages</a>.
     * 
     *  An accessibility application can use <b>SendMessage</b> to send <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
     * 
     *  Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or equal integrity level.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing; it depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagew
     * @since windows5.0
     */
    static SendMessageW(hWnd, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendMessageW", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends the specified message to one or more windows. (ANSI)
     * @remarks
     * The function calls the window procedure for the specified window and, if the specified window belongs to a different thread, does not return until the window procedure has processed the message or the specified time-out period has elapsed. If the window receiving the message belongs to the same queue as the current thread, the window procedure is called directlythe time-out value is ignored.
     * 
     * This function considers that a thread is not responding if it has not called <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or a similar function within five seconds.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SendMessageTimeout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message.
     * 
     * If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up to the value of <i>uTimeout</i> multiplied by the number of top-level windows.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Any additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Any additional message-specific information.
     * @param {Integer} fuFlags Type: <b>UINT</b>
     * @param {Integer} uTimeout Type: <b>UINT</b>
     * 
     * The duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay.
     * @param {Pointer<UIntPtr>} lpdwResult Type: <b>PDWORD_PTR</b>
     * 
     * The result of the message processing. The value of this parameter depends on the message that is specified.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * If the function succeeds, the return value is nonzero. <b>SendMessageTimeout</b> does not provide information about individual windows timing out if <b>HWND_BROADCAST</b> is used.
     * 
     * If the function fails or times out, the return value is 0. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If <b>GetLastError</b> returns <b>ERROR_TIMEOUT</b>, then the function timed out.
     * 
     * <b>Windows2000:</b>If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 0, then the function timed out.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta
     * @since windows5.0
     */
    static SendMessageTimeoutA(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendMessageTimeoutA", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "uint", fuFlags, "uint", uTimeout, "ptr*", lpdwResult, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends the specified message to one or more windows. (Unicode)
     * @remarks
     * The function calls the window procedure for the specified window and, if the specified window belongs to a different thread, does not return until the window procedure has processed the message or the specified time-out period has elapsed. If the window receiving the message belongs to the same queue as the current thread, the window procedure is called directlythe time-out value is ignored.
     * 
     * This function considers that a thread is not responding if it has not called <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or a similar function within five seconds.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SendMessageTimeout as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message.
     * 
     * If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up to the value of <i>uTimeout</i> multiplied by the number of top-level windows.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Any additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Any additional message-specific information.
     * @param {Integer} fuFlags Type: <b>UINT</b>
     * @param {Integer} uTimeout Type: <b>UINT</b>
     * 
     * The duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up to a 15 second delay.
     * @param {Pointer<UIntPtr>} lpdwResult Type: <b>PDWORD_PTR</b>
     * 
     * The result of the message processing. The value of this parameter depends on the message that is specified.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * If the function succeeds, the return value is nonzero. <b>SendMessageTimeout</b> does not provide information about individual windows timing out if <b>HWND_BROADCAST</b> is used.
     * 
     * If the function fails or times out, the return value is 0. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If <b>GetLastError</b> returns <b>ERROR_TIMEOUT</b>, then the function timed out.
     * 
     * <b>Windows2000:</b>If <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 0, then the function timed out.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagetimeoutw
     * @since windows5.0
     */
    static SendMessageTimeoutW(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendMessageTimeoutW", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "uint", fuFlags, "uint", uTimeout, "ptr*", lpdwResult, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends the specified message to a window or windows. (SendNotifyMessageA)
     * @remarks
     * If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a>, <b>SendNotifyMessage</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SendNotifyMessage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendnotifymessagea
     * @since windows5.0
     */
    static SendNotifyMessageA(hWnd, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendNotifyMessageA", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends the specified message to a window or windows. (SendNotifyMessageW)
     * @remarks
     * If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a>, <b>SendNotifyMessage</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SendNotifyMessage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendnotifymessagew
     * @since windows5.0
     */
    static SendNotifyMessageW(hWnd, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendNotifyMessageW", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends the specified message to a window or windows. (SendMessageCallbackA)
     * @remarks
     * If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the callback function is called immediately after the window procedure returns. If the target window belongs to a different thread from the caller, then the callback function is called only when the thread that called <b>SendMessageCallback</b> also calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-waitmessage">WaitMessage</a>.
     * 
     * If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a>, and <b>SendMessageCallback</b>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. 
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SendMessageCallback as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer<SENDASYNCPROC>} lpResultCallBack Type: <b>SENDASYNCPROC</b>
     * 
     * A pointer to a callback function that the system calls after the window procedure processes the message. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-sendasyncproc">SendAsyncProc</a>. 
     * 
     *                     
     * 
     * If <i>hWnd</i> is <b>HWND_BROADCAST</b> ((HWND)0xffff), the system calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-sendasyncproc">SendAsyncProc</a> callback function once for each top-level window.
     * @param {Pointer} dwData Type: <b>ULONG_PTR</b>
     * 
     * An application-defined value to be sent to the callback function pointed to by the <i>lpCallBack</i> parameter.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka
     * @since windows5.0
     */
    static SendMessageCallbackA(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendMessageCallbackA", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr", lpResultCallBack, "ptr", dwData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends the specified message to a window or windows. (SendMessageCallbackW)
     * @remarks
     * If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the callback function is called immediately after the window procedure returns. If the target window belongs to a different thread from the caller, then the callback function is called only when the thread that called <b>SendMessageCallback</b> also calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-waitmessage">WaitMessage</a>.
     * 
     * If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postmessagea">PostMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a>, and <b>SendMessageCallback</b>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used. 
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines SendMessageCallback as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure will receive the message. If this parameter is <b>HWND_BROADCAST</b> ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer<SENDASYNCPROC>} lpResultCallBack Type: <b>SENDASYNCPROC</b>
     * 
     * A pointer to a callback function that the system calls after the window procedure processes the message. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-sendasyncproc">SendAsyncProc</a>. 
     * 
     *                     
     * 
     * If <i>hWnd</i> is <b>HWND_BROADCAST</b> ((HWND)0xffff), the system calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-sendasyncproc">SendAsyncProc</a> callback function once for each top-level window.
     * @param {Pointer} dwData Type: <b>ULONG_PTR</b>
     * 
     * An application-defined value to be sent to the callback function pointed to by the <i>lpCallBack</i> parameter.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-sendmessagecallbackw
     * @since windows5.0
     */
    static SendMessageCallbackW(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData) {
        A_LastError := 0

        result := DllCall("USER32.dll\SendMessageCallbackW", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr", lpResultCallBack, "ptr", dwData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers the device or type of device for which a window will receive notifications. (ANSI)
     * @remarks
     * Applications send event notifications using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-broadcastsystemmessage">BroadcastSystemMessage</a> function. Any 
     *     application with a top-level window can receive basic notifications by processing the 
     *     <a href="https://docs.microsoft.com/windows/desktop/DevIO/wm-devicechange">WM_DEVICECHANGE</a> message. Applications can use the 
     *     <b>RegisterDeviceNotification</b> function to 
     *     register to receive device notifications.
     * 
     * Services can use the 
     *     <b>RegisterDeviceNotification</b> function to 
     *     register to receive device notifications. If a service specifies a window handle in the 
     *     <i>hRecipient</i> parameter, the notifications are sent to the window procedure. If 
     *     <i>hRecipient</i> is a service status handle, 
     *     <b>SERVICE_CONTROL_DEVICEEVENT</b> notifications are sent to the service control handler. For 
     *     more information about the service control handler, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nc-winsvc-lphandler_function_ex">HandlerEx</a>.
     * 
     * Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become 
     *     unresponsive. If your event handler is to perform an operation that may block execution (such as I/O), it is best 
     *     to start another thread to perform the operation asynchronously.
     * 
     * Device notification handles returned by 
     *     <b>RegisterDeviceNotification</b> must be closed 
     *     by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterdevicenotification">UnregisterDeviceNotification</a> function 
     *     when they are no longer needed.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/DevIO/dbt-devicearrival">DBT_DEVICEARRIVAL</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/DevIO/dbt-deviceremovecomplete">DBT_DEVICEREMOVECOMPLETE</a> events are 
     *     automatically broadcast to all top-level windows for port devices. Therefore, it is not necessary to call 
     *     <b>RegisterDeviceNotification</b> for ports, and 
     *     the function fails if the <b>dbch_devicetype</b> member is 
     *     <b>DBT_DEVTYP_PORT</b>. Volume notifications are also broadcast to top-level windows, so the 
     *     function fails if <b>dbch_devicetype</b> is <b>DBT_DEVTYP_VOLUME</b>. 
     *     OEM-defined devices are not used directly by the system, so the function fails if 
     *     <b>dbch_devicetype</b> is <b>DBT_DEVTYP_OEM</b>.
     * @param {Pointer<Void>} hRecipient A handle to the window or service that will receive device events for the devices specified in the 
     *        <i>NotificationFilter</i> parameter. The same window handle can be used in multiple calls to 
     *        <b>RegisterDeviceNotification</b>.
     * 
     * Services can specify either a window handle or service status handle.
     * @param {Pointer<Void>} NotificationFilter A pointer to a block of data that specifies the type of device for which notifications should be sent. This 
     *       block always begins with the <a href="https://docs.microsoft.com/windows/desktop/api/dbt/ns-dbt-dev_broadcast_hdr">DEV_BROADCAST_HDR</a> 
     *       structure. The data following this header is dependent on the value of the 
     *       <b>dbch_devicetype</b> member, which can be 
     *       <b>DBT_DEVTYP_DEVICEINTERFACE</b> or <b>DBT_DEVTYP_HANDLE</b>. For more 
     *       information, see Remarks.
     * @param {Integer} Flags 
     * @returns {Pointer<Void>} If the function succeeds, the return value is a device notification handle.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, 
     *        call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerdevicenotificationa
     * @since windows5.1.2600
     */
    static RegisterDeviceNotificationA(hRecipient, NotificationFilter, Flags) {
        A_LastError := 0

        result := DllCall("USER32.dll\RegisterDeviceNotificationA", "ptr", hRecipient, "ptr", NotificationFilter, "uint", Flags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers the device or type of device for which a window will receive notifications. (Unicode)
     * @remarks
     * Applications send event notifications using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-broadcastsystemmessage">BroadcastSystemMessage</a> function. Any 
     *     application with a top-level window can receive basic notifications by processing the 
     *     <a href="https://docs.microsoft.com/windows/desktop/DevIO/wm-devicechange">WM_DEVICECHANGE</a> message. Applications can use the 
     *     <b>RegisterDeviceNotification</b> function to 
     *     register to receive device notifications.
     * 
     * Services can use the 
     *     <b>RegisterDeviceNotification</b> function to 
     *     register to receive device notifications. If a service specifies a window handle in the 
     *     <i>hRecipient</i> parameter, the notifications are sent to the window procedure. If 
     *     <i>hRecipient</i> is a service status handle, 
     *     <b>SERVICE_CONTROL_DEVICEEVENT</b> notifications are sent to the service control handler. For 
     *     more information about the service control handler, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winsvc/nc-winsvc-lphandler_function_ex">HandlerEx</a>.
     * 
     * Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become 
     *     unresponsive. If your event handler is to perform an operation that may block execution (such as I/O), it is best 
     *     to start another thread to perform the operation asynchronously.
     * 
     * Device notification handles returned by 
     *     <b>RegisterDeviceNotification</b> must be closed 
     *     by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterdevicenotification">UnregisterDeviceNotification</a> function 
     *     when they are no longer needed.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/DevIO/dbt-devicearrival">DBT_DEVICEARRIVAL</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/DevIO/dbt-deviceremovecomplete">DBT_DEVICEREMOVECOMPLETE</a> events are 
     *     automatically broadcast to all top-level windows for port devices. Therefore, it is not necessary to call 
     *     <b>RegisterDeviceNotification</b> for ports, and 
     *     the function fails if the <b>dbch_devicetype</b> member is 
     *     <b>DBT_DEVTYP_PORT</b>. Volume notifications are also broadcast to top-level windows, so the 
     *     function fails if <b>dbch_devicetype</b> is <b>DBT_DEVTYP_VOLUME</b>. 
     *     OEM-defined devices are not used directly by the system, so the function fails if 
     *     <b>dbch_devicetype</b> is <b>DBT_DEVTYP_OEM</b>.
     * @param {Pointer<Void>} hRecipient A handle to the window or service that will receive device events for the devices specified in the 
     *        <i>NotificationFilter</i> parameter. The same window handle can be used in multiple calls to 
     *        <b>RegisterDeviceNotification</b>.
     * 
     * Services can specify either a window handle or service status handle.
     * @param {Pointer<Void>} NotificationFilter A pointer to a block of data that specifies the type of device for which notifications should be sent. This 
     *       block always begins with the <a href="https://docs.microsoft.com/windows/desktop/api/dbt/ns-dbt-dev_broadcast_hdr">DEV_BROADCAST_HDR</a> 
     *       structure. The data following this header is dependent on the value of the 
     *       <b>dbch_devicetype</b> member, which can be 
     *       <b>DBT_DEVTYP_DEVICEINTERFACE</b> or <b>DBT_DEVTYP_HANDLE</b>. For more 
     *       information, see Remarks.
     * @param {Integer} Flags 
     * @returns {Pointer<Void>} If the function succeeds, the return value is a device notification handle.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, 
     *        call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerdevicenotificationw
     * @since windows5.1.2600
     */
    static RegisterDeviceNotificationW(hRecipient, NotificationFilter, Flags) {
        A_LastError := 0

        result := DllCall("USER32.dll\RegisterDeviceNotificationW", "ptr", hRecipient, "ptr", NotificationFilter, "uint", Flags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes the specified device notification handle.
     * @param {Pointer<Void>} Handle Device notification handle returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerdevicenotificationa">RegisterDeviceNotification</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterdevicenotification
     * @since windows5.1.2600
     */
    static UnregisterDeviceNotification(Handle) {
        A_LastError := 0

        result := DllCall("USER32.dll\UnregisterDeviceNotification", "ptr", Handle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message. (ANSI)
     * @remarks
     * When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied).
     * 
     * Messages in a message queue are retrieved by calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<b>PostMessage</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
     * 
     * Do not post the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message using <b>PostMessage</b>; use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a> function.
     * 
     *  An accessibility application can use <b>PostMessage</b> to post <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications.
     * 
     * A message queue can contain at most 10,000 messages. This limit should be sufficiently large.  If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.
     * 				
     * <pre><b>HKEY_LOCAL_MACHINE</b>
     * <b>SOFTWARE</b>
     * <b>Microsoft</b>
     * <b>Windows NT</b>
     * <b>CurrentVersion</b>
     * <b>Windows</b>
     * <b>USERPostMessageLimit</b></pre>
     * 
     * If the function fails, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the limit is hit.
     * 
     * The minimum acceptable value is 4000.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure is to receive the message. The following values have special meanings.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HWND_BROADCAST"></a><a id="hwnd_broadcast"></a><dl>
     * <dt><b>HWND_BROADCAST</b></dt>
     * <dt>((HWND)0xffff)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>NULL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function behaves like a call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a> with the <i>dwThreadId</i> parameter set to the identifier of the current thread.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Starting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues of threads in processes of lesser or equal integrity level.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be posted.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagea
     * @since windows5.0
     */
    static PostMessageA(hWnd, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\PostMessageA", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message. (Unicode)
     * @remarks
     * When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied).
     * 
     * Messages in a message queue are retrieved by calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.
     * 
     * Applications that need to communicate using <b>HWND_BROADCAST</b> should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> function to obtain a unique message for inter-application communication.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     * If you send a message in the range below <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> to the asynchronous message functions (<b>PostMessage</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a>), its message parameters cannot include pointers. Otherwise, the operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free the memory before it is used.
     * 
     * Do not post the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message using <b>PostMessage</b>; use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postquitmessage">PostQuitMessage</a> function.
     * 
     *  An accessibility application can use <b>PostMessage</b> to post <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> messages  to the shell to launch applications. This  functionality is not guaranteed to work for other types of applications.
     * 
     * There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large.  If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.
     * 
     * <pre><b>HKEY_LOCAL_MACHINE</b>
     * <b>SOFTWARE</b>
     * <b>Microsoft</b>
     * <b>Windows NT</b>
     * <b>CurrentVersion</b>
     * <b>Windows</b>
     * <b>USERPostMessageLimit</b></pre>
     * 
     * If the function fails, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to get extended error information. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the limit is hit.
     * 
     * The minimum acceptable value is 4000.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose window procedure is to receive the message. The following values have special meanings.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="HWND_BROADCAST"></a><a id="hwnd_broadcast"></a><dl>
     * <dt><b>HWND_BROADCAST</b></dt>
     * <dt>((HWND)0xffff)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>NULL</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function behaves like a call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-postthreadmessagea">PostThreadMessage</a> with the <i>dwThreadId</i> parameter set to the identifier of the current thread.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Starting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues of threads in processes of lesser or equal integrity level.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be posted.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postmessagew
     * @since windows5.0
     */
    static PostMessageW(hWnd, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\PostMessageW", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message. (ANSI)
     * @remarks
     * When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied).
     * 
     * The thread to which the message is posted must have created a message queue, or else the call to <b>PostThreadMessage</b> fails. Use the following method to handle this situation. 
     * 
     * 				
     * 
     * <ul>
     * <li>
     * Create an event object, then create the thread.
     * 
     * </li>
     * <li>
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject</a> function to wait for the event to be set to the signaled state before calling <b>PostThreadMessage</b>.
     * 
     * </li>
     * <li>
     * In the thread to which the message will be posted, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> as shown here to force the system to create the message queue.
     * 
     * <c>PeekMessage(&amp;msg, NULL, WM_USER, WM_USER, PM_NOREMOVE)</c>
     * 
     * </li>
     * <li>
     * Set the event, to indicate that the thread is ready to receive posted messages.
     * 
     * </li>
     * </ul>
     * The thread to which the message is posted retrieves the message by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function. The <b>hwnd</b> member of the returned <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure is <b>NULL</b>.
     * 
     * Messages sent by <b>PostThreadMessage</b> are not associated with a window. As a general rule, messages that are not associated with a window cannot be dispatched by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a> function. Therefore, if the recipient thread is in a modal loop (as used by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxa">DialogBox</a>), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     *  There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.
     * 
     * 
     * <pre><b>HKEY_LOCAL_MACHINE</b>
     * <b>SOFTWARE</b>
     * <b>Microsoft</b>
     * <b>Windows NT</b>
     * <b>CurrentVersion</b>
     * <b>Windows</b>
     * <b>USERPostMessageLimit</b></pre>
     * 
     * 
     * The minimum acceptable value is 4000.
     * 			
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines PostThreadMessage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} idThread Type: <b>DWORD</b>
     * 
     * The identifier of the thread to which the message is to be posted.
     * 
     * The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section.
     * 
     * Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser or equal integrity level.
     * 
     *  This thread must have the <b>SE_TCB_NAME</b> privilege to post a message to a thread that belongs to a process with the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns <b>ERROR_INVALID_THREAD_ID</b>.
     * 
     *  This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails and returns <b>ERROR_INVALID_THREAD_ID</b>.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The type of message to be posted.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> returns <b>ERROR_INVALID_THREAD_ID</b> if <i>idThread</i> is not a valid thread identifier, or if the thread specified by <i>idThread</i> does not have a message queue. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the message limit is hit.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postthreadmessagea
     * @since windows5.0
     */
    static PostThreadMessageA(idThread, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\PostThreadMessageA", "uint", idThread, "uint", Msg, "ptr", wParam, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message. (Unicode)
     * @remarks
     * When a message is blocked by UIPI the last error, retrieved with <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, is set to 5 (access denied).
     * 
     * The thread to which the message is posted must have created a message queue, or else the call to <b>PostThreadMessage</b> fails. Use the following method to handle this situation. 
     * 
     * 				
     * 
     * <ul>
     * <li>
     * Create an event object, then create the thread.
     * 
     * </li>
     * <li>
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject</a> function to wait for the event to be set to the signaled state before calling <b>PostThreadMessage</b>.
     * 
     * </li>
     * <li>
     * In the thread to which the message will be posted, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> as shown here to force the system to create the message queue.
     * 
     * <c>PeekMessage(&amp;msg, NULL, WM_USER, WM_USER, PM_NOREMOVE)</c>
     * 
     * </li>
     * <li>
     * Set the event, to indicate that the thread is ready to receive posted messages.
     * 
     * </li>
     * </ul>
     * The thread to which the message is posted retrieves the message by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function. The <b>hwnd</b> member of the returned <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure is <b>NULL</b>.
     * 
     * Messages posted by <b>PostThreadMessage</b> are not associated with a window. As a general rule, messages that are not associated with a window cannot be dispatched by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a> function. Therefore, if the recipient thread is in a modal loop (as used by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxa">DialogBox</a>), the messages will be lost. To intercept thread messages while in a modal loop, use a thread-specific hook.
     * 
     * The system only does marshalling for system messages (those in the range 0 to (<a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a>-1)). To send other messages (those &gt;= <b>WM_USER</b>) to another process, you must do custom marshalling.
     * 
     *  There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit, it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.
     * 
     * 
     * <pre xml:space="preserve"><b>HKEY_LOCAL_MACHINE</b>
     * <b>SOFTWARE</b>
     * <b>Microsoft</b>
     * <b>Windows NT</b>
     * <b>CurrentVersion</b>
     * <b>Windows</b>
     * <b>USERPostMessageLimit</b></pre>
     * 
     * 
     * The minimum acceptable value is 4000.
     * 			
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines PostThreadMessage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} idThread Type: <b>DWORD</b>
     * 
     * The identifier of the thread to which the message is to be posted.
     * 
     * The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the thread makes its first call to one of the User or GDI functions. For more information, see the Remarks section.
     * 
     * Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser or equal integrity level.
     * 
     *  This thread must have the <b>SE_TCB_NAME</b> privilege to post a message to a thread that belongs to a process with the same locally unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns <b>ERROR_INVALID_THREAD_ID</b>.
     * 
     *  This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails and returns <b>ERROR_INVALID_THREAD_ID</b>.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The type of message to be posted.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> returns <b>ERROR_INVALID_THREAD_ID</b> if <i>idThread</i> is not a valid thread identifier, or if the thread specified by <i>idThread</i> does not have a message queue. <b>GetLastError</b> returns <b>ERROR_NOT_ENOUGH_QUOTA</b> when the message limit is hit.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postthreadmessagew
     * @since windows5.0
     */
    static PostThreadMessageW(idThread, Msg, wParam, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\PostThreadMessageW", "uint", idThread, "uint", Msg, "ptr", wParam, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replies to a message sent from another thread by the SendMessage function.
     * @remarks
     * By calling this function, the window procedure that receives the message allows the thread that called <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> to continue to run as though the thread receiving the message had returned control. The thread that calls the <b>ReplyMessage</b> function also continues to run. 
     * 
     * If the message was not sent through <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> or if the message was sent by the same thread, <b>ReplyMessage</b> has no effect.
     * @param {Pointer} lResult Type: <b>LRESULT</b>
     * 
     * The result of the message processing. The possible values are based on the message sent.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the calling thread was processing a message sent from another thread or process, the return value is nonzero.
     * 
     * If the calling thread was not processing a message sent from another thread or process, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-replymessage
     * @since windows5.0
     */
    static ReplyMessage(lResult) {
        result := DllCall("USER32.dll\ReplyMessage", "ptr", lResult, "int")
        return result
    }

    /**
     * Yields control to other threads when a thread has no other messages in its message queue. The WaitMessage function suspends the thread and does not return until a new message is placed in the thread's message queue.
     * @remarks
     * Note that <b>WaitMessage</b> does not return if there is unread input in the message queue after the thread has called a function to check the queue. This is because functions such as <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getqueuestatus">GetQueueStatus</a>, <b>WaitMessage</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjectsex">MsgWaitForMultipleObjectsEx</a> check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to <b>WaitMessage</b> will not return until new input of the specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-waitmessage
     * @since windows5.0
     */
    static WaitMessage() {
        A_LastError := 0

        result := DllCall("USER32.dll\WaitMessage", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Calls the default window procedure to provide default processing for any window messages that an application does not process. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines DefWindowProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window procedure that received the message.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value is the result of the message processing and depends on the message.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowproca
     * @since windows5.0
     */
    static DefWindowProcA(hWnd, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\DefWindowProcA", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Calls the default window procedure to provide default processing for any window messages that an application does not process. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines DefWindowProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window procedure that received the message.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message information. The content of this parameter depends on the value of the <i>Msg</i> parameter.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value is the result of the message processing and depends on the message.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defwindowprocw
     * @since windows5.0
     */
    static DefWindowProcW(hWnd, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\DefWindowProcW", "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a WM_DESTROY message.
     * @remarks
     * The <b>PostQuitMessage</b> function posts a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message to the thread's message queue and returns immediately; the function simply indicates to the system that the thread is requesting to quit at some time in the future. 
     * 
     * When the thread retrieves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message from its message queue, it should exit its message loop and return control to the system. The exit value returned to the system must be the <i>wParam</i> parameter of the <b>WM_QUIT</b> message.
     * @param {Integer} nExitCode Type: <b>int</b>
     * 
     * The application exit code. This value is used as the <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-quit">WM_QUIT</a> message.
     * @returns {Pointer} 
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-postquitmessage
     * @since windows5.0
     */
    static PostQuitMessage(nExitCode) {
        result := DllCall("USER32.dll\PostQuitMessage", "int", nExitCode)
        return result
    }

    /**
     * Passes message information to the specified window procedure. (ANSI)
     * @remarks
     * Use the <b>CallWindowProc</b> function for window subclassing. Usually, all windows with the same class share one window procedure. A subclass is a window or set of windows with the same class whose messages are intercepted and processed by another window procedure (or procedures) before being passed to the window procedure of the class. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> function creates the subclass by changing the window procedure associated with a particular window, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <b>CallWindowProc</b>. This allows the application to create a chain of window procedures. 
     * 
     * If <b>STRICT</b> is defined, the <i>lpPrevWndFunc</i> parameter has the data type <b>WNDPROC</b>. The <b>WNDPROC</b> type is declared as follows:
     * 
     * 
     * ``` syntax
     * LRESULT (CALLBACK* WNDPROC) (HWND, UINT, WPARAM, LPARAM); 
     * ```
     * 
     * If <b>STRICT</b> is not defined, the <i>lpPrevWndFunc</i> parameter has the data type <b>FARPROC</b>. The <b>FARPROC</b> type is declared as follows:
     * 
     * 
     * ``` syntax
     * int (FAR WINAPI * FARPROC) () 
     * ```
     * 
     * In C, the <b>FARPROC</b> declaration indicates a callback function that has an unspecified parameter list. In C++, however, the empty parameter list in the declaration indicates that a function has no parameters. This subtle distinction can break careless code. Following is one way to handle this situation:
     * 
     * 
     * ``` syntax
     * @param {Pointer<WNDPROC>} lpPrevWndFunc Type: <b>WNDPROC</b>
     * 
     * The previous window procedure. If this value is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowlonga">GetWindowLong</a> function with the <i>nIndex</i> parameter set to <b>GWL_WNDPROC</b> or <b>DWL_DLGPROC</b>, it is actually either the address of a window or dialog box procedure, or a special internal value meaningful only to <b>CallWindowProc</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window procedure to receive the message.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowproca
     * @since windows5.0
     */
    static CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\CallWindowProcA", "ptr", lpPrevWndFunc, "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Passes message information to the specified window procedure. (Unicode)
     * @remarks
     * Use the <b>CallWindowProc</b> function for window subclassing. Usually, all windows with the same class share one window procedure. A subclass is a window or set of windows with the same class whose messages are intercepted and processed by another window procedure (or procedures) before being passed to the window procedure of the class. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> function creates the subclass by changing the window procedure associated with a particular window, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <b>CallWindowProc</b>. This allows the application to create a chain of window procedures. 
     * 
     * If <b>STRICT</b> is defined, the <i>lpPrevWndFunc</i> parameter has the data type <b>WNDPROC</b>. The <b>WNDPROC</b> type is declared as follows:
     * 
     * 
     * ``` syntax
     * LRESULT (CALLBACK* WNDPROC) (HWND, UINT, WPARAM, LPARAM); 
     * ```
     * 
     * If <b>STRICT</b> is not defined, the <i>lpPrevWndFunc</i> parameter has the data type <b>FARPROC</b>. The <b>FARPROC</b> type is declared as follows:
     * 
     * 
     * ``` syntax
     * int (FAR WINAPI * FARPROC) () 
     * ```
     * 
     * In C, the <b>FARPROC</b> declaration indicates a callback function that has an unspecified parameter list. In C++, however, the empty parameter list in the declaration indicates that a function has no parameters. This subtle distinction can break careless code. Following is one way to handle this situation:
     * 
     * 
     * ``` syntax
     * @param {Pointer<WNDPROC>} lpPrevWndFunc Type: <b>WNDPROC</b>
     * 
     * The previous window procedure. If this value is obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowlonga">GetWindowLong</a> function with the <i>nIndex</i> parameter set to <b>GWL_WNDPROC</b> or <b>DWL_DLGPROC</b>, it is actually either the address of a window or dialog box procedure, or a special internal value meaningful only to <b>CallWindowProc</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window procedure to receive the message.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information. The contents of this parameter depend on the value of the <i>Msg</i> parameter.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callwindowprocw
     * @since windows5.0
     */
    static CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\CallWindowProcW", "ptr", lpPrevWndFunc, "ptr", hWnd, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process) by a call to the SendMessage function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window procedure is processing a message sent to it from another thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> function, the return value is nonzero.
     * 
     * If the window procedure is not processing a message sent to it from another thread using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> function, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-insendmessage
     * @since windows5.0
     */
    static InSendMessage() {
        result := DllCall("USER32.dll\InSendMessage", "int")
        return result
    }

    /**
     * Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different process).
     * @remarks
     * To determine if the sender is blocked, use the following test:
     * 
     * <c>fBlocked = ( InSendMessageEx(NULL) &amp; (ISMEX_REPLIED|ISMEX_SEND) ) == ISMEX_SEND;</c>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the message was not sent, the return value is <b>ISMEX_NOSEND</b> (0x00000000). Otherwise, the return value is one or more of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ISMEX_CALLBACK</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was sent using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagecallbacka">SendMessageCallback</a> function. The thread that sent the message is not blocked.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ISMEX_NOTIFY</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was sent using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendnotifymessagea">SendNotifyMessage</a> function. The thread that sent the message is not blocked.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ISMEX_REPLIED</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The window procedure has processed the message. The thread that sent the message is no longer blocked.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ISMEX_SEND</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was sent using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessagetimeouta">SendMessageTimeout</a> function. If <b>ISMEX_REPLIED</b> is not set, the thread that sent the message is blocked.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-insendmessageex
     * @since windows5.0
     */
    static InSendMessageEx() {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("USER32.dll\InSendMessageEx", "ptr", lpReserved, "uint")
        return result
    }

    /**
     * Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassA)
     * @remarks
     * If you register the window class by using 
     * 				<b>RegisterClassA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using 
     * 				<b>RegisterClassW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.
     * 
     * All window classes that an application registers are unregistered when it terminates. 
     * 
     * No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.
     * @param {Pointer<WNDCLASSA>} lpWndClass Type: <b>const WNDCLASS*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure. You must fill the structure with the appropriate class attributes before passing it to the function.
     * @returns {Integer} Type: <b>ATOM</b>
     * 
     * If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassa
     * @since windows5.0
     */
    static RegisterClassA(lpWndClass) {
        A_LastError := 0

        result := DllCall("USER32.dll\RegisterClassA", "ptr", lpWndClass, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassW)
     * @remarks
     * If you register the window class by using 
     * 				<b>RegisterClassA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using 
     * 				<b>RegisterClassW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.
     * 
     * All window classes that an application registers are unregistered when it terminates. 
     * 
     * No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.
     * @param {Pointer<WNDCLASSW>} lpWndClass Type: <b>const WNDCLASS*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure. You must fill the structure with the appropriate class attributes before passing it to the function.
     * @returns {Integer} Type: <b>ATOM</b>
     * 
     * If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassw
     * @since windows5.0
     */
    static RegisterClassW(lpWndClass) {
        A_LastError := 0

        result := DllCall("USER32.dll\RegisterClassW", "ptr", lpWndClass, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Unregisters a window class, freeing the memory required for the class. (ANSI)
     * @remarks
     * Before calling this function, an application must destroy all windows created with the specified class. 
     * 
     * All window classes that an application registers are unregistered when it terminates. 
     * 
     * Class atoms are special atoms returned only by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>. 
     * 
     * No window classes registered by a DLL are unregistered when the .dll is unloaded. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines UnregisterClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string or a class atom. If <i>lpClassName</i> is a string, it specifies the window class name. This class name must have been registered by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. System classes, such as dialog box controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the <b>RegisterClass</b> or <b>RegisterClassEx</b> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the module that created the class.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the class could not be found or if a window still exists that was created with the class, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterclassa
     * @since windows5.0
     */
    static UnregisterClassA(lpClassName, hInstance) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName

        A_LastError := 0

        result := DllCall("USER32.dll\UnregisterClassA", "ptr", lpClassName, "ptr", hInstance, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Unregisters a window class, freeing the memory required for the class. (Unicode)
     * @remarks
     * Before calling this function, an application must destroy all windows created with the specified class. 
     * 
     * All window classes that an application registers are unregistered when it terminates. 
     * 
     * Class atoms are special atoms returned only by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>. 
     * 
     * No window classes registered by a DLL are unregistered when the .dll is unloaded. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines UnregisterClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string or a class atom. If <i>lpClassName</i> is a string, it specifies the window class name. This class name must have been registered by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. System classes, such as dialog box controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the <b>RegisterClass</b> or <b>RegisterClassEx</b> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the module that created the class.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the class could not be found or if a window still exists that was created with the class, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unregisterclassw
     * @since windows5.0
     */
    static UnregisterClassW(lpClassName, hInstance) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName

        A_LastError := 0

        result := DllCall("USER32.dll\UnregisterClassW", "ptr", lpClassName, "ptr", hInstance, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a window class. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetClassInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons or list boxes), set this parameter to <b>NULL</b>.
     * @param {Pointer<Byte>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * The class name. The name must be that of a preregistered class or a class registered by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Alternatively, this parameter can be an atom. If so, it must be a class atom created by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>. The atom must be in the low-order word of 
     * 					<i>lpClassName</i>; the high-order word must be zero.
     * @param {Pointer<WNDCLASSA>} lpWndClass Type: <b>LPWNDCLASS</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure that receives the information about the class.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function finds a matching class and successfully copies the data, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassinfoa
     * @since windows5.0
     */
    static GetClassInfoA(hInstance, lpClassName, lpWndClass) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName

        A_LastError := 0

        result := DllCall("USER32.dll\GetClassInfoA", "ptr", hInstance, "ptr", lpClassName, "ptr", lpWndClass, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a window class. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetClassInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons or list boxes), set this parameter to <b>NULL</b>.
     * @param {Pointer<Char>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * The class name. The name must be that of a preregistered class or a class registered by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Alternatively, this parameter can be an atom. If so, it must be a class atom created by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>. The atom must be in the low-order word of 
     * 					<i>lpClassName</i>; the high-order word must be zero.
     * @param {Pointer<WNDCLASSW>} lpWndClass Type: <b>LPWNDCLASS</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure that receives the information about the class.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function finds a matching class and successfully copies the data, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassinfow
     * @since windows5.0
     */
    static GetClassInfoW(hInstance, lpClassName, lpWndClass) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName

        A_LastError := 0

        result := DllCall("USER32.dll\GetClassInfoW", "ptr", hInstance, "ptr", lpClassName, "ptr", lpWndClass, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassExA)
     * @remarks
     * If you register the window class by using 
     * 				<b>RegisterClassExA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using 
     * 				<b>RegisterClassExW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.
     * 
     * All window classes that an application registers are unregistered when it terminates. 
     * 
     * No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.
     * @param {Pointer<WNDCLASSEXA>} param0 
     * @returns {Integer} Type: <b>ATOM</b>
     * 
     * If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassexa
     * @since windows5.0
     */
    static RegisterClassExA(param0) {
        A_LastError := 0

        result := DllCall("USER32.dll\RegisterClassExA", "ptr", param0, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers a window class for subsequent use in calls to the CreateWindow or CreateWindowEx function. (RegisterClassExW)
     * @remarks
     * If you register the window class by using 
     * 				<b>RegisterClassExA</b>, the application tells the system that the windows of the created class expect messages with text or character parameters to use the ANSI character set; if you register it by using 
     * 				<b>RegisterClassExW</b>, the application requests that the system pass text parameters of messages as Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-iswindowunicode">IsWindowUnicode</a> function enables applications to query the nature of each window. For more information on ANSI and Unicode functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>.
     * 
     * All window classes that an application registers are unregistered when it terminates. 
     * 
     * No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is unloaded.
     * @param {Pointer<WNDCLASSEXW>} param0 
     * @returns {Integer} Type: <b>ATOM</b>
     * 
     * If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoexa">GetClassInfoEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowa">FindWindow</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-findwindowexa">FindWindowEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unregisterclassa">UnregisterClass</a> functions and the <b>IActiveIMMap::FilterClientWindows</b> method. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerclassexw
     * @since windows5.0
     */
    static RegisterClassExW(param0) {
        A_LastError := 0

        result := DllCall("USER32.dll\RegisterClassExW", "ptr", param0, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a window class, including a handle to the small icon associated with the window class. The GetClassInfo function does not retrieve a handle to the small icon. (ANSI)
     * @remarks
     * Class atoms are created using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function, not the 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetClassInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons or list boxes), set this parameter to <b>NULL</b>.
     * @param {Pointer<Byte>} lpszClass Type: <b>LPCTSTR</b>
     * 
     * The class name. The name must be that of a preregistered class or a class registered by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. Alternatively, this parameter can be a class atom created by a previous call to <b>RegisterClass</b> or <b>RegisterClassEx</b>. The atom must be in the low-order word of 
     * 					<i>lpszClass</i>; the high-order word must be zero.
     * @param {Pointer<WNDCLASSEXA>} lpwcx Type: <b>LPWNDCLASSEX</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure that receives the information about the class.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function finds a matching class and successfully copies the data, the return value is nonzero.
     * 
     * If the function does not find a matching class and successfully copy the data, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassinfoexa
     * @since windows5.0
     */
    static GetClassInfoExA(hInstance, lpszClass, lpwcx) {
        lpszClass := lpszClass is String? StrPtr(lpszClass) : lpszClass

        A_LastError := 0

        result := DllCall("USER32.dll\GetClassInfoExA", "ptr", hInstance, "ptr", lpszClass, "ptr", lpwcx, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a window class, including a handle to the small icon associated with the window class. The GetClassInfo function does not retrieve a handle to the small icon. (Unicode)
     * @remarks
     * Class atoms are created using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function, not the 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetClassInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons or list boxes), set this parameter to <b>NULL</b>.
     * @param {Pointer<Char>} lpszClass Type: <b>LPCTSTR</b>
     * 
     * The class name. The name must be that of a preregistered class or a class registered by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. Alternatively, this parameter can be a class atom created by a previous call to <b>RegisterClass</b> or <b>RegisterClassEx</b>. The atom must be in the low-order word of 
     * 					<i>lpszClass</i>; the high-order word must be zero.
     * @param {Pointer<WNDCLASSEXW>} lpwcx Type: <b>LPWNDCLASSEX</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure that receives the information about the class.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function finds a matching class and successfully copies the data, the return value is nonzero.
     * 
     * If the function does not find a matching class and successfully copy the data, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassinfoexw
     * @since windows5.0
     */
    static GetClassInfoExW(hInstance, lpszClass, lpwcx) {
        lpszClass := lpszClass is String? StrPtr(lpszClass) : lpszClass

        A_LastError := 0

        result := DllCall("USER32.dll\GetClassInfoExW", "ptr", hInstance, "ptr", lpszClass, "ptr", lpwcx, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. (ANSI)
     * @remarks
     * The <b>CreateWindowEx</b> function sends <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> messages to the window being created. 
     * 
     * If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost).
     * 
     * For information on controlling whether the Taskbar displays a button for the created window, see <a href="https://docs.microsoft.com/windows/desktop/shell/taskbar">Managing Taskbar Buttons</a>. 
     * 
     * For information on removing a window, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function.
     * 
     * The following predefined control classes can be specified in the <i>lpClassName</i> parameter. Note the corresponding control styles you can use in the <i>dwStyle</i> parameter. 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Class</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>BUTTON</b></td>
     * <td>
     * Designates a small rectangular child window that represents a button the user can click to turn it on or off. Button controls can be used alone or in groups, and they can either be labeled or appear without text. Button controls typically change appearance when the user clicks them. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Tapi/buttons">Buttons</a>.
     * 
     * For a table of the button styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/button-styles">Button Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>COMBOBOX</b></td>
     * <td>
     * Designates a control consisting of a list box and a selection field similar to an edit control. When using this style, an application should either display the list box at all times or enable a drop-down list box. If the list box is visible, typing characters into the selection field highlights the first list box entry that matches the characters typed. Conversely, selecting an item in the list box displays the selected text in the selection field. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/combo-boxes">Combo Boxes</a>.
     * 
     * For a table of the combo box styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/combo-box-styles">Combo Box Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>EDIT</b></td>
     * <td>
     * Designates a rectangular child window into which the user can type text from the keyboard. The user selects the control and gives it the keyboard focus by clicking it or moving to it by pressing the TAB key. The user can type text when the edit control displays a flashing caret; use the mouse to move the cursor, select characters to be replaced, or position the cursor for inserting characters; or use the  key to delete characters. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/edit-controls">Edit Controls</a>.
     * 
     * For a table of the edit control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/edit-control-styles">Edit Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>LISTBOX</b></td>
     * <td>
     * Designates a list of character strings. Specify this control whenever an application must present a list of names, such as filenames, from which the user can choose. The user can select a string by clicking it. A selected string is highlighted, and a notification message is passed to the parent window. For more information, see <a href="https://docs.microsoft.com/windows/desktop/uxguide/ctrl-list-boxes">List Boxes</a>.
     * 
     * For a table of the list box styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/list-box-styles">List Box Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>MDICLIENT</b></td>
     * <td>Designates an MDI client window. This window receives messages that control the MDI application's child windows. The recommended style bits are <b>WS_CLIPCHILDREN</b> and <b>WS_CHILD</b>. Specify the <b>WS_HSCROLL</b> and <b>WS_VSCROLL</b> styles to create an MDI client window that allows the user to scroll MDI child windows into view. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/multiple-document-interface">Multiple Document Interface</a>. </td>
     * </tr>
     * <tr>
     * <td><b>RichEdit</b></td>
     * <td>
     * Designates a Microsoft Rich Edit1.0 control. This window lets the user view and edit text with character and paragraph formatting, and can include embedded Component Object Model (COM) objects. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-controls">Rich Edit Controls</a>.
     * 
     * For a table of the rich edit control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-control-styles">Rich Edit Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>RICHEDIT_CLASS</b></td>
     * <td>
     * Designates a Microsoft Rich Edit2.0 control. This controls let the user view and edit text with character and paragraph formatting, and can include embedded COM objects. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-controls">Rich Edit Controls</a>.
     * 
     * For a table of the rich edit control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-control-styles">Rich Edit Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>SCROLLBAR</b></td>
     * <td>
     * Designates a rectangle that contains a scroll box and has direction arrows at both ends. The scroll bar sends a notification message to its parent window whenever the user clicks the control. The parent window is responsible for updating the position of the scroll box, if necessary. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/scroll-bars">Scroll Bars</a>.
     * 
     * For a table of the scroll bar control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/scroll-bar-control-styles">Scroll Bar Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>STATIC</b></td>
     * <td>
     * Designates a simple text field, box, or rectangle used to label, box, or separate other controls. Static controls take no input and provide no output. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/static-controls">Static Controls</a>. 
     * 
     * For a table of the static control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/static-control-styles">Static Control Styles</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The <b>WS_EX_NOACTIVATE</b> value for <i>dwExStyle</i> prevents foreground activation by the system. To prevent queue activation when the user clicks on the window, you must process the <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mouseactivate">WM_MOUSEACTIVATE</a> message appropriately. To bring the window to the foreground or to activate it programmatically, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setactivewindow">SetActiveWindow</a>. Returning <b>FALSE</b> to <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-ncactivate">WM_NCACTIVATE</a> prevents the window from losing queue activation. However, the return value is ignored at activation time.
     * 
     *  With <b>WS_EX_COMPOSITED</b> set, all descendants of a window get bottom-to-top painting order using double-buffering. Bottom-to-top painting order allows a descendent window to have translucency (alpha) and transparency (color-key) effects, but only if the descendent window also has the <b>WS_EX_TRANSPARENT</b> bit set. Double-buffering allows the window and its descendents to be painted without flicker.
     * @param {Integer} dwExStyle Type: <b>DWORD</b>
     * 
     * The extended window style of the window being created. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.
     * @param {Pointer<Byte>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * A <b>null</b>-terminated string or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.
     * @param {Pointer<Byte>} lpWindowName Type: <b>LPCTSTR</b>
     * 
     * The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".
     * @param {Integer} dwStyle Type: <b>DWORD</b>
     * 
     * The style of the window being created. This parameter can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.
     * @param {Integer} X Type: <b>int</b>
     * 
     * The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area. 
     * 
     * 
     * If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows.
     * 
     *  To create a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the module to be associated with the window.
     * @param {Pointer<Void>} lpParam Type: <b>LPVOID</b>
     * 
     * Pointer to a value to be passed to the window through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns.
     * 
     * If an application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the new window.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * This function typically fails for one of the following reasons: 
     * 
     * <ul>
     * <li>an invalid parameter value</li>
     * <li>the system class was registered by a different module</li>
     * <li>The <b>WH_CBT</b> hook is installed and returns a failure code</li>
     * <li>if one of the controls in the dialog template is not registered, or its window window procedure fails <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> or <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>
     * </li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexa
     * @since windows5.0
     */
    static CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName
        lpWindowName := lpWindowName is String? StrPtr(lpWindowName) : lpWindowName

        A_LastError := 0

        result := DllCall("USER32.dll\CreateWindowExA", "uint", dwExStyle, "ptr", lpClassName, "ptr", lpWindowName, "uint", dwStyle, "int", X, "int", Y, "int", nWidth, "int", nHeight, "ptr", hWndParent, "ptr", hMenu, "ptr", hInstance, "ptr", lpParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the CreateWindow function. (Unicode)
     * @remarks
     * The <b>CreateWindowEx</b> function sends <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> messages to the window being created. 
     * 
     * If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window, its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost).
     * 
     * For information on controlling whether the Taskbar displays a button for the created window, see <a href="https://docs.microsoft.com/windows/desktop/shell/taskbar">Managing Taskbar Buttons</a>. 
     * 
     * For information on removing a window, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function.
     * 
     * The following predefined control classes can be specified in the <i>lpClassName</i> parameter. Note the corresponding control styles you can use in the <i>dwStyle</i> parameter. 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Class</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>BUTTON</b></td>
     * <td>
     * Designates a small rectangular child window that represents a button the user can click to turn it on or off. Button controls can be used alone or in groups, and they can either be labeled or appear without text. Button controls typically change appearance when the user clicks them. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/buttons">Buttons</a>.
     * 
     * For a table of the button styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/button-styles">Button Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>COMBOBOX</b></td>
     * <td>
     * Designates a control consisting of a list box and a selection field similar to an edit control. When using this style, an application should either display the list box at all times or enable a drop-down list box. If the list box is visible, typing characters into the selection field highlights the first list box entry that matches the characters typed. Conversely, selecting an item in the list box displays the selected text in the selection field. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/combo-boxes">Combo Boxes</a>.
     * 
     * For a table of the combo box styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/combo-box-styles">Combo Box Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>EDIT</b></td>
     * <td>
     * Designates a rectangular child window into which the user can type text from the keyboard. The user selects the control and gives it the keyboard focus by clicking it or moving to it by pressing the TAB key. The user can type text when the edit control displays a flashing caret; use the mouse to move the cursor, select characters to be replaced, or position the cursor for inserting characters; or use the  key to delete characters. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/edit-controls">Edit Controls</a>.
     * 
     * For a table of the edit control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/edit-control-styles">Edit Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>LISTBOX</b></td>
     * <td>
     * Designates a list of character strings. Specify this control whenever an application must present a list of names, such as filenames, from which the user can choose. The user can select a string by clicking it. A selected string is highlighted, and a notification message is passed to the parent window. For more information, see <a href="https://docs.microsoft.com/windows/desktop/uxguide/ctrl-list-boxes">List Boxes</a>.
     * 
     * For a table of the list box styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/list-box-styles">List Box Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>MDICLIENT</b></td>
     * <td>Designates an MDI client window. This window receives messages that control the MDI application's child windows. The recommended style bits are <b>WS_CLIPCHILDREN</b> and <b>WS_CHILD</b>. Specify the <b>WS_HSCROLL</b> and <b>WS_VSCROLL</b> styles to create an MDI client window that allows the user to scroll MDI child windows into view. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/multiple-document-interface">Multiple Document Interface</a>. </td>
     * </tr>
     * <tr>
     * <td><b>RichEdit</b></td>
     * <td>
     * Designates a Microsoft Rich Edit1.0 control. This window lets the user view and edit text with character and paragraph formatting, and can include embedded Component Object Model (COM) objects. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-controls">Rich Edit Controls</a>.
     * 
     * For a table of the rich edit control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-control-styles">Rich Edit Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>RICHEDIT_CLASS</b></td>
     * <td>
     * Designates a Microsoft Rich Edit2.0 control. This controls let the user view and edit text with character and paragraph formatting, and can include embedded COM objects. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-controls">Rich Edit Controls</a>.
     * 
     * For a table of the rich edit control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/rich-edit-control-styles">Rich Edit Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>SCROLLBAR</b></td>
     * <td>
     * Designates a rectangle that contains a scroll box and has direction arrows at both ends. The scroll bar sends a notification message to its parent window whenever the user clicks the control. The parent window is responsible for updating the position of the scroll box, if necessary. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/scroll-bars">Scroll Bars</a>.
     * 
     * For a table of the scroll bar control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/scroll-bar-control-styles">Scroll Bar Control Styles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td><b>STATIC</b></td>
     * <td>
     * Designates a simple text field, box, or rectangle used to label, box, or separate other controls. Static controls take no input and provide no output. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Controls/static-controls">Static Controls</a>. 
     * 
     * For a table of the static control styles you can specify in the <i>dwStyle</i> parameter, see <a href="https://docs.microsoft.com/windows/desktop/Controls/static-control-styles">Static Control Styles</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The <b>WS_EX_NOACTIVATE</b> value for <i>dwExStyle</i> prevents foreground activation by the system. To prevent queue activation when the user clicks on the window, you must process the <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mouseactivate">WM_MOUSEACTIVATE</a> message appropriately. To bring the window to the foreground or to activate it programmatically, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setactivewindow">SetActiveWindow</a>. Returning <b>FALSE</b> to <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-ncactivate">WM_NCACTIVATE</a> prevents the window from losing queue activation. However, the return value is ignored at activation time.
     * 
     *  With <b>WS_EX_COMPOSITED</b> set, all descendants of a window get bottom-to-top painting order using double-buffering. Bottom-to-top painting order allows a descendent window to have translucency (alpha) and transparency (color-key) effects, but only if the descendent window also has the <b>WS_EX_TRANSPARENT</b> bit set. Double-buffering allows the window and its descendents to be painted without flicker.
     * @param {Integer} dwExStyle Type: <b>DWORD</b>
     * 
     * The extended window style of the window being created. For a list of possible values, see  <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">Extended Window Styles</a>.
     * @param {Pointer<Char>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * A <b>null</b>-terminated string or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. If <i>lpClassName</i> is a string, it specifies the window class name. The class name can be any name registered with <b>RegisterClass</b> or <b>RegisterClassEx</b>, provided that the module that registers the class is also the module that creates the window. The class name can also be any of the predefined <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-window-classes">system class</a> names.
     * @param {Pointer<Char>} lpWindowName Type: <b>LPCTSTR</b>
     * 
     * The window name. If the window style specifies a title bar, the window title pointed to by <i>lpWindowName</i> is displayed in the title bar. When using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create controls, such as buttons, check boxes, and static controls, use <i>lpWindowName</i> to specify the text of the control. When creating a static control with the <b>SS_ICON</b> style, use <i>lpWindowName</i> to specify the icon name or identifier. To specify an identifier, use the syntax "#<i>num</i>".
     * @param {Integer} dwStyle Type: <b>DWORD</b>
     * 
     * The style of the window being created. This parameter can be a combination of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style values</a>, plus the control styles indicated in the Remarks section.
     * @param {Integer} X Type: <b>int</b>
     * 
     * The initial horizontal position of the window. For an overlapped or pop-up window, the <i>x</i> parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>x</i> is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <i>x</i> is set to <b>CW_USEDEFAULT</b>, the system selects the default position for the window's upper-left corner and ignores the <i>y</i> parameter. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if it is specified for a pop-up or child window, the <i>x</i> and <i>y</i> parameters are set to zero.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The initial vertical position of the window. For an overlapped or pop-up window, the <i>y</i> parameter is the initial y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <i>y</i> is the initial y-coordinate of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box <i>y</i> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of the parent window's client area. 
     * 
     * 
     * If an overlapped window is created with the <b>WS_VISIBLE</b> style bit set and the <i>x</i> parameter is set to <b>CW_USEDEFAULT</b>, then the <i>y</i> parameter determines how the window is shown. If the <i>y</i> parameter is <b>CW_USEDEFAULT</b>, then the window manager calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with the <b>SW_SHOW</b> flag after the window has been created. If the <i>y</i> parameter is some other value, then the window manager calls <b>ShowWindow</b> with that value as the <i>nCmdShow</i> parameter.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The width, in device units, of the window. For overlapped windows, <i>nWidth</i> is the window's width, in screen coordinates, or <b>CW_USEDEFAULT</b>. If <i>nWidth</i> is <b>CW_USEDEFAULT</b>, the system selects a default width and height for the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial y-coordinate to the top of the icon area. <b>CW_USEDEFAULT</b> is valid only for overlapped windows; if <b>CW_USEDEFAULT</b> is specified for a pop-up or child window, the <i>nWidth</i> and <i>nHeight</i> parameter are set to zero.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The height, in device units, of the window. For overlapped windows, <i>nHeight</i> is the window's height, in screen coordinates. If the <i>nWidth</i> parameter is set to <b>CW_USEDEFAULT</b>, the system ignores <i>nHeight</i>.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window handle. This parameter is optional for pop-up windows.
     * 
     *  To create a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>, supply <b>HWND_MESSAGE</b> or a handle to an existing message-only window.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window, <i>hMenu</i> identifies the menu to be used with the window; it can be <b>NULL</b> if the class menu is to be used. For a child window, <i>hMenu</i> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events. The application determines the child-window identifier; it must be unique for all child windows with the same parent window.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the module to be associated with the window.
     * @param {Pointer<Void>} lpParam Type: <b>LPVOID</b>
     * 
     * Pointer to a value to be passed to the window through the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-createstructa">CREATESTRUCT</a> structure (<b>lpCreateParams</b> member) pointed to by the <i>lParam</i> param of the <b>WM_CREATE</b> message.  This message is sent to the created window by this function before it returns.
     * 
     * If an application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> to create a MDI client window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-clientcreatestruct">CLIENTCREATESTRUCT</a> structure. If an MDI client window calls <b>CreateWindow</b> to create an MDI child window, <i>lpParam</i> should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mdicreatestructa">MDICREATESTRUCT</a> structure. <i>lpParam</i> may be <b>NULL</b> if no additional data is needed.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the new window.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * This function typically fails for one of the following reasons: 
     * 
     * <ul>
     * <li>an invalid parameter value</li>
     * <li>the system class was registered by a different module</li>
     * <li>The <b>WH_CBT</b> hook is installed and returns a failure code</li>
     * <li>if one of the controls in the dialog template is not registered, or its window window procedure fails <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-create">WM_CREATE</a> or <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccreate">WM_NCCREATE</a>
     * </li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createwindowexw
     * @since windows5.0
     */
    static CreateWindowExW(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName
        lpWindowName := lpWindowName is String? StrPtr(lpWindowName) : lpWindowName

        A_LastError := 0

        result := DllCall("USER32.dll\CreateWindowExW", "uint", dwExStyle, "ptr", lpClassName, "ptr", lpWindowName, "uint", dwStyle, "int", X, "int", Y, "int", nWidth, "int", nHeight, "ptr", hWndParent, "ptr", hMenu, "ptr", hInstance, "ptr", lpParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the specified window handle identifies an existing window.
     * @remarks
     * A thread should not use <b>IsWindow</b> for a window that it did not create because the window could be destroyed after this function was called. Further, because window handles are recycled the handle could even point to a different window.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window handle identifies an existing window, the return value is nonzero.
     * 
     * If the window handle does not identify an existing window, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iswindow
     * @since windows5.0
     */
    static IsWindow(hWnd) {
        result := DllCall("USER32.dll\IsWindow", "ptr", hWnd, "int")
        return result
    }

    /**
     * Determines whether a handle is a menu handle.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the handle is a menu handle, the return value is nonzero. 
     * 
     * If the handle is not a menu handle, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ismenu
     * @since windows5.0
     */
    static IsMenu(hMenu) {
        result := DllCall("USER32.dll\IsMenu", "ptr", hMenu, "int")
        return result
    }

    /**
     * Determines whether a window is a child window or descendant window of a specified parent window.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window is a child or descendant window of the specified parent window, the return value is nonzero.
     * 
     * If the window is not a child or descendant window of the specified parent window, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischild
     * @since windows5.0
     */
    static IsChild(hWndParent, hWnd) {
        result := DllCall("USER32.dll\IsChild", "ptr", hWndParent, "ptr", hWnd, "int")
        return result
    }

    /**
     * Destroys the specified window.
     * @remarks
     * A thread cannot use <b>DestroyWindow</b> to destroy a window created by a different thread. 
     * 
     * If the window being destroyed is a child window that does not have the <b>WS_EX_NOPARENTNOTIFY</b> style, a <a href="https://docs.microsoft.com/windows/win32/inputmsg/wm-parentnotify">WM_PARENTNOTIFY</a> message is sent to the parent.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be destroyed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroywindow
     * @since windows5.0
     */
    static DestroyWindow(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\DestroyWindow", "ptr", hWnd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the specified window's show state.
     * @remarks
     * To perform certain special effects when showing or hiding a window, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>. 
     * 
     * The first time an application calls <b>ShowWindow</b>, it should use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-winmain">WinMain</a> function's <i>nCmdShow</i> parameter as its <i>nCmdShow</i> parameter. Subsequent calls to <b>ShowWindow</b> must use one of the values in the given list, instead of the one specified by the <b>WinMain</b> function's <i>nCmdShow</i> parameter. 
     * 
     * As noted in the discussion of the <i>nCmdShow</i> parameter, the <i>nCmdShow</i> value is ignored in the first call to <b>ShowWindow</b> if the program that launched the application specifies startup information in the  structure. In this case, <b>ShowWindow</b> uses the information specified in the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> structure to show the window. On subsequent calls, the application must call <b>ShowWindow</b> with <i>nCmdShow</i> set to <b>SW_SHOWDEFAULT</b> to use the startup information provided by the program that launched the application. This behavior is designed for the following situations: 
     * 
     * <ul>
     * <li>Applications create their main window by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> with the <b>WS_VISIBLE</b> flag set. </li>
     * <li>Applications create their main window by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> with the <b>WS_VISIBLE</b> flag cleared, and later call <b>ShowWindow</b> with the <b>SW_SHOW</b> flag set to make it visible. </li>
     * </ul>
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Integer} nCmdShow Type: <b>int</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window was previously visible, the return value is nonzero. 
     * 
     * If the window was previously hidden, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindow
     * @since windows5.0
     */
    static ShowWindow(hWnd, nCmdShow) {
        result := DllCall("USER32.dll\ShowWindow", "ptr", hWnd, "int", nCmdShow, "int")
        return result
    }

    /**
     * Enables you to produce special effects when showing or hiding windows. There are four types of animation:\_roll, slide, collapse or expand, and alpha-blended fade.
     * @remarks
     * To show or hide a window without special effects, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a>.
     * 
     * When using slide or roll animation, you must specify the direction. It can be either <b>AW_HOR_POSITIVE</b>, <b>AW_HOR_NEGATIVE</b>, AW_VER_POSITIVE, or AW_VER_NEGATIVE. 
     * 
     * You can combine <b>AW_HOR_POSITIVE</b> or <b>AW_HOR_NEGATIVE</b> with <b>AW_VER_POSITIVE</b> or <b>AW_VER_NEGATIVE</b> to animate a window diagonally. 
     * 
     * The window procedures for the window and its child windows should handle any <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-print">WM_PRINT</a> or <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-printclient">WM_PRINTCLIENT</a> messages. Dialog boxes, controls, and common controls already handle <b>WM_PRINTCLIENT</b>. The default window procedure already handles <b>WM_PRINT</b>. 
     * 
     * If a child window is displayed partially clipped, when it is animated it will have holes where it is clipped. 
     * 
     * <b>AnimateWindow</b> supports RTL windows.
     * 
     * Avoid animating a window that has a drop shadow because it produces visually distracting, jerky animations.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to animate. The calling thread must own this window.
     * @param {Integer} dwTime Type: <b>DWORD</b>
     * 
     * The time it takes to play the animation, in milliseconds. Typically, an animation takes 200 milliseconds to play.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. The function will fail in the following situations: 
     * 
     * <ul>
     * <li>If the window is already visible and you are trying to show the window.</li>
     * <li>If the window is already hidden and you are trying to hide the window.</li>
     * <li>If there is no direction specified for the slide or roll animation.</li>
     * <li>When trying to animate a child window with <b>AW_BLEND</b>. </li>
     * <li>If the thread does not own the window. Note that, in this case, <b>AnimateWindow</b> fails but <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_SUCCESS</b>.</li>
     * </ul>
     * To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-animatewindow
     * @since windows5.0
     */
    static AnimateWindow(hWnd, dwTime, dwFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\AnimateWindow", "ptr", hWnd, "uint", dwTime, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Updates the position, size, shape, content, and translucency of a layered window.
     * @remarks
     * The source DC should contain the surface that defines the visible contents of the layered window. For example, you can select a bitmap into a device context obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createcompatibledc">CreateCompatibleDC</a> function. 
     * 
     * An application should call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setlayout">SetLayout</a> on the <i>hdcSrc</i> device context to properly set the mirroring mode. <b>SetLayout</b> will properly mirror all drawing into an <b>HDC</b> while properly preserving text glyph and (optionally) bitmap direction order. It cannot modify drawing directly into the bits of a device-independent bitmap (DIB). For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">Window Layout and Mirroring</a>.
     * 
     * The <b>UpdateLayeredWindow</b> function maintains the window's appearance on the screen. The windows underneath a layered window do not need to be repainted when they are uncovered due to a call to <b>UpdateLayeredWindow</b>, because the system will automatically repaint them. This permits seamless animation of the layered window. 
     * 
     * <b>UpdateLayeredWindow</b> always updates the entire window. To update part of a window, use the traditional <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> and set the blend value using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlayeredwindowattributes">SetLayeredWindowAttributes</a>.
     * 
     * For best drawing performance by the layered window and any underlying windows, the layered window should be as small as possible. An application should also process the  message and re-create its layered windows when the display's color depth changes.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">Layered Windows</a>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to a layered window. A layered window is created by specifying <b>WS_EX_LAYERED</b> when creating the window with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function. 
     * 
     * <b>Windows8:</b>The <b>WS_EX_LAYERED</b> style is supported for top-level windows and child windows. Previous Windows versions support <b>WS_EX_LAYERED</b> only for top-level windows.
     * @param {Pointer<Void>} hdcDst Type: <b>HDC</b>
     * 
     * A handle to a DC for the screen. This handle is obtained by specifying <b>NULL</b> when calling the <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-getdc">GetDC</a> function. It is used for palette color matching when the window contents are updated. If <i>hdcDst</i> is <b>NULL</b>, the default palette will be used.
     * 
     * If <i>hdcSrc</i> is <b>NULL</b>, <i>hdcDst</i> must be <b>NULL</b>.
     * @param {Pointer<POINT>} pptDst Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b>
     * 
     * A pointer to a structure that specifies the new screen position of the layered window. If the current position is not changing, <i>pptDst</i> can be <b>NULL</b>.
     * @param {Pointer<SIZE>} psize Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-size">SIZE</a>*</b>
     * 
     * A pointer to a structure that specifies the new size of the layered window. If the size of the window is not changing, <i>psize</i> can be <b>NULL</b>. If <i>hdcSrc</i> is <b>NULL</b>, <i>psize</i> must be <b>NULL</b>.
     * @param {Pointer<Void>} hdcSrc Type: <b>HDC</b>
     * 
     * A handle to a DC for the surface that defines the layered window. This handle can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createcompatibledc">CreateCompatibleDC</a> function. If the shape and visual context of the window are not changing, <i>hdcSrc</i> can be <b>NULL</b>.
     * @param {Pointer<POINT>} pptSrc Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a>*</b>
     * 
     * A pointer to a structure that specifies the location of the layer in the device context. If <i>hdcSrc</i> is <b>NULL</b>, <i>pptSrc</i> should be <b>NULL</b>.
     * @param {Integer} crKey Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * A structure that specifies the color key to be used when composing the layered window. To generate a <a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a>, use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-rgb">RGB</a> macro.
     * @param {Pointer<BLENDFUNCTION>} pblend Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-blendfunction">BLENDFUNCTION</a>*</b>
     * 
     * A pointer to a structure that specifies the transparency value to be used when composing the layered window.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-updatelayeredwindow
     * @since windows5.0
     */
    static UpdateLayeredWindow(hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\UpdateLayeredWindow", "ptr", hWnd, "ptr", hdcDst, "ptr", pptDst, "ptr", psize, "ptr", hdcSrc, "ptr", pptSrc, "uint", crKey, "ptr", pblend, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} hWnd 
     * @param {Pointer<UPDATELAYEREDWINDOWINFO>} pULWInfo 
     * @returns {Integer} 
     */
    static UpdateLayeredWindowIndirect(hWnd, pULWInfo) {
        result := DllCall("USER32.dll\UpdateLayeredWindowIndirect", "ptr", hWnd, "ptr", pULWInfo, "int")
        return result
    }

    /**
     * Retrieves the opacity and transparency color key of a layered window.
     * @remarks
     * <b>GetLayeredWindowAttributes</b> can be called only if the application has previously called <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlayeredwindowattributes">SetLayeredWindowAttributes</a> on the window. The function will fail if the layered window was setup with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-updatelayeredwindow">UpdateLayeredWindow</a>.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/using-windows">Using Layered Windows</a>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the layered window. A layered window is created by specifying <b>WS_EX_LAYERED</b> when creating the window with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function or by setting <b>WS_EX_LAYERED</b> using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> after the window has been created.
     * @param {Pointer<UInt32>} pcrKey Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> value that receives the transparency color key to be used when composing the layered window. All pixels painted by the window in this color will be transparent. This can be <b>NULL</b> if the argument is not needed.
     * @param {Pointer<Byte>} pbAlpha Type: <b>BYTE*</b>
     * 
     * The Alpha value used to describe the opacity of the layered window. Similar to the <b>SourceConstantAlpha</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-blendfunction">BLENDFUNCTION</a> structure. When the variable referred to by <i>pbAlpha</i> is 0, the window is completely transparent. When the variable referred to by <i>pbAlpha</i> is 255, the window is opaque. This can be <b>NULL</b> if the argument is not needed.
     * @param {Pointer<UInt32>} pdwFlags Type: <b>DWORD*</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getlayeredwindowattributes
     * @since windows5.1.2600
     */
    static GetLayeredWindowAttributes(hwnd, pcrKey, pbAlpha, pdwFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetLayeredWindowAttributes", "ptr", hwnd, "uint*", pcrKey, "char*", pbAlpha, "uint*", pdwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the opacity and transparency color key of a layered window.
     * @remarks
     * Note that once <b>SetLayeredWindowAttributes</b> has been called for a layered window, subsequent <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-updatelayeredwindow">UpdateLayeredWindow</a> calls will fail until the layering style bit is cleared and set again.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/using-windows">Using Layered Windows</a>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the layered window. A layered window is created by specifying <b>WS_EX_LAYERED</b> when creating the window with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function or by setting <b>WS_EX_LAYERED</b> via <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> after the window has been created.
     * 
     * <b>Windows8:</b>The <b>WS_EX_LAYERED</b> style is supported for top-level windows and child windows. Previous Windows versions support <b>WS_EX_LAYERED</b> only for top-level windows.
     * @param {Integer} crKey Type: <b><a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a></b>
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/gdi/colorref">COLORREF</a> structure that specifies the transparency color key to be used when composing the layered window. All pixels painted by the window in this color will be transparent. To generate a <b>COLORREF</b>, use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-rgb">RGB</a> macro.
     * @param {Integer} bAlpha Type: <b>BYTE</b>
     * 
     * Alpha value used to describe the opacity of the layered window. Similar to the <b>SourceConstantAlpha</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-blendfunction">BLENDFUNCTION</a> structure. When <i>bAlpha</i> is 0, the window is completely transparent. When <i>bAlpha</i> is 255, the window is opaque.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes
     * @since windows5.0
     */
    static SetLayeredWindowAttributes(hwnd, crKey, bAlpha, dwFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetLayeredWindowAttributes", "ptr", hwnd, "uint", crKey, "char", bAlpha, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the show state of a window without waiting for the operation to complete.
     * @remarks
     * This function posts a show-window event to the message queue of the given window. An application can use this function to avoid becoming nonresponsive while waiting for a nonresponsive application to finish processing a show-window event.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Integer} nCmdShow Type: <b>int</b>
     * 
     * Controls how the window is to be shown. For a list of possible values, see the description of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the operation was successfully started, the return value is nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showwindowasync
     * @since windows5.0
     */
    static ShowWindowAsync(hWnd, nCmdShow) {
        result := DllCall("USER32.dll\ShowWindowAsync", "ptr", hWnd, "int", nCmdShow, "int")
        return result
    }

    /**
     * Flashes the specified window one time. It does not change the active state of the window.
     * @remarks
     * Flashing a window means changing the appearance of its caption bar as if the window were changing from inactive to active status, or vice versa. (An inactive caption bar changes to an active caption bar; an active caption bar changes to an inactive caption bar.)
     * 
     * Typically, a window is flashed to inform the user that the window requires attention but that it does not currently have the keyboard focus.
     * 
     * The 
     * <b>FlashWindow</b> function flashes the window only once; for repeated flashing, the application should create a system timer.
     * @param {Pointer<Void>} hWnd A handle to the window to be flashed. The window can be either open or minimized.
     * @param {Integer} bInvert If this parameter is <b>TRUE</b>, the window is flashed from one state to the other. If it is <b>FALSE</b>, the window is returned to its original state (either active or inactive). 
     * 
     * 
     * 
     * 
     * When an application is minimized and this parameter is <b>TRUE</b>, the taskbar window button flashes active/inactive. If it is <b>FALSE</b>, the taskbar window button flashes inactive, meaning that it does not change colors. It flashes, as if it were being redrawn, but it does not provide the visual invert clue to the user.
     * @returns {Integer} The return value specifies the window's state before the call to the 
     * <b>FlashWindow</b> function. If the window caption was drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-flashwindow
     * @since windows5.1.2600
     */
    static FlashWindow(hWnd, bInvert) {
        result := DllCall("USER32.dll\FlashWindow", "ptr", hWnd, "int", bInvert, "int")
        return result
    }

    /**
     * Flashes the specified window. It does not change the active state of the window.
     * @remarks
     * Typically, you flash a window to inform the user that the window requires attention but does not currently have the keyboard focus. When a window flashes, it appears to change from inactive to active status. An inactive caption bar changes to an active caption bar; an active caption bar changes to an inactive caption bar.
     * @param {Pointer<FLASHWINFO>} pfwi A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-flashwinfo">FLASHWINFO</a> structure.
     * @returns {Integer} The return value specifies the window's state before the call to the 
     * <b>FlashWindowEx</b> function. If the window caption was drawn as active before the call, the return value is nonzero. Otherwise, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-flashwindowex
     * @since windows5.1.2600
     */
    static FlashWindowEx(pfwi) {
        result := DllCall("USER32.dll\FlashWindowEx", "ptr", pfwi, "int")
        return result
    }

    /**
     * Shows or hides all pop-up windows owned by the specified window.
     * @remarks
     * <b>ShowOwnedPopups</b> shows only windows hidden by a previous call to <b>ShowOwnedPopups</b>. For example, if a pop-up window is hidden by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function, subsequently calling <b>ShowOwnedPopups</b> with the <i>fShow</i> parameter set to <b>TRUE</b> does not cause the window to be shown.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the pop-up windows to be shown or hidden.
     * @param {Integer} fShow Type: <b>BOOL</b>
     * 
     * If this parameter is <b>TRUE</b>, all hidden pop-up windows are shown. If this parameter is <b>FALSE</b>, all visible pop-up windows are hidden.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showownedpopups
     * @since windows5.0
     */
    static ShowOwnedPopups(hWnd, fShow) {
        A_LastError := 0

        result := DllCall("USER32.dll\ShowOwnedPopups", "ptr", hWnd, "int", fShow, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Restores a minimized (iconic) window to its previous size and position; it then activates the window.
     * @remarks
     * <b>OpenIcon</b> sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-queryopen">WM_QUERYOPEN</a> message to the given window.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be restored and activated.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-openicon
     * @since windows5.0
     */
    static OpenIcon(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\OpenIcon", "ptr", hWnd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Minimizes (but does not destroy) the specified window.
     * @remarks
     * To destroy a window, an application must use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be minimized.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-closewindow
     * @since windows5.0
     */
    static CloseWindow(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\CloseWindow", "ptr", hWnd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes the position and dimensions of the specified window.
     * @remarks
     * If the <i>bRepaint</i> parameter is <b>TRUE</b>, the system sends the <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> message to the window procedure immediately after moving the window (that is, the <b>MoveWindow</b> function calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-updatewindow">UpdateWindow</a> function). If <i>bRepaint</i> is <b>FALSE</b>, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
     * 
     * <b>MoveWindow</b> sends the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanging">WM_WINDOWPOSCHANGING</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanged">WM_WINDOWPOSCHANGED</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-move">WM_MOVE</a>, <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-size">WM_SIZE</a>, and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-nccalcsize">WM_NCCALCSIZE</a> messages to the window.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Integer} X Type: <b>int</b>
     * 
     * The new position of the left side of the window.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The new position of the top of the window.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The new width of the window.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The new height of the window.
     * @param {Integer} bRepaint Type: <b>BOOL</b>
     * 
     * Indicates whether the window is to be repainted. If this parameter is <b>TRUE</b>, the window receives a  message. If the parameter is <b>FALSE</b>, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-movewindow
     * @since windows5.0
     */
    static MoveWindow(hWnd, X, Y, nWidth, nHeight, bRepaint) {
        A_LastError := 0

        result := DllCall("USER32.dll\MoveWindow", "ptr", hWnd, "int", X, "int", Y, "int", nWidth, "int", nHeight, "int", bRepaint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their appearance on the screen. The topmost window receives the highest rank and is the first window in the Z order.
     * @remarks
     * As part of the Vista re-architecture, all services were moved off the interactive desktop into Session 0. hwnd and window manager operations are only effective inside a session and cross-session attempts to manipulate the hwnd will fail. For more information, see <a href="https://docs.microsoft.com/previous-versions/aa480152(v=msdn.10)">The Windows Vista Developer Story: Application Compatibility Cookbook</a>.
     * 
     * If you have changed certain window data using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a>, you must call <b>SetWindowPos</b> for the changes to take effect. Use the following combination for <i>uFlags</i>: <c>SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED</c>. 
     * 
     * A window can be made a topmost window either by setting the <i>hWndInsertAfter</i> parameter to <b>HWND_TOPMOST</b> and ensuring that the <b>SWP_NOZORDER</b> flag is not set, or by setting a window's position in the Z order so that it is above any existing topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed. 
     * 
     * If neither the <b>SWP_NOACTIVATE</b> nor <b>SWP_NOZORDER</b> flag is specified (that is, when the application requests that a window be simultaneously activated and its position in the Z order changed), the value specified in <i>hWndInsertAfter</i> is used only in the following circumstances. 
     * 
     * <ul>
     * <li>Neither the <b>HWND_TOPMOST</b> nor <b>HWND_NOTOPMOST</b> flag is specified in <i>hWndInsertAfter</i>. </li>
     * <li>The window identified by <i>hWnd</i> is not the active window. </li>
     * </ul>
     * An application cannot activate an inactive window without also bringing it to the top of the Z order. Applications can change an activated window's position in the Z order without restrictions, or it can activate a window and then move it to the top of the topmost or non-topmost windows. 
     * 
     * If a topmost window is repositioned to the bottom (<b>HWND_BOTTOM</b>) of the Z order or after any non-topmost window, it is no longer topmost. When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows. 
     * 
     * A non-topmost window can own a topmost window, but the reverse cannot occur. Any window (for example, a dialog box) owned by a topmost window is itself made a topmost window, to ensure that all owned windows stay above their owner. 
     * 
     * If an application is not in the foreground, and should be in the foreground, it must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> function. 
     * 
     * To use <b>SetWindowPos</b> to bring a window to the top, the process that owns the window must have <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> permission.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Pointer<Void>} hWndInsertAfter Type: <b>HWND</b>
     * @param {Integer} X Type: <b>int</b>
     * 
     * The new position of the left side of the window, in client coordinates.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The new position of the top of the window, in client coordinates.
     * @param {Integer} cx Type: <b>int</b>
     * 
     * The new width of the window, in pixels.
     * @param {Integer} cy Type: <b>int</b>
     * 
     * The new height of the window, in pixels.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowpos
     * @since windows5.0
     */
    static SetWindowPos(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowPos", "ptr", hWnd, "ptr", hWndInsertAfter, "int", X, "int", Y, "int", cx, "int", cy, "uint", uFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the show state and the restored, minimized, and maximized positions of the specified window.
     * @remarks
     * The <b>flags</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> retrieved by this function is always zero. If the window identified by the <i>hWnd</i> parameter is maximized, the <b>showCmd</b> member is SW_SHOWMAXIMIZED. If the window is minimized, <b>showCmd</b> is SW_SHOWMINIMIZED. Otherwise, it is SW_SHOWNORMAL. 
     * 
     * The <b>length</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> must be set to sizeof(<b>WINDOWPLACEMENT</b>). If this member is not set correctly, the function returns <b>FALSE</b>. For additional remarks on the proper use of window placement coordinates, see <b>WINDOWPLACEMENT</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Pointer<WINDOWPLACEMENT>} lpwndpl Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a>*</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> structure that receives the show state and position information. Before calling <b>GetWindowPlacement</b>, set the <b>length</b> member to <c>sizeof(WINDOWPLACEMENT)</c>. <b>GetWindowPlacement</b> fails if <i>lpwndpl</i>-&gt; <i>length</i> is not set correctly.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowplacement
     * @since windows5.0
     */
    static GetWindowPlacement(hWnd, lpwndpl) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowPlacement", "ptr", hWnd, "ptr", lpwndpl, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the show state and the restored, minimized, and maximized positions of the specified window.
     * @remarks
     * If the information specified in <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> would result in a window that is completely off the screen, the system will automatically adjust the coordinates so that the window is visible, taking into account changes in screen resolution and multiple monitor configuration. 
     * 
     * The <b>length</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> must be set to <c>sizeof(WINDOWPLACEMENT)</c>. If this member is not set correctly, the function returns <b>FALSE</b>. For additional remarks on the proper use of window placement coordinates, see <b>WINDOWPLACEMENT</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Pointer<WINDOWPLACEMENT>} lpwndpl Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a>*</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> structure that specifies the new show state and window positions.
     * 
     *  Before calling <b>SetWindowPlacement</b>, set the <b>length</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowplacement">WINDOWPLACEMENT</a> structure to sizeof(<b>WINDOWPLACEMENT</b>). <b>SetWindowPlacement</b> fails if the <b>length</b> member is not set correctly.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowplacement
     * @since windows5.0
     */
    static SetWindowPlacement(hWnd, lpwndpl) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowPlacement", "ptr", hWnd, "ptr", lpwndpl, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the current display affinity setting, from any process, for a given window.
     * @remarks
     * This function and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowdisplayaffinity">SetWindowDisplayAffinity</a> are designed to support the window content protection feature unique to Windows 7. This feature enables applications to protect their
     * 		own onscreen window content from being captured or copied via a specific set of public operating system features 
     * 		and APIs. However, it works only when the Desktop Window Manager (DWM) is composing the desktop. 
     * 		
     * 
     * It is important to note that unlike a security feature or an implementation of Digital Rights Management (DRM), there is no guarantee that 
     * 		 using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowdisplayaffinity">SetWindowDisplayAffinity</a> 
     * 		and <b>GetWindowDisplayAffinity</b>, and other necessary functions such as <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmiscompositionenabled">DwmIsCompositionEnabled</a>, will strictly protect windowed content, as in the case where someone takes a photograph of the screen.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Pointer<UInt32>} pdwAffinity Type: <b>DWORD*</b>
     * 
     * A pointer to a variable that receives the display affinity setting.
     * See <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowdisplayaffinity">SetWindowDisplayAffinity</a> for a list of affinity settings and their meanings.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * This function succeeds only when the window is layered and Desktop Windows Manager 
     * 				is composing the desktop. If this function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b>. 
     * 				To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowdisplayaffinity
     * @since windows6.1
     */
    static GetWindowDisplayAffinity(hWnd, pdwAffinity) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowDisplayAffinity", "ptr", hWnd, "uint*", pdwAffinity, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Stores the display affinity setting in kernel mode on the hWnd associated with the window.
     * @remarks
     * This function and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowdisplayaffinity">GetWindowDisplayAffinity</a> are designed to support the window content protection feature that is new to Windows 7. This feature enables applications to protect their own onscreen window content from being captured or copied through a specific set of public operating system features and APIs. However, it works only when the Desktop Window Manager(DWM) is composing the desktop. 		
     * 
     * It is important to note that unlike a security feature or an implementation of Digital Rights Management (DRM), there is no guarantee that using <b>SetWindowDisplayAffinity</b> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowdisplayaffinity">GetWindowDisplayAffinity</a>, and other necessary functions such as <a href="https://docs.microsoft.com/windows/desktop/api/dwmapi/nf-dwmapi-dwmiscompositionenabled">DwmIsCompositionEnabled</a>, will strictly protect windowed content, for example where someone takes a photograph of the screen.
     * 
     * Starting in Windows 10 Version 2004, WDA_EXCLUDEFROMCAPTURE is a supported value. Setting the display affinity to WDA_EXCLUDEFROMCAPTURE on previous version of Windows will behave as if WDA_MONITOR is applied.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the top-level window. The window must belong to the current process.
     * @param {Integer} dwAffinity Type: <b>DWORD</b>
     * 
     * The display affinity setting that specifies where the content of the window can be displayed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b> when, for example, the function call is made on a non top-level window. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowdisplayaffinity
     * @since windows6.1
     */
    static SetWindowDisplayAffinity(hWnd, dwAffinity) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowDisplayAffinity", "ptr", hWnd, "uint", dwAffinity, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Allocates memory for a multiple-window- position structure and returns the handle to the structure.
     * @remarks
     * The multiple-window-position structure is an internal structure; an application cannot access it directly. 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-deferwindowpos">DeferWindowPos</a> fills the multiple-window-position structure with information about the target position for one or more windows about to be moved. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddeferwindowpos">EndDeferWindowPos</a> function accepts the handle to this structure and repositions the windows by using the information stored in the structure. 
     * 
     * If the system must increase the size of the multiple-window- position structure beyond the initial size specified by the <i>nNumWindows</i> parameter but cannot allocate enough memory to do so, the system fails the entire window positioning sequence (<b>BeginDeferWindowPos</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-deferwindowpos">DeferWindowPos</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddeferwindowpos">EndDeferWindowPos</a>). By specifying the maximum size needed, an application can detect and process failure early in the process.
     * @param {Integer} nNumWindows Type: <b>int</b>
     * 
     * The initial number of windows for which to store position information. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-deferwindowpos">DeferWindowPos</a> function increases the size of the structure, if necessary.
     * @returns {Pointer<Void>} Type: <b>HDWP</b>
     * 
     * If the function succeeds, the return value identifies the multiple-window-position structure. If insufficient system resources are available to allocate the structure, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-begindeferwindowpos
     * @since windows5.0
     */
    static BeginDeferWindowPos(nNumWindows) {
        A_LastError := 0

        result := DllCall("USER32.dll\BeginDeferWindowPos", "int", nNumWindows)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Updates the specified multiple-window  position structure for the specified window.
     * @remarks
     * If a call to <b>DeferWindowPos</b> fails, the application should abandon the window-positioning operation and not call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddeferwindowpos">EndDeferWindowPos</a>. 
     * 
     * If <b>SWP_NOZORDER</b> is not specified, the system places the window identified by the <i>hWnd</i> parameter in the position following the window identified by the <i>hWndInsertAfter</i> parameter. If <i>hWndInsertAfter</i> is <b>NULL</b> or <b>HWND_TOP</b>, the system places the <i>hWnd</i> window at the top of the Z order. If <i>hWndInsertAfter</i> is set to <b>HWND_BOTTOM</b>, the system places the <i>hWnd</i> window at the bottom of the Z order. 
     * 
     * All coordinates for child windows are relative to the upper-left corner of the parent window's client area. 
     * 
     * A window can be made a topmost window either by setting <i>hWndInsertAfter</i> to the <b>HWND_TOPMOST</b> flag and ensuring that the <b>SWP_NOZORDER</b> flag is not set, or by setting the window's position in the Z order so that it is above any existing topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not changed. 
     * 
     * If neither the <b>SWP_NOACTIVATE</b> nor <b>SWP_NOZORDER</b> flag is specified (that is, when the application requests that a window be simultaneously activated and its position in the Z order changed), the value specified in <i>hWndInsertAfter</i> is used only in the following circumstances: 
     * 
     * <ul>
     * <li>Neither the <b>HWND_TOPMOST</b> nor <b>HWND_NOTOPMOST</b> flag is specified in <i>hWndInsertAfter</i>. </li>
     * <li>The window identified by <i>hWnd</i> is not the active window. </li>
     * </ul>
     * An application cannot activate an inactive window without also bringing it to the top of the Z order. An application can change an activated window's position in the Z order without restrictions, or it can activate a window and then move it to the top of the topmost or non-topmost windows. 
     * 
     * A topmost window is no longer topmost if it is repositioned to the bottom (<b>HWND_BOTTOM</b>) of the Z order or after any non-topmost window. When a topmost window is made non-topmost, its owners and its owned windows are also made non-topmost windows. 
     * 
     * A non-topmost window may own a topmost window, but not vice versa. Any window (for example, a dialog box) owned by a topmost window is itself made a topmost window to ensure that all owned windows stay above their owner.
     * @param {Pointer<Void>} hWinPosInfo Type: <b>HDWP</b>
     * 
     * A handle to a multiple-window 
     * 					 position structure that contains size and position information for one or more windows. This structure is returned by <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-begindeferwindowpos">BeginDeferWindowPos</a> or by the most recent call to <b>DeferWindowPos</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window for which update information is stored in the structure. All windows in a multiple-window 
     * 					 position structure must have the same parent.
     * @param {Pointer<Void>} hWndInsertAfter Type: <b>HWND</b>
     * @param {Integer} x Type: <b>int</b>
     * 
     * The x-coordinate of the window's upper-left corner.
     * @param {Integer} y Type: <b>int</b>
     * 
     * The y-coordinate of the window's upper-left corner.
     * @param {Integer} cx Type: <b>int</b>
     * 
     * The window's new width, in pixels.
     * @param {Integer} cy Type: <b>int</b>
     * 
     * The window's new height, in pixels.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Pointer<Void>} Type: <b>HDWP</b>
     * 
     * The return value identifies the updated multiple-window 
     * 						 position structure. The handle returned by this function may differ from the handle passed to the function. The new handle that this function returns should be passed during the next call to the <b>DeferWindowPos</b> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddeferwindowpos">EndDeferWindowPos</a> function. 
     * 
     * If insufficient system resources are available for the function to succeed, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-deferwindowpos
     * @since windows5.0
     */
    static DeferWindowPos(hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\DeferWindowPos", "ptr", hWinPosInfo, "ptr", hWnd, "ptr", hWndInsertAfter, "int", x, "int", y, "int", cx, "int", cy, "uint", uFlags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Simultaneously updates the position and size of one or more windows in a single screen-refreshing cycle.
     * @remarks
     * The <b>EndDeferWindowPos</b> function sends the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanging">WM_WINDOWPOSCHANGING</a> and <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-windowposchanged">WM_WINDOWPOSCHANGED</a> messages to each window identified in the internal structure.
     * @param {Pointer<Void>} hWinPosInfo Type: <b>HDWP</b>
     * 
     * A handle to a multiple-window 
     * 					 position structure that contains size and position information for one or more windows. This internal structure is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-begindeferwindowpos">BeginDeferWindowPos</a> function or by the most recent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-deferwindowpos">DeferWindowPos</a> function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enddeferwindowpos
     * @since windows5.0
     */
    static EndDeferWindowPos(hWinPosInfo) {
        A_LastError := 0

        result := DllCall("USER32.dll\EndDeferWindowPos", "ptr", hWinPosInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines the visibility state of the specified window.
     * @remarks
     * The visibility state of a window is indicated by the <b>WS_VISIBLE</b> style bit. When <b>WS_VISIBLE</b> is set, the window is displayed and subsequent drawing into it is displayed as long as the window has the <b>WS_VISIBLE</b> style. 
     * 
     * Any drawing to a window with the <b>WS_VISIBLE</b> style will not be displayed if the window is obscured by other windows or is clipped by its parent window.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the specified window, its parent window, its parent's parent window, and so forth, have the <b>WS_VISIBLE</b> style, the return value is nonzero. Otherwise, the return value is zero. 
     * 
     * Because the return value specifies whether the window has the <b>WS_VISIBLE</b> style, it may be nonzero even if the window is totally obscured by other windows.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iswindowvisible
     * @since windows5.0
     */
    static IsWindowVisible(hWnd) {
        result := DllCall("USER32.dll\IsWindowVisible", "ptr", hWnd, "int")
        return result
    }

    /**
     * Determines whether the specified window is minimized (iconic).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window is iconic, the return value is nonzero.
     * 
     * If the window is not iconic, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-isiconic
     * @since windows5.0
     */
    static IsIconic(hWnd) {
        result := DllCall("USER32.dll\IsIconic", "ptr", hWnd, "int")
        return result
    }

    /**
     * Indicates whether an owned, visible, top-level pop-up, or overlapped window exists on the screen. The function searches the entire screen, not just the calling application's client area.
     * @remarks
     * This function does not detect unowned pop-up windows or windows that do not have the <b>WS_VISIBLE</b> style bit set.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If a pop-up window exists, the return value is nonzero, even if the pop-up window is completely covered by other windows.
     * 
     * If a pop-up window does not exist, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-anypopup
     * @since windows5.0
     */
    static AnyPopup() {
        result := DllCall("USER32.dll\AnyPopup", "int")
        return result
    }

    /**
     * Brings the specified window to the top of the Z order. If the window is a top-level window, it is activated. If the window is a child window, the top-level parent window associated with the child window is activated.
     * @remarks
     * Use the <b>BringWindowToTop</b> function to uncover any window that is partially or completely obscured by other windows. 
     * 
     * Calling this function is similar to calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function to change a window's position in the Z order. <b>BringWindowToTop</b> does not make a window a top-level window.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to bring to the top of the Z order.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-bringwindowtotop
     * @since windows5.0
     */
    static BringWindowToTop(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\BringWindowToTop", "ptr", hWnd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a window is maximized.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window is zoomed, the return value is nonzero.
     * 
     * If the window is not zoomed, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iszoomed
     * @since windows5.0
     */
    static IsZoomed(hWnd) {
        result := DllCall("USER32.dll\IsZoomed", "ptr", hWnd, "int")
        return result
    }

    /**
     * Creates a modeless dialog box from a dialog box template resource. (ANSI)
     * @remarks
     * The <b>CreateDialogParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>CreateDialogParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message (and a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message if the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box if the template specifies the <b>WS_VISIBLE</b> style. Finally, <b>CreateDialogParam</b> returns the window handle of the dialog box. 
     * 
     * After <b>CreateDialogParam</b> returns, the application displays the dialog box (if it is not already displayed) using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function. The application destroys the dialog box by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CreateDialogParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
     * @param {Pointer<Byte>} lpTemplateName Type: <b>LPCTSTR</b>
     * 
     * The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and low-order word must contain the identifier. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to be passed to the dialog box procedure in the <i>lParam</i> parameter in the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the window handle to the dialog box.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createdialogparama
     * @since windows5.0
     */
    static CreateDialogParamA(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) {
        lpTemplateName := lpTemplateName is String? StrPtr(lpTemplateName) : lpTemplateName

        A_LastError := 0

        result := DllCall("USER32.dll\CreateDialogParamA", "ptr", hInstance, "ptr", lpTemplateName, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a modeless dialog box from a dialog box template resource. (Unicode)
     * @remarks
     * The <b>CreateDialogParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>CreateDialogParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message (and a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message if the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box if the template specifies the <b>WS_VISIBLE</b> style. Finally, <b>CreateDialogParam</b> returns the window handle of the dialog box. 
     * 
     * After <b>CreateDialogParam</b> returns, the application displays the dialog box (if it is not already displayed) using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function. The application destroys the dialog box by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CreateDialogParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
     * @param {Pointer<Char>} lpTemplateName Type: <b>LPCTSTR</b>
     * 
     * The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and low-order word must contain the identifier. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to be passed to the dialog box procedure in the <i>lParam</i> parameter in the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the window handle to the dialog box.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createdialogparamw
     * @since windows5.0
     */
    static CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) {
        lpTemplateName := lpTemplateName is String? StrPtr(lpTemplateName) : lpTemplateName

        A_LastError := 0

        result := DllCall("USER32.dll\CreateDialogParamW", "ptr", hInstance, "ptr", lpTemplateName, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a modeless dialog box from a dialog box template in memory. (ANSI)
     * @remarks
     * The <b>CreateDialogIndirectParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>CreateDialogIndirectParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message to the dialog box procedure. If the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style, the function also sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message to the dialog box procedure. The function displays the dialog box if the template specifies the <b>WS_VISIBLE</b> style. Finally, <b>CreateDialogIndirectParam</b> returns the window handle to the dialog box. 
     * 
     * After <b>CreateDialogIndirectParam</b> returns, you can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function to display the dialog box (if it is not already visible). To destroy the dialog box, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a> function.
     * 
     * In a standard dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure and each of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structures must be aligned on <b>DWORD</b> boundaries. The creation data array that follows a <b>DLGITEMTEMPLATE</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * In an extended dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> header and each of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> control definitions must be aligned on <b>DWORD</b> boundaries. The creation data array, if any, that follows a <b>DLGITEMTEMPLATEEX</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CreateDialogIndirectParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
     * @param {Pointer<DLGTEMPLATE>} lpTemplate Type: <b>LPCDLGTEMPLATE</b>
     * 
     * The template <b>CreateDialogIndirectParam</b> uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format. 
     * 					
     * 
     * In a standard template, the header is a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure followed by additional variable-length arrays. The data for each control consists of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structure followed by additional variable-length arrays. 
     * 
     * In an extended dialog box template, the header uses the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> format and the control definitions use the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> format. 
     * 
     * After <b>CreateDialogIndirectParam</b> returns, you can free the template, which is only used to get the dialog box started.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the window handle to the dialog box.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createdialogindirectparama
     * @since windows5.0
     */
    static CreateDialogIndirectParamA(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateDialogIndirectParamA", "ptr", hInstance, "ptr", lpTemplate, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a modeless dialog box from a dialog box template in memory. (Unicode)
     * @remarks
     * The <b>CreateDialogIndirectParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>CreateDialogIndirectParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message to the dialog box procedure. If the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style, the function also sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message to the dialog box procedure. The function displays the dialog box if the template specifies the <b>WS_VISIBLE</b> style. Finally, <b>CreateDialogIndirectParam</b> returns the window handle to the dialog box. 
     * 
     * After <b>CreateDialogIndirectParam</b> returns, you can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function to display the dialog box (if it is not already visible). To destroy the dialog box, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroywindow">DestroyWindow</a> function. To support keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-isdialogmessagea">IsDialogMessage</a> function.
     * 
     * In a standard dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure and each of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structures must be aligned on <b>DWORD</b> boundaries. The creation data array that follows a <b>DLGITEMTEMPLATE</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * In an extended dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> header and each of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> control definitions must be aligned on <b>DWORD</b> boundaries. The creation data array, if any, that follows a <b>DLGITEMTEMPLATEEX</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CreateDialogIndirectParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
     * @param {Pointer<DLGTEMPLATE>} lpTemplate Type: <b>LPCDLGTEMPLATE</b>
     * 
     * The template <b>CreateDialogIndirectParam</b> uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format. 
     * 					
     * 
     * In a standard template, the header is a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure followed by additional variable-length arrays. The data for each control consists of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structure followed by additional variable-length arrays. 
     * 
     * In an extended dialog box template, the header uses the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> format and the control definitions use the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> format. 
     * 
     * After <b>CreateDialogIndirectParam</b> returns, you can free the template, which is only used to get the dialog box started.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the window handle to the dialog box.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createdialogindirectparamw
     * @since windows5.0
     */
    static CreateDialogIndirectParamW(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateDialogIndirectParamW", "ptr", hInstance, "ptr", lpTemplate, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a modal dialog box from a dialog box template resource. (ANSI)
     * @remarks
     * The <b>DialogBoxParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>DialogBoxParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message (and a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message if the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the <b>WS_VISIBLE</b> style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box. 
     * 
     * When the dialog box procedure calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function, <b>DialogBoxParam</b> destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the <i>nResult</i> parameter specified by the dialog box procedure when it called <b>EndDialog</b>. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DialogBoxParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
     * @param {Pointer<Byte>} lpTemplateName Type: <b>LPCTSTR</b>
     * 
     * The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer} Type: <b>INT_PTR</b>
     * 
     * If the function succeeds, the return value is the value of the <i>nResult</i> parameter specified in the call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function used to terminate the dialog box.
     * 
     * If the function fails because the <i>hWndParent</i> parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is 1. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dialogboxparama
     * @since windows5.0
     */
    static DialogBoxParamA(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) {
        lpTemplateName := lpTemplateName is String? StrPtr(lpTemplateName) : lpTemplateName

        A_LastError := 0

        result := DllCall("USER32.dll\DialogBoxParamA", "ptr", hInstance, "ptr", lpTemplateName, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a modal dialog box from a dialog box template resource. (Unicode)
     * @remarks
     * The <b>DialogBoxParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>DialogBoxParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message (and a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message if the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the <b>WS_VISIBLE</b> style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box. 
     * 
     * When the dialog box procedure calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function, <b>DialogBoxParam</b> destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the <i>nResult</i> parameter specified by the dialog box procedure when it called <b>EndDialog</b>. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DialogBoxParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module which contains the dialog box template. If this parameter is NULL, then the current executable is used.
     * @param {Pointer<Char>} lpTemplateName Type: <b>LPCTSTR</b>
     * 
     * The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier, its high-order word must be zero and its low-order word must contain the identifier. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer} Type: <b>INT_PTR</b>
     * 
     * If the function succeeds, the return value is the value of the <i>nResult</i> parameter specified in the call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function used to terminate the dialog box.
     * 
     * If the function fails because the <i>hWndParent</i> parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is 1. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dialogboxparamw
     * @since windows5.0
     */
    static DialogBoxParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam) {
        lpTemplateName := lpTemplateName is String? StrPtr(lpTemplateName) : lpTemplateName

        A_LastError := 0

        result := DllCall("USER32.dll\DialogBoxParamW", "ptr", hInstance, "ptr", lpTemplateName, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a modal dialog box from a dialog box template in memory. (ANSI)
     * @remarks
     * The <b>DialogBoxIndirectParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>DialogBoxIndirectParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message to the dialog box procedure. If the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style, the function also sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the <b>WS_VISIBLE</b> style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box. 
     * 
     * When the dialog box procedure calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function, <b>DialogBoxIndirectParam</b> destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the <i>nResult</i> parameter specified by the dialog box procedure when it called <b>EndDialog</b>. 
     * 
     * In a standard dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure and each of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structures must be aligned on <b>DWORD</b> boundaries. The creation data array that follows a <b>DLGITEMTEMPLATE</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * In an extended dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> header and each of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> control definitions must be aligned on <b>DWORD</b> boundaries. The creation data array, if any, that follows a <b>DLGITEMTEMPLATEEX</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DialogBoxIndirectParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module that creates the dialog box.
     * @param {Pointer<DLGTEMPLATE>} hDialogTemplate Type: <b>LPCDLGTEMPLATE</b>
     * 
     * The template that <b>DialogBoxIndirectParam</b> uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format. 
     * 					
     * 
     * In a standard template for a dialog box, the header is a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure followed by additional variable-length arrays. The data for each control consists of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structure followed by additional variable-length arrays. 
     * 
     * In an extended template for a dialog box, the header uses the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> format and the control definitions use the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> format.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer} Type: <b>INT_PTR</b>
     * 
     * If the function succeeds, the return value is the <i>nResult</i> parameter specified in the call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function that was used to terminate the dialog box.
     * 
     * If the function fails because the <i>hWndParent</i> parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is 1. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dialogboxindirectparama
     * @since windows5.0
     */
    static DialogBoxIndirectParamA(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\DialogBoxIndirectParamA", "ptr", hInstance, "ptr", hDialogTemplate, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a modal dialog box from a dialog box template in memory. (Unicode)
     * @remarks
     * The <b>DialogBoxIndirectParam</b> function uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function to create the dialog box. <b>DialogBoxIndirectParam</b> then sends a <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message to the dialog box procedure. If the template specifies the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or DS_SHELLFONT style, the function also sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-setfont">WM_SETFONT</a> message to the dialog box procedure. The function displays the dialog box (regardless of whether the template specifies the <b>WS_VISIBLE</b> style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box. 
     * 
     * When the dialog box procedure calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function, <b>DialogBoxIndirectParam</b> destroys the dialog box, ends the message loop, enables the owner window (if previously enabled), and returns the <i>nResult</i> parameter specified by the dialog box procedure when it called <b>EndDialog</b>. 
     * 
     * In a standard dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure and each of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structures must be aligned on <b>DWORD</b> boundaries. The creation data array that follows a <b>DLGITEMTEMPLATE</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * In an extended dialog box template, the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> header and each of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> control definitions must be aligned on <b>DWORD</b> boundaries. The creation data array, if any, that follows a <b>DLGITEMTEMPLATEEX</b> structure must also be aligned on a <b>DWORD</b> boundary. All of the other variable-length arrays in the template must be aligned on <b>WORD</b> boundaries. 
     * 
     * All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DialogBoxIndirectParam as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module that creates the dialog box.
     * @param {Pointer<DLGTEMPLATE>} hDialogTemplate Type: <b>LPCDLGTEMPLATE</b>
     * 
     * The template that <b>DialogBoxIndirectParam</b> uses to create the dialog box. A dialog box template consists of a header that describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The template can use either the standard format or the extended format. 
     * 					
     * 
     * In a standard template for a dialog box, the header is a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgtemplate">DLGTEMPLATE</a> structure followed by additional variable-length arrays. The data for each control consists of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-dlgitemtemplate">DLGITEMTEMPLATE</a> structure followed by additional variable-length arrays. 
     * 
     * In an extended template for a dialog box, the header uses the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgtemplateex">DLGTEMPLATEEX</a> format and the control definitions use the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgitemtemplateex">DLGITEMTEMPLATEEX</a> format.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the window that owns the dialog box.
     * @param {Pointer<DLGPROC>} lpDialogFunc Type: <b>DLGPROC</b>
     * 
     * A pointer to the dialog box procedure. For more information about the dialog box procedure, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>.
     * @param {Pointer} dwInitParam Type: <b>LPARAM</b>
     * 
     * The value to pass to the dialog box in the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message.
     * @returns {Pointer} Type: <b>INT_PTR</b>
     * 
     * If the function succeeds, the return value is the <i>nResult</i> parameter specified in the call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> function that was used to terminate the dialog box.
     * 
     * If the function fails because the <i>hWndParent</i> parameter is invalid, the return value is zero. The function returns zero in this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is 1. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-dialogboxindirectparamw
     * @since windows5.0
     */
    static DialogBoxIndirectParamW(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\DialogBoxIndirectParamW", "ptr", hInstance, "ptr", hDialogTemplate, "ptr", hWndParent, "ptr", lpDialogFunc, "ptr", dwInitParam, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys a modal dialog box, causing the system to end any processing for the dialog box.
     * @remarks
     * Dialog boxes created by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxa">DialogBox</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxparama">DialogBoxParam</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxindirecta">DialogBoxIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dialogboxindirectparama">DialogBoxIndirectParam</a> functions must be destroyed using the <b>EndDialog</b> function. An application calls <b>EndDialog</b> from within the dialog box procedure; the function must not be used for any other purpose. 
     * 
     * A dialog box procedure can call <b>EndDialog</b> at any time, even during the processing of the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a> message. If your application calls the function while <b>WM_INITDIALOG</b> is being processed, the dialog box is destroyed before it is shown and before the input focus is set. 
     * 
     * <b>EndDialog</b> does not destroy the dialog box immediately. Instead, it sets a flag and allows the dialog box procedure to return control to the system. The system checks the flag before attempting to retrieve the next message from the application queue. If the flag is set, the system ends the message loop, destroys the dialog box, and uses the value in <i>nResult</i> as the return value from the function that created the dialog box.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box to be destroyed.
     * @param {Pointer} nResult Type: <b>INT_PTR</b>
     * 
     * The value to be returned to the application from the function that created the dialog box.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enddialog
     * @since windows5.0
     */
    static EndDialog(hDlg, nResult) {
        A_LastError := 0

        result := DllCall("USER32.dll\EndDialog", "ptr", hDlg, "ptr", nResult, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to a control in the specified dialog box.
     * @remarks
     * You can use the <b>GetDlgItem</b> function with any parent-child window pair, not just with dialog boxes. As long as the <i>hDlg</i> parameter specifies a parent window and the child window has a unique identifier (as specified by the <i>hMenu</i> parameter in the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function that created the child window), <b>GetDlgItem</b> returns a valid handle to the child window.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The identifier of the control to be retrieved.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the window handle of the specified control. 
     * 
     * If the function fails, the return value is <b>NULL</b>, indicating an invalid dialog box handle or a nonexistent control. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdlgitem
     * @since windows5.0
     */
    static GetDlgItem(hDlg, nIDDlgItem) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetDlgItem", "ptr", hDlg, "int", nIDDlgItem)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the text of a control in a dialog box to the string representation of a specified integer value.
     * @remarks
     * To set the new text, this function sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message to the specified control.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The control to be changed.
     * @param {Integer} uValue Type: <b>UINT</b>
     * 
     * The integer value used to generate the item text.
     * @param {Integer} bSigned Type: <b>BOOL</b>
     * 
     * Indicates whether the <i>uValue</i> parameter is signed or unsigned. If this parameter is <b>TRUE</b>, <i>uValue</i> is signed. If this parameter is <b>TRUE</b> and <i>uValue</i> is less than zero, a minus sign is placed before the first digit in the string. If this parameter is <b>FALSE</b>, <i>uValue</i> is unsigned.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setdlgitemint
     * @since windows5.0
     */
    static SetDlgItemInt(hDlg, nIDDlgItem, uValue, bSigned) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetDlgItemInt", "ptr", hDlg, "int", nIDDlgItem, "uint", uValue, "int", bSigned, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates the text of a specified control in a dialog box into an integer value.
     * @remarks
     * The <b>GetDlgItemInt</b> function retrieves the text of the specified control by sending the control a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message. The function translates the retrieved text by stripping any extra spaces at the beginning of the text and then converting the decimal digits. The function stops translating when it reaches the end of the text or encounters a nonnumeric character. 
     * 
     * The <b>GetDlgItemInt</b> function returns zero if the translated value is greater than <b>INT_MAX</b> (for signed numbers) or <b>UINT_MAX</b> (for unsigned numbers).
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control of interest.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The identifier of the control whose text is to be translated.
     * @param {Pointer<Int32>} lpTranslated Type: <b>BOOL*</b>
     * 
     * Indicates success or failure (<b>TRUE</b> indicates success, <b>FALSE</b> indicates failure). 
     * 
     * If this parameter is <b>NULL</b>, the function returns no information about success or failure.
     * @param {Integer} bSigned Type: <b>BOOL</b>
     * 
     * Indicates whether the function should examine the text for a minus sign at the beginning and return a signed integer value if it finds one (<b>TRUE</b> specifies this should be done, <b>FALSE</b> that it should not).
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the variable pointed to by <i>lpTranslated</i> is set to <b>TRUE</b>, and the return value is the translated value of the control text. 
     * 
     * If the function fails, the variable pointed to by <i>lpTranslated</i> is set to <b>FALSE</b>, and the return value is zero. Note that, because zero is a possible translated value, a return value of zero does not by itself indicate failure.
     * 
     * If <i>lpTranslated</i> is <b>NULL</b>, the function returns no information about success or failure.
     * 
     * Note that, if the <i>bSigned</i> parameter is <b>TRUE</b> and there is a minus sign () at the beginning of the text, <b>GetDlgItemInt</b> translates the text into a signed integer value. Otherwise, the function creates an unsigned integer value. To obtain the proper value in this case, cast the return value to an <b>int</b> type.
     * 
     * To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdlgitemint
     * @since windows5.0
     */
    static GetDlgItemInt(hDlg, nIDDlgItem, lpTranslated, bSigned) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetDlgItemInt", "ptr", hDlg, "int", nIDDlgItem, "int*", lpTranslated, "int", bSigned)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the title or text of a control in a dialog box. (ANSI)
     * @remarks
     * The <b>SetDlgItemText</b> function sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message to the specified control.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The control with a title or text to be set.
     * @param {Pointer<Byte>} lpString Type: <b>LPCTSTR</b>
     * 
     * The text to be copied to the control.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setdlgitemtexta
     * @since windows5.0
     */
    static SetDlgItemTextA(hDlg, nIDDlgItem, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\SetDlgItemTextA", "ptr", hDlg, "int", nIDDlgItem, "ptr", lpString, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the title or text of a control in a dialog box. (Unicode)
     * @remarks
     * The <b>SetDlgItemText</b> function sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message to the specified control.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The control with a title or text to be set.
     * @param {Pointer<Char>} lpString Type: <b>LPCTSTR</b>
     * 
     * The text to be copied to the control.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setdlgitemtextw
     * @since windows5.0
     */
    static SetDlgItemTextW(hDlg, nIDDlgItem, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\SetDlgItemTextW", "ptr", hDlg, "int", nIDDlgItem, "ptr", lpString, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the title or text associated with a control in a dialog box. (ANSI)
     * @remarks
     * If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.
     * 
     * The <b>GetDlgItemText</b> function sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message to the control.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The identifier of the control whose title or text is to be retrieved.
     * @param {Pointer<Byte>} lpString Type: <b>LPTSTR</b>
     * 
     * The buffer to receive the title or text.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The maximum length, in characters, of the string to be copied to the buffer pointed to by <i>lpString</i>. If the length of the string, including the null character, exceeds the limit, the string is truncated.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdlgitemtexta
     * @since windows5.0
     */
    static GetDlgItemTextA(hDlg, nIDDlgItem, lpString, cchMax) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\GetDlgItemTextA", "ptr", hDlg, "int", nIDDlgItem, "ptr", lpString, "int", cchMax)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the title or text associated with a control in a dialog box. (Unicode)
     * @remarks
     * If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.
     * 
     * The <b>GetDlgItemText</b> function sends a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message to the control.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The identifier of the control whose title or text is to be retrieved.
     * @param {Pointer<Char>} lpString Type: <b>LPTSTR</b>
     * 
     * The buffer to receive the title or text.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The maximum length, in characters, of the string to be copied to the buffer pointed to by <i>lpString</i>. If the length of the string, including the null character, exceeds the limit, the string is truncated.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdlgitemtextw
     * @since windows5.0
     */
    static GetDlgItemTextW(hDlg, nIDDlgItem, lpString, cchMax) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\GetDlgItemTextW", "ptr", hDlg, "int", nIDDlgItem, "ptr", lpString, "int", cchMax)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends a message to the specified control in a dialog box. (ANSI)
     * @remarks
     * The <b>SendDlgItemMessage</b> function does not return until the message has been processed. 
     * 
     * Using <b>SendDlgItemMessage</b> is identical to retrieving a handle to the specified control and calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> function.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The identifier of the control that receives the message.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-senddlgitemmessagea
     * @since windows5.0
     */
    static SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\SendDlgItemMessageA", "ptr", hDlg, "int", nIDDlgItem, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Sends a message to the specified control in a dialog box. (Unicode)
     * @remarks
     * The <b>SendDlgItemMessage</b> function does not return until the message has been processed. 
     * 
     * Using <b>SendDlgItemMessage</b> is identical to retrieving a handle to the specified control and calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendmessage">SendMessage</a> function.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box that contains the control.
     * @param {Integer} nIDDlgItem Type: <b>int</b>
     * 
     * The identifier of the control that receives the message.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message to be sent.
     * 
     * For lists of the system-provided messages, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-messages-and-message-queues">System-Defined Messages</a>.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-senddlgitemmessagew
     * @since windows5.0
     */
    static SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\SendDlgItemMessageW", "ptr", hDlg, "int", nIDDlgItem, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Retrieves a handle to the first control in a group of controls that precedes (or follows) the specified control in a dialog box.
     * @remarks
     * The <b>GetNextDlgGroupItem</b> function searches controls in the order (or reverse order) they were created in the dialog box template. The first control in the group must have the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">WS_GROUP</a> style; all other controls in the group must have been consecutively created and must not have the <b>WS_GROUP</b> style. 
     * 
     * When searching for the previous control, the function returns the first control it locates that is visible and not disabled. If the control specified by <i>hCtl</i> has the <b>WS_GROUP</b> style, the function temporarily reverses the search to locate the first control having the <b>WS_GROUP</b> style, then resumes the search in the original direction, returning the first control it locates that is visible and not disabled, or returning <i>hCtl</i> if no such control is found. 
     * 
     * When searching for the next control, the function returns the first control it locates that is visible, not disabled, and does not have the <b>WS_GROUP</b> style. If it encounters a control having the <b>WS_GROUP</b> style, the function reverses the search, locates the first control having the <b>WS_GROUP</b> style, and returns this control if it is visible and not disabled. Otherwise, the function resumes the search in the original direction and returns the first control it locates that is visible and not disabled, or returns <i>hCtl</i> if no such control is found. 
     * 
     * If the search for the next control in the group encounters a window with the <b>WS_EX_CONTROLPARENT</b> style, the system recursively searches the window's children.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box to be searched.
     * @param {Pointer<Void>} hCtl Type: <b>HWND</b>
     * 
     * A handle to the control to be used as the starting point for the search. If this parameter is <b>NULL</b>, the function uses the last (or first) control in the dialog box as the starting point for the search.
     * @param {Integer} bPrevious Type: <b>BOOL</b>
     * 
     * Indicates how the function is to search the group of controls in the dialog box. If this parameter is <b>TRUE</b>, the function searches for the previous control in the group. If it is <b>FALSE</b>, the function searches for the next control in the group.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the previous (or next) control in the group of controls. 
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getnextdlggroupitem
     * @since windows5.0
     */
    static GetNextDlgGroupItem(hDlg, hCtl, bPrevious) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetNextDlgGroupItem", "ptr", hDlg, "ptr", hCtl, "int", bPrevious)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to the first control that has the WS_TABSTOP style that precedes (or follows) the specified control.
     * @remarks
     * The <b>GetNextDlgTabItem</b> function searches controls in the order (or reverse order) they were created in the dialog box template. The function returns the first control it locates that is visible, not disabled, and has the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">WS_TABSTOP</a> style. If no such control exists, the function returns <i>hCtl</i>. 
     * 
     * If the search for the next control with the <b>WS_TABSTOP</b> style encounters a window with the <b>WS_EX_CONTROLPARENT</b> style, the system recursively searches the window's children.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box to be searched.
     * @param {Pointer<Void>} hCtl Type: <b>HWND</b>
     * 
     * A handle to the control to be used as the starting point for the search. 
     * 				If this parameter is <b>NULL</b>, the function fails.
     * @param {Integer} bPrevious Type: <b>BOOL</b>
     * 
     * Indicates how the function is to search the dialog box. If this parameter 
     * 				is <b>TRUE</b>, the function searches for the previous control 
     * 				in the dialog box. If this parameter is <b>FALSE</b>, the function searches 
     * 				for the next control in the dialog box.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the window handle 
     * 				of the previous (or next) control that has the 
     * 				<a href="https://docs.microsoft.com/windows/desktop/dlgbox/dlgbox-programming-considerations">WS_TABSTOP</a> style set. 
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error 
     * 				information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getnextdlgtabitem
     * @since windows5.0
     */
    static GetNextDlgTabItem(hDlg, hCtl, bPrevious) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetNextDlgTabItem", "ptr", hDlg, "ptr", hCtl, "int", bPrevious)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the identifier of the specified control.
     * @remarks
     * <b>GetDlgCtrlID</b> accepts child window handles as well as handles of controls in dialog boxes. An application sets the identifier for a child window when it creates the window by assigning the identifier value to the <i>hmenu</i> parameter when calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowa">CreateWindow</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> function. 
     * 
     * Although <b>GetDlgCtrlID</b> may return a value if <i>hwndCtl</i> is a handle to a top-level window, top-level windows cannot have identifiers and such a return value is never valid.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the control.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the identifier of the control.
     * 
     * If the function fails, the return value is zero. An invalid value for the <i>hwndCtl</i> parameter, for example, will cause the function to fail. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdlgctrlid
     * @since windows5.0
     */
    static GetDlgCtrlID(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetDlgCtrlID", "ptr", hWnd)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the system's dialog base units, which are the average width and height of characters in the system font.
     * @remarks
     * The horizontal base unit returned by <b>GetDialogBaseUnits</b> is equal to the average width, in pixels, of the characters in the system font; the vertical base unit is equal to the height, in pixels, of the font.
     * 
     * The system font is used only if the dialog box template fails to specify a font. Most dialog box templates specify a font; as a result, this function is not useful for most dialog boxes.
     *  
     * 
     * For a dialog box that does not use the system font, the base units are the average width and height, in pixels, of the characters in the dialog's font. You can use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextmetrics">GetTextMetrics</a> and <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-gettextextentpoint32a">GetTextExtentPoint32</a> functions to calculate these values for a selected font. However, by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-mapdialogrect">MapDialogRect</a> function, you can avoid errors that might result if your calculations differ from those performed by the system.
     * 
     * Each horizontal base unit is equal to 4 horizontal dialog template units; each vertical base unit is equal to 8 vertical dialog template units. Therefore, to convert dialog template units to pixels, use the following formulas: 		
     * 				
     * 				
     * 
     * 
     * ```
     * 
     * pixelX = MulDiv(templateunitX, baseunitX, 4);
     * pixelY = MulDiv(templateunitY, baseunitY, 8);
     * ```
     * 
     * 
     * Similarly, to convert from pixels to dialog template units, use the following formulas:
     * 				
     * 				
     * 
     * 
     * ```
     * 
     * templateunitX = MulDiv(pixelX, 4, baseunitX);
     * templateunitY = MulDiv(pixelY, 8, baseunitY);
     * ```
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * The function returns the dialog base units. The low-order word of the return value contains the horizontal dialog box base unit, and the high-order word contains the vertical dialog box base unit.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdialogbaseunits
     * @since windows5.0
     */
    static GetDialogBaseUnits() {
        result := DllCall("USER32.dll\GetDialogBaseUnits", "int")
        return result
    }

    /**
     * Calls the default dialog box window procedure to provide default processing for any window messages that a dialog box with a private window class does not process. (ANSI)
     * @remarks
     * The <b>DefDlgProc</b> function is the window procedure for the predefined class of dialog box. This procedure provides internal processing for the dialog box by forwarding messages to the dialog box procedure and carrying out default processing for any messages that the dialog box procedure returns as <b>FALSE</b>. Applications that create custom window procedures for their custom dialog boxes often use <b>DefDlgProc</b> instead of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function to carry out default message processing.
     * 
     * Applications create custom dialog box classes by filling a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure with appropriate information and registering the class with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function. Some applications fill the structure by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a> function, specifying the name of the predefined dialog box. In such cases, the applications modify at least the <b>lpszClassName</b> member before registering. In all cases, the <b>cbWndExtra</b> member of <b>WNDCLASS</b> for a custom dialog box class must be set to at least <b>DLGWINDOWEXTRA</b>.
     * 
     * The <b>DefDlgProc</b> function must not be called by a dialog box procedure; doing so results in recursive execution.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defdlgproca
     */
    static DefDlgProcA(hDlg, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\DefDlgProcA", "ptr", hDlg, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Calls the default dialog box window procedure to provide default processing for any window messages that a dialog box with a private window class does not process. (Unicode)
     * @remarks
     * The <b>DefDlgProc</b> function is the window procedure for the predefined class of dialog box. This procedure provides internal processing for the dialog box by forwarding messages to the dialog box procedure and carrying out default processing for any messages that the dialog box procedure returns as <b>FALSE</b>. Applications that create custom window procedures for their custom dialog boxes often use <b>DefDlgProc</b> instead of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function to carry out default message processing. 
     * 
     * Applications create custom dialog box classes by filling a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure with appropriate information and registering the class with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function. Some applications fill the structure by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getclassinfoa">GetClassInfo</a> function, specifying the name of the predefined dialog box. In such cases, the applications modify at least the <b>lpszClassName</b> member before registering. In all cases, the <b>cbWndExtra</b> member of <b>WNDCLASS</b> for a custom dialog box class must be set to at least <b>DLGWINDOWEXTRA</b>.
     * 
     * The <b>DefDlgProc</b> function must not be called by a dialog box procedure; doing so results in recursive execution.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box.
     * @param {Integer} Msg Type: <b>UINT</b>
     * 
     * The message.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message sent.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defdlgprocw
     * @since windows5.0
     */
    static DefDlgProcW(hDlg, Msg, wParam, lParam) {
        result := DllCall("USER32.dll\DefDlgProcW", "ptr", hDlg, "uint", Msg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Passes the specified message and hook code to the hook procedures associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks. (ANSI)
     * @remarks
     * The system calls <b>CallMsgFilter</b> to enable applications to examine and control the flow of messages during internal processing of dialog boxes, message boxes, menus, and scroll bars, or when the user activates a different window by pressing the ALT+TAB key combination. 
     * 
     * Install this hook procedure by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx</a> function.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains the message to be passed to the hook procedures.
     * @param {Integer} nCode Type: <b>int</b>
     * 
     * An application-defined code used by the hook procedure to determine how to process the message. The code must not have the same value as system-defined hook codes (MSGF_ and HC_) associated with the <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-hooks">WH_SYSMSGFILTER</a> and <b>WH_MSGFILTER</b> hooks.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the application should process the message further, the return value is zero.
     * 
     * If the application should not process the message further, the return value is nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callmsgfiltera
     * @since windows5.0
     */
    static CallMsgFilterA(lpMsg, nCode) {
        result := DllCall("USER32.dll\CallMsgFilterA", "ptr", lpMsg, "int", nCode, "int")
        return result
    }

    /**
     * Passes the specified message and hook code to the hook procedures associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks. (Unicode)
     * @remarks
     * The system calls <b>CallMsgFilter</b> to enable applications to examine and control the flow of messages during internal processing of dialog boxes, message boxes, menus, and scroll bars, or when the user activates a different window by pressing the ALT+TAB key combination. 
     * 
     * Install this hook procedure by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx</a> function.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains the message to be passed to the hook procedures.
     * @param {Integer} nCode Type: <b>int</b>
     * 
     * An application-defined code used by the hook procedure to determine how to process the message. The code must not have the same value as system-defined hook codes (MSGF_ and HC_) associated with the <a href="https://docs.microsoft.com/windows/desktop/winmsg/about-hooks">WH_SYSMSGFILTER</a> and <b>WH_MSGFILTER</b> hooks.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the application should process the message further, the return value is zero.
     * 
     * If the application should not process the message further, the return value is nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callmsgfilterw
     * @since windows5.0
     */
    static CallMsgFilterW(lpMsg, nCode) {
        result := DllCall("USER32.dll\CallMsgFilterW", "ptr", lpMsg, "int", nCode, "int")
        return result
    }

    /**
     * Translates a string into the OEM-defined character set.WarningDo not use. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines CharToOem as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pSrc Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be translated.
     * @param {Pointer<Byte>} pDst Type: <b>LPSTR</b>
     * 
     * The destination buffer, which receives the translated string. If the <b>CharToOem</b> function is being used as an ANSI function, the string can be translated in place by setting the 
     * 					<i>lpszDst</i> parameter to the same address as the 
     * 					<i>lpszSrc</i> parameter. This cannot be done if <b>CharToOem</b> is being used as a wide-character function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to 
     * 						<i>lpszSrc</i> and 
     * 						<i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-chartooema
     * @since windows5.0
     */
    static CharToOemA(pSrc, pDst) {
        pSrc := pSrc is String? StrPtr(pSrc) : pSrc
        pDst := pDst is String? StrPtr(pDst) : pDst

        A_LastError := 0

        result := DllCall("USER32.dll\CharToOemA", "ptr", pSrc, "ptr", pDst, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates a string into the OEM-defined character set.WarningDo not use. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines CharToOem as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} pSrc Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be translated.
     * @param {Pointer<Byte>} pDst Type: <b>LPSTR</b>
     * 
     * The destination buffer, which receives the translated string. If the <b>CharToOem</b> function is being used as an ANSI function, the string can be translated in place by setting the 
     * 					<i>lpszDst</i> parameter to the same address as the 
     * 					<i>lpszSrc</i> parameter. This cannot be done if <b>CharToOem</b> is being used as a wide-character function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to 
     * 						<i>lpszSrc</i> and 
     * 						<i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-chartooemw
     * @since windows5.0
     */
    static CharToOemW(pSrc, pDst) {
        pSrc := pSrc is String? StrPtr(pSrc) : pSrc
        pDst := pDst is String? StrPtr(pDst) : pDst

        A_LastError := 0

        result := DllCall("USER32.dll\CharToOemW", "ptr", pSrc, "ptr", pDst, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates a string from the OEM-defined character set into either an ANSI or a wide-character string.WarningDo not use. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines OemToChar as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pSrc Type: <b>LPCSTR</b>
     * 
     * A null-terminated string of characters from the OEM-defined character set.
     * @param {Pointer<Byte>} pDst Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the translated string. If the <b>OemToChar</b> function is being used as an ANSI function, the string can be translated in place by setting the 
     * 					<i>lpszDst</i> parameter to the same address as the 
     * 					<i>lpszSrc</i> parameter. This cannot be done if <b>OemToChar</b> is being used as a wide-character function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to 
     * 						<i>lpszSrc</i> and 
     * 						<i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-oemtochara
     * @since windows5.0
     */
    static OemToCharA(pSrc, pDst) {
        pSrc := pSrc is String? StrPtr(pSrc) : pSrc
        pDst := pDst is String? StrPtr(pDst) : pDst

        A_LastError := 0

        result := DllCall("USER32.dll\OemToCharA", "ptr", pSrc, "ptr", pDst, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates a string from the OEM-defined character set into either an ANSI or a wide-character string.WarningDo not use. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines OemToChar as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} pSrc Type: <b>LPCSTR</b>
     * 
     * A null-terminated string of characters from the OEM-defined character set.
     * @param {Pointer<Char>} pDst Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the translated string. If the <b>OemToChar</b> function is being used as an ANSI function, the string can be translated in place by setting the 
     * 					<i>lpszDst</i> parameter to the same address as the 
     * 					<i>lpszSrc</i> parameter. This cannot be done if <b>OemToChar</b> is being used as a wide-character function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to 
     * 						<i>lpszSrc</i> and 
     * 						<i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-oemtocharw
     * @since windows5.0
     */
    static OemToCharW(pSrc, pDst) {
        pSrc := pSrc is String? StrPtr(pSrc) : pSrc
        pDst := pDst is String? StrPtr(pDst) : pDst

        A_LastError := 0

        result := DllCall("USER32.dll\OemToCharW", "ptr", pSrc, "ptr", pDst, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates a specified number of characters in a string into the OEM-defined character set. (ANSI)
     * @remarks
     * Unlike the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-chartooema">CharToOem</a> function, the <b>CharToOemBuff</b> function does not stop converting characters when it encounters a null character in the buffer pointed to by <i>lpszSrc</i>. The <b>CharToOemBuff</b> function converts all <i>cchDstLength</i> characters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharToOemBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszSrc Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be translated.
     * @param {Pointer<Byte>} lpszDst Type: <b>LPSTR</b>
     * 
     * The buffer for the translated string. If the <b>CharToOemBuff</b> function is being used as an ANSI function, the string can be translated in place by setting the <i>lpszDst</i> parameter to the same address as the <i>lpszSrc</i> parameter. This cannot be done if <b>CharToOemBuff</b> is being used as a wide-character function.
     * @param {Integer} cchDstLength Type: <b>DWORD</b>
     * 
     * The number of characters to translate in the string identified by the <i>lpszSrc</i> parameter.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to <i>lpszSrc</i> and <i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-chartooembuffa
     * @since windows5.0
     */
    static CharToOemBuffA(lpszSrc, lpszDst, cchDstLength) {
        lpszSrc := lpszSrc is String? StrPtr(lpszSrc) : lpszSrc
        lpszDst := lpszDst is String? StrPtr(lpszDst) : lpszDst

        A_LastError := 0

        result := DllCall("USER32.dll\CharToOemBuffA", "ptr", lpszSrc, "ptr", lpszDst, "uint", cchDstLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates a specified number of characters in a string into the OEM-defined character set. (Unicode)
     * @remarks
     * Unlike the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-chartooema">CharToOem</a> function, the <b>CharToOemBuff</b> function does not stop converting characters when it encounters a null character in the buffer pointed to by <i>lpszSrc</i>. The <b>CharToOemBuff</b> function converts all <i>cchDstLength</i> characters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharToOemBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpszSrc Type: <b>LPCTSTR</b>
     * 
     * The null-terminated string to be translated.
     * @param {Pointer<Byte>} lpszDst Type: <b>LPSTR</b>
     * 
     * The buffer for the translated string. If the <b>CharToOemBuff</b> function is being used as an ANSI function, the string can be translated in place by setting the <i>lpszDst</i> parameter to the same address as the <i>lpszSrc</i> parameter. This cannot be done if <b>CharToOemBuff</b> is being used as a wide-character function.
     * @param {Integer} cchDstLength Type: <b>DWORD</b>
     * 
     * The number of characters to translate in the string identified by the <i>lpszSrc</i> parameter.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to <i>lpszSrc</i> and <i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-chartooembuffw
     * @since windows5.0
     */
    static CharToOemBuffW(lpszSrc, lpszDst, cchDstLength) {
        lpszSrc := lpszSrc is String? StrPtr(lpszSrc) : lpszSrc
        lpszDst := lpszDst is String? StrPtr(lpszDst) : lpszDst

        A_LastError := 0

        result := DllCall("USER32.dll\CharToOemBuffW", "ptr", lpszSrc, "ptr", lpszDst, "uint", cchDstLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates a specified number of characters in a string from the OEM-defined character set into either an ANSI or a wide-character string. (ANSI)
     * @remarks
     * Unlike the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-oemtochara">OemToChar</a> function, the <b>OemToCharBuff</b> function does not stop converting characters when it encounters a null character in the buffer pointed to by 
     * 				<i>lpszSrc</i>. The <b>OemToCharBuff</b> function converts all 
     * 				<i>cchDstLength</i> characters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines OemToCharBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszSrc Type: <b>LPCSTR</b>
     * 
     * One or more characters from the OEM-defined character set.
     * @param {Pointer<Byte>} lpszDst Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the translated string. If the <b>OemToCharBuff</b> function is being used as an ANSI function, the string can be translated in place by setting the 
     * 					<i>lpszDst</i> parameter to the same address as the 
     * 					<i>lpszSrc</i> parameter. This cannot be done if the <b>OemToCharBuff</b> function is being used as a wide-character function.
     * @param {Integer} cchDstLength Type: <b>DWORD</b>
     * 
     * The number of 
     * 					characters to be translated in the buffer identified by the 
     * 					<i>lpszSrc</i> parameter.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to 
     * 						<i>lpszSrc</i> and 
     * 						<i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-oemtocharbuffa
     * @since windows5.0
     */
    static OemToCharBuffA(lpszSrc, lpszDst, cchDstLength) {
        lpszSrc := lpszSrc is String? StrPtr(lpszSrc) : lpszSrc
        lpszDst := lpszDst is String? StrPtr(lpszDst) : lpszDst

        A_LastError := 0

        result := DllCall("USER32.dll\OemToCharBuffA", "ptr", lpszSrc, "ptr", lpszDst, "uint", cchDstLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Translates a specified number of characters in a string from the OEM-defined character set into either an ANSI or a wide-character string. (Unicode)
     * @remarks
     * Unlike the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-oemtochara">OemToChar</a> function, the <b>OemToCharBuff</b> function does not stop converting characters when it encounters a null character in the buffer pointed to by 
     * 				<i>lpszSrc</i>. The <b>OemToCharBuff</b> function converts all 
     * 				<i>cchDstLength</i> characters.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines OemToCharBuff as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszSrc Type: <b>LPCSTR</b>
     * 
     * One or more characters from the OEM-defined character set.
     * @param {Pointer<Char>} lpszDst Type: <b>LPTSTR</b>
     * 
     * The destination buffer, which receives the translated string. If the <b>OemToCharBuff</b> function is being used as an ANSI function, the string can be translated in place by setting the 
     * 					<i>lpszDst</i> parameter to the same address as the 
     * 					<i>lpszSrc</i> parameter. This cannot be done if the <b>OemToCharBuff</b> function is being used as a wide-character function.
     * @param {Integer} cchDstLength Type: <b>DWORD</b>
     * 
     * The number of 
     * 					characters to be translated in the buffer identified by the 
     * 					<i>lpszSrc</i> parameter.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is always nonzero except when you pass the same address to 
     * 						<i>lpszSrc</i> and 
     * 						<i>lpszDst</i> in the wide-character version of the function. In this case the function returns zero and 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_ADDRESS</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-oemtocharbuffw
     * @since windows5.0
     */
    static OemToCharBuffW(lpszSrc, lpszDst, cchDstLength) {
        lpszSrc := lpszSrc is String? StrPtr(lpszSrc) : lpszSrc
        lpszDst := lpszDst is String? StrPtr(lpszDst) : lpszDst

        A_LastError := 0

        result := DllCall("USER32.dll\OemToCharBuffW", "ptr", lpszSrc, "ptr", lpszDst, "uint", cchDstLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a character string or a single character to uppercase. If the operand is a character string, the function converts the characters in place. (ANSI)
     * @remarks
     * Note that <b>CharUpper</b> always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharUpper as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpsz Type: <b>LPTSTR</b>
     * 
     * A null-terminated string, or a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to 
     * 						<i>lpsz</i>. 
     * 
     * If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character. 
     * 
     * There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charuppera
     * @since windows5.0
     */
    static CharUpperA(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        A_LastError := 0

        result := DllCall("USER32.dll\CharUpperA", "ptr", lpsz, "char*")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a character string or a single character to uppercase. If the operand is a character string, the function converts the characters in place. (Unicode)
     * @remarks
     * Note that <b>CharUpper</b> always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharUpper as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpsz Type: <b>LPTSTR</b>
     * 
     * A null-terminated string, or a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to 
     * 						<i>lpsz</i>. 
     * 
     * If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character. 
     * 
     * There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charupperw
     * @since windows5.0
     */
    static CharUpperW(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        A_LastError := 0

        result := DllCall("USER32.dll\CharUpperW", "ptr", lpsz, "char*")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts lowercase characters in a buffer to uppercase characters. The function converts the characters in place. (ANSI)
     * @remarks
     * Note that <b>CharUpperBuff</b> always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * @param {Pointer<Byte>} lpsz Type: <b>LPTSTR</b>
     * 
     * A buffer containing one or more characters to be processed.
     * @param {Integer} cchLength Type: <b>DWORD</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>lpsz</i>.
     * 
     * The function examines each character, and converts lowercase characters to uppercase characters. The function examines the number of characters indicated by 
     * 					<i>cchLength</i>, even if one or more characters are null characters.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the number of 
     * 						characters processed.
     * 
     * For example, if <b>CharUpperBuff</b>("Zenith of API Sets", 10) succeeds, the return value is 10.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charupperbuffa
     * @since windows5.0
     */
    static CharUpperBuffA(lpsz, cchLength) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("USER32.dll\CharUpperBuffA", "ptr", lpsz, "uint", cchLength, "uint")
        return result
    }

    /**
     * Converts lowercase characters in a buffer to uppercase characters. The function converts the characters in place. (Unicode)
     * @remarks
     * Note that <b>CharUpperBuff</b> always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * @param {Pointer<Char>} lpsz Type: <b>LPTSTR</b>
     * 
     * A buffer containing one or more characters to be processed.
     * @param {Integer} cchLength Type: <b>DWORD</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>lpsz</i>.
     * 
     * The function examines each character, and converts lowercase characters to uppercase characters. The function examines the number of characters indicated by 
     * 					<i>cchLength</i>, even if one or more characters are null characters.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the number of 
     * 						characters processed.
     * 
     * For example, if <b>CharUpperBuff</b>("Zenith of API Sets", 10) succeeds, the return value is 10.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charupperbuffw
     * @since windows5.0
     */
    static CharUpperBuffW(lpsz, cchLength) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("USER32.dll\CharUpperBuffW", "ptr", lpsz, "uint", cchLength, "uint")
        return result
    }

    /**
     * Converts a character string or a single character to lowercase. If the operand is a character string, the function converts the characters in place. (ANSI)
     * @remarks
     * Note that <b>CharLower</b> always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharLower as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpsz Type: <b>LPTSTR</b>
     * 
     * A null-terminated string, or specifies a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to 
     * 						<i>lpsz</i>. 
     * 
     * If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character. 
     * 
     * There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charlowera
     * @since windows5.0
     */
    static CharLowerA(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        A_LastError := 0

        result := DllCall("USER32.dll\CharLowerA", "ptr", lpsz, "char*")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a character string or a single character to lowercase. If the operand is a character string, the function converts the characters in place. (Unicode)
     * @remarks
     * Note that <b>CharLower</b> always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapString</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharLower as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpsz Type: <b>LPTSTR</b>
     * 
     * A null-terminated string, or specifies a single character. If the high-order word of this parameter is zero, the low-order word must contain a single character to be converted.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the return value is equal to 
     * 						<i>lpsz</i>. 
     * 
     * If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the converted character. 
     * 
     * There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call 
     * 						<a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charlowerw
     * @since windows5.0
     */
    static CharLowerW(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        A_LastError := 0

        result := DllCall("USER32.dll\CharLowerW", "ptr", lpsz, "char*")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts uppercase characters in a buffer to lowercase characters. The function converts the characters in place. (ANSI)
     * @remarks
     * Note that <b>CharLowerBuff</b> always maps uppercase I to lowercase I  ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapSting</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * @param {Pointer<Byte>} lpsz Type: <b>LPTSTR</b>
     * 
     * A buffer containing one or more characters to be processed.
     * @param {Integer} cchLength Type: <b>DWORD</b>
     * 
     * The size, in 
     * 					characters, of the buffer pointed to by 
     * 					<i>lpsz</i>. The function examines each character, and converts uppercase characters to lowercase characters. The function examines the number of 
     * 					characters indicated by 
     * 					<i>cchLength</i>, even if one or more characters are null characters.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the number of 
     * 						characters processed. For example, if <b>CharLowerBuff</b>("Acme of Operating Systems", 10) succeeds, the return value is 10.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charlowerbuffa
     * @since windows5.0
     */
    static CharLowerBuffA(lpsz, cchLength) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("USER32.dll\CharLowerBuffA", "ptr", lpsz, "uint", cchLength, "uint")
        return result
    }

    /**
     * Converts uppercase characters in a buffer to lowercase characters. The function converts the characters in place. (Unicode)
     * @remarks
     * Note that <b>CharLowerBuff</b> always maps uppercase I to lowercase I  ("i"), even when the current language is Turkish or Azerbaijani. If you need a function that is linguistically sensitive in this respect, call <a href="https://docs.microsoft.com/windows/desktop/api/winnls/nf-winnls-lcmapstringa">LCMapSting</a>.
     * 
     * Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.
     * @param {Pointer<Char>} lpsz Type: <b>LPTSTR</b>
     * 
     * A buffer containing one or more characters to be processed.
     * @param {Integer} cchLength Type: <b>DWORD</b>
     * 
     * The size, in 
     * 					characters, of the buffer pointed to by 
     * 					<i>lpsz</i>. The function examines each character, and converts uppercase characters to lowercase characters. The function examines the number of 
     * 					characters indicated by 
     * 					<i>cchLength</i>, even if one or more characters are null characters.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the number of 
     * 						characters processed. For example, if <b>CharLowerBuff</b>("Acme of Operating Systems", 10) succeeds, the return value is 10.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charlowerbuffw
     * @since windows5.0
     */
    static CharLowerBuffW(lpsz, cchLength) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("USER32.dll\CharLowerBuffW", "ptr", lpsz, "uint", cchLength, "uint")
        return result
    }

    /**
     * Retrieves a pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte characters. (ANSI)
     * @remarks
     * When called as an ANSI function, <b>CharNext</b> uses the system default code-page, whereas <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-charnextexa">CharNextExA</a> specifies a code-page to use.
     * 
     * This function works with default "user" expectations of characters when dealing with diacritics. For example:
     * A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE"  which looks like "", will advance two code points, not one.
     * A string that contains U+0061 U+0301 U+0302 U+0303 U+0304  which looks like "a^~", will advance five code points, not one,
     * and so on.
     * 			
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpsz Type: <b>LPCTSTR</b>
     * 
     * A character in a null-terminated string.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * The return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.
     * 
     * If 
     * 						<i>lpsz</i> points to the terminating null character, the return value is equal to 
     * 						<i>lpsz</i>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charnexta
     * @since windows5.0
     */
    static CharNextA(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("USER32.dll\CharNextA", "ptr", lpsz, "char*")
        return result
    }

    /**
     * Retrieves a pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte characters. (Unicode)
     * @remarks
     * When called as an ANSI function, <b>CharNext</b> uses the system default code-page, whereas <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-charnextexa">CharNextExA</a> specifies a code-page to use.
     * 
     * This function works with default "user" expectations of characters when dealing with diacritics. For example:
     * A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE"  which looks like "", will advance two code points, not one.
     * A string that contains U+0061 U+0301 U+0302 U+0303 U+0304  which looks like "a^~", will advance five code points, not one,
     * and so on.
     * 			
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpsz Type: <b>LPCTSTR</b>
     * 
     * A character in a null-terminated string.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * The return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.
     * 
     * If 
     * 						<i>lpsz</i> points to the terminating null character, the return value is equal to 
     * 						<i>lpsz</i>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charnextw
     * @since windows5.0
     */
    static CharNextW(lpsz) {
        lpsz := lpsz is String? StrPtr(lpsz) : lpsz

        result := DllCall("USER32.dll\CharNextW", "ptr", lpsz, "char*")
        return result
    }

    /**
     * Retrieves a pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte characters. (ANSI)
     * @remarks
     * When called as an ANSI function, <b>CharPrev</b> uses the system default code-page, whereas <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-charprevexa">CharPrevExA</a> specifies a code-page to use.
     * 
     * This function works with default "user" expectations of characters when dealing with diacritics. For example:
     * A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE"  which looks like "", will advance two code points, not one.
     * A string that contains U+0061 U+0301 U+0302 U+0303 U+0304  which looks like "a^~", will advance five code points, not one,
     * and so on.
     * 			
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharPrev as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszStart Type: <b>LPCTSTR</b>
     * 
     * The beginning of the string.
     * @param {Pointer<Byte>} lpszCurrent Type: <b>LPCTSTR</b>
     * 
     * A character in a null-terminated string.
     * @returns {Pointer<Byte>} Type: <b>LPTSTR</b>
     * 
     * The return value is a pointer to the preceding character in the string, or to the first character in the string if the 
     * 						<i>lpszCurrent</i> parameter equals the 
     * 						<i>lpszStart</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charpreva
     * @since windows5.0
     */
    static CharPrevA(lpszStart, lpszCurrent) {
        lpszStart := lpszStart is String? StrPtr(lpszStart) : lpszStart
        lpszCurrent := lpszCurrent is String? StrPtr(lpszCurrent) : lpszCurrent

        result := DllCall("USER32.dll\CharPrevA", "ptr", lpszStart, "ptr", lpszCurrent, "char*")
        return result
    }

    /**
     * Retrieves a pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte characters. (Unicode)
     * @remarks
     * When called as an ANSI function, <b>CharPrev</b> uses the system default code-page, whereas <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-charprevexa">CharPrevExA</a> specifies a code-page to use.
     * 
     * This function works with default "user" expectations of characters when dealing with diacritics. For example:
     * A string that contains U+0061 U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE"  which looks like "", will advance two code points, not one.
     * A string that contains U+0061 U+0301 U+0302 U+0303 U+0304  which looks like "a^~", will advance five code points, not one,
     * and so on.
     * 			
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines CharPrev as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpszStart Type: <b>LPCTSTR</b>
     * 
     * The beginning of the string.
     * @param {Pointer<Char>} lpszCurrent Type: <b>LPCTSTR</b>
     * 
     * A character in a null-terminated string.
     * @returns {Pointer<Char>} Type: <b>LPTSTR</b>
     * 
     * The return value is a pointer to the preceding character in the string, or to the first character in the string if the 
     * 						<i>lpszCurrent</i> parameter equals the 
     * 						<i>lpszStart</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charprevw
     * @since windows5.0
     */
    static CharPrevW(lpszStart, lpszCurrent) {
        lpszStart := lpszStart is String? StrPtr(lpszStart) : lpszStart
        lpszCurrent := lpszCurrent is String? StrPtr(lpszCurrent) : lpszCurrent

        result := DllCall("USER32.dll\CharPrevW", "ptr", lpszStart, "ptr", lpszCurrent, "char*")
        return result
    }

    /**
     * Retrieves the pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte characters.
     * @remarks
     * <b>CharNextExA</b> specifies a code-page to use, whereas <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-charnexta">CharNext</a> (if called as an ANSI function) uses the system default code-page.
     * @param {Integer} CodePage Type: <b>WORD</b>
     * 
     * The identifier of the code page to use to check lead-byte ranges. Can be one of the code-page values provided in <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>, or one of the following predefined values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default OEM code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpCurrentChar Type: <b>LPCSTR</b>
     * 
     * A character in a null-terminated string.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * This parameter is reserved and must be 0.
     * @returns {Pointer<Byte>} Type: <b>LPSTR</b>
     * 
     * The return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.
     * 
     * If 
     * 						<i>lpCurrentChar</i> points to the terminating null character, the return value is equal to 
     * 						<i>lpCurrentChar</i>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charnextexa
     * @since windows5.0
     */
    static CharNextExA(CodePage, lpCurrentChar, dwFlags) {
        lpCurrentChar := lpCurrentChar is String? StrPtr(lpCurrentChar) : lpCurrentChar

        result := DllCall("USER32.dll\CharNextExA", "ushort", CodePage, "ptr", lpCurrentChar, "uint", dwFlags, "char*")
        return result
    }

    /**
     * Retrieves the pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte characters.
     * @remarks
     * <b>CharPrevExA</b> specifies a code-page to use, whereas <a href="https://docs.microsoft.com/windows/desktop/menurc/v">CharPrev</a> (if called as an ANSI function) uses the system default code-page.
     * @param {Integer} CodePage Type: <b>WORD</b>
     * 
     * The identifier of the code page to use to check lead-byte ranges. Can be one of the code-page values provided in <a href="https://docs.microsoft.com/windows/desktop/Intl/code-page-identifiers">Code Page Identifiers</a>,  or one of the following predefined values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_ACP"></a><a id="cp_acp"></a><dl>
     * <dt><b>CP_ACP</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default ANSI code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_MACCP"></a><a id="cp_maccp"></a><dl>
     * <dt><b>CP_MACCP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Use the system default Macintosh code page.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CP_OEMCP"></a><a id="cp_oemcp"></a><dl>
     * <dt><b>CP_OEMCP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use system default OEM code page.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpStart Type: <b>LPCSTR</b>
     * 
     * The beginning of the string.
     * @param {Pointer<Byte>} lpCurrentChar Type: <b>LPCSTR</b>
     * 
     * A character in a null-terminated string.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * This parameter is reserved and must be zero.
     * @returns {Pointer<Byte>} Type: <b>LPSTR</b>
     * 
     * The return value is a pointer to the preceding character in the string, or to the first character in the string if the 
     * 						<i>lpCurrentChar</i> parameter equals the 
     * 						<i>lpStart</i> parameter.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-charprevexa
     * @since windows5.0
     */
    static CharPrevExA(CodePage, lpStart, lpCurrentChar, dwFlags) {
        lpStart := lpStart is String? StrPtr(lpStart) : lpStart
        lpCurrentChar := lpCurrentChar is String? StrPtr(lpCurrentChar) : lpCurrentChar

        result := DllCall("USER32.dll\CharPrevExA", "ushort", CodePage, "ptr", lpStart, "ptr", lpCurrentChar, "uint", dwFlags, "char*")
        return result
    }

    /**
     * Determines whether a character is an alphabetical character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines IsCharAlpha as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TCHAR</b>
     * 
     * The character to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the character is alphabetical, the return value is nonzero.
     * 
     * If the character is not alphabetical, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischaralphaa
     * @since windows5.0
     */
    static IsCharAlphaA(ch) {
        A_LastError := 0

        result := DllCall("USER32.dll\IsCharAlphaA", "char", ch, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a character is an alphabetical character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines IsCharAlpha as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TCHAR</b>
     * 
     * The character to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the character is alphabetical, the return value is nonzero.
     * 
     * If the character is not alphabetical, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischaralphaw
     * @since windows5.0
     */
    static IsCharAlphaW(ch) {
        A_LastError := 0

        result := DllCall("USER32.dll\IsCharAlphaW", "char", ch, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a character is either an alphabetical or a numeric character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines IsCharAlphaNumeric as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TCHAR</b>
     * 
     * The character to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the character is alphanumeric, the return value is nonzero.
     * 
     * If the character is not alphanumeric, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischaralphanumerica
     * @since windows5.0
     */
    static IsCharAlphaNumericA(ch) {
        A_LastError := 0

        result := DllCall("USER32.dll\IsCharAlphaNumericA", "char", ch, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a character is either an alphabetical or a numeric character. This determination is based on the semantics of the language selected by the user during setup or through Control Panel. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines IsCharAlphaNumeric as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TCHAR</b>
     * 
     * The character to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the character is alphanumeric, the return value is nonzero.
     * 
     * If the character is not alphanumeric, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischaralphanumericw
     * @since windows5.0
     */
    static IsCharAlphaNumericW(ch) {
        A_LastError := 0

        result := DllCall("USER32.dll\IsCharAlphaNumericW", "char", ch, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a character is uppercase. This determination is based on the semantics of the language selected by the user during setup or through Control Panel. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines IsCharUpper as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TCHAR</b>
     * 
     * The character to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the character is uppercase, the return value is nonzero.
     * 
     * If the character is not uppercase, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischaruppera
     * @since windows5.0
     */
    static IsCharUpperA(ch) {
        A_LastError := 0

        result := DllCall("USER32.dll\IsCharUpperA", "char", ch, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a character is uppercase. This determination is based on the semantics of the language selected by the user during setup or through Control Panel. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines IsCharUpper as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TCHAR</b>
     * 
     * The character to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the character is uppercase, the return value is nonzero.
     * 
     * If the character is not uppercase, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischarupperw
     * @since windows5.0
     */
    static IsCharUpperW(ch) {
        A_LastError := 0

        result := DllCall("USER32.dll\IsCharUpperW", "char", ch, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a character is lowercase. This determination is based on the semantics of the language selected by the user during setup or through Control Panel.
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines IsCharLower as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ch Type: <b>TCHAR</b>
     * 
     * The character to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the character is lowercase, the return value is nonzero.
     * 
     * If the character is not lowercase, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-ischarlowera
     * @since windows5.0
     */
    static IsCharLowerA(ch) {
        A_LastError := 0

        result := DllCall("USER32.dll\IsCharLowerA", "char", ch, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether there are mouse-button or keyboard messages in the calling thread's message queue.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the queue contains one or more new mouse-button or keyboard messages, the return value is nonzero.
     * 
     * If there are no new mouse-button or keyboard messages in the queue, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getinputstate
     * @since windows5.0
     */
    static GetInputState() {
        result := DllCall("USER32.dll\GetInputState", "int")
        return result
    }

    /**
     * Retrieves the type of messages found in the calling thread's message queue.
     * @remarks
     * The presence of a QS_ flag in the return value does not guarantee that a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function will return a message. <b>GetMessage</b> and <b>PeekMessage</b> perform some internal filtering that may cause the message to be processed internally. For this reason, the return value from <b>GetQueueStatus</b> should be considered only a hint as to whether <b>GetMessage</b> or <b>PeekMessage</b> should be called. 
     * 
     * The <b>QS_ALLPOSTMESSAGE</b> and <b>QS_POSTMESSAGE</b> flags differ in when they are cleared. <b>QS_POSTMESSAGE</b> is cleared when you call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, whether or not you are filtering messages. <b>QS_ALLPOSTMESSAGE</b> is cleared when you call <b>GetMessage</b> or <b>PeekMessage</b> without filtering messages (<i>wMsgFilterMin</i> and <i>wMsgFilterMax</i> are 0). This can be useful when you call <b>PeekMessage</b> multiple times to get messages in different ranges.
     * @param {Integer} flags Type: <b>UINT</b>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The high-order word of the return value indicates the types of messages currently in the queue. The low-order word indicates the types of messages that have been added to the queue and that are still in the queue since the last call to the <b>GetQueueStatus</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getqueuestatus
     * @since windows5.0
     */
    static GetQueueStatus(flags) {
        result := DllCall("USER32.dll\GetQueueStatus", "uint", flags, "uint")
        return result
    }

    /**
     * Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can include input event objects.
     * @remarks
     * The 
     * <b>MsgWaitForMultipleObjects</b> function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.
     * 
     * When <i>bWaitAll</i> is <b>TRUE</b>, the function does not modify the states of the specified objects until the states of all objects have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects have also been set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled.
     * 
     * When <i>bWaitAll</i> is <b>TRUE</b>, the function's wait is completed only when the states of all objects have been set to signaled and an input event has been received. Therefore, setting <i>bWaitAll</i> to <b>TRUE</b> prevents input from being processed until the state of all objects in the <i>pHandles</i> array have been set to signaled. For this reason, if you set <i>bWaitAll</i> to <b>TRUE</b>, you should use a short timeout value in <i>dwMilliseconds</i>. If you have a thread that creates windows waiting for all objects in the <i>pHandles</i> array, including input events specified by <i>dwWakeMask</i>, with no timeout interval, the system will deadlock. This is because threads that create windows must process messages. DDE sends message to all windows in the system. Therefore, if a thread creates windows, do not set the <i>bWaitAll</i> parameter to <b>TRUE</b> in calls to 
     * <b>MsgWaitForMultipleObjects</b> made from that thread.
     * 
     * When <i>bWaitAll</i> is <b>FALSE</b>, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.
     * 
     * <b>MsgWaitForMultipleObjects</b> does not return if there is unread input of the specified type in the message queue after the thread has called a function to check the queue. This is because functions such as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/direct3d10/id3dx10threadpump-getqueuestatus">GetQueueStatus</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-waitmessage">WaitMessage</a> check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to 
     * <b>MsgWaitForMultipleObjects</b> will not return until new input of the specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored.
     * 
     * The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the documentation for the individual synchronization objects.
     * 
     * The 
     * <b>MsgWaitForMultipleObjects</b> function can specify handles of any of the following object types in the <i>pHandles</i> array:
     * 
     * <ul>
     * <li>Change notification</li>
     * <li>Console input</li>
     * <li>Event</li>
     * <li>Memory resource notification</li>
     * <li>Mutex</li>
     * <li>Process</li>
     * <li>Semaphore</li>
     * <li>Thread</li>
     * <li>Waitable timer</li>
     * </ul>
     * @param {Integer} nCount The number of object handles in the array pointed to by <i>pHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b> minus one. If this parameter has the value zero, then the function waits only for an input event.
     * @param {Pointer<Void>} pHandles An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle. 
     * 
     * 
     * 
     * 
     * If one of these handles is closed while the wait is still pending, the function's behavior is undefined.
     * 
     * The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.
     * @param {Integer} fWaitAll If this parameter is <b>TRUE</b>, the function returns when the states of all objects in the <i>pHandles</i> array have been set to signaled and an input event has been received. If this parameter is <b>FALSE</b>, the function returns when the state of any one of the objects is set to signaled or an input event has been received. In this case, the return value indicates the object whose state caused the function to return.
     * @param {Integer} dwMilliseconds The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the specified objects are not signaled; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled.
     * 
     * <b>WindowsXP, Windows Server2003, WindowsVista, Windows7, Windows Server2008 and Windows Server2008R2:</b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.
     * 
     * <b>Windows8, Windows Server2012, Windows8.1, Windows Server2012R2, Windows10 and Windows Server2016:</b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.
     * @param {Integer} dwWakeMask The input types for which an input event object handle will be added to the array of object handles. This parameter can be any combination of the values listed in [GetQueueStatus](/windows/win32/api/winuser/nf-winuser-getqueuestatus) *flags* parameter.
     * @returns {Integer} If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_OBJECT_0</b> to
     * (<b>WAIT_OBJECT_0</b> + <i>nCount</i> 1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all specified objects is signaled. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_OBJECT_0</b> indicates the <i>pHandles</i> array index of the object that satisfied the wait.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_OBJECT_0</b> + <i>nCount</i></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * New input of the type specified in the <i>dwWakeMask</i> parameter is available in the thread's input queue. Functions such as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-waitmessage">WaitMessage</a> mark messages in the queue as old messages. Therefore, after you call one of these functions, a subsequent call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects</a> will not return until new input of the specified type arrives. 
     * 
     * 
     * 
     * 
     * This value is also returned upon the occurrence of a system event that requires the thread's action, such as foreground activation. Therefore, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects</a> can return even though no appropriate input is available and even if <i>dwWakeMask</i> is set to 0. If this occurs, call <a href="https://docs.microsoft.com/previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> to process the system event before trying the call to 
     * <b>MsgWaitForMultipleObjects</b> again.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_ABANDONED_0</b> to
     * (<b>WAIT_ABANDONED_0</b> + <i>nCount</i> 1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If <i>bWaitAll</i> is <b>TRUE</b>, a return value within the specified range indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned mutex object. If <i>bWaitAll</i> is <b>FALSE</b>, the return value minus <b>WAIT_ABANDONED_0</b> indicates the <i>pHandles</i> array index of an abandoned mutex object that satisfied the wait. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.
     * 
     * If the mutex was protecting persistent state information, you should check it for consistency.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_TIMEOUT</b></dt>
     * <dt>258L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The time-out interval elapsed and the conditions specified by the <i>bWaitAll</i> and <i>dwWakeMask</i> parameters were not satisfied.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_FAILED</b></dt>
     * <dt>(DWORD)0xFFFFFFFF</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function has failed. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects
     * @since windows5.1.2600
     */
    static MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask) {
        A_LastError := 0

        result := DllCall("USER32.dll\MsgWaitForMultipleObjects", "uint", nCount, "ptr", pHandles, "int", fWaitAll, "uint", dwMilliseconds, "uint", dwWakeMask, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include input event objects.
     * @remarks
     * The 
     * <b>MsgWaitForMultipleObjectsEx</b> function determines whether the conditions specified by <i>dwWakeMask</i> and <i>dwFlags</i> have been met. If the conditions have not been met, the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.
     * 
     * When <i>dwFlags</i> is zero, this function checks the handles in the array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was signaled.
     * 
     * <b>MsgWaitForMultipleObjectsEx</b> does not return if there is unread input of the specified type in the message queue after the thread has called a function to check the queue, unless you use the <b>MWMO_INPUTAVAILABLE</b> flag. This is because functions such as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/direct3d10/id3dx10threadpump-getqueuestatus">GetQueueStatus</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-waitmessage">WaitMessage</a> check the queue and then change the state information for the queue so that the input is no longer considered new. A subsequent call to 
     * <b>MsgWaitForMultipleObjectsEx</b> will not return until new input of the specified type arrives, unless you use the <b>MWMO_INPUTAVAILABLE</b> flag. If this flag is not used, the existing unread input (received prior to the last time the thread checked the queue) is ignored.
     * 
     * The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled state caused the function to return. For example, the system decreases the count of a semaphore object by one. For more information, see the documentation for the individual synchronization objects.
     * 
     * The 
     * <b>MsgWaitForMultipleObjectsEx</b> function can specify handles of any of the following object types in the <i>pHandles</i> array:
     * 
     * <ul>
     * <li>Change notification</li>
     * <li>Console input</li>
     * <li>Event</li>
     * <li>Memory resource notification</li>
     * <li>Mutex</li>
     * <li>Process</li>
     * <li>Semaphore</li>
     * <li>Thread</li>
     * <li>Waitable timer</li>
     * </ul>
     * @param {Integer} nCount The number of object handles in the array pointed to by <i>pHandles</i>. The maximum number of object handles is <b>MAXIMUM_WAIT_OBJECTS</b> minus one. If this parameter has the value zero, then the function waits only for an input event.
     * @param {Pointer<Void>} pHandles An array of object handles. For a list of the object types whose handles you can specify, see the Remarks section later in this topic. The array can contain handles to multiple types of objects. It may not contain multiple copies of the same handle. 
     * 
     * 
     * 
     * 
     * If one of these handles is closed while the wait is still pending, the function's behavior is undefined.
     * 
     * The handles must have the <b>SYNCHRONIZE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.
     * @param {Integer} dwMilliseconds The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O completion routine or APC is queued, or the interval elapses. If <i>dwMilliseconds</i> is zero, the function does not enter a wait state if the criteria is not met; it always returns immediately. If <i>dwMilliseconds</i> is <b>INFINITE</b>, the function will return only when the specified objects are signaled or an I/O completion routine or APC is queued.
     * 
     * <b>WindowsXP, Windows Server2003, WindowsVista, Windows7, Windows Server2008 and Windows Server2008R2:</b>The <i>dwMilliseconds</i> value does include time spent in low-power states. For example, the timeout does keep counting down while the computer is asleep.
     * 
     * <b>Windows8, Windows Server2012, Windows8.1, Windows Server2012R2, Windows10 and Windows Server2016:</b>The <i>dwMilliseconds</i> value does not include time spent in low-power states. For example, the timeout does not keep counting down while the computer is asleep.
     * @param {Integer} dwWakeMask The input types for which an input event object handle will be added to the array of object handles. This parameter can be any combination of the values listed in [GetQueueStatus](/windows/win32/api/winuser/nf-winuser-getqueuestatus) *flags* parameter.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note that <b>WAIT_OBJECT_0</b> is defined as 0 and <b>WAIT_ABANDONED_0</b> is defined as 0x00000080L.)
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_OBJECT_0</b> to
     *  (<b>WAIT_OBJECT_0</b> + <i>nCount</i> - 1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <b>MWMO_WAITALL</b> flag is used, a return value within the specified range indicates that the state of all specified objects is signaled. Otherwise, the return value minus <b>WAIT_OBJECT_0</b> indicates the <i>pHandles</i> array index of the object that caused the function to return.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_OBJECT_0</b> + <i>nCount</i></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * New input of the type specified in the <i>dwWakeMask</i> parameter is available in the thread's input queue. Functions such as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a>, 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/direct3d10/id3dx10threadpump-getqueuestatus">GetQueueStatus</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-waitmessage">WaitMessage</a> mark messages in the queue as old messages. Therefore, after you call one of these functions, a subsequent call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjectsex">MsgWaitForMultipleObjectsEx</a> will not return until new input of the specified type arrives. 
     * 
     * 
     * 
     * 
     * This value is also returned upon the occurrence of a system event that requires the thread's action, such as foreground activation. Therefore, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjectsex">MsgWaitForMultipleObjectsEx</a> can return even though no appropriate input is available and even if <i>dwWakeMask</i> is set to 0. If this occurs, call <a href="https://docs.microsoft.com/previous-versions/windows/desktop/fax/-mfax-faxaccountincomingarchive-getmessage-vb">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> to process the system event before trying the call to 
     * <b>MsgWaitForMultipleObjectsEx</b> again.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_ABANDONED_0</b> to
     * (<b>WAIT_ABANDONED_0</b> + <i>nCount</i> - 1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <b>MWMO_WAITALL</b> flag is used, a return value within the specified range indicates that the state of all specified objects is signaled and at least one of the objects is an abandoned mutex object. Otherwise, the return value minus <b>WAIT_ABANDONED_0</b> indicates the <i>pHandles</i> array index of an abandoned mutex object that caused the function to return. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.
     * 
     * If the mutex was protecting persistent state information, you should check it for consistency.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_IO_COMPLETION</b></dt>
     * <dt>0x000000C0L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The wait was ended by one or more user-mode 
     * <a href="https://docs.microsoft.com/windows/desktop/Sync/asynchronous-procedure-calls">asynchronous procedure calls</a> (APC) queued to the thread.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_TIMEOUT</b></dt>
     * <dt>258L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The time-out interval elapsed, but the conditions specified by the <i>dwFlags</i> and <i>dwWakeMask</i> parameters were not met.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WAIT_FAILED</b></dt>
     * <dt>(DWORD)0xFFFFFFFF</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function has failed. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex
     * @since windows5.1.2600
     */
    static MsgWaitForMultipleObjectsEx(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\MsgWaitForMultipleObjectsEx", "uint", nCount, "ptr", pHandles, "uint", dwMilliseconds, "uint", dwWakeMask, "uint", dwFlags, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a timer with the specified time-out value.
     * @remarks
     * An application can process <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> messages by including a <b>WM_TIMER</b> case statement in the window procedure or by specifying a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-timerproc">TimerProc</a> callback function when creating the timer. When you specify a <b>TimerProc</b> callback function, the DispatchMessage calls the callback function instead of calling the window procedure when it processes <b>WM_TIMER</b> with a non-NULL lParam. Therefore, you need to dispatch messages in the calling thread, even when you use <b>TimerProc</b> instead of processing <b>WM_TIMER</b>.
     * 
     * The <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message contains the value of the <i>nIDEvent</i> parameter. 
     * 
     * The timer identifier, <i>nIDEvent</i>, is specific to the associated window. Another window can have its own timer which has the same identifier as a timer owned by another window. The timers are distinct. 
     * 
     * <b>SetTimer</b> can reuse timer IDs in the case where <i>hWnd</i> is <b>NULL</b>. 
     * 	
     * Before using **SetTimer** or other timer-related functions, it is recommended to set the **UOI_TIMERPROC_EXCEPTION_SUPPRESSION** flag to **false** through the **SetUserObjectInformationW** function, otherwise the application could behave unpredictably and could be vulnerable to security exploits. For more info, see <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setuserobjectinformationw">SetUserObjectInformationW</a>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be associated with the timer. This window must be owned by the calling thread. If a <b>NULL</b> value for <i>hWnd</i> is passed in along with an <i>nIDEvent</i> of an existing timer, that timer will be replaced in the same way that an existing non-NULL <i>hWnd</i> timer will be.
     * @param {Pointer} nIDEvent Type: <b>UINT_PTR</b>
     * 
     * A nonzero timer identifier. If the <i>hWnd</i> parameter is <b>NULL</b>, and the <i>nIDEvent</i> does not match an existing timer then it is ignored and a new timer ID is generated. If the <i>hWnd</i> parameter is not <b>NULL</b> and the window specified by <i>hWnd</i> already has a timer with the value <i>nIDEvent</i>, then the existing timer is replaced by the new timer. When <b>SetTimer</b> replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, <i>nIDEvent</i> should be 0 if the <i>hWnd</i> is <b>NULL</b>.
     * @param {Integer} uElapse Type: <b>UINT</b>
     * 
     * The time-out value, in milliseconds.
     * 
     *  If <i>uElapse</i> is less than <b>USER_TIMER_MINIMUM</b> (0x0000000A), the timeout is set to <b>USER_TIMER_MINIMUM</b>. If <i>uElapse</i> is greater than <b>USER_TIMER_MAXIMUM</b> (0x7FFFFFFF), the timeout is set to <b>USER_TIMER_MAXIMUM</b>.
     * @param {Pointer<TIMERPROC>} lpTimerFunc Type: <b>TIMERPROC</b>
     * 
     * A pointer to the function to be notified when the time-out value elapses. For more information about the function, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-timerproc">TimerProc</a>. If <i>lpTimerFunc</i> is <b>NULL</b>, the system posts a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message to the application queue. The <b>hwnd</b> member of the message's <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure contains the value of the <i>hWnd</i> parameter.
     * @returns {Pointer} Type: <b>UINT_PTR</b>
     * 
     * If the function succeeds and the <i>hWnd</i> parameter is <b>NULL</b>, the return value is an integer identifying the new timer. An application can pass this value to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.
     * 
     * If the function succeeds and the <i>hWnd</i> parameter is not <b>NULL</b>, then the return value is a nonzero integer. An application can pass the value of the <i>nIDEvent</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.
     * 
     * If the function fails to create a timer, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-settimer
     * @since windows5.0
     */
    static SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetTimer", "ptr", hWnd, "ptr", nIDEvent, "uint", uElapse, "ptr", lpTimerFunc, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a timer with the specified time-out value and coalescing tolerance delay.
     * @remarks
     * An application can process <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> messages by including a <b>WM_TIMER</b> case statement in the window procedure or by specifying a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-timerproc">TimerProc</a> callback function when creating the timer. When you specify a <b>TimerProc</b> callback function, the default window procedure calls the callback function when it processes <b>WM_TIMER</b>. Therefore, you need to dispatch messages in the calling thread, even when you use <b>TimerProc</b> instead of processing <b>WM_TIMER</b>.
     * 
     * The <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message contains the value of the <i>nIDEvent</i> parameter. 
     * 
     * The timer identifier, <i>nIDEvent</i>, is specific to the associated window. Another window can have its own timer which has the same identifier as a timer owned by another window. The timers are distinct. 
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-settimer">SetTimer</a> can reuse timer IDs in the case where <i>hWnd</i> is <b>NULL</b>. 
     *             
     * 
     * When <i>uToleranceDelay</i> is set to 0, the system default timer coalescing is used and   <b>SetCoalescableTimer</b>  behaves the same as <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-settimer">SetTimer</a>.
     * 
     * Before using **SetCoalescableTimer** or other timer-related functions, it is recommended to set the **UOI_TIMERPROC_EXCEPTION_SUPPRESSION** flag to **false** through the **SetUserObjectInformationW** function, otherwise the application could behave unpredictably and could be vulnerable to security exploits. For more info, see <a href="https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setuserobjectinformationw">SetUserObjectInformationW</a>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be associated with the timer. This window must be owned by the calling thread. If a <b>NULL</b> value for <i>hWnd</i> is passed in along with an <i>nIDEvent</i> of an existing timer, that timer will be replaced in the same way that an existing non-NULL <i>hWnd</i> timer will be.
     * @param {Pointer} nIDEvent Type: <b>UINT_PTR</b>
     * 
     * A timer identifier. If the <i>hWnd</i> parameter is <b>NULL</b>, and the <i>nIDEvent</i> does not match an existing timer, then the <i>nIDEvent</i> is ignored and a new timer ID is generated. If the <i>hWnd</i> parameter is not <b>NULL</b> and the window specified by <i>hWnd</i> already has a timer with the value <i>nIDEvent</i>, then the existing timer is replaced by the new timer. When <b>SetCoalescableTimer</b> replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses, but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, <i>nIDEvent</i> should be 0 if the <i>hWnd</i> is <b>NULL</b>.
     * @param {Integer} uElapse Type: <b>UINT</b>
     * 
     * The time-out value, in milliseconds.
     * 
     *  If <i>uElapse</i> is less than <b>USER_TIMER_MINIMUM</b> (0x0000000A), the timeout is set to <b>USER_TIMER_MINIMUM</b>. If <i>uElapse</i> is greater than <b>USER_TIMER_MAXIMUM</b> (0x7FFFFFFF), the timeout is set to <b>USER_TIMER_MAXIMUM</b>.
     * 
     * If the sum of <i>uElapse</i> and <i>uToleranceDelay</i> exceeds <b>USER_TIMER_MAXIMUM</b>, an ERROR_INVALID_PARAMETER exception occurs.
     * @param {Pointer<TIMERPROC>} lpTimerFunc Type: <b>TIMERPROC</b>
     * 
     * A pointer to the function to be notified when the time-out value elapses. For more information about the function, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-timerproc">TimerProc</a>. If <i>lpTimerFunc</i> is <b>NULL</b>, the system posts a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> message to the application queue. The <b>hwnd</b> member of the message's <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure contains the value of the <i>hWnd</i> parameter.
     * @param {Integer} uToleranceDelay Type: <b>ULONG</b>
     * @returns {Pointer} Type: <b>UINT_PTR</b>
     * 
     * If the function succeeds and the <i>hWnd</i> parameter is <b>NULL</b>, the return value is an integer identifying the new timer. An application can pass this value to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.
     * 
     * If the function succeeds and the <i>hWnd</i> parameter is not <b>NULL</b>, then the return value is a nonzero integer. An application can pass the value of the <i>nIDEvent</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-killtimer">KillTimer</a> function to destroy the timer.
     * 
     * If the function fails to create a timer, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setcoalescabletimer
     * @since windows8.0
     */
    static SetCoalescableTimer(hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetCoalescableTimer", "ptr", hWnd, "ptr", nIDEvent, "uint", uElapse, "ptr", lpTimerFunc, "uint", uToleranceDelay, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys the specified timer.
     * @remarks
     * The <b>KillTimer</b> function does not remove <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-timer">WM_TIMER</a> messages already posted to the message queue.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window associated with the specified timer. This value must be the same as the 
     * 					<i>hWnd</i> value passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-settimer">SetTimer</a> function that created the timer.
     * @param {Pointer} uIDEvent Type: <b>UINT_PTR</b>
     * 
     * The timer to be destroyed. If the window handle passed to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-settimer">SetTimer</a> is valid, this parameter must be the same as the
     * 					<i>nIDEvent</i> 
     * 
     * value passed to <b>SetTimer</b>. If the application calls <b>SetTimer</b> with 
     * 					<i>hWnd</i> set to <b>NULL</b>, this parameter must be the timer identifier returned by <b>SetTimer</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-killtimer
     * @since windows5.0
     */
    static KillTimer(hWnd, uIDEvent) {
        A_LastError := 0

        result := DllCall("USER32.dll\KillTimer", "ptr", hWnd, "ptr", uIDEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the specified window is a native Unicode window.
     * @remarks
     * The character set of a window is determined by the use of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function. If the window class was registered with the ANSI version of <b>RegisterClass</b> (<b>RegisterClassA</b>), the character set of the window is ANSI. If the window class was registered with the Unicode version of <b>RegisterClass</b> (<b>RegisterClassW</b>), the character set of the window is Unicode. 
     * 
     * The system does automatic two-way translation (Unicode to ANSI) for window messages. For example, if an ANSI window message is sent to a window that uses the Unicode character set, the system translates that message into a Unicode message before calling the window procedure. The system calls <b>IsWindowUnicode</b> to determine whether to translate the message.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window is a native Unicode window, the return value is nonzero.
     * 
     * If the window is not a native Unicode window, the return value is zero. The window is a native ANSI window.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-iswindowunicode
     * @since windows5.0
     */
    static IsWindowUnicode(hWnd) {
        result := DllCall("USER32.dll\IsWindowUnicode", "ptr", hWnd, "int")
        return result
    }

    /**
     * Loads the specified accelerator table. (ANSI)
     * @remarks
     * If the accelerator table has not yet been loaded, the function loads it from the specified executable file.
     * 
     * Accelerator tables loaded from resources are freed automatically when the application terminates.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module whose executable file contains the accelerator table to be loaded.
     * @param {Pointer<Byte>} lpTableName Type: <b>LPCTSTR</b>
     * 
     * The name of the accelerator table to be loaded. Alternatively, this parameter can specify the resource identifier of an accelerator-table resource in the low-order word and zero in the high-order word. To create this value, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro.
     * @returns {Pointer<Void>} Type: <b>HACCEL</b>
     * 
     * If the function succeeds, the return value is a handle to the loaded accelerator table.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadacceleratorsa
     * @since windows5.0
     */
    static LoadAcceleratorsA(hInstance, lpTableName) {
        lpTableName := lpTableName is String? StrPtr(lpTableName) : lpTableName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadAcceleratorsA", "ptr", hInstance, "ptr", lpTableName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified accelerator table. (Unicode)
     * @remarks
     * If the accelerator table has not yet been loaded, the function loads it from the specified executable file.
     * 
     * Accelerator tables loaded from resources are freed automatically when the application terminates.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module whose executable file contains the accelerator table to be loaded.
     * @param {Pointer<Char>} lpTableName Type: <b>LPCTSTR</b>
     * 
     * The name of the accelerator table to be loaded. Alternatively, this parameter can specify the resource identifier of an accelerator-table resource in the low-order word and zero in the high-order word. To create this value, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro.
     * @returns {Pointer<Void>} Type: <b>HACCEL</b>
     * 
     * If the function succeeds, the return value is a handle to the loaded accelerator table.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadacceleratorsw
     * @since windows5.0
     */
    static LoadAcceleratorsW(hInstance, lpTableName) {
        lpTableName := lpTableName is String? StrPtr(lpTableName) : lpTableName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadAcceleratorsW", "ptr", hInstance, "ptr", lpTableName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an accelerator table. (ANSI)
     * @remarks
     * Before an application closes, it can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyacceleratortable">DestroyAcceleratorTable</a> function to destroy any accelerator tables that it created by using the <b>CreateAcceleratorTable</b> function.
     * @param {Pointer<ACCEL>} paccel Type: <b>LPACCEL</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures that describes the accelerator table.
     * @param {Integer} cAccel Type: <b>int</b>
     * 
     * The number of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures in the array. This must be within the range 1 to 32767 or the function will fail.
     * @returns {Pointer<Void>} Type: <b>HACCEL</b>
     * 
     * If the function succeeds, the return value is the handle to the created accelerator table; otherwise, it is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createacceleratortablea
     * @since windows5.0
     */
    static CreateAcceleratorTableA(paccel, cAccel) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateAcceleratorTableA", "ptr", paccel, "int", cAccel)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an accelerator table. (Unicode)
     * @remarks
     * Before an application closes, it can use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyacceleratortable">DestroyAcceleratorTable</a> function to destroy any accelerator tables that it created by using the <b>CreateAcceleratorTable</b> function.
     * @param {Pointer<ACCEL>} paccel Type: <b>LPACCEL</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures that describes the accelerator table.
     * @param {Integer} cAccel Type: <b>int</b>
     * 
     * The number of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures in the array. This must be within the range 1 to 32767 or the function will fail.
     * @returns {Pointer<Void>} Type: <b>HACCEL</b>
     * 
     * If the function succeeds, the return value is the handle to the created accelerator table; otherwise, it is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createacceleratortablew
     * @since windows5.0
     */
    static CreateAcceleratorTableW(paccel, cAccel) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateAcceleratorTableW", "ptr", paccel, "int", cAccel)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys an accelerator table.
     * @param {Pointer<Void>} hAccel Type: <b>HACCEL</b>
     * 
     * A handle to the accelerator table to be destroyed. This handle must have been created by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createacceleratortablea">CreateAcceleratorTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadacceleratorsa">LoadAccelerators</a> function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. However, if the table has been loaded more than one call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadacceleratorsa">LoadAccelerators</a>, the function will return a nonzero value only when <b>DestroyAcceleratorTable</b> has been called an equal number of times.
     * 
     * If the function fails, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyacceleratortable
     * @since windows5.0
     */
    static DestroyAcceleratorTable(hAccel) {
        result := DllCall("USER32.dll\DestroyAcceleratorTable", "ptr", hAccel, "int")
        return result
    }

    /**
     * Copies the specified accelerator table. This function is used to obtain the accelerator-table data that corresponds to an accelerator-table handle, or to determine the size of the accelerator-table data. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines CopyAcceleratorTable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hAccelSrc Type: <b>HACCEL</b>
     * 
     * A handle to the accelerator table to copy.
     * @param {Pointer<ACCEL>} lpAccelDst Type: <b>LPACCEL</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures that receives the accelerator-table information.
     * @param {Integer} cAccelEntries Type: <b>int</b>
     * 
     * The number of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures to copy to the buffer pointed to by the 
     *      <i>lpAccelDst</i> parameter.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If 
     *       <i>lpAccelDst</i> is <b>NULL</b>, the return value specifies the number of accelerator-table entries in the original table. Otherwise, it specifies the number of accelerator-table entries that were copied.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyacceleratortablea
     * @since windows5.0
     */
    static CopyAcceleratorTableA(hAccelSrc, lpAccelDst, cAccelEntries) {
        result := DllCall("USER32.dll\CopyAcceleratorTableA", "ptr", hAccelSrc, "ptr", lpAccelDst, "int", cAccelEntries)
        return result
    }

    /**
     * Copies the specified accelerator table. This function is used to obtain the accelerator-table data that corresponds to an accelerator-table handle, or to determine the size of the accelerator-table data. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines CopyAcceleratorTable as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hAccelSrc Type: <b>HACCEL</b>
     * 
     * A handle to the accelerator table to copy.
     * @param {Pointer<ACCEL>} lpAccelDst Type: <b>LPACCEL</b>
     * 
     * An array of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures that receives the accelerator-table information.
     * @param {Integer} cAccelEntries Type: <b>int</b>
     * 
     * The number of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accel">ACCEL</a> structures to copy to the buffer pointed to by the 
     *      <i>lpAccelDst</i> parameter.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If 
     *       <i>lpAccelDst</i> is <b>NULL</b>, the return value specifies the number of accelerator-table entries in the original table. Otherwise, it specifies the number of accelerator-table entries that were copied.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyacceleratortablew
     * @since windows5.0
     */
    static CopyAcceleratorTableW(hAccelSrc, lpAccelDst, cAccelEntries) {
        result := DllCall("USER32.dll\CopyAcceleratorTableW", "ptr", hAccelSrc, "ptr", lpAccelDst, "int", cAccelEntries)
        return result
    }

    /**
     * Processes accelerator keys for menu commands. (ANSI)
     * @remarks
     * To differentiate the message that this function sends from messages sent by menus or controls, the high-order word of the
     *         <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> or <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syscommand">WM_SYSCOMMAND</a> message contains the value 1.
     * 
     * Accelerator key combinations used to select items from the
     *         <b>window</b> menu are translated into <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syscommand">WM_SYSCOMMAND</a> messages; all other accelerator key combinations are translated into <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> messages.
     * 
     * When <b>TranslateAccelerator</b> returns a nonzero value and the message is translated, the application should not use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translatemessage">TranslateMessage</a> function to process the message again.
     * 
     * An accelerator need not correspond to a menu command.
     * 
     * If the accelerator command corresponds to a menu item, the application is sent <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-initmenu">WM_INITMENU</a> and <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-initmenupopup">WM_INITMENUPOPUP</a> messages, as if the user were trying to display the menu. However, these messages are not sent if any of the following conditions exist:
     * 
     * <ul>
     * <li>The window is disabled.</li>
     * <li>The accelerator key combination does not correspond to an item on the <b>window</b> menu and the window is minimized.</li>
     * <li>A mouse capture is in effect. For information about mouse capture, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setcapture">SetCapture</a> function.</li>
     * </ul>
     * If the specified window is the active window and no window has the keyboard focus (which is generally the case if the window is minimized), <b>TranslateAccelerator</b> translates
     *         <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a> messages instead of
     *         <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a> messages.
     * 
     * If an accelerator keystroke occurs that corresponds to a menu item when the window that owns the menu is minimized, <b>TranslateAccelerator</b> does not send a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message. However, if an accelerator keystroke occurs that does not match any of the items in the window's menu or in the
     *         <b>window</b> menu, the function sends a <b>WM_COMMAND</b> message, even if the window is minimized.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose messages are to be translated.
     * @param {Pointer<Void>} hAccTable Type: <b>HACCEL</b>
     * 
     * A handle to the accelerator table. The accelerator table must have been loaded by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadacceleratorsa">LoadAccelerators</a> function or created by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createacceleratortablea">CreateAcceleratorTable</a> function.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translateacceleratora
     * @since windows5.0
     */
    static TranslateAcceleratorA(hWnd, hAccTable, lpMsg) {
        A_LastError := 0

        result := DllCall("USER32.dll\TranslateAcceleratorA", "ptr", hWnd, "ptr", hAccTable, "ptr", lpMsg)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Processes accelerator keys for menu commands. (Unicode)
     * @remarks
     * To differentiate the message that this function sends from messages sent by menus or controls, the high-order word of the
     *         <i>wParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> or <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syscommand">WM_SYSCOMMAND</a> message contains the value 1.
     * 
     * Accelerator key combinations used to select items from the
     *         <b>window</b> menu are translated into <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syscommand">WM_SYSCOMMAND</a> messages; all other accelerator key combinations are translated into <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> messages.
     * 
     * When <b>TranslateAccelerator</b> returns a nonzero value and the message is translated, the application should not use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translatemessage">TranslateMessage</a> function to process the message again.
     * 
     * An accelerator need not correspond to a menu command.
     * 
     * If the accelerator command corresponds to a menu item, the application is sent <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-initmenu">WM_INITMENU</a> and <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-initmenupopup">WM_INITMENUPOPUP</a> messages, as if the user were trying to display the menu. However, these messages are not sent if any of the following conditions exist:
     * 
     * <ul>
     * <li>The window is disabled.</li>
     * <li>The accelerator key combination does not correspond to an item on the <b>window</b> menu and the window is minimized.</li>
     * <li>A mouse capture is in effect. For information about mouse capture, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setcapture">SetCapture</a> function.</li>
     * </ul>
     * If the specified window is the active window and no window has the keyboard focus (which is generally the case if the window is minimized), <b>TranslateAccelerator</b> translates
     *         <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeyup">WM_SYSKEYUP</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-syskeydown">WM_SYSKEYDOWN</a> messages instead of
     *         <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keyup">WM_KEYUP</a> and <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-keydown">WM_KEYDOWN</a> messages.
     * 
     * If an accelerator keystroke occurs that corresponds to a menu item when the window that owns the menu is minimized, <b>TranslateAccelerator</b> does not send a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message. However, if an accelerator keystroke occurs that does not match any of the items in the window's menu or in the
     *         <b>window</b> menu, the function sends a <b>WM_COMMAND</b> message, even if the window is minimized.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose messages are to be translated.
     * @param {Pointer<Void>} hAccTable Type: <b>HACCEL</b>
     * 
     * A handle to the accelerator table. The accelerator table must have been loaded by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadacceleratorsa">LoadAccelerators</a> function or created by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createacceleratortablea">CreateAcceleratorTable</a> function.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains message information retrieved from the calling thread's message queue using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translateacceleratorw
     * @since windows5.0
     */
    static TranslateAcceleratorW(hWnd, hAccTable, lpMsg) {
        A_LastError := 0

        result := DllCall("USER32.dll\TranslateAcceleratorW", "ptr", hWnd, "ptr", hAccTable, "ptr", lpMsg)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the specified system metric or system configuration setting.
     * @remarks
     * System metrics can vary from display to display.
     * 
     * <b>GetSystemMetrics</b>(SM_CMONITORS) counts only 
     *     visible display monitors. This is different from 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumdisplaymonitors">EnumDisplayMonitors</a>, which enumerates both visible display 
     *     monitors and invisible  pseudo-monitors that are associated with mirroring drivers. An invisible pseudo-monitor is associated with a pseudo-device used to mirror application drawing for remoting or other purposes.
     * 
     * The SM_ARRANGE setting specifies how the system arranges minimized windows, and consists of a starting 
     *     position and a direction. The starting position can be one of the following values.
     *    
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>ARW_BOTTOMLEFT</td>
     * <td>Start at the lower-left corner of the screen. The default position.</td>
     * </tr>
     * <tr>
     * <td>ARW_BOTTOMRIGHT</td>
     * <td>Start at the lower-right corner of the screen. Equivalent to ARW_STARTRIGHT.</td>
     * </tr>
     * <tr>
     * <td>ARW_TOPLEFT</td>
     * <td>Start at the upper-left corner of the screen. Equivalent to ARW_STARTTOP.</td>
     * </tr>
     * <tr>
     * <td>ARW_TOPRIGHT</td>
     * <td>Start at the upper-right corner of the screen. Equivalent to ARW_STARTTOP | SRW_STARTRIGHT.</td>
     * </tr>
     * </table>
     * 
     * 
     * The direction in which to arrange minimized windows can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>ARW_DOWN</td>
     * <td>Arrange vertically, top to bottom.</td>
     * </tr>
     * <tr>
     * <td>ARW_HIDE</td>
     * <td>Hide minimized windows by moving them off the visible area of the screen.</td>
     * </tr>
     * <tr>
     * <td>ARW_LEFT</td>
     * <td>Arrange horizontally, left to right.</td>
     * </tr>
     * <tr>
     * <td>ARW_RIGHT</td>
     * <td>Arrange horizontally, right to left.</td>
     * </tr>
     * <tr>
     * <td>ARW_UP</td>
     * <td>Arrange vertically, bottom to top.</td>
     * </tr>
     * </table>
     * 
     * 
     * The SM_DIGITIZER setting specifies the type of digitizers that are installed on a device running Windows7 or Windows Server2008R2. The return value is a bitmask that specifies one or more of the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>
     * NID_INTEGRATED_TOUCH
     * 
     * 0x01
     * 
     * </td>
     * <td>
     * The device has an integrated touch digitizer. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * NID_EXTERNAL_TOUCH
     * 
     * 0x02
     * 
     * </td>
     * <td>
     * The device has an external touch digitizer. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * NID_INTEGRATED_PEN
     * 
     * 0x04
     * 
     * </td>
     * <td>
     * The device has an integrated pen digitizer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * NID_EXTERNAL_PEN
     * 
     * 0x08
     * 
     * </td>
     * <td>
     * The device has an external pen digitizer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * NID_MULTI_INPUT
     * 
     * 0x40
     * 
     * </td>
     * <td>
     * The device supports multiple sources of digitizer input. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * NID_READY
     * 
     * 0x80
     * 
     * </td>
     * <td>
     * The device is ready to receive digitizer input.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetricsfordpi">GetSystemMetricsForDPI</a>. For more information on DPI awareness, see <a href="https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows">the Windows High DPI documentation.</a>
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the requested system metric or configuration setting.
     * 
     * If the function fails, the return value is 0. 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> does not provide extended error information.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getsystemmetrics
     * @since windows5.0
     */
    static GetSystemMetrics(nIndex) {
        result := DllCall("USER32.dll\GetSystemMetrics", "int", nIndex)
        return result
    }

    /**
     * Loads the specified menu resource from the executable (.exe) file associated with an application instance. (ANSI)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroymenu">DestroyMenu</a> function is used, before an application closes, to destroy the menu and free memory that the loaded menu occupied.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module containing the menu resource to be loaded.
     * @param {Pointer<Byte>} lpMenuName Type: <b>LPCTSTR</b>
     * 
     * The name of the menu resource. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. To create this value, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the function succeeds, the return value is a handle to the menu resource.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadmenua
     * @since windows5.0
     */
    static LoadMenuA(hInstance, lpMenuName) {
        lpMenuName := lpMenuName is String? StrPtr(lpMenuName) : lpMenuName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadMenuA", "ptr", hInstance, "ptr", lpMenuName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified menu resource from the executable (.exe) file associated with an application instance. (Unicode)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroymenu">DestroyMenu</a> function is used, before an application closes, to destroy the menu and free memory that the loaded menu occupied.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the module containing the menu resource to be loaded.
     * @param {Pointer<Char>} lpMenuName Type: <b>LPCTSTR</b>
     * 
     * The name of the menu resource. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. To create this value, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the function succeeds, the return value is a handle to the menu resource.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadmenuw
     * @since windows5.0
     */
    static LoadMenuW(hInstance, lpMenuName) {
        lpMenuName := lpMenuName is String? StrPtr(lpMenuName) : lpMenuName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadMenuW", "ptr", hInstance, "ptr", lpMenuName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified menu template in memory. (ANSI)
     * @remarks
     * For both the ANSI and the Unicode version of this function, the strings in the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplate">MENUITEMTEMPLATE</a> structure must be Unicode strings. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines LoadMenuIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} lpMenuTemplate Type: <b>const MENUTEMPLATE*</b>
     * 
     * A pointer to a menu template or an extended menu template. A menu template consists of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplateheader">MENUITEMTEMPLATEHEADER</a> structure followed by one or more contiguous <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplate">MENUITEMTEMPLATE</a> structures. An extended menu template consists of a <a href="https://docs.microsoft.com/windows/desktop/menurc/menuex-template-header">MENUEX_TEMPLATE_HEADER</a> structure followed by one or more contiguous <a href="https://docs.microsoft.com/windows/desktop/menurc/menuex-template-item">MENUEX_TEMPLATE_ITEM</a> structures.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the function succeeds, the return value is a handle to the menu.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadmenuindirecta
     * @since windows5.0
     */
    static LoadMenuIndirectA(lpMenuTemplate) {
        A_LastError := 0

        result := DllCall("USER32.dll\LoadMenuIndirectA", "ptr", lpMenuTemplate)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified menu template in memory. (Unicode)
     * @remarks
     * For both the ANSI and the Unicode version of this function, the strings in the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplate">MENUITEMTEMPLATE</a> structure must be Unicode strings. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines LoadMenuIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} lpMenuTemplate Type: <b>const MENUTEMPLATE*</b>
     * 
     * A pointer to a menu template or an extended menu template. A menu template consists of a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplateheader">MENUITEMTEMPLATEHEADER</a> structure followed by one or more contiguous <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuitemtemplate">MENUITEMTEMPLATE</a> structures. An extended menu template consists of a <a href="https://docs.microsoft.com/windows/desktop/menurc/menuex-template-header">MENUEX_TEMPLATE_HEADER</a> structure followed by one or more contiguous <a href="https://docs.microsoft.com/windows/desktop/menurc/menuex-template-item">MENUEX_TEMPLATE_ITEM</a> structures.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the function succeeds, the return value is a handle to the menu.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadmenuindirectw
     * @since windows5.0
     */
    static LoadMenuIndirectW(lpMenuTemplate) {
        A_LastError := 0

        result := DllCall("USER32.dll\LoadMenuIndirectW", "ptr", lpMenuTemplate)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to the menu assigned to the specified window.
     * @remarks
     * <b>GetMenu</b> does not work on floating menu bars. Floating menu bars are custom controls that mimic standard menus; they are not menus. To get the handle on a floating menu bar, use the <a href="https://docs.microsoft.com/previous-versions/ms971350(v=msdn.10)">Active Accessibility</a> APIs.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose menu handle is to be retrieved.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * The return value is a handle to the menu. If the specified window has no menu, the return value is <b>NULL</b>. If the window is a child window, the return value is undefined.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenu
     * @since windows5.0
     */
    static GetMenu(hWnd) {
        result := DllCall("USER32.dll\GetMenu", "ptr", hWnd)
        return result
    }

    /**
     * Assigns a new menu to the specified window.
     * @remarks
     * The window is redrawn to reflect the menu change. A menu can be assigned to any window that is not a child window.
     * 
     * The <b>SetMenu</b> function replaces the previous menu, if any, but it does not destroy it. An application should call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroymenu">DestroyMenu</a> function to accomplish this task.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window to which the menu is to be assigned.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the new menu. If this parameter is <b>NULL</b>, the window's current menu is removed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmenu
     * @since windows5.0
     */
    static SetMenu(hWnd, hMenu) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetMenu", "ptr", hWnd, "ptr", hMenu, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} hMenu 
     * @param {Integer} cmd 
     * @param {Pointer<Byte>} lpszNewItem 
     * @param {Integer} cmdInsert 
     * @param {Integer} flags 
     * @returns {Integer} 
     */
    static ChangeMenuA(hMenu, cmd, lpszNewItem, cmdInsert, flags) {
        lpszNewItem := lpszNewItem is String? StrPtr(lpszNewItem) : lpszNewItem

        result := DllCall("USER32.dll\ChangeMenuA", "ptr", hMenu, "uint", cmd, "ptr", lpszNewItem, "uint", cmdInsert, "uint", flags, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} hMenu 
     * @param {Integer} cmd 
     * @param {Pointer<Char>} lpszNewItem 
     * @param {Integer} cmdInsert 
     * @param {Integer} flags 
     * @returns {Integer} 
     */
    static ChangeMenuW(hMenu, cmd, lpszNewItem, cmdInsert, flags) {
        lpszNewItem := lpszNewItem is String? StrPtr(lpszNewItem) : lpszNewItem

        result := DllCall("USER32.dll\ChangeMenuW", "ptr", hMenu, "uint", cmd, "ptr", lpszNewItem, "uint", cmdInsert, "uint", flags, "int")
        return result
    }

    /**
     * Adds or removes highlighting from an item in a menu bar.
     * @remarks
     * The <b>MF_HILITE</b> and <b>MF_UNHILITE</b> flags can be used only with the <b>HiliteMenuItem</b> function; they cannot be used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-modifymenua">ModifyMenu</a> function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that contains the menu.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu bar that contains the item.
     * @param {Integer} uIDHiliteItem Type: <b>UINT</b>
     * 
     * The menu item. This parameter is either the identifier of the menu item or the offset of the menu item in the menu bar, depending on the value of the <i>uHilite</i> parameter.
     * @param {Integer} uHilite Type: <b>UINT</b>
     * 
     * Controls the interpretation of the <i>uItemHilite</i> parameter and indicates whether the menu item is highlighted. This parameter must be a combination of either <b>MF_BYCOMMAND</b> or <b>MF_BYPOSITION</b> and <b>MF_HILITE</b> or <b>MF_UNHILITE</b>. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYCOMMAND"></a><a id="mf_bycommand"></a><dl>
     * <dt><b>MF_BYCOMMAND</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that <i>uItemHilite</i> gives the identifier of the menu item.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYPOSITION"></a><a id="mf_byposition"></a><dl>
     * <dt><b>MF_BYPOSITION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that <i>uItemHilite</i> gives the zero-based relative position of the menu item.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_HILITE"></a><a id="mf_hilite"></a><dl>
     * <dt><b>MF_HILITE</b></dt>
     * <dt>0x00000080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Highlights the menu item. If this flag is not specified, the highlighting is removed from the item.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_UNHILITE"></a><a id="mf_unhilite"></a><dl>
     * <dt><b>MF_UNHILITE</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Removes highlighting from the menu item.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the menu item is set to the specified highlight state, the return value is nonzero.
     * 
     * If the menu item is not set to the specified highlight state, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-hilitemenuitem
     * @since windows5.0
     */
    static HiliteMenuItem(hWnd, hMenu, uIDHiliteItem, uHilite) {
        result := DllCall("USER32.dll\HiliteMenuItem", "ptr", hWnd, "ptr", hMenu, "uint", uIDHiliteItem, "uint", uHilite, "int")
        return result
    }

    /**
     * Copies the text string of the specified menu item into the specified buffer. (ANSI)
     * @remarks
     * The <i>nMaxCount</i> parameter must be one larger than the number of characters in the text string to accommodate the terminating null character. 
     * 
     * If <i>nMaxCount</i> is 0, the function returns the length of the menu string.
     * 
     * <h3><a id="Security_Warning"></a><a id="security_warning"></a><a id="SECURITY_WARNING"></a>Security Warning</h3>
     * The <i>lpString</i> parameter is a <b>TCHAR</b> buffer, and <i>nMaxCount</i> is the length of the menu string in characters. Sizing these parameters incorrectly can cause truncation of the string, leading to possible loss of data.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu.
     * @param {Integer} uIDItem Type: <b>UINT</b>
     * 
     * The menu item to be changed, as determined by the <i>uFlag</i> parameter.
     * @param {Pointer<Byte>} lpString Type: <b>LPTSTR</b>
     * 
     * The buffer that receives the null-terminated string. If the string is as long or longer than <i>lpString</i>, the string is truncated and the terminating null character is added. If <i>lpString</i> is <b>NULL</b>, the function returns the length of the menu string.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The maximum length, in characters, of the string to be copied. If the string is longer than the maximum specified in the <i>nMaxCount</i> parameter, the extra characters are truncated. If <i>nMaxCount</i> is 0, the function returns the length of the menu string.
     * @param {Integer} flags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.
     * 
     * If the function fails, the return value is zero. 
     * 
     * If the specified item is not of type <b>MIIM_STRING</b> or <b>MFT_STRING</b>, then the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenustringa
     * @since windows5.0
     */
    static GetMenuStringA(hMenu, uIDItem, lpString, cchMax, flags) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        result := DllCall("USER32.dll\GetMenuStringA", "ptr", hMenu, "uint", uIDItem, "ptr", lpString, "int", cchMax, "uint", flags)
        return result
    }

    /**
     * Copies the text string of the specified menu item into the specified buffer. (Unicode)
     * @remarks
     * The <i>nMaxCount</i> parameter must be one larger than the number of characters in the text string to accommodate the terminating null character. 
     * 
     * If <i>nMaxCount</i> is 0, the function returns the length of the menu string.
     * 
     * <h3><a id="Security_Warning"></a><a id="security_warning"></a><a id="SECURITY_WARNING"></a>Security Warning</h3>
     * The <i>lpString</i> parameter is a <b>TCHAR</b> buffer, and <i>nMaxCount</i> is the length of the menu string in characters. Sizing these parameters incorrectly can cause truncation of the string, leading to possible loss of data.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu.
     * @param {Integer} uIDItem Type: <b>UINT</b>
     * 
     * The menu item to be changed, as determined by the <i>uFlag</i> parameter.
     * @param {Pointer<Char>} lpString Type: <b>LPTSTR</b>
     * 
     * The buffer that receives the null-terminated string. If the string is as long or longer than <i>lpString</i>, the string is truncated and the terminating null character is added. If <i>lpString</i> is <b>NULL</b>, the function returns the length of the menu string.
     * @param {Integer} cchMax Type: <b>int</b>
     * 
     * The maximum length, in characters, of the string to be copied. If the string is longer than the maximum specified in the <i>nMaxCount</i> parameter, the extra characters are truncated. If <i>nMaxCount</i> is 0, the function returns the length of the menu string.
     * @param {Integer} flags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null character.
     * 
     * If the function fails, the return value is zero. 
     * 
     * If the specified item is not of type <b>MIIM_STRING</b> or <b>MFT_STRING</b>, then the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenustringw
     * @since windows5.0
     */
    static GetMenuStringW(hMenu, uIDItem, lpString, cchMax, flags) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        result := DllCall("USER32.dll\GetMenuStringW", "ptr", hMenu, "uint", uIDItem, "ptr", lpString, "int", cchMax, "uint", flags)
        return result
    }

    /**
     * Retrieves the menu flags associated with the specified menu item.
     * @remarks
     * It is possible to test an item for a flag value of <b>MF_ENABLED</b>, <b>MF_STRING</b>, <b>MF_UNCHECKED</b>, or <b>MF_UNHILITE</b>. However, since these values equate to zero you must use an expression to test for them.
     * 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Flag </th>
     * <th>Expression to test for the flag</th>
     * </tr>
     * <tr>
     * <td><b>MF_ENABLED</b></td>
     * <td><c>! (Flag&amp;(MF_DISABLED | MF_GRAYED))</c></td>
     * </tr>
     * <tr>
     * <td><b>MF_STRING</b></td>
     * <td><c>! (Flag&amp;(MF_BITMAP | MF_OWNERDRAW))</c></td>
     * </tr>
     * <tr>
     * <td><b>MF_UNCHECKED</b></td>
     * <td><c>! (Flag&amp;MF_CHECKED)</c></td>
     * </tr>
     * <tr>
     * <td><b>MF_UNHILITE</b></td>
     * <td><c>! (Flag&amp;HILITE)</c></td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu that contains the menu item whose flags are to be retrieved.
     * @param {Integer} uId Type: <b>UINT</b>
     * 
     * The menu item for which the menu flags are to be retrieved, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the specified item does not exist, the return value is -1.
     * 
     * If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and the high-order byte contains the number of items in the submenu opened by the item. 
     * 
     * Otherwise, the return value is a mask (Bitwise OR) of the menu flags. Following are the menu flags associated with the menu item.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_CHECKED</b></dt>
     * <dt>0x00000008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A check mark is placed next to the item (for drop-down menus, submenus, and shortcut menus only). 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_DISABLED</b></dt>
     * <dt>0x00000002L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The item is disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_GRAYED</b></dt>
     * <dt>0x00000001L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The item is disabled and grayed. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_HILITE</b></dt>
     * <dt>0x00000080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The item is highlighted. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_MENUBARBREAK</b></dt>
     * <dt>0x00000020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is the same as the <b>MF_MENUBREAK</b> flag, except for drop-down menus, submenus, and shortcut menus, where the new column is separated from the old column by a vertical line. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_MENUBREAK</b></dt>
     * <dt>0x00000040L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The item is placed on a new line (for menu bars) or in a new column (for drop-down menus, submenus, and shortcut menus) without separating columns. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_OWNERDRAW</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The item is owner-drawn.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_POPUP</b></dt>
     * <dt>0x00000010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Menu item is a submenu.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>MF_SEPARATOR</b></dt>
     * <dt>0x00000800L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is a horizontal dividing line (for drop-down menus, submenus, and shortcut menus only). 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenustate
     * @since windows5.0
     */
    static GetMenuState(hMenu, uId, uFlags) {
        result := DllCall("USER32.dll\GetMenuState", "ptr", hMenu, "uint", uId, "uint", uFlags)
        return result
    }

    /**
     * Redraws the menu bar of the specified window. If the menu bar changes after the system has created the window, this function must be called to draw the changed menu bar.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose menu bar is to be redrawn.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawmenubar
     * @since windows5.0
     */
    static DrawMenuBar(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\DrawMenuBar", "ptr", hWnd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enables the application to access the window menu (also known as the system menu or the control menu) for copying and modifying.
     * @remarks
     * Any window that does not use the <b>GetSystemMenu</b> function to make its own copy of the window menu receives the standard window menu. 
     * 
     * The window menu initially contains items with various identifier values, such as <b>SC_CLOSE</b>, <b>SC_MOVE</b>, and <b>SC_SIZE</b>. 
     * 
     * Menu items on the window menu send <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syscommand">WM_SYSCOMMAND</a> messages. 
     * 
     * All predefined window menu items have identifier numbers greater than 0xF000. If an application adds commands to the window menu, it should use identifier numbers less than 0xF000. 
     * 
     * The system automatically grays items on the standard window menu, depending on the situation. The application can perform its own checking or graying by responding to the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-initmenu">WM_INITMENU</a> message that is sent before any menu is displayed.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that will own a copy of the window menu.
     * @param {Integer} bRevert Type: <b>BOOL</b>
     * 
     * The action to be taken. If this parameter is <b>FALSE</b>, <b>GetSystemMenu</b> returns a handle to the copy of the window menu currently in use. The copy is initially identical to the window menu, but it can be modified. If this parameter is <b>TRUE</b>, <b>GetSystemMenu</b> resets the window menu back to the default state. The previous window menu, if any, is destroyed.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the <i>bRevert</i> parameter is <b>FALSE</b>, the return value is a handle to a copy of the window menu. If the <i>bRevert</i> parameter is <b>TRUE</b>, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getsystemmenu
     * @since windows5.0
     */
    static GetSystemMenu(hWnd, bRevert) {
        result := DllCall("USER32.dll\GetSystemMenu", "ptr", hWnd, "int", bRevert)
        return result
    }

    /**
     * Creates a menu. The menu is initially empty, but it can be filled with menu items by using the InsertMenuItem, AppendMenu, and InsertMenu functions.
     * @remarks
     * Resources associated with a menu that is assigned to a window are freed automatically. If the menu is not assigned to a window, an application must free system resources associated with the menu before closing. An application frees menu resources by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroymenu">DestroyMenu</a> function.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the function succeeds, the return value is a handle to the newly created menu.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createmenu
     * @since windows5.0
     */
    static CreateMenu() {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateMenu")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a drop-down menu, submenu, or shortcut menu.
     * @remarks
     * The application can add the new menu to an existing menu, or it can display a shortcut menu by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenuex">TrackPopupMenuEx</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenu">TrackPopupMenu</a> functions. 
     * 
     * Resources associated with a menu that is assigned to a window are freed automatically. If the menu is not assigned to a window, an application must free system resources associated with the menu before closing. An application frees menu resources by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroymenu">DestroyMenu</a> function.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the function succeeds, the return value is a handle to the newly created menu.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createpopupmenu
     * @since windows5.0
     */
    static CreatePopupMenu() {
        A_LastError := 0

        result := DllCall("USER32.dll\CreatePopupMenu")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys the specified menu and frees any memory that the menu occupies.
     * @remarks
     * Before closing, an application must use the <b>DestroyMenu</b> function to destroy a menu not assigned to a window. A menu that is assigned to a window is automatically destroyed when the application closes.
     * 
     * <b>DestroyMenu</b> is recursive, that is, it will destroy the menu and all its submenus.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be destroyed.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroymenu
     * @since windows5.0
     */
    static DestroyMenu(hMenu) {
        A_LastError := 0

        result := DllCall("USER32.dll\DestroyMenu", "ptr", hMenu, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the state of the specified menu item's check-mark attribute to either selected or clear.
     * @remarks
     * An item in a menu bar cannot have a check mark. 
     * 
     * The <i>uIDCheckItem</i> parameter identifies a item that opens a submenu or a command item. For a item that opens a submenu, the <i>uIDCheckItem</i> parameter must specify the position of the item. For a command item, the <i>uIDCheckItem</i> parameter can specify either the item's position or its identifier.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu of interest.
     * @param {Integer} uIDCheckItem Type: <b>UINT</b>
     * 
     * The menu item whose check-mark attribute is to be set, as determined by the <i>uCheck</i> parameter.
     * @param {Integer} uCheck Type: <b>UINT</b>
     * 
     * The flags that control the interpretation of the <i>uIDCheckItem</i> parameter and the state of the menu item's check-mark attribute. This parameter can be a combination of either <b>MF_BYCOMMAND</b>, or <b>MF_BYPOSITION</b> and <b>MF_CHECKED</b> or <b>MF_UNCHECKED</b>. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYCOMMAND"></a><a id="mf_bycommand"></a><dl>
     * <dt><b>MF_BYCOMMAND</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uIDCheckItem</i> parameter gives the identifier of the menu item. The <b>MF_BYCOMMAND</b> flag is the default, if neither the <b>MF_BYCOMMAND</b> nor <b>MF_BYPOSITION</b> flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYPOSITION"></a><a id="mf_byposition"></a><dl>
     * <dt><b>MF_BYPOSITION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uIDCheckItem</i> parameter gives the zero-based relative position of the menu item.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_CHECKED"></a><a id="mf_checked"></a><dl>
     * <dt><b>MF_CHECKED</b></dt>
     * <dt>0x00000008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the check-mark attribute to the selected state.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_UNCHECKED"></a><a id="mf_unchecked"></a><dl>
     * <dt><b>MF_UNCHECKED</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the check-mark attribute to the clear state.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value specifies the previous state of the menu item (either <b>MF_CHECKED</b> or <b>MF_UNCHECKED</b>). If the menu item does not exist, the return value is 1.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-checkmenuitem
     * @since windows5.0
     */
    static CheckMenuItem(hMenu, uIDCheckItem, uCheck) {
        result := DllCall("USER32.dll\CheckMenuItem", "ptr", hMenu, "uint", uIDCheckItem, "uint", uCheck, "uint")
        return result
    }

    /**
     * Enables, disables, or grays the specified menu item.
     * @remarks
     * An application must use the <b>MF_BYPOSITION</b> flag to specify the correct menu handle. If the menu handle to the menu bar is specified, the top-level menu item (an item in the menu bar) is affected. To set the state of an item in a drop-down menu or submenu by position, an application must specify a handle to the drop-down menu or submenu. 
     * 
     * When an application specifies the <b>MF_BYCOMMAND</b> flag, the system checks all items that open submenus in the menu identified by the specified menu handle. Therefore, unless duplicate menu items are present, specifying the menu handle to the menu bar is sufficient. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-insertmenua">InsertMenu</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-insertmenuitema">InsertMenuItem</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadmenuindirecta">LoadMenuIndirect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-modifymenua">ModifyMenu</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setmenuiteminfoa">SetMenuItemInfo</a> functions can also set the state (enabled, disabled, or grayed) of a menu item.
     * 
     * When you change a window menu, the menu bar is not immediately updated. To force the update, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a>.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu.
     * @param {Integer} uIDEnableItem Type: <b>UINT</b>
     * 
     * The menu item to be enabled, disabled, or grayed, as determined by the <i>uEnable</i> parameter. This parameter specifies an item in a menu bar, menu, or submenu.
     * @param {Integer} uEnable Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value specifies the previous state of the menu item (it is either <b>MF_DISABLED</b>, <b>MF_ENABLED</b>, or <b>MF_GRAYED</b>). If the menu item does not exist, the return value is -1.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enablemenuitem
     * @since windows5.0
     */
    static EnableMenuItem(hMenu, uIDEnableItem, uEnable) {
        result := DllCall("USER32.dll\EnableMenuItem", "ptr", hMenu, "uint", uIDEnableItem, "uint", uEnable, "int")
        return result
    }

    /**
     * Retrieves a handle to the drop-down menu or submenu activated by the specified menu item.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu.
     * @param {Integer} nPos Type: <b>int</b>
     * 
     * The zero-based relative position in the specified menu of an item that activates a drop-down menu or submenu.
     * @returns {Pointer<Void>} Type: <b>HMENU</b>
     * 
     * If the function succeeds, the return value is a handle to the drop-down menu or submenu activated by the menu item. If the menu item does not activate a drop-down menu or submenu, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getsubmenu
     * @since windows5.0
     */
    static GetSubMenu(hMenu, nPos) {
        result := DllCall("USER32.dll\GetSubMenu", "ptr", hMenu, "int", nPos)
        return result
    }

    /**
     * Retrieves the menu item identifier of a menu item located at the specified position in a menu.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu that contains the item whose identifier is to be retrieved.
     * @param {Integer} nPos Type: <b>int</b>
     * 
     * The zero-based relative position of the menu item whose identifier is to be retrieved.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * The return value is the identifier of the specified menu item. If the menu item identifier is <b>NULL</b> or if the specified item opens a submenu, the return value is -1.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenuitemid
     * @since windows5.0
     */
    static GetMenuItemID(hMenu, nPos) {
        result := DllCall("USER32.dll\GetMenuItemID", "ptr", hMenu, "int", nPos)
        return result
    }

    /**
     * Determines the number of items in the specified menu.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be examined.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value specifies the number of items in the menu.
     * 
     * If the function fails, the return value is -1. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenuitemcount
     * @since windows5.0
     */
    static GetMenuItemCount(hMenu) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMenuItemCount", "ptr", hMenu)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Inserts a new menu item into a menu, moving other items down the menu. (ANSI)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window. 
     * 
     * The following groups of flags cannot be used together: 
     * 
     * <ul>
     * <li><b>MF_BYCOMMAND</b> and <b>MF_BYPOSITION</b></li>
     * <li><b>MF_DISABLED</b>, <b>MF_ENABLED</b>, and <b>MF_GRAYED</b></li>
     * <li><b>MF_BITMAP</b>, <b>MF_STRING</b>, <b>MF_OWNERDRAW</b>, and <b>MF_SEPARATOR</b></li>
     * <li><b>MF_MENUBARBREAK</b> and <b>MF_MENUBREAK</b></li>
     * <li><b>MF_CHECKED</b> and <b>MF_UNCHECKED</b></li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines InsertMenu as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be changed.
     * @param {Integer} uPosition Type: <b>UINT</b>
     * 
     * The menu item before which the new menu item is to be inserted, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * Controls the interpretation of the <i>uPosition</i> parameter and the content, appearance, and behavior of the new menu item. This parameter must include one of the following required values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYCOMMAND"></a><a id="mf_bycommand"></a><dl>
     * <dt><b>MF_BYCOMMAND</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the identifier of the menu item. The <b>MF_BYCOMMAND</b> flag is the default if neither the <b>MF_BYCOMMAND</b> nor <b>MF_BYPOSITION</b> flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYPOSITION"></a><a id="mf_byposition"></a><dl>
     * <dt><b>MF_BYPOSITION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the zero-based relative position of the new menu item. If <i>uPosition</i> is -1, the new menu item is appended to the end of the menu. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} uIDNewItem Type: <b>UINT_PTR</b>
     * 
     * The identifier of the new menu item or, if the <i>uFlags</i> parameter has the <b>MF_POPUP</b> flag set, a handle to the drop-down menu or submenu.
     * @param {Pointer<Byte>} lpNewItem Type: <b>LPCTSTR</b>
     * 
     * The content of the new menu item. The interpretation of <i>lpNewItem</i> depends on whether the <i>uFlags</i> parameter includes the <b>MF_BITMAP</b>, <b>MF_OWNERDRAW</b>, or <b>MF_STRING</b> flag, as follows. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BITMAP"></a><a id="mf_bitmap"></a><dl>
     * <dt><b>MF_BITMAP</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a bitmap handle. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_OWNERDRAW"></a><a id="mf_ownerdraw"></a><dl>
     * <dt><b>MF_OWNERDRAW</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the <b>itemData</b> member of the structure pointed to by the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-measureitem">WM_MEASUREITEM</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-drawitem">WM_DRAWITEM</a> message sent when the menu item is created or its appearance is updated. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_STRING"></a><a id="mf_string"></a><dl>
     * <dt><b>MF_STRING</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a pointer to a null-terminated string (the default). 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-insertmenua
     * @since windows5.0
     */
    static InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem) {
        lpNewItem := lpNewItem is String? StrPtr(lpNewItem) : lpNewItem

        A_LastError := 0

        result := DllCall("USER32.dll\InsertMenuA", "ptr", hMenu, "uint", uPosition, "uint", uFlags, "ptr", uIDNewItem, "ptr", lpNewItem, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Inserts a new menu item into a menu, moving other items down the menu. (Unicode)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window. 
     * 
     * The following groups of flags cannot be used together: 
     * 
     * <ul>
     * <li><b>MF_BYCOMMAND</b> and <b>MF_BYPOSITION</b></li>
     * <li><b>MF_DISABLED</b>, <b>MF_ENABLED</b>, and <b>MF_GRAYED</b></li>
     * <li><b>MF_BITMAP</b>, <b>MF_STRING</b>, <b>MF_OWNERDRAW</b>, and <b>MF_SEPARATOR</b></li>
     * <li><b>MF_MENUBARBREAK</b> and <b>MF_MENUBREAK</b></li>
     * <li><b>MF_CHECKED</b> and <b>MF_UNCHECKED</b></li>
     * </ul>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines InsertMenu as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be changed.
     * @param {Integer} uPosition Type: <b>UINT</b>
     * 
     * The menu item before which the new menu item is to be inserted, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * Controls the interpretation of the <i>uPosition</i> parameter and the content, appearance, and behavior of the new menu item. This parameter must include one of the following required values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYCOMMAND"></a><a id="mf_bycommand"></a><dl>
     * <dt><b>MF_BYCOMMAND</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the identifier of the menu item. The <b>MF_BYCOMMAND</b> flag is the default if neither the <b>MF_BYCOMMAND</b> nor <b>MF_BYPOSITION</b> flag is specified. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYPOSITION"></a><a id="mf_byposition"></a><dl>
     * <dt><b>MF_BYPOSITION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the zero-based relative position of the new menu item. If <i>uPosition</i> is -1, the new menu item is appended to the end of the menu. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} uIDNewItem Type: <b>UINT_PTR</b>
     * 
     * The identifier of the new menu item or, if the <i>uFlags</i> parameter has the <b>MF_POPUP</b> flag set, a handle to the drop-down menu or submenu.
     * @param {Pointer<Char>} lpNewItem Type: <b>LPCTSTR</b>
     * 
     * The content of the new menu item. The interpretation of <i>lpNewItem</i> depends on whether the <i>uFlags</i> parameter includes the <b>MF_BITMAP</b>, <b>MF_OWNERDRAW</b>, or <b>MF_STRING</b> flag, as follows. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BITMAP"></a><a id="mf_bitmap"></a><dl>
     * <dt><b>MF_BITMAP</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a bitmap handle. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_OWNERDRAW"></a><a id="mf_ownerdraw"></a><dl>
     * <dt><b>MF_OWNERDRAW</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the <b>itemData</b> member of the structure pointed to by the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-measureitem">WM_MEASUREITEM</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-drawitem">WM_DRAWITEM</a> message sent when the menu item is created or its appearance is updated. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_STRING"></a><a id="mf_string"></a><dl>
     * <dt><b>MF_STRING</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a pointer to a null-terminated string (the default). 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-insertmenuw
     * @since windows5.0
     */
    static InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem) {
        lpNewItem := lpNewItem is String? StrPtr(lpNewItem) : lpNewItem

        A_LastError := 0

        result := DllCall("USER32.dll\InsertMenuW", "ptr", hMenu, "uint", uPosition, "uint", uFlags, "ptr", uIDNewItem, "ptr", lpNewItem, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to specify the content, appearance, and behavior of the menu item. (ANSI)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window. 
     * 
     * To get keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. For more information, see <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a>.
     * 
     * The following groups of flags cannot be used together:
     * 
     * <ul>
     * <li><b>MF_BITMAP</b>, <b>MF_STRING</b>, and <b>MF_OWNERDRAW</b></li>
     * <li><b>MF_CHECKED</b> and <b>MF_UNCHECKED</b></li>
     * <li><b>MF_DISABLED</b>, <b>MF_ENABLED</b>, and <b>MF_GRAYED</b></li>
     * <li><b>MF_MENUBARBREAK</b> and <b>MF_MENUBREAK</b></li>
     * </ul>
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @param {Pointer} uIDNewItem Type: <b>UINT_PTR</b>
     * 
     * The identifier of the new menu item or, if the <i>uFlags</i> parameter is set to <b>MF_POPUP</b>, a handle to the drop-down menu or submenu.
     * @param {Pointer<Byte>} lpNewItem Type: <b>LPCTSTR</b>
     * 
     * The content of the new menu item. The interpretation of <i>lpNewItem</i> depends on whether the <i>uFlags</i> parameter includes the following values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BITMAP"></a><a id="mf_bitmap"></a><dl>
     * <dt><b>MF_BITMAP</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a bitmap handle. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_OWNERDRAW"></a><a id="mf_ownerdraw"></a><dl>
     * <dt><b>MF_OWNERDRAW</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the <b>itemData</b> member of the structure pointed to by the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-measureitem">WM_MEASUREITEM</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-drawitem">WM_DRAWITEM</a> message sent when the menu is created or its appearance is updated. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_STRING"></a><a id="mf_string"></a><dl>
     * <dt><b>MF_STRING</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a pointer to a null-terminated string. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-appendmenua
     * @since windows5.0
     */
    static AppendMenuA(hMenu, uFlags, uIDNewItem, lpNewItem) {
        lpNewItem := lpNewItem is String? StrPtr(lpNewItem) : lpNewItem

        A_LastError := 0

        result := DllCall("USER32.dll\AppendMenuA", "ptr", hMenu, "uint", uFlags, "ptr", uIDNewItem, "ptr", lpNewItem, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to specify the content, appearance, and behavior of the menu item. (Unicode)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window. 
     * 
     * To get keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. For more information, see <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a>.
     * 
     * The following groups of flags cannot be used together:
     * 
     * <ul>
     * <li><b>MF_BITMAP</b>, <b>MF_STRING</b>, and <b>MF_OWNERDRAW</b></li>
     * <li><b>MF_CHECKED</b> and <b>MF_UNCHECKED</b></li>
     * <li><b>MF_DISABLED</b>, <b>MF_ENABLED</b>, and <b>MF_GRAYED</b></li>
     * <li><b>MF_MENUBARBREAK</b> and <b>MF_MENUBREAK</b></li>
     * </ul>
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @param {Pointer} uIDNewItem Type: <b>UINT_PTR</b>
     * 
     * The identifier of the new menu item or, if the <i>uFlags</i> parameter is set to <b>MF_POPUP</b>, a handle to the drop-down menu or submenu.
     * @param {Pointer<Char>} lpNewItem Type: <b>LPCTSTR</b>
     * 
     * The content of the new menu item. The interpretation of <i>lpNewItem</i> depends on whether the <i>uFlags</i> parameter includes the following values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BITMAP"></a><a id="mf_bitmap"></a><dl>
     * <dt><b>MF_BITMAP</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a bitmap handle. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_OWNERDRAW"></a><a id="mf_ownerdraw"></a><dl>
     * <dt><b>MF_OWNERDRAW</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the <b>itemData</b> member of the structure pointed to by the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-measureitem">WM_MEASUREITEM</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-drawitem">WM_DRAWITEM</a> message sent when the menu is created or its appearance is updated. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_STRING"></a><a id="mf_string"></a><dl>
     * <dt><b>MF_STRING</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Contains a pointer to a null-terminated string. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-appendmenuw
     * @since windows5.0
     */
    static AppendMenuW(hMenu, uFlags, uIDNewItem, lpNewItem) {
        lpNewItem := lpNewItem is String? StrPtr(lpNewItem) : lpNewItem

        A_LastError := 0

        result := DllCall("USER32.dll\AppendMenuW", "ptr", hMenu, "uint", uFlags, "ptr", uIDNewItem, "ptr", lpNewItem, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes an existing menu item. (ANSI)
     * @remarks
     * If <b>ModifyMenu</b> replaces a menu item that opens a drop-down menu or submenu, the function destroys the old drop-down menu or submenu and frees the memory used by it. 
     * 
     * In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. See <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a> for more information.
     * 
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window. To change the attributes of existing menu items, it is much faster to use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-checkmenuitem">CheckMenuItem</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enablemenuitem">EnableMenuItem</a> functions. 
     * 
     * The following groups of flags cannot be used together:
     * 
     * 				
     * 
     * <ul>
     * <li><b>MF_BYCOMMAND</b> and <b>MF_BYPOSITION</b></li>
     * <li><b>MF_DISABLED</b>, <b>MF_ENABLED</b>, and <b>MF_GRAYED</b></li>
     * <li><b>MF_BITMAP</b>, <b>MF_STRING</b>, <b>MF_OWNERDRAW</b>, and <b>MF_SEPARATOR</b></li>
     * <li><b>MF_MENUBARBREAK</b> and <b>MF_MENUBREAK</b></li>
     * <li><b>MF_CHECKED</b> and <b>MF_UNCHECKED</b></li>
     * </ul>
     * @param {Pointer<Void>} hMnu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be changed.
     * @param {Integer} uPosition Type: <b>UINT</b>
     * 
     * The menu item to be changed, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * Controls the interpretation of the <i>uPosition</i> parameter and the content, appearance, and behavior of the menu item. This parameter must include one of the following required values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYCOMMAND"></a><a id="mf_bycommand"></a><dl>
     * <dt><b>MF_BYCOMMAND</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the identifier of the menu item. The <b>MF_BYCOMMAND</b> flag is the default if neither the <b>MF_BYCOMMAND</b> nor <b>MF_BYPOSITION</b> flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYPOSITION"></a><a id="mf_byposition"></a><dl>
     * <dt><b>MF_BYPOSITION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the zero-based relative position of the menu item. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} uIDNewItem Type: <b>UINT_PTR</b>
     * 
     * The identifier of the modified menu item or, if the <i>uFlags</i> parameter has the <b>MF_POPUP</b> flag set, a handle to the drop-down menu or submenu.
     * @param {Pointer<Byte>} lpNewItem Type: <b>LPCTSTR</b>
     * 
     * The contents of the changed menu item. The interpretation of this parameter depends on whether the <i>uFlags</i> parameter includes the <b>MF_BITMAP</b>, <b>MF_OWNERDRAW</b>, or <b>MF_STRING</b> flag. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BITMAP"></a><a id="mf_bitmap"></a><dl>
     * <dt><b>MF_BITMAP</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A bitmap handle. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_OWNERDRAW"></a><a id="mf_ownerdraw"></a><dl>
     * <dt><b>MF_OWNERDRAW</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A value supplied by an application that is used to maintain additional data related to the menu item. The value is in the <b>itemData</b> member of the structure pointed to by the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-measureitem">WM_MEASUREITEM</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-drawitem">WM_DRAWITEM</a> messages sent when the menu item is created or its appearance is updated. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_STRING"></a><a id="mf_string"></a><dl>
     * <dt><b>MF_STRING</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A pointer to a null-terminated string (the default). 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-modifymenua
     * @since windows5.0
     */
    static ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem) {
        lpNewItem := lpNewItem is String? StrPtr(lpNewItem) : lpNewItem

        A_LastError := 0

        result := DllCall("USER32.dll\ModifyMenuA", "ptr", hMnu, "uint", uPosition, "uint", uFlags, "ptr", uIDNewItem, "ptr", lpNewItem, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes an existing menu item. (Unicode)
     * @remarks
     * If <b>ModifyMenu</b> replaces a menu item that opens a drop-down menu or submenu, the function destroys the old drop-down menu or submenu and frees the memory used by it. 
     * 
     * In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. See <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a> for more information.
     * 
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window. To change the attributes of existing menu items, it is much faster to use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-checkmenuitem">CheckMenuItem</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enablemenuitem">EnableMenuItem</a> functions. 
     * 
     * The following groups of flags cannot be used together:
     * 
     * 				
     * 
     * <ul>
     * <li><b>MF_BYCOMMAND</b> and <b>MF_BYPOSITION</b></li>
     * <li><b>MF_DISABLED</b>, <b>MF_ENABLED</b>, and <b>MF_GRAYED</b></li>
     * <li><b>MF_BITMAP</b>, <b>MF_STRING</b>, <b>MF_OWNERDRAW</b>, and <b>MF_SEPARATOR</b></li>
     * <li><b>MF_MENUBARBREAK</b> and <b>MF_MENUBREAK</b></li>
     * <li><b>MF_CHECKED</b> and <b>MF_UNCHECKED</b></li>
     * </ul>
     * @param {Pointer<Void>} hMnu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be changed.
     * @param {Integer} uPosition Type: <b>UINT</b>
     * 
     * The menu item to be changed, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * Controls the interpretation of the <i>uPosition</i> parameter and the content, appearance, and behavior of the menu item. This parameter must include one of the following required values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYCOMMAND"></a><a id="mf_bycommand"></a><dl>
     * <dt><b>MF_BYCOMMAND</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the identifier of the menu item. The <b>MF_BYCOMMAND</b> flag is the default if neither the <b>MF_BYCOMMAND</b> nor <b>MF_BYPOSITION</b> flag is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BYPOSITION"></a><a id="mf_byposition"></a><dl>
     * <dt><b>MF_BYPOSITION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the <i>uPosition</i> parameter gives the zero-based relative position of the menu item. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} uIDNewItem Type: <b>UINT_PTR</b>
     * 
     * The identifier of the modified menu item or, if the <i>uFlags</i> parameter has the <b>MF_POPUP</b> flag set, a handle to the drop-down menu or submenu.
     * @param {Pointer<Char>} lpNewItem Type: <b>LPCTSTR</b>
     * 
     * The contents of the changed menu item. The interpretation of this parameter depends on whether the <i>uFlags</i> parameter includes the <b>MF_BITMAP</b>, <b>MF_OWNERDRAW</b>, or <b>MF_STRING</b> flag. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_BITMAP"></a><a id="mf_bitmap"></a><dl>
     * <dt><b>MF_BITMAP</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A bitmap handle. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_OWNERDRAW"></a><a id="mf_ownerdraw"></a><dl>
     * <dt><b>MF_OWNERDRAW</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A value supplied by an application that is used to maintain additional data related to the menu item. The value is in the <b>itemData</b> member of the structure pointed to by the <i>lParam</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-measureitem">WM_MEASUREITEM</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-drawitem">WM_DRAWITEM</a> messages sent when the menu item is created or its appearance is updated. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="MF_STRING"></a><a id="mf_string"></a><dl>
     * <dt><b>MF_STRING</b></dt>
     * <dt>0x00000000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A pointer to a null-terminated string (the default). 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-modifymenuw
     * @since windows5.0
     */
    static ModifyMenuW(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem) {
        lpNewItem := lpNewItem is String? StrPtr(lpNewItem) : lpNewItem

        A_LastError := 0

        result := DllCall("USER32.dll\ModifyMenuW", "ptr", hMnu, "uint", uPosition, "uint", uFlags, "ptr", uIDNewItem, "ptr", lpNewItem, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes a menu item or detaches a submenu from the specified menu.
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be changed.
     * @param {Integer} uPosition Type: <b>UINT</b>
     * 
     * The menu item to be deleted, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-removemenu
     * @since windows5.0
     */
    static RemoveMenu(hMenu, uPosition, uFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\RemoveMenu", "ptr", hMenu, "uint", uPosition, "uint", uFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an item from the specified menu. If the menu item opens a menu or submenu, this function destroys the handle to the menu or submenu and frees the memory used by the menu or submenu.
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu to be changed.
     * @param {Integer} uPosition Type: <b>UINT</b>
     * 
     * The menu item to be deleted, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-deletemenu
     * @since windows5.0
     */
    static DeleteMenu(hMenu, uPosition, uFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\DeleteMenu", "ptr", hMenu, "uint", uPosition, "uint", uFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates the specified bitmap with a menu item. Whether the menu item is selected or clear, the system displays the appropriate bitmap next to the menu item.
     * @remarks
     * If either the <i>hBitmapUnchecked</i> or 
     * 				<i>hBitmapChecked</i> parameter is <b>NULL</b>, the system displays nothing next to the menu item for the corresponding check state. If both parameters are <b>NULL</b>, the system displays the default check-mark bitmap when the item is selected, and removes the bitmap when the item is not selected. 
     * 
     * When the menu is destroyed, these bitmaps are not destroyed; it is up to the application to destroy them. 
     * 
     * The selected and clear bitmaps should be monochrome. The system uses the Boolean AND operator to combine bitmaps with the menu so that the white part becomes transparent and the black part becomes the menu-item color. If you use color bitmaps, the results may be undesirable.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> function with the <b>SM_CXMENUCHECK</b> and <b>SM_CYMENUCHECK</b> values to retrieve the bitmap dimensions.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu containing the item to receive new check-mark bitmaps.
     * @param {Integer} uPosition Type: <b>UINT</b>
     * 
     * The menu item to be changed, as determined by the <i>uFlags</i> parameter.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * @param {Pointer<Void>} hBitmapUnchecked Type: <b>HBITMAP</b>
     * 
     * A handle to the bitmap displayed when the menu item is not selected.
     * @param {Pointer<Void>} hBitmapChecked Type: <b>HBITMAP</b>
     * 
     * A handle to the bitmap displayed when the menu item is selected.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmenuitembitmaps
     * @since windows5.0
     */
    static SetMenuItemBitmaps(hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetMenuItemBitmaps", "ptr", hMenu, "uint", uPosition, "uint", uFlags, "ptr", hBitmapUnchecked, "ptr", hBitmapChecked, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the dimensions of the default check-mark bitmap.
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * The return value specifies the height and width, in pixels, of the default check-mark bitmap. The high-order word contains the height; the low-order word contains the width.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenucheckmarkdimensions
     * @since windows5.0
     */
    static GetMenuCheckMarkDimensions() {
        result := DllCall("USER32.dll\GetMenuCheckMarkDimensions", "int")
        return result
    }

    /**
     * Displays a shortcut menu at the specified location and tracks the selection of items on the menu. The shortcut menu can appear anywhere on the screen.
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with <b>SM_MENUDROPALIGNMENT</b> to determine the correct horizontal alignment flag (<b>TPM_LEFTALIGN</b> or <b>TPM_RIGHTALIGN</b>) and/or horizontal animation direction flag (<b>TPM_HORPOSANIMATION</b> or <b>TPM_HORNEGANIMATION</b>) to pass to <b>TrackPopupMenu</b> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenuex">TrackPopupMenuEx</a>. This is essential for creating an optimal user experience, especially when developing Microsoft Tablet PC applications.
     * 
     * To specify an area of the screen that the menu should not overlap, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenuex">TrackPopupMenuEx</a> function
     * 
     * To display a context menu for a notification icon, the current window must be the foreground window before the application calls <b>TrackPopupMenu</b> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenuex">TrackPopupMenuEx</a>. Otherwise, the menu will not disappear when the user clicks outside of the menu or the window that created the menu (if it is visible). If the current window is a child window, you must set the (top-level) parent window as the foreground window.
     * 
     * However, when the current window is the foreground window, the second time this menu is displayed, it appears and then immediately disappears. To correct this, you must force a task switch to the application that called <b>TrackPopupMenu</b>. This is done by posting a benign message to the window or thread, as shown in the following code sample:
     * 
     * 
     * 
     * 
     * ```
     * 
     *    SetForegroundWindow(hDlg);
     * 
     *    // Display the menu
     *    TrackPopupMenu(   hSubMenu,
     *                      TPM_RIGHTBUTTON,
     *                      pt.x,
     *                      pt.y,
     *                      0,
     *                      hDlg,
     *                      NULL);
     * 
     *    PostMessage(hDlg, WM_NULL, 0, 0);
     *  
     * ```
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the shortcut menu to be displayed. The handle can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createpopupmenu">CreatePopupMenu</a> to create a new shortcut menu, or by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsubmenu">GetSubMenu</a> to retrieve a handle to a submenu associated with an existing menu item.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * Use zero of more of these flags to specify function options. 
     * 
     * 
     * Use one of the following flags to specify how the function positions the shortcut menu horizontally. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_CENTERALIGN"></a><a id="tpm_centeralign"></a><dl>
     * <dt><b>TPM_CENTERALIGN</b></dt>
     * <dt>0x0004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Centers the shortcut menu horizontally relative to the coordinate specified by the <i>x</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_LEFTALIGN"></a><a id="tpm_leftalign"></a><dl>
     * <dt><b>TPM_LEFTALIGN</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its left side is aligned with the coordinate specified by the <i>x</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_RIGHTALIGN"></a><a id="tpm_rightalign"></a><dl>
     * <dt><b>TPM_RIGHTALIGN</b></dt>
     * <dt>0x0008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its right side is aligned with the coordinate specified by the <i>x</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use one of the following flags to specify how the function positions the shortcut menu vertically.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_BOTTOMALIGN"></a><a id="tpm_bottomalign"></a><dl>
     * <dt><b>TPM_BOTTOMALIGN</b></dt>
     * <dt>0x0020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the <i>y</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_TOPALIGN"></a><a id="tpm_topalign"></a><dl>
     * <dt><b>TPM_TOPALIGN</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its top side is aligned with the coordinate specified by the <i>y</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VCENTERALIGN"></a><a id="tpm_vcenteralign"></a><dl>
     * <dt><b>TPM_VCENTERALIGN</b></dt>
     * <dt>0x0010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Centers the shortcut menu vertically relative to the coordinate specified by the <i>y</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use the following flags to control discovery of the user selection without having to set up a parent window for the menu. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_NONOTIFY"></a><a id="tpm_nonotify"></a><dl>
     * <dt><b>TPM_NONOTIFY</b></dt>
     * <dt>0x0080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function does not send notification messages when the user clicks a menu item.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_RETURNCMD"></a><a id="tpm_returncmd"></a><dl>
     * <dt><b>TPM_RETURNCMD</b></dt>
     * <dt>0x0100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function returns the menu item identifier of the user's selection in the return value.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use one of the following flags to specify which mouse button the shortcut menu tracks. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_LEFTBUTTON"></a><a id="tpm_leftbutton"></a><dl>
     * <dt><b>TPM_LEFTBUTTON</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user can select menu items with only the left mouse button.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_RIGHTBUTTON"></a><a id="tpm_rightbutton"></a><dl>
     * <dt><b>TPM_RIGHTBUTTON</b></dt>
     * <dt>0x0002L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user can select menu items with both the left and right mouse buttons.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal and a vertical flag, you can achieve diagonal animation. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_HORNEGANIMATION"></a><a id="tpm_horneganimation"></a><dl>
     * <dt><b>TPM_HORNEGANIMATION</b></dt>
     * <dt>0x0800L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from right to left.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_HORPOSANIMATION"></a><a id="tpm_horposanimation"></a><dl>
     * <dt><b>TPM_HORPOSANIMATION</b></dt>
     * <dt>0x0400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from left to right.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_NOANIMATION"></a><a id="tpm_noanimation"></a><dl>
     * <dt><b>TPM_NOANIMATION</b></dt>
     * <dt>0x4000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Displays menu without animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VERNEGANIMATION"></a><a id="tpm_verneganimation"></a><dl>
     * <dt><b>TPM_VERNEGANIMATION</b></dt>
     * <dt>0x2000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from bottom to top.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VERPOSANIMATION"></a><a id="tpm_verposanimation"></a><dl>
     * <dt><b>TPM_VERPOSANIMATION</b></dt>
     * <dt>0x1000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from top to bottom.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * For any animation to occur, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> function must set <b>SPI_SETMENUANIMATION</b>. Also, all the TPM_*ANIMATION flags, except <b>TPM_NOANIMATION</b>, are ignored if menu fade animation is on. For more information, see the <b>SPI_GETMENUFADE</b> flag in <b>SystemParametersInfo</b>. 
     * 
     *  Use the <b>TPM_RECURSE</b> flag to display a menu when another menu is already displayed. This is intended to support context menus within a menu. 
     * 
     *  For right-to-left text layout, use <b>TPM_LAYOUTRTL</b>. By default, the text layout is left-to-right.
     * @param {Integer} x Type: <b>int</b>
     * 
     * The horizontal location of the shortcut menu, in screen coordinates.
     * @param {Integer} y Type: <b>int</b>
     * 
     * The vertical location of the shortcut menu, in screen coordinates.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message from the menu until the function returns. If you specify TPM_NONOTIFY in the <i>uFlags</i> parameter, the function does not send messages to the window identified by <i>hWnd</i>. However, you must still pass a window handle in <i>hWnd</i>. It can be any window handle from your application.
     * @param {Pointer<RECT>} prcRect Type: <b>const RECT*</b>
     * 
     * Ignored.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If you specify <b>TPM_RETURNCMD</b> in the <i>uFlags</i> parameter, the return value is the menu-item identifier of the item that the user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.
     * 
     * If you do not specify <b>TPM_RETURNCMD</b> in the <i>uFlags</i> parameter, the return value is nonzero if the function succeeds and zero if it fails. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-trackpopupmenu
     * @since windows5.0
     */
    static TrackPopupMenu(hMenu, uFlags, x, y, hWnd, prcRect) {
        static nReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("USER32.dll\TrackPopupMenu", "ptr", hMenu, "uint", uFlags, "int", x, "int", y, "int", nReserved, "ptr", hWnd, "ptr", prcRect, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Displays a shortcut menu at the specified location and tracks the selection of items on the shortcut menu. The shortcut menu can appear anywhere on the screen.
     * @remarks
     * Call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with <b>SM_MENUDROPALIGNMENT</b> to determine the correct horizontal alignment flag (<b>TPM_LEFTALIGN</b> or <b>TPM_RIGHTALIGN</b>) and/or horizontal animation direction flag (<b>TPM_HORPOSANIMATION</b> or <b>TPM_HORNEGANIMATION</b>) to pass to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenu">TrackPopupMenu</a> or <b>TrackPopupMenuEx</b>. This is essential for creating an optimal user experience, especially when developing Microsoft Tablet PC applications.
     * 
     * To display a context menu for a notification icon, the current window must be the foreground window before the application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenu">TrackPopupMenu</a> or <b>TrackPopupMenuEx</b>. Otherwise, the menu will not disappear when the user clicks outside of the menu or the window that created the menu (if it is visible). If the current window is a child window, you must set the (top-level) parent window as the foreground window.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the shortcut menu to be displayed. This handle can be obtained by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createpopupmenu">CreatePopupMenu</a> function to create a new shortcut menu or by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsubmenu">GetSubMenu</a> function to retrieve a handle to a submenu associated with an existing menu item.
     * @param {Integer} uFlags Type: <b>UINT</b>
     * 
     * Specifies function options. 
     * 
     * 
     * Use one of the following flags to specify how the function positions the shortcut menu horizontally. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_CENTERALIGN"></a><a id="tpm_centeralign"></a><dl>
     * <dt><b>TPM_CENTERALIGN</b></dt>
     * <dt>0x0004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Centers the shortcut menu horizontally relative to the coordinate specified by the <i>x</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_LEFTALIGN"></a><a id="tpm_leftalign"></a><dl>
     * <dt><b>TPM_LEFTALIGN</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its left side is aligned with the coordinate specified by the <i>x</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_RIGHTALIGN"></a><a id="tpm_rightalign"></a><dl>
     * <dt><b>TPM_RIGHTALIGN</b></dt>
     * <dt>0x0008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its right side is aligned with the coordinate specified by the <i>x</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use one of the following flags to specify how the function positions the shortcut menu vertically.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_BOTTOMALIGN"></a><a id="tpm_bottomalign"></a><dl>
     * <dt><b>TPM_BOTTOMALIGN</b></dt>
     * <dt>0x0020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the <i>y</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_TOPALIGN"></a><a id="tpm_topalign"></a><dl>
     * <dt><b>TPM_TOPALIGN</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the shortcut menu so that its top side is aligned with the coordinate specified by the <i>y</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VCENTERALIGN"></a><a id="tpm_vcenteralign"></a><dl>
     * <dt><b>TPM_VCENTERALIGN</b></dt>
     * <dt>0x0010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Centers the shortcut menu vertically relative to the coordinate specified by the <i>y</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use the following flags to control discovery of the user selection without having to set up a parent window for the menu. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_NONOTIFY"></a><a id="tpm_nonotify"></a><dl>
     * <dt><b>TPM_NONOTIFY</b></dt>
     * <dt>0x0080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function does not send notification messages when the user clicks a menu item.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_RETURNCMD"></a><a id="tpm_returncmd"></a><dl>
     * <dt><b>TPM_RETURNCMD</b></dt>
     * <dt>0x0100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function returns the menu item identifier of the user's selection in the return value.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use one of the following flags to specify which mouse button the shortcut menu tracks. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_LEFTBUTTON"></a><a id="tpm_leftbutton"></a><dl>
     * <dt><b>TPM_LEFTBUTTON</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user can select menu items with only the left mouse button.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_RIGHTBUTTON"></a><a id="tpm_rightbutton"></a><dl>
     * <dt><b>TPM_RIGHTBUTTON</b></dt>
     * <dt>0x0002L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user can select menu items with both the left and right mouse buttons.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal and a vertical flag, you can achieve diagonal animation. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_HORNEGANIMATION"></a><a id="tpm_horneganimation"></a><dl>
     * <dt><b>TPM_HORNEGANIMATION</b></dt>
     * <dt>0x0800L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from right to left.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_HORPOSANIMATION"></a><a id="tpm_horposanimation"></a><dl>
     * <dt><b>TPM_HORPOSANIMATION</b></dt>
     * <dt>0x0400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from left to right.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_NOANIMATION"></a><a id="tpm_noanimation"></a><dl>
     * <dt><b>TPM_NOANIMATION</b></dt>
     * <dt>0x4000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Displays menu without animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VERNEGANIMATION"></a><a id="tpm_verneganimation"></a><dl>
     * <dt><b>TPM_VERNEGANIMATION</b></dt>
     * <dt>0x2000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from bottom to top.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VERPOSANIMATION"></a><a id="tpm_verposanimation"></a><dl>
     * <dt><b>TPM_VERPOSANIMATION</b></dt>
     * <dt>0x1000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Animates the menu from top to bottom.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * For any animation to occur, the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> function must set <b>SPI_SETMENUANIMATION</b>. Also, all the <b>TPM_*ANIMATION</b> flags, except <b>TPM_NOANIMATION</b>, are ignored if menu fade animation is on. For more information, see the <b>SPI_GETMENUFADE</b> flag in <b>SystemParametersInfo</b>. 
     * 
     *  Use the <b>TPM_RECURSE</b> flag to display a menu when another menu is already displayed. This is intended to support context menus within a menu. 
     * 
     * Use one of the following flags to specify whether to accommodate horizontal or vertical alignment. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_HORIZONTAL"></a><a id="tpm_horizontal"></a><dl>
     * <dt><b>TPM_HORIZONTAL</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate the requested horizontal alignment before the requested vertical alignment.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VERTICAL"></a><a id="tpm_vertical"></a><dl>
     * <dt><b>TPM_VERTICAL</b></dt>
     * <dt>0x0040L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate the requested vertical alignment before the requested horizontal alignment.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The excluded rectangle is a portion of the screen that the menu should not overlap; it is specified by the <i>lptpm</i> parameter. 
     * 
     *  For right-to-left text layout, use <b>TPM_LAYOUTRTL</b>. By default, the text layout is left-to-right.
     * @param {Integer} x Type: <b>int</b>
     * 
     * The horizontal location of the shortcut menu, in screen coordinates.
     * @param {Integer} y Type: <b>int</b>
     * 
     * The vertical location of the shortcut menu, in screen coordinates.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a> message from the menu until the function returns. If you specify TPM_NONOTIFY in the <i>fuFlags</i> parameter, the function does not send messages to the window identified by <i>hwnd</i>. However, you must still pass a window handle in <i>hwnd</i>. It can be any window handle from your application.
     * @param {Pointer<TPMPARAMS>} lptpm Type: <b>LPTPMPARAMS</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-tpmparams">TPMPARAMS</a> structure that specifies an area of the screen the menu should not overlap. This parameter can be <b>NULL</b>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If you specify <b>TPM_RETURNCMD</b> in the <i>fuFlags</i> parameter, the return value is the menu-item identifier of the item that the user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.
     * 
     * If you do not specify <b>TPM_RETURNCMD</b> in the <i>fuFlags</i> parameter, the return value is nonzero if the function succeeds and zero if it fails. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-trackpopupmenuex
     * @since windows5.0
     */
    static TrackPopupMenuEx(hMenu, uFlags, x, y, hwnd, lptpm) {
        A_LastError := 0

        result := DllCall("USER32.dll\TrackPopupMenuEx", "ptr", hMenu, "uint", uFlags, "int", x, "int", y, "ptr", hwnd, "ptr", lptpm, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Calculates an appropriate pop-up window position using the specified anchor point, pop-up window size, flags, and the optional exclude rectangle.
     * @remarks
     * <b>TPM_WORKAREA</b> is supported for the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenu">TrackPopupMenu</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenuex">TrackPopupMenuEx</a> functions.
     * @param {Pointer<POINT>} anchorPoint Type: <b>const POINT*</b>
     * 
     * The specified anchor point.
     * @param {Pointer<SIZE>} windowSize Type: <b>const SIZE*</b>
     * 
     * The specified window size.
     * @param {Integer} flags Type: <b>UINT</b>
     * 
     * Use one of the following flags to specify how the function positions the pop-up window horizontally and vertically. The flags are the same as the vertical and horizontal positioning flags of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackpopupmenuex">TrackPopupMenuEx</a> function.
     * 
     * 
     * Use one of the following flags to specify how the function positions the pop-up window horizontally. 
     * 					
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_CENTERALIGN"></a><a id="tpm_centeralign"></a><dl>
     * <dt><b>TPM_CENTERALIGN</b></dt>
     * <dt>0x0004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Centers pop-up window horizontally relative to the coordinate specified by the anchorPoint-&gt;x parameter. 
     * 						
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_LEFTALIGN"></a><a id="tpm_leftalign"></a><dl>
     * <dt><b>TPM_LEFTALIGN</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the pop-up window so 
     * 						that its left edge is aligned with the coordinate specified by 
     * 						the anchorPoint-&gt;x parameter. 
     * 						
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_RIGHTALIGN"></a><a id="tpm_rightalign"></a><dl>
     * <dt><b>TPM_RIGHTALIGN</b></dt>
     * <dt>0x0008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the pop-up window so that its right edge is aligned with the coordinate specified by the anchorPoint-&gt;x parameter.
     * 						
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Uses one of the following flags to specify how the function positions the pop-up window vertically. 
     * 					
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_BOTTOMALIGN"></a><a id="tpm_bottomalign"></a><dl>
     * <dt><b>TPM_BOTTOMALIGN</b></dt>
     * <dt>0x0020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the pop-up window so 
     * 					that its bottom edge is aligned with the coordinate specified by 
     * 					the anchorPoint-&gt;y parameter. 
     * 						
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_TOPALIGN"></a><a id="tpm_topalign"></a><dl>
     * <dt><b>TPM_TOPALIGN</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Positions the pop-up window so 
     * 						that its top edge is aligned with the coordinate specified by 
     * 						the anchorPoint-&gt;y parameter. 
     * 						
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VCENTERALIGN"></a><a id="tpm_vcenteralign"></a><dl>
     * <dt><b>TPM_VCENTERALIGN</b></dt>
     * <dt>0x0010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Centers the pop-up window vertically relative to the coordinate specified by the anchorPoint-&gt;y 
     * 						parameter.
     * 						
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * Use one of the following flags to specify whether to accommodate horizontal or vertical alignment. 
     * 					
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_HORIZONTAL"></a><a id="tpm_horizontal"></a><dl>
     * <dt><b>TPM_HORIZONTAL</b></dt>
     * <dt>0x0000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the pop-up window cannot be shown at the specified location without overlapping 
     * 					the excluded rectangle, the system tries to accommodate the requested 
     * 					horizontal alignment before the requested vertical alignment. 
     * 						
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_VERTICAL"></a><a id="tpm_vertical"></a><dl>
     * <dt><b>TPM_VERTICAL</b></dt>
     * <dt>0x0040L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the pop-up window cannot be shown at the specified location without overlapping 
     * 					the excluded rectangle, the system tries to accommodate the requested vertical 
     * 					alignment before the requested horizontal alignment.
     * 						
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * The following flag
     * 					is available starting with Windows 7.
     * 					
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TPM_WORKAREA"></a><a id="tpm_workarea"></a><dl>
     * <dt><b>TPM_WORKAREA</b></dt>
     * <dt>0x10000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Restricts the pop-up window 
     * 						to within the work area. If this flag is not set, 
     * 						the pop-up window is restricted to the work area only if the 
     * 						input point is within the work area. 
     * 						For more information, see the <b>rcWork</b> 
     * 						and <b>rcMonitor</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-monitorinfo">MONITORINFO</a> structure.
     * 						
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<RECT>} excludeRect Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * A pointer to a structure that specifies the exclude rectangle. 
     * 				It can be <b>NULL</b>.
     * @param {Pointer<RECT>} popupWindowPosition Type: <b><a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * A pointer to a structure that specifies the pop-up window position.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b>. 
     * 				To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-calculatepopupwindowposition
     * @since windows6.1
     */
    static CalculatePopupWindowPosition(anchorPoint, windowSize, flags, excludeRect, popupWindowPosition) {
        A_LastError := 0

        result := DllCall("USER32.dll\CalculatePopupWindowPosition", "ptr", anchorPoint, "ptr", windowSize, "uint", flags, "ptr", excludeRect, "ptr", popupWindowPosition, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a specified menu.
     * @param {Pointer<Void>} param0 
     * @param {Pointer<MENUINFO>} param1 
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenuinfo
     * @since windows5.0
     */
    static GetMenuInfo(param0, param1) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMenuInfo", "ptr", param0, "ptr", param1, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets information for a specified menu.
     * @param {Pointer<Void>} param0 
     * @param {Pointer<MENUINFO>} param1 
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmenuinfo
     * @since windows5.0
     */
    static SetMenuInfo(param0, param1) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetMenuInfo", "ptr", param0, "ptr", param1, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Ends the calling thread's active menu.
     * @remarks
     * If a platform does not support <b>EndMenu</b>, send the owner of the active menu a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-cancelmode">WM_CANCELMODE</a> message.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-endmenu
     * @since windows5.0
     */
    static EndMenu() {
        A_LastError := 0

        result := DllCall("USER32.dll\EndMenu", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Inserts a new menu item at the specified position in a menu. (ANSI)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window.
     * 
     * In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. See <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a> for more information.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * A handle to the menu in which the new menu item is inserted.
     * @param {Integer} item Type: <b>UINT</b>
     * 
     * The identifier or position of the menu item before which to insert the new item. The meaning of this parameter depends on the value of <i>fByPosition</i>.
     * @param {Integer} fByPosition Type: <b>BOOL</b>
     * 
     * Controls the meaning of <i>item</i>. If this parameter is <b>FALSE</b>, <i>item</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href="https://docs.microsoft.com/windows/desktop/menurc/about-menus">Accessing Menu Items Programmatically</a> for more information.
     * @param {Pointer<MENUITEMINFOA>} lpmi Type: <b>LPCMENUITEMINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that contains information about the new menu item.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-insertmenuitema
     * @since windows5.0
     */
    static InsertMenuItemA(hmenu, item, fByPosition, lpmi) {
        A_LastError := 0

        result := DllCall("USER32.dll\InsertMenuItemA", "ptr", hmenu, "uint", item, "int", fByPosition, "ptr", lpmi, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Inserts a new menu item at the specified position in a menu. (Unicode)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window.
     * 
     * In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. See <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a> for more information.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * A handle to the menu in which the new menu item is inserted.
     * @param {Integer} item Type: <b>UINT</b>
     * 
     * The identifier or position of the menu item before which to insert the new item. The meaning of this parameter depends on the value of <i>fByPosition</i>.
     * @param {Integer} fByPosition Type: <b>BOOL</b>
     * 
     * Controls the meaning of <i>item</i>. If this parameter is <b>FALSE</b>, <i>item</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href="https://docs.microsoft.com/windows/desktop/menurc/about-menus">Accessing Menu Items Programmatically</a> for more information.
     * @param {Pointer<MENUITEMINFOW>} lpmi Type: <b>LPCMENUITEMINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that contains information about the new menu item.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-insertmenuitemw
     * @since windows5.0
     */
    static InsertMenuItemW(hmenu, item, fByPosition, lpmi) {
        A_LastError := 0

        result := DllCall("USER32.dll\InsertMenuItemW", "ptr", hmenu, "uint", item, "int", fByPosition, "ptr", lpmi, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a menu item. (ANSI)
     * @remarks
     * To retrieve a menu item of type <b>MFT_STRING</b>, first find the size of the string by setting the <b>dwTypeData</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> to <b>NULL</b> and then calling <b>GetMenuItemInfo</b>. The value of <b>cch</b>+1 is the size needed. Then allocate a buffer of this size, place the pointer to the buffer in <b>dwTypeData</b>, increment <b>cch</b> by one, and then call <b>GetMenuItemInfo</b> once again to fill the buffer with the string.
     * 
     * If the retrieved menu item is of some other type, then <b>GetMenuItemInfo</b> sets the <b>dwTypeData</b> member to a value whose type is specified by the <b>fType</b><b>fType</b> member and sets <b>cch</b> to 0.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * A handle to the menu that contains the menu item.
     * @param {Integer} item Type: <b>UINT</b>
     * 
     * The identifier or position of the menu item to get information about. The meaning of this parameter depends on the value of <i>fByPosition</i>.
     * @param {Integer} fByPosition Type: <b>BOOL</b>
     * 
     * The meaning of <i>uItem</i>. If this parameter is <b>FALSE</b>, <i>uItem</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href="https://docs.microsoft.com/windows/desktop/menurc/about-menus">Accessing Menu Items Programmatically</a> for more information.
     * @param {Pointer<MENUITEMINFOA>} lpmii Type: <b>LPMENUITEMINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that specifies the information to retrieve and receives information about the menu item. Note that you must set the <b>cbSize</b> member to <c>sizeof(MENUITEMINFO)</c> before calling this function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenuiteminfoa
     * @since windows5.0
     */
    static GetMenuItemInfoA(hmenu, item, fByPosition, lpmii) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMenuItemInfoA", "ptr", hmenu, "uint", item, "int", fByPosition, "ptr", lpmii, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about a menu item. (Unicode)
     * @remarks
     * To retrieve a menu item of type <b>MFT_STRING</b>, first find the size of the string by setting the <b>dwTypeData</b> member of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> to <b>NULL</b> and then calling <b>GetMenuItemInfo</b>. The value of <b>cch</b>+1 is the size needed. Then allocate a buffer of this size, place the pointer to the buffer in <b>dwTypeData</b>, increment <b>cch</b> by one, and then call <b>GetMenuItemInfo</b> once again to fill the buffer with the string.
     * 
     * If the retrieved menu item is of some other type, then <b>GetMenuItemInfo</b> sets the <b>dwTypeData</b> member to a value whose type is specified by the <b>fType</b><b>fType</b> member and sets <b>cch</b> to 0.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * A handle to the menu that contains the menu item.
     * @param {Integer} item Type: <b>UINT</b>
     * 
     * The identifier or position of the menu item to get information about. The meaning of this parameter depends on the value of <i>fByPosition</i>.
     * @param {Integer} fByPosition Type: <b>BOOL</b>
     * 
     * The meaning of <i>uItem</i>. If this parameter is <b>FALSE</b>, <i>uItem</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href="https://docs.microsoft.com/windows/desktop/menurc/about-menus">Accessing Menu Items Programmatically</a> for more information.
     * @param {Pointer<MENUITEMINFOW>} lpmii Type: <b>LPMENUITEMINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that specifies the information to retrieve and receives information about the menu item. Note that you must set the <b>cbSize</b> member to <c>sizeof(MENUITEMINFO)</c> before calling this function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenuiteminfow
     * @since windows5.0
     */
    static GetMenuItemInfoW(hmenu, item, fByPosition, lpmii) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMenuItemInfoW", "ptr", hmenu, "uint", item, "int", fByPosition, "ptr", lpmii, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes information about a menu item. (ANSI)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window.
     * 
     * In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. See <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a> for more information.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * A handle to the menu that contains the menu item.
     * @param {Integer} item Type: <b>UINT</b>
     * 
     * The identifier or position of the menu item to change. The meaning of this parameter depends on the value of <i>fByPosition</i>.
     * @param {Integer} fByPositon 
     * @param {Pointer<MENUITEMINFOA>} lpmii Type: <b>LPMENUITEMINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that contains information about the menu item and specifies which menu item attributes to change.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmenuiteminfoa
     * @since windows5.0
     */
    static SetMenuItemInfoA(hmenu, item, fByPositon, lpmii) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetMenuItemInfoA", "ptr", hmenu, "uint", item, "int", fByPositon, "ptr", lpmii, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes information about a menu item. (Unicode)
     * @remarks
     * The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawmenubar">DrawMenuBar</a> function whenever a menu changes, whether the menu is in a displayed window.
     * 
     * In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a> message. See <a href="https://docs.microsoft.com/windows/desktop/menurc/using-menus">Owner-Drawn Menus and the WM_MENUCHAR Message</a> for more information.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * A handle to the menu that contains the menu item.
     * @param {Integer} item Type: <b>UINT</b>
     * 
     * The identifier or position of the menu item to change. The meaning of this parameter depends on the value of <i>fByPosition</i>.
     * @param {Integer} fByPositon 
     * @param {Pointer<MENUITEMINFOW>} lpmii Type: <b>LPMENUITEMINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure that contains information about the menu item and specifies which menu item attributes to change.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmenuiteminfow
     * @since windows5.0
     */
    static SetMenuItemInfoW(hmenu, item, fByPositon, lpmii) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetMenuItemInfoW", "ptr", hmenu, "uint", item, "int", fByPositon, "ptr", lpmii, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines the default menu item on the specified menu.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu for which to retrieve the default menu item.
     * @param {Integer} fByPos Type: <b>UINT</b>
     * 
     * Indicates whether to retrieve the menu item's identifier or its position. If this parameter is <b>FALSE</b>, the identifier is returned. Otherwise, the position is returned.
     * @param {Integer} gmdiFlags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the return value is the identifier or position of the menu item.
     * 
     * If the function fails, the return value is -1. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenudefaultitem
     * @since windows5.0
     */
    static GetMenuDefaultItem(hMenu, fByPos, gmdiFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMenuDefaultItem", "ptr", hMenu, "uint", fByPos, "uint", gmdiFlags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the default menu item for the specified menu.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu to set the default item for.
     * @param {Integer} uItem Type: <b>UINT</b>
     * 
     * The identifier or position of the new default menu item or -1 for no default item. The meaning of this parameter depends on the value of 
     * 					<i>fByPos</i>.
     * @param {Integer} fByPos Type: <b>UINT</b>
     * 
     * The meaning of <i>uItem</i>. If this parameter is <b>FALSE</b>, <i>uItem</i> is a menu item identifier. Otherwise, it is a menu item position. See <a href="https://docs.microsoft.com/windows/desktop/menurc/about-menus">About Menus</a> for more information.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setmenudefaultitem
     * @since windows5.0
     */
    static SetMenuDefaultItem(hMenu, uItem, fByPos) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetMenuDefaultItem", "ptr", hMenu, "uint", uItem, "uint", fByPos, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the bounding rectangle for the specified menu item.
     * @remarks
     * In order for the returned rectangle to be meaningful, the menu must be popped 
     * 		up if a popup menu or attached to a window if a menu bar. Menu item positions are not 
     * 		determined until the menu is displayed.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window containing the menu.
     * 
     * If this value is <b>NULL</b> and the <i>hMenu</i> 
     * 						parameter represents a popup menu, the function will find the menu window.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to a menu.
     * @param {Integer} uItem Type: <b>UINT</b>
     * 
     * The zero-based position of the menu item.
     * @param {Pointer<RECT>} lprcItem Type: <b>LPRECT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the 
     * 				bounding rectangle of the specified menu item expressed in screen coordinates.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error 
     * 					information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenuitemrect
     * @since windows5.0
     */
    static GetMenuItemRect(hWnd, hMenu, uItem, lprcItem) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMenuItemRect", "ptr", hWnd, "ptr", hMenu, "uint", uItem, "ptr", lprcItem, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines which menu item, if any, is at the specified location.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window containing the menu. If this value is <b>NULL</b> and the <i>hMenu</i> parameter represents a popup menu, the function will find the menu window.
     * @param {Pointer<Void>} hMenu Type: <b>HMENU</b>
     * 
     * A handle to the menu containing the menu items to hit test.
     * @param {Pointer} ptScreen Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * A structure that specifies the location to test. If <i>hMenu</i> specifies a menu bar, this parameter is in window coordinates. Otherwise, it is in client coordinates.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * Returns the zero-based position of the menu item at the specified location or -1 if no menu item is at the specified location.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-menuitemfrompoint
     * @since windows5.0
     */
    static MenuItemFromPoint(hWnd, hMenu, ptScreen) {
        result := DllCall("USER32.dll\MenuItemFromPoint", "ptr", hWnd, "ptr", hMenu, "ptr", ptScreen)
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} hwndParent 
     * @param {Pointer<Void>} hwndFrom 
     * @param {Integer} fmt 
     * @param {Pointer} data 
     * @param {Pointer<Void>} hcur 
     * @returns {Integer} 
     */
    static DragObject(hwndParent, hwndFrom, fmt, data, hcur) {
        result := DllCall("USER32.dll\DragObject", "ptr", hwndParent, "ptr", hwndFrom, "uint", fmt, "ptr", data, "ptr", hcur, "uint")
        return result
    }

    /**
     * Draws an icon or cursor into the specified device context.
     * @remarks
     * <b>DrawIcon</b> places the icon's upper-left corner at the location specified by the <i>X</i> and <i>Y</i> parameters. The location is subject to the current mapping mode of the device context. 
     * 
     * <b>DrawIcon</b> draws the icon or cursor using the width and height specified by the system metric values for icons; for more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a>.
     * @param {Pointer<Void>} hDC Type: <b>HDC</b>
     * 
     * A handle to the device context into which the icon or cursor will be drawn.
     * @param {Integer} X Type: <b>int</b>
     * 
     * The logical x-coordinate of the upper-left corner of the icon.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The logical y-coordinate of the upper-left corner of the icon.
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * 
     * A handle to the icon to be drawn.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawicon
     * @since windows5.0
     */
    static DrawIcon(hDC, X, Y, hIcon) {
        A_LastError := 0

        result := DllCall("USER32.dll\DrawIcon", "ptr", hDC, "int", X, "int", Y, "ptr", hIcon, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is a handle to the foreground window. The foreground window can be <b>NULL</b> in certain circumstances, such as when a window is losing activation.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getforegroundwindow
     * @since windows5.0
     */
    static GetForegroundWindow() {
        result := DllCall("USER32.dll\GetForegroundWindow")
        return result
    }

    /**
     * Switches focus to the specified window and brings it to the foreground.
     * @remarks
     * This function is typically called to maintain window z-ordering. 
     * 
     * This function was not included in the SDK headers and libraries until WindowsXP with Service Pack1 (SP1) and Windows Server2003. If you do not have a header file and import library for this function, you can call the function using <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Integer} fUnknown Type: <b>BOOL</b>
     * 
     * A <b>TRUE</b> for this parameter indicates that the window
     * 				is being switched to using the Alt/Ctl+Tab key sequence.  This parameter
     * 				should be <b>FALSE</b> otherwise.
     * @returns {Pointer} 
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-switchtothiswindow
     * @since windows5.0
     */
    static SwitchToThisWindow(hwnd, fUnknown) {
        result := DllCall("USER32.dll\SwitchToThisWindow", "ptr", hwnd, "int", fUnknown)
        return result
    }

    /**
     * Brings the thread that created the specified window into the foreground and activates the window.
     * @remarks
     * The system restricts which processes can set the foreground window. A process can set the foreground window by calling **SetForegroundWindow** only if:
     * 
     * - All of the following conditions are true:
     *   - The calling process belongs to a desktop application, not a UWP app or a Windows Store app designed for Windows 8 or 8.1.
     *   - The foreground process has not disabled calls to **SetForegroundWindow** by a previous call to the [**LockSetForegroundWindow**](nf-winuser-locksetforegroundwindow.md) function.
     *   - The foreground lock time-out has expired (see [**SPI_GETFOREGROUNDLOCKTIMEOUT** in **SystemParametersInfo**](nf-winuser-systemparametersinfoa.md#SPI_GETFOREGROUNDLOCKTIMEOUT)).
     *   - No menus are active.
     * - Additionally, at least one of the following conditions is true:
     *   - The calling process is the foreground process.
     *   - The calling process was started by the foreground process.
     *   - There is currently no foreground window, and thus no foreground process.
     *   - The calling process received the last input event.
     *   - Either the foreground process or the calling process is being debugged.
     * 
     * It is possible for a process to be denied the right to set the foreground window even if it meets these conditions.
     * 
     * An application cannot force a window to the foreground while the user is working with another window. Instead, Windows flashes the taskbar button of the window to notify the user.
     * 
     * A process that can set the foreground window can enable another process to set the foreground window by calling the [**AllowSetForegroundWindow**](nf-winuser-allowsetforegroundwindow.md) function. The process specified by the *dwProcessId* parameter to **AllowSetForegroundWindow** loses the ability to set the foreground window the next time that either the user generates input, unless the input is directed at that process, or the next time a process calls **AllowSetForegroundWindow**, unless the same process is specified as in the previous call to **AllowSetForegroundWindow**.
     * 
     * The foreground process can disable calls to <b>SetForegroundWindow</b> by calling the [**LockSetForegroundWindow**](nf-winuser-locksetforegroundwindow.md) function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that should be activated and brought to the foreground.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the window was brought to the foreground, the return value is nonzero.
     * 
     * If the window was not brought to the foreground, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setforegroundwindow
     * @since windows5.0
     */
    static SetForegroundWindow(hWnd) {
        result := DllCall("USER32.dll\SetForegroundWindow", "ptr", hWnd, "int")
        return result
    }

    /**
     * Enables the specified process to set the foreground window using the SetForegroundWindow function. The calling process must already be able to set the foreground window. For more information, see Remarks later in this topic.
     * @remarks
     * The system restricts which processes can set the foreground window. Normally, a process can set the foreground window by calling the [**SetForegroundWindow**](nf-winuser-setforegroundwindow.md) function only if:
     * 
     * - All of the following conditions are true:
     *   - The calling process belongs to a desktop application, not a UWP app or a Windows Store app designed for Windows 8 or 8.1.
     *   - The foreground process has not disabled calls to **SetForegroundWindow** by a previous call to the [**LockSetForegroundWindow**](nf-winuser-locksetforegroundwindow.md) function.
     *   - The foreground lock time-out has expired (see [**SPI_GETFOREGROUNDLOCKTIMEOUT** in **SystemParametersInfo**](nf-winuser-systemparametersinfoa.md#SPI_GETFOREGROUNDLOCKTIMEOUT)).
     *   - No menus are active.
     * - Additionally, at least one of the following conditions is true:
     *   - The calling process is the foreground process.
     *   - The calling process was started by the foreground process.
     *   - There is currently no foreground window, and thus no foreground process.
     *   - The calling process received the last input event.
     *   - Either the foreground process or the calling process is being debugged.
     * 
     * A process that can set the foreground window can enable another process to set the foreground window
     * by calling **AllowSetForegroundWindow**. The process specified by the *dwProcessId* parameter
     * loses the ability to set the foreground window the next time that either the user generates input,
     * unless the input is directed at that process, or the next time a process calls
     * **AllowSetForegroundWindow**, unless the same process is specified as in the previous call to
     * **AllowSetForegroundWindow**.
     * @param {Integer} dwProcessId Type: <b>DWORD</b>
     * 
     * The identifier of the process that will be enabled to set the foreground window. If this parameter is <b>ASFW_ANY</b>, all processes will be enabled to set the foreground window.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. The function will fail if the calling process cannot set the foreground window. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-allowsetforegroundwindow
     * @since windows5.0
     */
    static AllowSetForegroundWindow(dwProcessId) {
        A_LastError := 0

        result := DllCall("USER32.dll\AllowSetForegroundWindow", "uint", dwProcessId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The foreground process can call the LockSetForegroundWindow function to disable calls to the SetForegroundWindow function.
     * @remarks
     * The system automatically enables calls to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> if the user presses the ALT key or takes some action that causes the system itself to change the foreground window (for example, clicking a background window).
     * 
     * This function is provided so applications can prevent other applications from making a foreground change that can interrupt its interaction with the user.
     * @param {Integer} uLockCode Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow
     * @since windows5.0
     */
    static LockSetForegroundWindow(uLockCode) {
        A_LastError := 0

        result := DllCall("USER32.dll\LockSetForegroundWindow", "uint", uLockCode, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ScrollWindow function scrolls the contents of the specified window's client area.
     * @remarks
     * If the caret is in the window being scrolled, <b>ScrollWindow</b> automatically hides the caret to prevent it from being erased and then restores the caret after the scrolling is finished. The caret position is adjusted accordingly. 
     * 
     * The area uncovered by <b>ScrollWindow</b> is not repainted, but it is combined into the window's update region. The application eventually receives a <a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> message notifying it that the region must be repainted. To repaint the uncovered area at the same time the scrolling is in action, call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-updatewindow">UpdateWindow</a> function immediately after calling <b>ScrollWindow</b>. 
     * 
     * If the 
     * 				<i>lpRect</i> parameter is <b>NULL</b>, the positions of any child windows in the window are offset by the amount specified by the 
     * 				<i>XAmount</i> and 
     * 				<i>YAmount</i> parameters; invalid (unpainted) areas in the window are also offset. <b>ScrollWindow</b> is faster when 
     * 				<i>lpRect</i> is <b>NULL</b>. 
     * 
     * If 
     * 				<i>lpRect</i> is not <b>NULL</b>, the positions of child windows are not changed and invalid areas in the window are not offset. To prevent updating problems when 
     * 				<i>lpRect</i> is not <b>NULL</b>, call 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-updatewindow">UpdateWindow</a> to repaint the window before calling <b>ScrollWindow</b>.
     * @param {Pointer<Void>} hWnd Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b>
     * 
     * Handle to the window where the client area is to be scrolled.
     * @param {Integer} XAmount Type: <b>int</b>
     * 
     * Specifies the amount, in device units, of horizontal scrolling. If the window being scrolled has the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_OWNDC</a> or <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_CLASSDC</a> style, then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the content of the window to the left.
     * @param {Integer} YAmount Type: <b>int</b>
     * 
     * Specifies the amount, in device units, of vertical scrolling. If the window being scrolled has the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_OWNDC</a> or <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_CLASSDC</a> style, then this parameter uses logical units rather than device units. This parameter must be a negative value to scroll the content of the window up.
     * @param {Pointer<RECT>} lpRect Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure specifying the portion of the client area to be scrolled. If this parameter is <b>NULL</b>, the entire client area is scrolled.
     * @param {Pointer<RECT>} lpClipRect Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to the 
     * 					<a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-scrollwindow
     * @since windows6.0.6000
     */
    static ScrollWindow(hWnd, XAmount, YAmount, lpRect, lpClipRect) {
        A_LastError := 0

        result := DllCall("USER32.dll\ScrollWindow", "ptr", hWnd, "int", XAmount, "int", YAmount, "ptr", lpRect, "ptr", lpClipRect, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ScrollDC function scrolls a rectangle of bits horizontally and vertically.
     * @remarks
     * If the 
     * 				<i>lprcUpdate</i> parameter is <b>NULL</b>, the system does not compute the update rectangle. If both the 
     * 				<i>hrgnUpdate</i> and 
     * 				<i>lprcUpdate</i> parameters are <b>NULL</b>, the system does not compute the update region. If 
     * 				<i>hrgnUpdate</i> is not <b>NULL</b>, the system proceeds as though it contains a valid handle to the region uncovered by the scrolling process (defined by <b>ScrollDC</b>). 
     * 
     * When you must scroll the entire client area of a window, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-scrollwindowex">ScrollWindowEx</a> function.
     * @param {Pointer<Void>} hDC Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HDC</a></b>
     * 
     * Handle to the device context that contains the bits to be scrolled.
     * @param {Integer} dx Type: <b>int</b>
     * 
     * Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.
     * @param {Integer} dy Type: <b>int</b>
     * 
     * Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.
     * @param {Pointer<RECT>} lprcScroll Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the coordinates of the bits to be scrolled. The only bits affected by the scroll operation are bits in the intersection of this rectangle and the rectangle specified by 
     * 					<i>lprcClip</i>. If 
     * 					<i>lprcScroll</i> is <b>NULL</b>, the entire client area is used.
     * @param {Pointer<RECT>} lprcClip Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to a 
     * 					<a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure containing the coordinates of the clipping rectangle. The only bits that will be painted are the bits that remain inside this rectangle after the scroll operation has been completed. If 
     * 					<i>lprcClip</i> is <b>NULL</b>, the entire client area is used.
     * @param {Pointer<Void>} hrgnUpdate Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HRGN</a></b>
     * 
     * Handle to the region uncovered by the scrolling process. <b>ScrollDC</b> defines this region; it is not necessarily a rectangle.
     * @param {Pointer<RECT>} lprcUpdate Type: <b>LPRECT</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the coordinates of the rectangle bounding the scrolling update region. This is the largest rectangular area that requires repainting. When the function returns, the values in the structure are in client coordinates, regardless of the mapping mode for the specified device context. This allows applications to use the update region in a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-invalidatergn">InvalidateRgn</a> function, if required.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-scrolldc
     * @since windows6.0.6000
     */
    static ScrollDC(hDC, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate) {
        A_LastError := 0

        result := DllCall("USER32.dll\ScrollDC", "ptr", hDC, "int", dx, "int", dy, "ptr", lprcScroll, "ptr", lprcClip, "ptr", hrgnUpdate, "ptr", lprcUpdate, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ScrollWindowEx function scrolls the contents of the specified window's client area.
     * @remarks
     * If the SW_INVALIDATE and SW_ERASE flags are not specified, <b>ScrollWindowEx</b> does not invalidate the area that is scrolled from. If either of these flags is set, <b>ScrollWindowEx</b> invalidates this area. The area is not updated until the application calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-updatewindow">UpdateWindow</a> function, calls the  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-redrawwindow">RedrawWindow</a> function (specifying the RDW_UPDATENOW or RDW_ERASENOW flag), or retrieves the 
     * 				<a href="https://docs.microsoft.com/windows/desktop/gdi/wm-paint">WM_PAINT</a> message from the application queue. 
     * 
     * If the window has the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">WS_CLIPCHILDREN</a> style, the returned areas specified by 
     * 				<i>hrgnUpdate</i> and 
     * 				<i>prcUpdate</i> represent the total area of the scrolled window that must be updated, including any areas in child windows that need updating. 
     * 
     * If the SW_SCROLLCHILDREN flag is specified, the system does not properly update the screen if part of a child window is scrolled. The part of the scrolled child window that lies outside the source rectangle is not erased and is not properly redrawn in its new destination. To move child windows that do not lie completely within the rectangle specified by 
     * 				<i>prcScroll</i>, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-deferwindowpos">DeferWindowPos</a> function. The cursor is repositioned if the SW_SCROLLCHILDREN flag is set and the caret rectangle intersects the scroll rectangle. 
     * 
     * All input and output coordinates (for 
     * 				<i>prcScroll</i>, 
     * 				<i>prcClip</i>, 
     * 				<i>prcUpdate</i>, and 
     * 				<i>hrgnUpdate</i>) are determined as client coordinates, regardless of whether the window has the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_OWNDC</a> or <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-class-styles">CS_CLASSDC</a> class style. Use the 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-lptodp">LPtoDP</a> and 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-dptolp">DPtoLP</a> functions to convert to and from logical coordinates, if necessary.
     * @param {Pointer<Void>} hWnd Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b>
     * 
     * Handle to the window where the client area is to be scrolled.
     * @param {Integer} dx Type: <b>int</b>
     * 
     * Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.
     * @param {Integer} dy Type: <b>int</b>
     * 
     * Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.
     * @param {Pointer<RECT>} prcScroll Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the portion of the client area to be scrolled. If this parameter is <b>NULL</b>, the entire client area is scrolled.
     * @param {Pointer<RECT>} prcClip Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * Pointer to a 
     * 					<a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted. This parameter may be <b>NULL</b>.
     * @param {Pointer<Void>} hrgnUpdate Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HRGN</a></b>
     * 
     * Handle to the region that is modified to hold the region invalidated by scrolling. This parameter may be <b>NULL</b>.
     * @param {Pointer<RECT>} prcUpdate Type: <b>LPRECT</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the boundaries of the rectangle invalidated by scrolling. This parameter may be <b>NULL</b>.
     * @param {Integer} flags Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">UINT</a></b>
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is SIMPLEREGION (rectangular invalidated region), COMPLEXREGION (nonrectangular invalidated region; overlapping rectangles), or NULLREGION (no invalidated region). 
     * 
     * If the function fails, the return value is ERROR. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-scrollwindowex
     * @since windows6.0.6000
     */
    static ScrollWindowEx(hWnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags) {
        A_LastError := 0

        result := DllCall("USER32.dll\ScrollWindowEx", "ptr", hWnd, "int", dx, "int", dy, "ptr", prcScroll, "ptr", prcClip, "ptr", hrgnUpdate, "ptr", prcUpdate, "uint", flags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetScrollPos function retrieves the current position of the scroll box (thumb) in the specified scroll bar.
     * @remarks
     * The <b>GetScrollPos</b> function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll bar position, <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-hscroll">WM_HSCROLL</a> and <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-vscroll">WM_VSCROLL</a>, are limited to 16 bits of position data, the functions <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setscrollpos">SetScrollPos</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setscrollrange">SetScrollRange</a>, <b>GetScrollPos</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getscrollrange">GetScrollRange</a> support 32-bit scroll bar position data. Thus, an application can call <b>GetScrollPos</b> while processing either the <b>WM_HSCROLL</b> or <b>WM_VSCROLL</b> messages to obtain 32-bit scroll bar position data. 
     * 
     * To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-hscroll">WM_HSCROLL</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-vscroll">WM_VSCROLL</a> message, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getscrollinfo">GetScrollInfo</a> function.
     * 
     * If the <i>nBar</i> parameter is SB_CTL and the window specified by the <i>hWnd</i> parameter is not a system scroll bar control, the system sends the <a href="https://docs.microsoft.com/windows/desktop/Controls/sbm-getpos">SBM_GETPOS</a> message to the window to obtain scroll bar information.  This allows <b>GetScrollPos</b> to operate on a custom control that mimics a scroll bar.  If the window does not handle the <b>SBM_GETPOS</b> message, the <b>GetScrollPos</b> function fails.
     * @param {Pointer<Void>} hWnd Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b>
     * 
     * Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the 
     * 					<i>nBar</i> parameter.
     * @param {Integer} nBar Type: <b>int</b>
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the current position of the scroll box.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getscrollpos
     * @since windows6.0.6000
     */
    static GetScrollPos(hWnd, nBar) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetScrollPos", "ptr", hWnd, "int", nBar)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetScrollRange function retrieves the current minimum and maximum scroll box (thumb) positions for the specified scroll bar.
     * @remarks
     * If the specified window does not have standard scroll bars or is not a scroll bar control, the <b>GetScrollRange</b> function copies zero to the 
     * 				<i>lpMinPos</i> and 
     * 				<i>lpMaxPos</i> parameters. 
     * 
     * The default range for a standard scroll bar is 0 through 100. The default range for a scroll bar control is empty (both values are zero). 
     * 
     * The messages that indicate scroll bar position, <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-hscroll">WM_HSCROLL</a> and <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-vscroll">WM_VSCROLL</a>, are limited to 16 bits of position data. However, because <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setscrollinfo">SetScrollInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setscrollpos">SetScrollPos</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setscrollrange">SetScrollRange</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getscrollinfo">GetScrollInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getscrollpos">GetScrollPos</a>, and <b>GetScrollRange</b> support 32-bit scroll bar position data, there is a way to circumvent the 16-bit barrier of the <b>WM_HSCROLL</b> and <b>WM_VSCROLL</b> messages. See the <b>GetScrollInfo</b> function for a description of the technique. 
     * 
     * If the <i>nBar</i> parameter is SB_CTL and the window specified by the <i>hWnd</i> parameter is not a system scroll bar control, the system sends the <a href="https://docs.microsoft.com/windows/desktop/Controls/sbm-getrange">SBM_GETRANGE</a> message to the window to obtain scroll bar information.  This allows <b>GetScrollRange</b> to operate on a custom control that mimics a scroll bar.  If the window does not handle the <b>SBM_GETRANGE</b> message, the <b>GetScrollRange</b> function fails.
     * @param {Pointer<Void>} hWnd Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b>
     * 
     * Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the 
     * 					<i>nBar</i> parameter.
     * @param {Integer} nBar Type: <b>int</b>
     * @param {Pointer<Int32>} lpMinPos Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPINT</a></b>
     * 
     * Pointer to the integer variable that receives the minimum position.
     * @param {Pointer<Int32>} lpMaxPos Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LPINT</a></b>
     * 
     * Pointer to the integer variable that receives the maximum position.
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getscrollrange
     * @since windows6.0.6000
     */
    static GetScrollRange(hWnd, nBar, lpMinPos, lpMaxPos) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetScrollRange", "ptr", hWnd, "int", nBar, "int*", lpMinPos, "int*", lpMaxPos, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a new entry or changes an existing entry in the property list of the specified window. (ANSI)
     * @remarks
     * Before a window is destroyed (that is, before it returns from processing the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-ncdestroy">WM_NCDESTROY</a> message), an application must remove all entries it has added to the property list. The application must use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-removepropa">RemoveProp</a> function to remove the entries. 
     * 
     * <b>SetProp</b> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 5.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list receives the new entry.
     * @param {Pointer<Byte>} lpString Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string or an atom that identifies a string. If this parameter is an atom, it must be a global atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom must be placed in the low-order word of <i>lpString</i>; the high-order word must be zero.
     * @param {Pointer<Void>} hData Type: <b>HANDLE</b>
     * 
     * A handle to the data to be copied to the property list. The data handle can identify any value useful to the application.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the data handle and string are added to the property list, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setpropa
     * @since windows5.0
     */
    static SetPropA(hWnd, lpString, hData) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\SetPropA", "ptr", hWnd, "ptr", lpString, "ptr", hData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a new entry or changes an existing entry in the property list of the specified window. (Unicode)
     * @remarks
     * Before a window is destroyed (that is, before it returns from processing the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-ncdestroy">WM_NCDESTROY</a> message), an application must remove all entries it has added to the property list. The application must use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-removepropa">RemoveProp</a> function to remove the entries. 
     * 
     * <b>SetProp</b> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 5.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list receives the new entry.
     * @param {Pointer<Char>} lpString Type: <b>LPCTSTR</b>
     * 
     * A null-terminated string or an atom that identifies a string. If this parameter is an atom, it must be a global atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom must be placed in the low-order word of <i>lpString</i>; the high-order word must be zero.
     * @param {Pointer<Void>} hData Type: <b>HANDLE</b>
     * 
     * A handle to the data to be copied to the property list. The data handle can identify any value useful to the application.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the data handle and string are added to the property list, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setpropw
     * @since windows5.0
     */
    static SetPropW(hWnd, lpString, hData) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\SetPropW", "ptr", hWnd, "ptr", lpString, "ptr", hData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a data handle from the property list of the specified window. The character string identifies the handle to be retrieved. The string and handle must have been added to the property list by a previous call to the SetProp function. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetProp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be searched.
     * @param {Pointer<Byte>} lpString Type: <b>LPCTSTR</b>
     * 
     * An atom that identifies a string. If this parameter is an atom, it must have been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom, a 16-bit value, must be placed in the low-order word of the <i>lpString</i> parameter; the high-order word must be zero.
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * If the property list contains the string, the return value is the associated data handle. Otherwise, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getpropa
     * @since windows5.0
     */
    static GetPropA(hWnd, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        result := DllCall("USER32.dll\GetPropA", "ptr", hWnd, "ptr", lpString)
        return result
    }

    /**
     * Retrieves a data handle from the property list of the specified window. The character string identifies the handle to be retrieved. The string and handle must have been added to the property list by a previous call to the SetProp function. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetProp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be searched.
     * @param {Pointer<Char>} lpString Type: <b>LPCTSTR</b>
     * 
     * An atom that identifies a string. If this parameter is an atom, it must have been created by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom, a 16-bit value, must be placed in the low-order word of the <i>lpString</i> parameter; the high-order word must be zero.
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * If the property list contains the string, the return value is the associated data handle. Otherwise, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getpropw
     * @since windows5.0
     */
    static GetPropW(hWnd, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        result := DllCall("USER32.dll\GetPropW", "ptr", hWnd, "ptr", lpString)
        return result
    }

    /**
     * Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed. (ANSI)
     * @remarks
     * The return value is the <i>hData</i> value that was passed to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setpropa">SetProp</a>; it is an application-defined value. Note, this function only destroys the association between the data and the window. If appropriate, the application must free the data handles associated with entries removed from a property list. The application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.
     * 
     * The <b>RemoveProp</b> function returns the data handle associated with the string so that the application can free the data associated with the handle.
     * 
     * Starting with Windows Vista, <b>RemoveProp</b> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>5</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be changed.
     * @param {Pointer<Byte>} lpString Type: <b>LPCTSTR</b>
     * 
     * A null-terminated character string or an atom that identifies a string. If this parameter is an atom, it must have been created using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom, a 16-bit value, must be placed in the low-order word of <i>lpString</i>; the high-order word must be zero.
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * The return value identifies the specified data. If the data cannot be found in the specified property list, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-removepropa
     * @since windows5.0
     */
    static RemovePropA(hWnd, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\RemovePropA", "ptr", hWnd, "ptr", lpString)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed. (Unicode)
     * @remarks
     * The return value is the <i>hData</i> value that was passed to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setpropa">SetProp</a>; it is an application-defined value. Note, this function only destroys the association between the data and the window. If appropriate, the application must free the data handles associated with entries removed from a property list. The application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.
     * 
     * The <b>RemoveProp</b> function returns the data handle associated with the string so that the application can free the data associated with the handle.
     * 
     * Starting with Windows Vista, <b>RemoveProp</b> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return <b>5</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be changed.
     * @param {Pointer<Char>} lpString Type: <b>LPCTSTR</b>
     * 
     * A null-terminated character string or an atom that identifies a string. If this parameter is an atom, it must have been created using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-globaladdatoma">GlobalAddAtom</a> function. The atom, a 16-bit value, must be placed in the low-order word of <i>lpString</i>; the high-order word must be zero.
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * The return value identifies the specified data. If the data cannot be found in the specified property list, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-removepropw
     * @since windows5.0
     */
    static RemovePropW(hWnd, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\RemovePropW", "ptr", hWnd, "ptr", lpString)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumPropsEx continues until the last entry is enumerated or the callback function returns FALSE. (ANSI)
     * @remarks
     * An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be enumerated.
     * @param {Pointer<PROPENUMPROCEXA>} lpEnumFunc Type: <b>PROPENUMPROCEX</b>
     * 
     * A pointer to the callback function. For more information about the callback function, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-propenumprocexa">PropEnumProcEx</a> function.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Application-defined data to be passed to the callback function.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumpropsexa
     * @since windows5.0
     */
    static EnumPropsExA(hWnd, lpEnumFunc, lParam) {
        result := DllCall("USER32.dll\EnumPropsExA", "ptr", hWnd, "ptr", lpEnumFunc, "ptr", lParam)
        return result
    }

    /**
     * Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumPropsEx continues until the last entry is enumerated or the callback function returns FALSE. (Unicode)
     * @remarks
     * An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be enumerated.
     * @param {Pointer<PROPENUMPROCEXW>} lpEnumFunc Type: <b>PROPENUMPROCEX</b>
     * 
     * A pointer to the callback function. For more information about the callback function, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-propenumprocexw">PropEnumProcEx</a> function.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Application-defined data to be passed to the callback function.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumpropsexw
     * @since windows5.0
     */
    static EnumPropsExW(hWnd, lpEnumFunc, lParam) {
        result := DllCall("USER32.dll\EnumPropsExW", "ptr", hWnd, "ptr", lpEnumFunc, "ptr", lParam)
        return result
    }

    /**
     * Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumProps continues until the last entry is enumerated or the callback function returns FALSE. (ANSI)
     * @remarks
     * An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines EnumProps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be enumerated.
     * @param {Pointer<PROPENUMPROCA>} lpEnumFunc Type: <b>PROPENUMPROC</b>
     * 
     * A pointer to the callback function. For more information about the callback function, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-propenumproca">PropEnumProc</a> function.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumpropsa
     * @since windows5.0
     */
    static EnumPropsA(hWnd, lpEnumFunc) {
        result := DllCall("USER32.dll\EnumPropsA", "ptr", hWnd, "ptr", lpEnumFunc)
        return result
    }

    /**
     * Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function. EnumProps continues until the last entry is enumerated or the callback function returns FALSE. (Unicode)
     * @remarks
     * An application can remove only those properties it has added. It must not remove properties added by other applications or by the system itself. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines EnumProps as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose property list is to be enumerated.
     * @param {Pointer<PROPENUMPROCW>} lpEnumFunc Type: <b>PROPENUMPROC</b>
     * 
     * A pointer to the callback function. For more information about the callback function, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nc-winuser-propenumproca">PropEnumProc</a> function.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for enumeration.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumpropsw
     * @since windows5.0
     */
    static EnumPropsW(hWnd, lpEnumFunc) {
        result := DllCall("USER32.dll\EnumPropsW", "ptr", hWnd, "ptr", lpEnumFunc)
        return result
    }

    /**
     * Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the control is changed. However, SetWindowText cannot change the text of a control in another application. (ANSI)
     * @remarks
     * If the target window is owned by the current process, <b>SetWindowText</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message to be sent to the specified window or control. If the control is a list box control created with the <b>WS_CAPTION</b> style, however, <b>SetWindowText</b> sets the text for the control, not for the list box entries. 
     * 
     * To set the text of a control in another process, send the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message directly instead of calling <b>SetWindowText</b>. 
     * 
     * The <b>SetWindowText</b> function does not expand tab characters (ASCII code 0x09). Tab characters are displayed as vertical bar (|) characters.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window or control whose text is to be changed.
     * @param {Pointer<Byte>} lpString Type: <b>LPCTSTR</b>
     * 
     * The new title or control text.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowtexta
     * @since windows5.0
     */
    static SetWindowTextA(hWnd, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowTextA", "ptr", hWnd, "ptr", lpString, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the control is changed. However, SetWindowText cannot change the text of a control in another application. (Unicode)
     * @remarks
     * If the target window is owned by the current process, <b>SetWindowText</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message to be sent to the specified window or control. If the control is a list box control created with the <b>WS_CAPTION</b> style, however, <b>SetWindowText</b> sets the text for the control, not for the list box entries. 
     * 
     * To set the text of a control in another process, send the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message directly instead of calling <b>SetWindowText</b>. 
     * 
     * The <b>SetWindowText</b> function does not expand tab characters (ASCII code 0x09). Tab characters are displayed as vertical bar (|) characters.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window or control whose text is to be changed.
     * @param {Pointer<Char>} lpString Type: <b>LPCWSTR</b>
     * 
     * The new title or control text.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowtextw
     * @since windows5.0
     */
    static SetWindowTextW(hWnd, lpString) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowTextW", "ptr", hWnd, "ptr", lpString, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application. (ANSI)
     * @remarks
     * If the target window is owned by the current process, <b>GetWindowText</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message to be sent to the specified window or control. If the target window is owned by another process and has a caption, <b>GetWindowText</b> retrieves the window caption text. If the window does not have a caption, the return value is a null string. This behavior is by design. It allows applications to call <b>GetWindowText</b> without becoming unresponsive if the process that owns the target window is not responding. However, if the target window is not responding and it belongs to the calling application, <b>GetWindowText</b> will cause the calling application to become unresponsive. 
     * 
     * To retrieve the text of a control in another process, send a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message directly instead of calling <b>GetWindowText</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window or control containing the text.
     * @param {Pointer<Byte>} lpString Type: <b>LPTSTR</b>
     * 
     * The buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a null character.
     * @param {Integer} nMaxCount Type: <b>int</b>
     * 
     * The maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * This function cannot retrieve the text of an edit control in another application.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtexta
     * @since windows5.0
     */
    static GetWindowTextA(hWnd, lpString, nMaxCount) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowTextA", "ptr", hWnd, "ptr", lpString, "int", nMaxCount)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application. (Unicode)
     * @remarks
     * If the target window is owned by the current process, <b>GetWindowText</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message to be sent to the specified window or control. If the target window is owned by another process and has a caption, <b>GetWindowText</b> retrieves the window caption text. If the window does not have a caption, the return value is a null string. This behavior is by design. It allows applications to call <b>GetWindowText</b> without becoming unresponsive if the process that owns the target window is not responding. However, if the target window is not responding and it belongs to the calling application, <b>GetWindowText</b> will cause the calling application to become unresponsive. 
     * 
     * To retrieve the text of a control in another process, send a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a> message directly instead of calling <b>GetWindowText</b>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window or control containing the text.
     * @param {Pointer<Char>} lpString Type: <b>LPTSTR</b>
     * 
     * The buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a null character.
     * @param {Integer} nMaxCount Type: <b>int</b>
     * 
     * The maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is truncated.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * This function cannot retrieve the text of an edit control in another application.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextw
     * @since windows5.0
     */
    static GetWindowTextW(hWnd, lpString, nMaxCount) {
        lpString := lpString is String? StrPtr(lpString) : lpString

        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowTextW", "ptr", hWnd, "ptr", lpString, "int", nMaxCount)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). (ANSI)
     * @remarks
     * If the target window is owned by the current process, <b>GetWindowTextLength</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettextlength">WM_GETTEXTLENGTH</a> message to be sent to the specified window or control. 
     * 
     * Under certain conditions, the <b>GetWindowTextLength</b> function may return a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. It can also occur when an application uses the ANSI version of <b>GetWindowTextLength</b> with a window whose window procedure is Unicode, or the Unicode version of <b>GetWindowTextLength</b> with a window whose window procedure is ANSI. For more information on ANSI and ANSI functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. 
     * 
     * To obtain the exact length of the text, use the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a>, <a href="https://docs.microsoft.com/windows/desktop/Controls/lb-gettext">LB_GETTEXT</a>, or <a href="https://docs.microsoft.com/windows/desktop/Controls/cb-getlbtext">CB_GETLBTEXT</a> messages, or the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetWindowTextLength as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window or control.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value might be greater than the length of the text (see Remarks).
     * 
     * If the window has no text, the return value is zero. 
     * 
     * Function failure is indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.
     * 
     * > [!NOTE]
     * > This function does not clear the most recent error information. To determine success or failure, clear the most recent error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0, then call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextlengtha
     * @since windows5.0
     */
    static GetWindowTextLengthA(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowTextLengthA", "ptr", hWnd)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). (Unicode)
     * @remarks
     * If the target window is owned by the current process, <b>GetWindowTextLength</b> causes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettextlength">WM_GETTEXTLENGTH</a> message to be sent to the specified window or control. 
     * 
     * Under certain conditions, the <b>GetWindowTextLength</b> function may return a value that is larger than the actual length of the text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common dialogs, which use Unicode. It can also occur when an application uses the ANSI version of <b>GetWindowTextLength</b> with a window whose window procedure is Unicode, or the Unicode version of <b>GetWindowTextLength</b> with a window whose window procedure is ANSI. For more information on ANSI and ANSI functions, see <a href="https://docs.microsoft.com/windows/desktop/Intl/conventions-for-function-prototypes">Conventions for Function Prototypes</a>. 
     * 
     * To obtain the exact length of the text, use the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-gettext">WM_GETTEXT</a>, <a href="https://docs.microsoft.com/windows/desktop/Controls/lb-gettext">LB_GETTEXT</a>, or <a href="https://docs.microsoft.com/windows/desktop/Controls/cb-getlbtext">CB_GETLBTEXT</a> messages, or the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetWindowTextLength as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window or control.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value might be greater than the length of the text (see Remarks).
     * 
     * If the window has no text, the return value is zero. 
     * 
     * Function failure is indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.
     * 
     * > [!NOTE]
     * > This function does not clear the most recent error information. To determine success or failure, clear the most recent error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0, then call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtextlengthw
     * @since windows5.0
     */
    static GetWindowTextLengthW(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowTextLengthW", "ptr", hWnd)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the coordinates of a window's client area.
     * @remarks
     * In conformance with conventions for the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (<b>right</b>, <b>bottom</b>) lies immediately outside the rectangle.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose client coordinates are to be retrieved.
     * @param {Pointer<RECT>} lpRect Type: <b>LPRECT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the client coordinates. The <b>left</b> and <b>top</b> members are zero. The <b>right</b> and <b>bottom</b> members contain the width and height of the window.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclientrect
     * @since windows5.0
     */
    static GetClientRect(hWnd, lpRect) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetClientRect", "ptr", hWnd, "ptr", lpRect, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.
     * @remarks
     * In conformance with conventions for the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (<b>right</b>, <b>bottom</b>) lies immediately outside the rectangle.
     * 
     * GetWindowRect is virtualized for DPI.
     * 
     * In Windows Vista and later, the Window Rect now includes the area occupied by the drop shadow.
     * 
     * Calling GetWindowRect will have different behavior depending on whether the window has ever been shown or not.  If the window has not been shown before, GetWindowRect will not include the area of the drop shadow.
     * 
     * To get the window bounds excluding the drop shadow, use <a href="https://docs.microsoft.com/windows/win32/api/dwmapi/nf-dwmapi-dwmgetwindowattribute">DwmGetWindowAttribute</a>, specifying <b>DWMWA_EXTENDED_FRAME_BOUNDS</b>.  Note that unlike the Window Rect, the DWM Extended Frame Bounds are not adjusted for DPI.  Getting the extended frame bounds can only be done after the window has been shown at least once.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Pointer<RECT>} lpRect Type: <b>LPRECT</b>
     * 
     * A pointer to a  <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the screen coordinates of the upper-left and lower-right corners of the window.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowrect
     * @since windows5.0
     */
    static GetWindowRect(hWnd, lpRect) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowRect", "ptr", hWnd, "ptr", lpRect, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Calculates the required size of the window rectangle, based on the desired client-rectangle size. The window rectangle can then be passed to the CreateWindow function to create a window whose client area is the desired size.
     * @remarks
     * A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle that completely encloses the window, which includes the client area and the nonclient area. 
     * 
     * The <b>AdjustWindowRect</b> function does not add extra space when a menu bar wraps to two or more rows. 
     * 
     * The <b>AdjustWindowRect</b> function does not take the <b>WS_VSCROLL</b> or <b>WS_HSCROLL</b> styles into account. To account for the scroll bars, call the  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> function with <b>SM_CXVSCROLL</b> or <b>SM_CYHSCROLL</b>.
     * @param {Pointer<RECT>} lpRect Type: <b>LPRECT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.
     * @param {Integer} dwStyle Type: <b>DWORD</b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style</a> of the window whose required size is to be calculated. Note that you cannot specify the <b>WS_OVERLAPPED</b> style.
     * @param {Integer} bMenu Type: <b>BOOL</b>
     * 
     * Indicates whether the window has a menu.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-adjustwindowrect
     * @since windows5.0
     */
    static AdjustWindowRect(lpRect, dwStyle, bMenu) {
        A_LastError := 0

        result := DllCall("USER32.dll\AdjustWindowRect", "ptr", lpRect, "uint", dwStyle, "int", bMenu, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Calculates the required size of the window rectangle, based on the desired size of the client rectangle. The window rectangle can then be passed to the CreateWindowEx function to create a window whose client area is the desired size.
     * @remarks
     * A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle that completely encloses the window, which includes the client area and the nonclient area. 
     * 
     * The <b>AdjustWindowRectEx</b> function does not add extra space when a menu bar wraps to two or more rows. 
     * 
     * The <b>AdjustWindowRectEx</b> function does not take the <b>WS_VSCROLL</b> or <b>WS_HSCROLL</b> styles into account. To account for the scroll bars, call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> function with <b>SM_CXVSCROLL</b> or <b>SM_CYHSCROLL</b>. 
     * 
     * This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-adjustwindowrectexfordpi">AdjustWindowsRectExForDPI</a>. For more information on DPI awareness, see <a href="https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows">the Windows High DPI documentation.</a>
     * @param {Pointer<RECT>} lpRect Type: <b>LPRECT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area.
     * @param {Integer} dwStyle Type: <b>DWORD</b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">window style</a> of the window whose required size is to be calculated. Note that you cannot specify the <b>WS_OVERLAPPED</b> style.
     * @param {Integer} bMenu Type: <b>BOOL</b>
     * 
     * Indicates whether the window has a menu.
     * @param {Integer} dwExStyle Type: <b>DWORD</b>
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/winmsg/extended-window-styles">extended window style</a> of the window whose required size is to be calculated.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-adjustwindowrectex
     * @since windows5.0
     */
    static AdjustWindowRectEx(lpRect, dwStyle, bMenu, dwExStyle) {
        A_LastError := 0

        result := DllCall("USER32.dll\AdjustWindowRectEx", "ptr", lpRect, "uint", dwStyle, "int", bMenu, "uint", dwExStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information. The message box returns an integer value that indicates which button the user clicked. (MessageBoxA)
     * @remarks
     * The following system icons can be used in a message box by setting the <i>uType</i> parameter to the corresponding flag value.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Icon</th>
     * <th>Flag values</th>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONHAND, MB_ICONSTOP, and MB_ICONERROR" src="./images/MB_ICONHAND.png"/></td>
     * <td><b>MB_ICONHAND</b>, <b>MB_ICONSTOP</b>, or <b>MB_ICONERROR</b></td>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONQUESTION" src="./images/MB_ICONQUESTION.png"/></td>
     * <td><b>MB_ICONQUESTION</b></td>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONEXCLAMATION and MB_ICONWARNING" src="./images/MB_ICONEXCLAMATION.png"/></td>
     * <td><b>MB_ICONEXCLAMATION</b> or <b>MB_ICONWARNING</b></td>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONASTERISK and MB_ICONINFORMATION" src="./images/MB_ICONASTERISK.png"/></td>
     * <td><b>MB_ICONASTERISK</b> or <b>MB_ICONINFORMATION</b></td>
     * </tr>
     * </table>
     * 
     * 
     * Adding two right-to-left marks (RLMs), represented by Unicode formatting character U+200F, in the beginning of a MessageBox display string is interpreted by the MessageBox rendering engine so as to cause the reading order of the MessageBox to be rendered as right-to-left (RTL).
     * 
     * When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <i>lpText</i> and <i>lpCaption</i> parameters should not be taken from a resource file because an attempt to load the resource may fail.
     * 
     * If you create a message box while a dialog box is present, use a handle to the dialog box as the <i>hWnd</i> parameter. The <i>hWnd</i> parameter should not identify a child window, such as a control in a dialog box.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this parameter is <b>NULL</b>, the message box has no owner window.
     * @param {Pointer<Byte>} lpText Type: <b>LPCTSTR</b>
     * 
     * The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return and/or linefeed character between each line.
     * @param {Pointer<Byte>} lpCaption Type: <b>LPCTSTR</b>
     * 
     * The dialog box title. If this parameter is <b>NULL</b>, the default title is <b>Error</b>.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <b>IDOK</b>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the function succeeds, the return value is one of the following menu-item values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Abort</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCANCEL</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Cancel</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCONTINUE</b></dt>
     * <dt>11</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Continue</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Ignore</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>No</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDOK</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>OK</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDRETRY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Retry</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDTRYAGAIN</b></dt>
     * <dt>10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Try Again</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Yes</b> button was selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-messageboxa
     * @since windows5.0
     */
    static MessageBoxA(hWnd, lpText, lpCaption, uType) {
        lpText := lpText is String? StrPtr(lpText) : lpText
        lpCaption := lpCaption is String? StrPtr(lpCaption) : lpCaption

        A_LastError := 0

        result := DllCall("USER32.dll\MessageBoxA", "ptr", hWnd, "ptr", lpText, "ptr", lpCaption, "uint", uType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information. The message box returns an integer value that indicates which button the user clicked. (MessageBoxW)
     * @remarks
     * The following system icons can be used in a message box by setting the <i>uType</i> parameter to the corresponding flag value.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Icon</th>
     * <th>Flag values</th>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONHAND, MB_ICONSTOP, and MB_ICONERROR" src="./images/MB_ICONHAND.png"/></td>
     * <td><b>MB_ICONHAND</b>, <b>MB_ICONSTOP</b>, or <b>MB_ICONERROR</b></td>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONQUESTION" src="./images/MB_ICONQUESTION.png"/></td>
     * <td><b>MB_ICONQUESTION</b></td>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONEXCLAMATION and MB_ICONWARNING" src="./images/MB_ICONEXCLAMATION.png"/></td>
     * <td><b>MB_ICONEXCLAMATION</b> or <b>MB_ICONWARNING</b></td>
     * </tr>
     * <tr>
     * <td><img alt="Icon for MB_ICONASTERISK and MB_ICONINFORMATION" src="./images/MB_ICONASTERISK.png"/></td>
     * <td><b>MB_ICONASTERISK</b> or <b>MB_ICONINFORMATION</b></td>
     * </tr>
     * </table>
     * 
     * 
     * Adding two right-to-left marks (RLMs), represented by Unicode formatting character U+200F, in the beginning of a MessageBox display string is interpreted by the MessageBox rendering engine so as to cause the reading order of the MessageBox to be rendered as right-to-left (RTL).
     * 
     * When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <i>lpText</i> and <i>lpCaption</i> parameters should not be taken from a resource file because an attempt to load the resource may fail.
     * 
     * If you create a message box while a dialog box is present, use a handle to the dialog box as the <i>hWnd</i> parameter. The <i>hWnd</i> parameter should not identify a child window, such as a control in a dialog box.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this parameter is <b>NULL</b>, the message box has no owner window.
     * @param {Pointer<Char>} lpText Type: <b>LPCTSTR</b>
     * 
     * The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return and/or linefeed character between each line.
     * @param {Pointer<Char>} lpCaption Type: <b>LPCTSTR</b>
     * 
     * The dialog box title. If this parameter is <b>NULL</b>, the default title is <b>Error</b>.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <b>IDOK</b>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the function succeeds, the return value is one of the following menu-item values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Abort</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCANCEL</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Cancel</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCONTINUE</b></dt>
     * <dt>11</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Continue</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Ignore</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>No</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDOK</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>OK</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDRETRY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Retry</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDTRYAGAIN</b></dt>
     * <dt>10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Try Again</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Yes</b> button was selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-messageboxw
     * @since windows5.0
     */
    static MessageBoxW(hWnd, lpText, lpCaption, uType) {
        lpText := lpText is String? StrPtr(lpText) : lpText
        lpCaption := lpCaption is String? StrPtr(lpCaption) : lpCaption

        A_LastError := 0

        result := DllCall("USER32.dll\MessageBoxW", "ptr", hWnd, "ptr", lpText, "ptr", lpCaption, "uint", uType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates, displays, and operates a message box. (ANSI)
     * @remarks
     * When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <i>lpText</i> and <i>lpCaption</i> parameters should not be taken from a resource file because an attempt to load the resource may fail. 
     * 
     * If you create a message box while a dialog box is present, use a handle to the dialog box as the <i>hWnd</i> parameter. The <i>hWnd</i> parameter should not identify a child window, such as a control in a dialog box. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines MessageBoxEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this parameter is <b>NULL</b>, the message box has no owner window.
     * @param {Pointer<Byte>} lpText Type: <b>LPCTSTR</b>
     * 
     * The message to be displayed.
     * @param {Pointer<Byte>} lpCaption Type: <b>LPCTSTR</b>
     * 
     * The dialog box title. If this parameter is <b>NULL</b>, the default title <b>Error</b> is used.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The contents and behavior of the dialog box. For information on the supported flags, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * @param {Integer} wLanguageId Type: <b>WORD</b>
     * 
     * The language for the text displayed in the message box button(s). Specifying a value of zero (0) indicates to display the button text in the default system language. If this parameter is <c>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</c>, the current language associated with the calling thread is used.
     *            
     * 
     * To specify a language other than the current language, use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelangid">MAKELANGID</a> macro to create this parameter. For more information, see <b>MAKELANGID</b>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <b>IDOK</b>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the function succeeds, the return value is one of the following menu-item values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Abort</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCANCEL</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Cancel</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCONTINUE</b></dt>
     * <dt>11</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Continue</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Ignore</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>No</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDOK</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>OK</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDRETRY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Retry</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDTRYAGAIN</b></dt>
     * <dt>10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Try Again</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Yes</b> button was selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-messageboxexa
     * @since windows5.0
     */
    static MessageBoxExA(hWnd, lpText, lpCaption, uType, wLanguageId) {
        lpText := lpText is String? StrPtr(lpText) : lpText
        lpCaption := lpCaption is String? StrPtr(lpCaption) : lpCaption

        A_LastError := 0

        result := DllCall("USER32.dll\MessageBoxExA", "ptr", hWnd, "ptr", lpText, "ptr", lpCaption, "uint", uType, "ushort", wLanguageId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates, displays, and operates a message box. (Unicode)
     * @remarks
     * When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <i>lpText</i> and <i>lpCaption</i> parameters should not be taken from a resource file because an attempt to load the resource may fail. 
     * 
     * If you create a message box while a dialog box is present, use a handle to the dialog box as the <i>hWnd</i> parameter. The <i>hWnd</i> parameter should not identify a child window, such as a control in a dialog box. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines MessageBoxEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window of the message box to be created. If this parameter is <b>NULL</b>, the message box has no owner window.
     * @param {Pointer<Char>} lpText Type: <b>LPCTSTR</b>
     * 
     * The message to be displayed.
     * @param {Pointer<Char>} lpCaption Type: <b>LPCTSTR</b>
     * 
     * The dialog box title. If this parameter is <b>NULL</b>, the default title <b>Error</b> is used.
     * @param {Integer} uType Type: <b>UINT</b>
     * 
     * The contents and behavior of the dialog box. For information on the supported flags, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-messagebox">MessageBox</a>.
     * @param {Integer} wLanguageId Type: <b>WORD</b>
     * 
     * The language for the text displayed in the message box button(s). Specifying a value of zero (0) indicates to display the button text in the default system language. If this parameter is <c>MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)</c>, the current language associated with the calling thread is used.
     *            
     * 
     * To specify a language other than the current language, use the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/nf-winnt-makelangid">MAKELANGID</a> macro to create this parameter. For more information, see <b>MAKELANGID</b>.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC will no effect - unless an MB_OK button is present. If an MB_OK button is displayed and the user presses ESC, the return value will be <b>IDOK</b>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the function succeeds, the return value is one of the following menu-item values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Abort</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCANCEL</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Cancel</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCONTINUE</b></dt>
     * <dt>11</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Continue</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Ignore</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>No</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDOK</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>OK</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDRETRY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Retry</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDTRYAGAIN</b></dt>
     * <dt>10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Try Again</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Yes</b> button was selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-messageboxexw
     * @since windows5.0
     */
    static MessageBoxExW(hWnd, lpText, lpCaption, uType, wLanguageId) {
        lpText := lpText is String? StrPtr(lpText) : lpText
        lpCaption := lpCaption is String? StrPtr(lpCaption) : lpCaption

        A_LastError := 0

        result := DllCall("USER32.dll\MessageBoxExW", "ptr", hWnd, "ptr", lpText, "ptr", lpCaption, "uint", uType, "ushort", wLanguageId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates, displays, and operates a message box. The message box contains application-defined message text and title, any icon, and any combination of predefined push buttons. (ANSI)
     * @remarks
     * When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <b>lpszText</b> and <b>lpszCaption</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msgboxparamsa">MSGBOXPARAMS</a> structure should not be taken from a resource file, because an attempt to load the resource may fail. 
     * 
     * If you create a message box while a dialog box is present, use a handle to the dialog box as the <i>hWnd</i> parameter. The <i>hWnd</i> parameter should not identify a child window, such as a control in a dialog box. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines MessageBoxIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<MSGBOXPARAMSA>} lpmbp Type: <b>const LPMSGBOXPARAMS</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msgboxparamsa">MSGBOXPARAMS</a> structure that contains information used to display the message box.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is one of the following menu-item values.
     * 
     * If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC has no effect. 
     * 
     * If there is not enough memory to create the message box, the return value is zero. 
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Abort</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCANCEL</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Cancel</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCONTINUE</b></dt>
     * <dt>11</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Continue</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Ignore</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>No</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDOK</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>OK</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDRETRY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Retry</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDTRYAGAIN</b></dt>
     * <dt>10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Try Again</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Yes</b> button was selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-messageboxindirecta
     * @since windows5.0
     */
    static MessageBoxIndirectA(lpmbp) {
        result := DllCall("USER32.dll\MessageBoxIndirectA", "ptr", lpmbp, "int")
        return result
    }

    /**
     * Creates, displays, and operates a message box. The message box contains application-defined message text and title, any icon, and any combination of predefined push buttons. (Unicode)
     * @remarks
     * When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <b>lpszText</b> and <b>lpszCaption</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msgboxparamsa">MSGBOXPARAMS</a> structure should not be taken from a resource file, because an attempt to load the resource may fail. 
     * 
     * If you create a message box while a dialog box is present, use a handle to the dialog box as the <i>hWnd</i> parameter. The <i>hWnd</i> parameter should not identify a child window, such as a control in a dialog box. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines MessageBoxIndirect as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<MSGBOXPARAMSW>} lpmbp Type: <b>const LPMSGBOXPARAMS</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msgboxparamsa">MSGBOXPARAMS</a> structure that contains information used to display the message box.
     * @returns {Integer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is one of the following menu-item values.
     * 
     * If a message box has a <b>Cancel</b> button, the function returns the <b>IDCANCEL</b> value if either the ESC key is pressed or the <b>Cancel</b> button is selected. If the message box has no <b>Cancel</b> button, pressing ESC has no effect. 
     * 
     * If there is not enough memory to create the message box, the return value is zero. 
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDABORT</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Abort</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCANCEL</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Cancel</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDCONTINUE</b></dt>
     * <dt>11</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Continue</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDIGNORE</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Ignore</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDNO</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>No</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDOK</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>OK</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDRETRY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Retry</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDTRYAGAIN</b></dt>
     * <dt>10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Try Again</b> button was selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>IDYES</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>Yes</b> button was selected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-messageboxindirectw
     * @since windows5.0
     */
    static MessageBoxIndirectW(lpmbp) {
        result := DllCall("USER32.dll\MessageBoxIndirectW", "ptr", lpmbp, "int")
        return result
    }

    /**
     * Displays or hides the cursor. (ShowCursor)
     * @remarks
     * <b>Windows8</b>: Call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getcursorinfo">GetCursorInfo</a> to determine the cursor visibility.
     * 
     * This function sets an internal display counter that determines whether the cursor should be displayed. The cursor is displayed only if the display count is greater than or equal to 0. If a mouse is installed, the initial display count is 0. If no mouse is installed, the display count is 
     * 				1.
     * @param {Integer} bShow Type: <b>BOOL</b>
     * 
     * If <i>bShow</i> is <b>TRUE</b>, the display count is incremented by one. If <i>bShow</i> is <b>FALSE</b>, the display count is decremented by one.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * The return value specifies the new display counter.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showcursor
     * @since windows5.0
     */
    static ShowCursor(bShow) {
        result := DllCall("USER32.dll\ShowCursor", "int", bShow)
        return result
    }

    /**
     * Moves the cursor to the specified screen coordinates.
     * @remarks
     * The cursor is a shared resource. A window should move the cursor only when the cursor is in the window's client area.
     * 
     * The calling process must have <b>WINSTA_WRITEATTRIBUTES</b> access to the window station.
     * 
     * The input desktop must be the current desktop when you call <b>SetCursorPos</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openinputdesktop">OpenInputDesktop</a> to determine whether the current desktop is the input desktop. If it is not, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setthreaddesktop">SetThreadDesktop</a> with the <b>HDESK</b> returned by <b>OpenInputDesktop</b> to switch to that desktop.
     * @param {Integer} X Type: <b>int</b>
     * 
     * The new x-coordinate of the cursor, in screen coordinates.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The new y-coordinate of the cursor, in screen coordinates.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful or zero otherwise. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setcursorpos
     * @since windows5.0
     */
    static SetCursorPos(X, Y) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetCursorPos", "int", X, "int", Y, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the position of the cursor in physical coordinates.
     * @remarks
     * For a description of the difference between logical coordinates and physical coordinates, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-physicaltologicalpoint">PhysicalToLogicalPoint</a>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can be called to get more information about any error that is generated.
     * @param {Integer} X Type: <b>int</b>
     * 
     * The new x-coordinate of the cursor, in physical coordinates.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The new y-coordinate of the cursor, in physical coordinates.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setphysicalcursorpos
     * @since windows6.0.6000
     */
    static SetPhysicalCursorPos(X, Y) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetPhysicalCursorPos", "int", X, "int", Y, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the cursor shape.
     * @remarks
     * The cursor is set only if the new cursor is different from the previous cursor; otherwise, the function returns immediately. 
     * 
     * The cursor is a shared resource. A window should set the cursor shape only when the cursor is in its client area or when the window is capturing mouse input. In systems without a mouse, the window should restore the previous cursor before the cursor leaves the client area or before it relinquishes control to another window. 
     * 
     * If your application must set the cursor while it is in a window, make sure the class cursor for the specified window's class is set to <b>NULL</b>. If the class cursor is not <b>NULL</b>, the system restores the class cursor each time the mouse is moved. 
     * 
     * The cursor is not shown on the screen if the internal cursor display count is less than zero. This occurs if the application uses the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showcursor">ShowCursor</a> function to hide the cursor more times than to show the cursor.
     * @param {Pointer<Void>} hCursor Type: <b>HCURSOR</b>
     * 
     * A handle to the cursor.
     * 
     * The cursor must have been created by either the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createcursor">CreateCursor</a> or the <a href="https://docs.microsoft.com/win32/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a> function, or loaded by either the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursora">LoadCursor</a> or the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function.
     * 
     * If this parameter is <b>NULL</b>, the cursor is removed from the screen.
     * @returns {Pointer<Void>} Type: <b>HCURSOR</b>
     * 
     * The return value is the handle to the previous cursor, if there was one. 
     * 
     * If there was no previous cursor, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setcursor
     * @since windows5.0
     */
    static SetCursor(hCursor) {
        result := DllCall("USER32.dll\SetCursor", "ptr", hCursor)
        return result
    }

    /**
     * Retrieves the position of the mouse cursor, in screen coordinates.
     * @remarks
     * The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains the cursor.
     * 
     * The calling process must have <b>WINSTA_READATTRIBUTES</b> access to the window station.
     * 
     * The input desktop must be the current desktop when you call <b>GetCursorPos</b>. Call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-openinputdesktop">OpenInputDesktop</a> to determine whether the current desktop is the input desktop. If it is not, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setthreaddesktop">SetThreadDesktop</a> with the <b>HDESK</b> returned by <b>OpenInputDesktop</b> to switch to that desktop.
     * @param {Pointer<POINT>} lpPoint Type: <b>LPPOINT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that receives the screen coordinates of the cursor.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * Returns nonzero if successful or zero otherwise. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcursorpos
     * @since windows5.0
     */
    static GetCursorPos(lpPoint) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetCursorPos", "ptr", lpPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the position of the cursor in physical coordinates.
     * @remarks
     * For a description of the difference between logical coordinates and physical coordinates, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-physicaltologicalpoint">PhysicalToLogicalPoint</a>.
     * @param {Pointer<POINT>} lpPoint Type: <b>LPPOINT</b>
     * 
     * The position of the cursor, in physical coordinates.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise <b>FALSE</b>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can be called to get more information about any error that is generated.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getphysicalcursorpos
     * @since windows6.0.6000
     */
    static GetPhysicalCursorPos(lpPoint) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetPhysicalCursorPos", "ptr", lpPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the screen coordinates of the rectangular area to which the cursor is confined.
     * @remarks
     * The cursor is a shared resource. If an application confines the cursor with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-clipcursor">ClipCursor</a> function, it must later release the cursor by using <b>ClipCursor</b> before relinquishing control to another application. 
     * 
     * The calling process must have <b>WINSTA_READATTRIBUTES</b> access to the window station.
     * @param {Pointer<RECT>} lpRect Type: <b>LPRECT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the screen coordinates of the confining rectangle. The structure receives the dimensions of the screen if the cursor is not confined to a rectangle.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclipcursor
     * @since windows5.0
     */
    static GetClipCursor(lpRect) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetClipCursor", "ptr", lpRect, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to the current cursor.
     * @returns {Pointer<Void>} Type: <b>HCURSOR</b>
     * 
     * The return value is the handle to the current cursor. If there is no cursor, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcursor
     * @since windows5.0
     */
    static GetCursor() {
        result := DllCall("USER32.dll\GetCursor")
        return result
    }

    /**
     * Creates a new shape for the system caret and assigns ownership of the caret to the specified window. The caret shape can be a line, a block, or a bitmap.
     * @remarks
     * The <i>nWidth</i> and <i>nHeight</i> parameters specify the caret's width and height, in logical units; the exact width and height, in pixels, depend on the window's mapping mode. 
     * 
     * <b>CreateCaret</b> automatically destroys the previous caret shape, if any, regardless of the window that owns the caret. The caret is hidden until the application calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showcaret">ShowCaret</a> function to make the caret visible. 
     * 
     * The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should destroy the caret before losing the keyboard focus or becoming inactive. 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The width and height parameters are interpreted as logical sizes in terms of the window in question. The calling thread is not taken into consideration.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the caret.
     * @param {Pointer<Void>} hBitmap Type: <b>HBITMAP</b>
     * 
     * A handle to the bitmap that defines the caret shape. If this parameter is <b>NULL</b>, the caret is solid. If this parameter is <c>(HBITMAP) 1</c>, the caret is gray. If this parameter is a bitmap handle, the caret is the specified bitmap. The bitmap handle must have been created by the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createbitmap">CreateBitmap</a>, <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createdibitmap">CreateDIBitmap</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadbitmapa">LoadBitmap</a> function.
     * 
     * If <i>hBitmap</i> is a bitmap handle, <b>CreateCaret</b> ignores the <i>nWidth</i> and <i>nHeight</i> parameters; the bitmap defines its own width and height.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The width of the caret, in logical units. If this parameter is zero, the width is set to the system-defined window border width. If <i>hBitmap</i> is a bitmap handle, <b>CreateCaret</b> ignores this parameter.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The height of the caret, in logical units. If this parameter is zero, the height is set to the system-defined window border height. If <i>hBitmap</i> is a bitmap handle, <b>CreateCaret</b> ignores this parameter.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createcaret
     * @since windows5.0
     */
    static CreateCaret(hWnd, hBitmap, nWidth, nHeight) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateCaret", "ptr", hWnd, "ptr", hBitmap, "int", nWidth, "int", nHeight, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the time required to invert the caret's pixels. The user can set this value.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the return value is the blink time, in milliseconds.
     *           
     * 
     * A return value of <b>INFINITE</b> indicates that the caret does not blink.
     * 
     * A return value is zero indicates that the function has failed.
     *              To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcaretblinktime
     * @since windows5.0
     */
    static GetCaretBlinkTime() {
        A_LastError := 0

        result := DllCall("USER32.dll\GetCaretBlinkTime")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the caret blink time to the specified number of milliseconds. The blink time is the elapsed time, in milliseconds, required to invert the caret's pixels.
     * @remarks
     * The user can set the blink time using the Control Panel. Applications should respect the setting that the user has chosen. The <b>SetCaretBlinkTime</b> function should only be used by application that allow the user to set the blink time, such as a Control Panel applet.
     * 
     * If you change the blink time, subsequently activated applications will use the modified blink time, even if you restore the previous blink time when you lose the keyboard focus or become inactive. This is due to the multithreaded environment, where deactivation of your application is not synchronized with the activation of another application. This feature allows the system to activate another application even if the current application is not responding.
     * @param {Integer} uMSeconds Type: <b>UINT</b>
     * 
     * The new blink time, in milliseconds.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setcaretblinktime
     * @since windows5.0
     */
    static SetCaretBlinkTime(uMSeconds) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetCaretBlinkTime", "uint", uMSeconds, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys the caret's current shape, frees the caret from the window, and removes the caret from the screen.
     * @remarks
     * <b>DestroyCaret</b> destroys the caret only if a window in the current task owns the caret. If a window that is not in the current task owns the caret, <b>DestroyCaret</b> does nothing and returns <b>FALSE</b>. 
     * 
     * The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should destroy the caret before losing the keyboard focus or becoming inactive. 
     * 
     * For an example, see <a href="https://docs.microsoft.com/windows/desktop/menurc/using-carets">Destroying a Caret</a>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycaret
     * @since windows5.0
     */
    static DestroyCaret() {
        A_LastError := 0

        result := DllCall("USER32.dll\DestroyCaret", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes the caret from the screen. Hiding a caret does not destroy its current shape or invalidate the insertion point.
     * @remarks
     * <b>HideCaret</b> hides the caret only if the specified window owns the caret. If the specified window does not own the caret, <b>HideCaret</b> does nothing and returns <b>FALSE</b>. 
     * 
     * Hiding is cumulative. If your application calls <b>HideCaret</b> five times in a row, it must also call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showcaret">ShowCaret</a> five times before the caret is displayed. 
     * 
     * For an example, see <a href="https://docs.microsoft.com/windows/desktop/menurc/using-carets">Hiding a Caret</a>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the caret. If this parameter is <b>NULL</b>, <b>HideCaret</b> searches the current task for the window that owns the caret.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-hidecaret
     * @since windows5.0
     */
    static HideCaret(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\HideCaret", "ptr", hWnd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Makes the caret visible on the screen at the caret's current position. When the caret becomes visible, it begins flashing automatically.
     * @remarks
     * <b>ShowCaret</b> shows the caret only if the specified window owns the caret, the caret has a shape, and the caret has not been hidden two or more times in a row. If one or more of these conditions is not met, <b>ShowCaret</b> does nothing and returns <b>FALSE</b>. 
     * 
     * Hiding is cumulative. If your application calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-hidecaret">HideCaret</a> five times in a row, it must also call <b>ShowCaret</b> five times before the caret reappears. 
     * 
     * The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should destroy the caret before losing the keyboard focus or becoming inactive.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window that owns the caret. If this parameter is <b>NULL</b>, <b>ShowCaret</b> searches the current task for the window that owns the caret.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-showcaret
     * @since windows5.0
     */
    static ShowCaret(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\ShowCaret", "ptr", hWnd, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves the caret to the specified coordinates. If the window that owns the caret was created with the CS_OWNDC class style, then the specified coordinates are subject to the mapping mode of the device context associated with that window.
     * @remarks
     * <b>SetCaretPos</b> moves the caret whether the caret is hidden. 
     * 
     * The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should destroy the caret before losing the keyboard focus or becoming inactive. A window can set the caret position only if it owns the caret. 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The provided position is interpreted as logical coordinates in terms of the window associated with the caret. The calling thread is not taken into consideration.
     * @param {Integer} X Type: <b>int</b>
     * 
     * The new x-coordinate of the caret.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The new y-coordinate of the caret.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setcaretpos
     * @since windows5.0
     */
    static SetCaretPos(X, Y) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetCaretPos", "int", X, "int", Y, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies the caret's position to the specified POINT structure.
     * @remarks
     * The caret position is always given in the client coordinates of the window that contains the caret. 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The returned values are interpreted as logical sizes in terms of the window in question. The calling thread is not taken into consideration.
     * @param {Pointer<POINT>} lpPoint Type: <b>LPPOINT</b>
     * 
     * A pointer to the <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that is to receive the client coordinates of the caret.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     *                 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcaretpos
     * @since windows5.0
     */
    static GetCaretPos(lpPoint) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetCaretPos", "ptr", lpPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the logical coordinates of a point in a window to physical coordinates.
     * @remarks
     * WindowsVista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the screen. For scaled windows, logical and physical coordinates are different.
     * 
     * <b>LogicalToPhysicalPoint</b> is a transformation API that can be called by a process that declares itself as dpi aware. The function uses the window identified by the <i>hWnd</i> parameter and the logical coordinates given in the <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure to compute the physical coordinates.
     * 
     * The <b>LogicalToPhysicalPoint</b> function replaces the logical coordinates in the <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure with the physical coordinates. The physical coordinates are relative to the upper-left corner of the screen. The coordinates have to be inside the client area of <i>hWnd</i>.
     * 
     * On all platforms, <b>LogicalToPhysicalPoint</b> will fail on a window that has either 0 width or height; an application must first establish a non-0 width and height by calling, for example, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-movewindow">MoveWindow</a>.  On some versions of Windows (including Windows7), <b>LogicalToPhysicalPoint</b> will still fail if <b>MoveWindow</b> has been called after a call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with <b>SH_HIDE</b> has hidden the window.
     * 
     * In Windows8, systemDPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and LogicalToPhysicalPoint. In Windows8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs. As a result, in Windows8.1, PhysicalToLogicalPoint and LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space. 
     * This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected.
     * In those cases, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-physicaltologicalpointforpermonitordpi">PhysicalToLogicalPointForPerMonitorDPI</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-logicaltophysicalpointforpermonitordpi">LogicalToPhysicalPointForPerMonitorDPI.</a>
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child windows, only the area of overlap between the parent and the child window is converted.
     * @param {Pointer<POINT>} lpPoint Type: <b>LPPOINT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that specifies the logical coordinates to be converted. The new physical coordinates are copied into this structure if the function succeeds.
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-logicaltophysicalpoint
     * @since windows6.0.6000
     */
    static LogicalToPhysicalPoint(hWnd, lpPoint) {
        result := DllCall("USER32.dll\LogicalToPhysicalPoint", "ptr", hWnd, "ptr", lpPoint, "int")
        return result
    }

    /**
     * Converts the physical coordinates of a point in a window to logical coordinates.
     * @remarks
     * WindowsVista introduces the concept of physical coordinates. Desktop Window Manager (DWM) scales non-dots per inch (dpi) aware windows when the display is high dpi. The window seen on the screen corresponds to the physical coordinates. The application continues to work in logical space. Therefore, the application's view of the window is different from that which appears on the screen. For scaled windows, logical and physical coordinates are different.
     * 
     * The function uses the window identified by the <i>hWnd</i> parameter and the physical coordinates given in the <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure to compute the logical coordinates. The logical coordinates are the <i>unscaled</i> coordinates that appear to the application in a programmatic way. In other words, the logical coordinates are the coordinates the application recognizes, which can be different from the physical coordinates. The API then replaces the physical coordinates with the logical coordinates. The new coordinates are in the <i>world</i> coordinates whose origin is (0, 0) on the desktop. The coordinates passed to the API have to be on the <i>hWnd</i>.
     * 
     * The source coordinates are in device units.
     * 
     * On all platforms, <b>PhysicalToLogicalPoint</b> will fail on a window that has either 0 width or height; an application must first establish a non-0 width and height by calling, for example, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-movewindow">MoveWindow</a>.  On some versions of Windows (including Windows7), <b>PhysicalToLogicalPoint</b> will still fail if <b>MoveWindow</b> has been called after a call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> with <b>SH_HIDE</b> has hidden the window.
     * 
     * In Windows8, systemDPI aware applications translate between physical and logical space using PhysicalToLogicalPoint and LogicalToPhysicalPoint. In Windows8.1, the additional virtualization of the system and inter-process communications means that for the majority of applications, you do not need these APIs. As a result, in Windows8.1, PhysicalToLogicalPoint and LogicalToPhysicalPoint no longer transform points. The system returns all points to an application in its own coordinate space. 
     * This behavior preserves functionality for the majority of applications, but there are some exceptions in which you must make changes to ensure that the application works as expected.
     * In those cases, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-physicaltologicalpointforpermonitordpi">PhysicalToLogicalPointForPerMonitorDPI</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-logicaltophysicalpointforpermonitordpi">LogicalToPhysicalPointForPerMonitorDPI.</a>
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose transform is used for the conversion. Top level windows are fully supported. In the case of child windows, only the area of overlap between the parent and the child window is converted.
     * @param {Pointer<POINT>} lpPoint Type: <b>LPPOINT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that specifies the physical/screen coordinates to be converted. The new logical coordinates are copied into this structure if the function succeeds.
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-physicaltologicalpoint
     * @since windows6.0.6000
     */
    static PhysicalToLogicalPoint(hWnd, lpPoint) {
        result := DllCall("USER32.dll\PhysicalToLogicalPoint", "ptr", hWnd, "ptr", lpPoint, "int")
        return result
    }

    /**
     * Retrieves a handle to the window that contains the specified point.
     * @remarks
     * The <b>WindowFromPoint</b> function does not retrieve a handle to a hidden or disabled window, even if the point is within the window. An application should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-childwindowfrompoint">ChildWindowFromPoint</a> function for a nonrestrictive search.
     * @param {Pointer} Point Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * The point to be checked.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is a handle to the window that contains the point. If no window exists at the given point, the return value is <b>NULL</b>. If the point is over a static text control, the return value is a handle to the window under the static text control.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-windowfrompoint
     * @since windows5.0
     */
    static WindowFromPoint(Point) {
        result := DllCall("USER32.dll\WindowFromPoint", "ptr", Point)
        return result
    }

    /**
     * Retrieves a handle to the window that contains the specified physical point.
     * @remarks
     * The <b>WindowFromPhysicalPoint</b> function does not retrieve a handle to a hidden or disabled window, even if the point is within the window.
     * @param {Pointer} Point Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * The physical coordinates of the point.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * A handle to the window that contains the given physical point. If no window exists at the point, this value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-windowfromphysicalpoint
     * @since windows6.0.6000
     */
    static WindowFromPhysicalPoint(Point) {
        result := DllCall("USER32.dll\WindowFromPhysicalPoint", "ptr", Point)
        return result
    }

    /**
     * Determines which, if any, of the child windows belonging to a parent window contains the specified point. The search is restricted to immediate child windows. Grandchildren, and deeper descendant windows are not searched.
     * @remarks
     * The system maintains an internal list, containing the handles of the child windows 
     * 			associated with a parent window. The order of the handles in the list depends on the Z 
     * 			order of the child windows. If more than one child window contains the specified point, 
     * 			the system returns a handle to the first window in the list that contains the point. 
     * 
     * <b>ChildWindowFromPoint</b> treats an <b>HTTRANSPARENT</b> area of a standard 
     * 			control the same as other parts of the control. In contrast, 
     * 			<a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-realchildwindowfrompoint">RealChildWindowFromPoint</a> treats an <b>HTTRANSPARENT</b> area differently; 
     * 			it returns the child window behind a transparent area of a control. For example, if the 
     * 			point is in a transparent area of a groupbox, <b>ChildWindowFromPoint</b> 
     * 			returns the groupbox while <b>RealChildWindowFromPoint</b> returns the 
     * 			child window behind the groupbox. However, both APIs return 
     * 			a static field, even though it, too, returns <b>HTTRANSPARENT</b>.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {Pointer} Point Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * A structure that defines the client 
     * 				coordinates, relative to <i>hWndParent</i>, 
     * 				of the point to be checked.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is a handle to the child window that contains the point, 
     * 				even if the child window is hidden or disabled. If the point lies outside the 
     * 				parent window, the return value is <b>NULL</b>. If the point is within 
     * 				the parent window but not within any child window, the return value is a handle 
     * 				to the parent window.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-childwindowfrompoint
     * @since windows5.0
     */
    static ChildWindowFromPoint(hWndParent, Point) {
        result := DllCall("USER32.dll\ChildWindowFromPoint", "ptr", hWndParent, "ptr", Point)
        return result
    }

    /**
     * Confines the cursor to a rectangular area on the screen.
     * @remarks
     * The cursor is a shared resource. If an application confines the cursor, it must release the cursor by using <b>ClipCursor</b> before relinquishing control to another application. 
     * 
     * The calling process must have <b>WINSTA_WRITEATTRIBUTES</b> access to the window station.
     * @param {Pointer<RECT>} lpRect Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * A pointer to the structure that contains the screen coordinates of the upper-left and lower-right corners of the confining rectangle. If this parameter is <b>NULL</b>, the cursor is free to move anywhere on the screen.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-clipcursor
     * @since windows5.0
     */
    static ClipCursor(lpRect) {
        A_LastError := 0

        result := DllCall("USER32.dll\ClipCursor", "ptr", lpRect, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines which, if any, of the child windows belonging to the specified parent window contains the specified point.
     * @remarks
     * The system maintains an internal list that contains the handles of the child 
     * 			windows associated with a parent window. The order of the handles in the list 
     * 			depends on the Z order of the child windows. If more than one child window 
     * 			contains the specified point, the system returns a handle to the first window 
     * 			in the list that contains the point and meets the criteria specified by 
     * 			<i>uFlags</i>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @param {Pointer} pt Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * A structure that defines the 
     * 				client coordinates (relative to <i>hwndParent</i>) 
     * 				of the point to be checked.
     * @param {Integer} flags Type: <b>UINT</b>
     * 
     * The child windows to be skipped. This parameter can be one or more of the 
     * 				following values. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CWP_ALL"></a><a id="cwp_all"></a><dl>
     * <dt><b>CWP_ALL</b></dt>
     * <dt>0x0000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Does not skip any child windows
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CWP_SKIPDISABLED"></a><a id="cwp_skipdisabled"></a><dl>
     * <dt><b>CWP_SKIPDISABLED</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips disabled child windows
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CWP_SKIPINVISIBLE"></a><a id="cwp_skipinvisible"></a><dl>
     * <dt><b>CWP_SKIPINVISIBLE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips invisible child windows
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CWP_SKIPTRANSPARENT"></a><a id="cwp_skiptransparent"></a><dl>
     * <dt><b>CWP_SKIPTRANSPARENT</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Skips transparent child windows
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is a handle to the first child window that contains 
     * 				the point and meets the criteria specified by <i>uFlags</i>. 
     * 				If the point is within the parent window but not within any child window that 
     * 				meets the criteria, the return value is a handle to the parent window. If the 
     * 				point lies outside the parent window or if the function fails, the return 
     * 				value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-childwindowfrompointex
     * @since windows5.0
     */
    static ChildWindowFromPointEx(hwnd, pt, flags) {
        result := DllCall("USER32.dll\ChildWindowFromPointEx", "ptr", hwnd, "ptr", pt, "uint", flags)
        return result
    }

    /**
     * Retrieves the 16-bit (**DWORD**) value at the specified offset into the extra window memor
     * @remarks
     * Reserve extra window memory by specifying a nonzero value in the <b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.
     * @param {Pointer<Void>} hWnd A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex 
     * @returns {Integer} If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowword
     */
    static GetWindowWord(hWnd, nIndex) {
        result := DllCall("USER32.dll\GetWindowWord", "ptr", hWnd, "int", nIndex, "ushort")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} hWnd 
     * @param {Integer} nIndex 
     * @param {Integer} wNewWord 
     * @returns {Integer} 
     */
    static SetWindowWord(hWnd, nIndex, wNewWord) {
        result := DllCall("USER32.dll\SetWindowWord", "ptr", hWnd, "int", nIndex, "ushort", wNewWord, "ushort")
        return result
    }

    /**
     * Retrieves information about the specified window. (GetWindowLongA)
     * @remarks
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> has not been called previously, <b>GetWindowLong</b> returns zero for values in the extra window or class memory.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlonga
     * @since windows5.0
     */
    static GetWindowLongA(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowLongA", "ptr", hWnd, "int", nIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified window. (GetWindowLongW)
     * @remarks
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowlonga">SetWindowLong</a> has not been called previously, <b>GetWindowLong</b> returns zero for values in the extra window or class memory.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowlongw
     * @since windows5.0
     */
    static GetWindowLongW(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowLongW", "ptr", hWnd, "int", nIndex, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window memory. (ANSI)
     * @remarks
     * Certain window data is cached, so changes you make using <b>SetWindowLong</b> will not take effect until you call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function. Specifically, if you change any of the frame styles, you must call <b>SetWindowPos</b> with the <b>SWP_FRAMECHANGED</b> flag for the cache to be updated properly. 
     * 
     * If you use <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * If you use <b>SetWindowLong</b> with the <b>DWL_MSGRESULT</b> index to set the return value for a message processed by a dialog procedure, you should return <b>TRUE</b> directly afterward. Otherwise, if you call any function that results in your dialog procedure receiving a window message, the nested window message could overwrite the return value you set using <b>DWL_MSGRESULT</b>. 
     * 
     * Calling <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The <b>SetWindowLong</b> function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>. This allows the application to create a chain of window procedures. 
     * 
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * You must not call <b>SetWindowLong</b> with the <b>GWL_HWNDPARENT</b> index to change the parent of a child window. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setparent">SetParent</a> function. 
     * 
     * If the window has a class style of <b>CS_CLASSDC</b> or <b>CS_OWNDC</b>, do not set the extended window styles <b>WS_EX_COMPOSITED</b> or <b>WS_EX_LAYERED</b>.
     * 
     * Calling <b>SetWindowLong</b> to set the style on a progressbar will reset its position.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Integer} dwNewLong Type: <b>LONG</b>
     * 
     * The replacement value.
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified 32-bit integer.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0 before calling <b>SetWindowLong</b>. Then, function failure will be indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlonga
     * @since windows5.0
     */
    static SetWindowLongA(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowLongA", "ptr", hWnd, "int", nIndex, "int", dwNewLong, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window memory. (Unicode)
     * @remarks
     * Certain window data is cached, so changes you make using <b>SetWindowLong</b> will not take effect until you call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowpos">SetWindowPos</a> function. Specifically, if you change any of the frame styles, you must call <b>SetWindowPos</b> with the <b>SWP_FRAMECHANGED</b> flag for the cache to be updated properly. 
     * 
     * If you use <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * If you use <b>SetWindowLong</b> with the <b>DWL_MSGRESULT</b> index to set the return value for a message processed by a dialog procedure, you should return <b>TRUE</b> directly afterward. Otherwise, if you call any function that results in your dialog procedure receiving a window message, the nested window message could overwrite the return value you set using <b>DWL_MSGRESULT</b>. 
     * 
     * Calling <b>SetWindowLong</b> with the <b>GWL_WNDPROC</b> index creates a subclass of the window class used to create the window. An application can subclass a system class, but should not subclass a window class created by another process. The <b>SetWindowLong</b> function creates the window subclass by changing the window procedure associated with a particular window class, causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new window procedure to the previous window procedure by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callwindowproca">CallWindowProc</a>. This allows the application to create a chain of window procedures. 
     * 
     * Reserve extra window memory by specifying a nonzero value in the 
     * 				<b>cbWndExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * You must not call <b>SetWindowLong</b> with the <b>GWL_HWNDPARENT</b> index to change the parent of a child window. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setparent">SetParent</a> function. 
     * 
     * If the window has a class style of <b>CS_CLASSDC</b> or <b>CS_OWNDC</b>, do not set the extended window styles <b>WS_EX_COMPOSITED</b> or <b>WS_EX_LAYERED</b>.
     * 
     * Calling <b>SetWindowLong</b> to set the style on a progressbar will reset its position.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Integer} dwNewLong Type: <b>LONG</b>
     * 
     * The replacement value.
     * @returns {Integer} Type: <b>LONG</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified 32-bit integer.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error information by calling <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> with 0 before calling <b>SetWindowLong</b>. Then, function failure will be indicated by a return value of zero and a <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> result that is nonzero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowlongw
     * @since windows5.0
     */
    static SetWindowLongW(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowLongW", "ptr", hWnd, "int", nIndex, "int", dwNewLong, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the specified window belongs.
     * @remarks
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * 
     * The zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of class memory, minus two; for example, if you specified 10 or more bytes of extra class memory, a value of eight would be an index to the fifth 16-bit integer. There is an additional valid value as shown in the following table. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GCW_ATOM"></a><a id="gcw_atom"></a><dl>
     * <dt><b>GCW_ATOM</b></dt>
     * <dt>-32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves an <b>ATOM</b> value that uniquely identifies the window class. This is the same atom that the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function returns.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>WORD</b>
     * 
     * If the function succeeds, the return value is the requested 16-bit value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassword
     * @since windows5.0
     */
    static GetClassWord(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetClassWord", "ptr", hWnd, "int", nIndex, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the specified window belongs.
     * @remarks
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassa">WNDCLASS</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> function.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * 
     * The zero-based byte offset of the value to be replaced. Valid values are in the range zero through the number of bytes of class memory minus two; for example, if you specified 10 or more bytes of extra class memory, a value of 8 would be an index to the fifth 16-bit integer.
     * @param {Integer} wNewWord Type: <b>WORD</b>
     * 
     * The replacement value.
     * @returns {Integer} Type: <b>WORD</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified 16-bit integer. If the value was not previously set, the return value is zero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setclassword
     * @since windows5.0
     */
    static SetClassWord(hWnd, nIndex, wNewWord) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetClassWord", "ptr", hWnd, "int", nIndex, "ushort", wNewWord, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the specified 32-bit (DWORD) value from the WNDCLASSEX structure associated with the specified window. (ANSI)
     * @remarks
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetClassLong as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclasslonga
     * @since windows5.0
     */
    static GetClassLongA(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetClassLongA", "ptr", hWnd, "int", nIndex, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the specified 32-bit (DWORD) value from the WNDCLASSEX structure associated with the specified window. (Unicode)
     * @remarks
     * Reserve extra class memory by specifying a nonzero value in the 
     * 				<b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetClassLong as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the requested value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclasslongw
     * @since windows5.0
     */
    static GetClassLongW(hWnd, nIndex) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetClassLongW", "ptr", hWnd, "int", nIndex, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces the specified 32-bit (long) value at the specified offset into the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs. (ANSI)
     * @remarks
     * If you use the <b>SetClassLong</b> function and the <b>GCL_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * Calling <b>SetClassLong</b> with the <b>GCL_WNDPROC</b> index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process. 
     * 
     * Reserve extra class memory by specifying a nonzero value in the <b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Use the <b>SetClassLong</b> function with care. For example, it is possible to change the background color for a class by using <b>SetClassLong</b>, but this change does not immediately repaint all windows belonging to the class.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Integer} dwNewLong Type: <b>LONG</b>
     * 
     * The replacement value.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified 32-bit integer. If the value was not previously set, the return value is zero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setclasslonga
     * @since windows5.0
     */
    static SetClassLongA(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetClassLongA", "ptr", hWnd, "int", nIndex, "int", dwNewLong, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces the specified 32-bit (long) value at the specified offset into the extra class memory or the WNDCLASSEX structure for the class to which the specified window belongs. (Unicode)
     * @remarks
     * If you use the <b>SetClassLong</b> function and the <b>GCL_WNDPROC</b> index to replace the window procedure, the window procedure must conform to the guidelines specified in the description of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)">WindowProc</a> callback function. 
     * 
     * Calling <b>SetClassLong</b> with the <b>GCL_WNDPROC</b> index creates a subclass of the window class that affects all windows subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another process. 
     * 
     * Reserve extra class memory by specifying a nonzero value in the <b>cbClsExtra</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-wndclassexa">WNDCLASSEX</a> structure used with the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. 
     * 
     * Use the <b>SetClassLong</b> function with care. For example, it is possible to change the background color for a class by using <b>SetClassLong</b>, but this change does not immediately repaint all windows belonging to the class.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Integer} nIndex Type: <b>int</b>
     * @param {Integer} dwNewLong Type: <b>LONG</b>
     * 
     * The replacement value.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the previous value of the specified 32-bit integer. If the value was not previously set, the return value is zero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setclasslongw
     * @since windows5.0
     */
    static SetClassLongW(hWnd, nIndex, dwNewLong) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetClassLongW", "ptr", hWnd, "int", nIndex, "int", dwNewLong, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the default layout that is used when windows are created with no parent or owner.
     * @remarks
     * The layout specifies how text and graphics are laid out in a window; the default is left to right. The <b>GetProcessDefaultLayout</b> function lets you know if the default layout has changed, from using <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setprocessdefaultlayout">SetProcessDefaultLayout</a>.
     * @param {Pointer<UInt32>} pdwDefaultLayout Type: <b>DWORD*</b>
     * 
     * The current default process layout. For a list of values, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setprocessdefaultlayout">SetProcessDefaultLayout</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getprocessdefaultlayout
     * @since windows5.0
     */
    static GetProcessDefaultLayout(pdwDefaultLayout) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetProcessDefaultLayout", "uint*", pdwDefaultLayout, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes the default layout when windows are created with no parent or owner only for the currently running process.
     * @remarks
     * The layout specifies how text and graphics are laid out; the default is left to right. The <b>SetProcessDefaultLayout</b> function changes layout to be right to left, which is the standard in Arabic and Hebrew cultures. 
     * 
     * After the <b>LAYOUT_RTL</b> flag is selected, flags normally specifying right or left are reversed. To avoid confusion, consider defining alternate words for standard flags, such as those in the following table.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Standard flag</th>
     * <th>Suggested alternate name</th>
     * </tr>
     * <tr>
     * <td><b>WS_EX_RIGHT</b></td>
     * <td><b>WS_EX_TRAILING</b></td>
     * </tr>
     * <tr>
     * <td><b>WS_EX_RTLREADING</b></td>
     * <td><b>WS_EX_REVERSEREADING</b></td>
     * </tr>
     * <tr>
     * <td><b>WS_EX_LEFTSCROLLBAR</b></td>
     * <td><b>WS_EX_LEADSCROLLBAR</b></td>
     * </tr>
     * <tr>
     * <td><b>ES_LEFT</b></td>
     * <td><b>ES_LEAD</b></td>
     * </tr>
     * <tr>
     * <td><b>ES_RIGHT</b></td>
     * <td><b>ES_TRAIL</b></td>
     * </tr>
     * <tr>
     * <td><b>EC_LEFTMARGIN</b></td>
     * <td><b>EC_LEADMARGIN</b></td>
     * </tr>
     * <tr>
     * <td><b>EC_RIGHTMARGIN</b></td>
     * <td><b>EC_TRAILMARGIN</b></td>
     * </tr>
     * </table>
     * 
     * 
     * If using this function with a mirrored window, note that the <b>SetProcessDefaultLayout</b> function does not mirror the whole process and all the device contexts (DCs) created in it. It mirrors only the mirrored window's DCs. To mirror any DC, use the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-setlayout">SetLayout</a> function.
     * @param {Integer} dwDefaultLayout Type: <b>DWORD</b>
     * 
     * The default process layout. This parameter can be 0 or the following value. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LAYOUT_RTL"></a><a id="layout_rtl"></a><dl>
     * <dt><b>LAYOUT_RTL</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the default horizontal layout to be right to left.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout
     * @since windows5.0
     */
    static SetProcessDefaultLayout(dwDefaultLayout) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetProcessDefaultLayout", "uint", dwDefaultLayout, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other windows are painted.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is a handle to the desktop window.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getdesktopwindow
     * @since windows5.0
     */
    static GetDesktopWindow() {
        result := DllCall("USER32.dll\GetDesktopWindow")
        return result
    }

    /**
     * Retrieves a handle to the specified window's parent or owner.
     * @remarks
     * To obtain a window's owner window, instead of using <b>GetParent</b>, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindow">GetWindow</a> with the <b>GW_OWNER</b> flag. To obtain the parent window and not the owner, instead of using <b>GetParent</b>, use <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getancestor">GetAncestor</a> with the <b>GA_PARENT</b> flag.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window whose parent window handle is to be retrieved.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the window is a child window, the return value is a handle to the parent window. If the window is a top-level window with the <b>WS_POPUP</b> style, the return value is a handle to the owner window. 
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * This function typically fails for one of the following reasons:
     * 
     * 
     * <ul>
     * <li>The window is a top-level window that is unowned or does not have the <b>WS_POPUP</b> style. </li>
     * <li>The owner window has <b>WS_POPUP</b> style.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getparent
     * @since windows5.0
     */
    static GetParent(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetParent", "ptr", hWnd)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Changes the parent window of the specified child window.
     * @remarks
     * An application can use the <b>SetParent</b> function to set the parent window of a pop-up, overlapped, or child window.
     * 
     * If the window identified by the <i>hWndChild</i> parameter is visible, the system performs the appropriate redrawing and repainting. 
     * 
     * For compatibility reasons, <b>SetParent</b> does not modify the <b>WS_CHILD</b> or <b>WS_POPUP</b> window styles of the window whose parent is being changed. Therefore, if <i>hWndNewParent</i> is <b>NULL</b>, you should also clear the <b>WS_CHILD</b> bit and set the <b>WS_POPUP</b> style after calling <b>SetParent</b>. Conversely, if <i>hWndNewParent</i> is not <b>NULL</b> and the window was previously a child of the desktop, you should clear the <b>WS_POPUP</b> style and set the <b>WS_CHILD</b> style before calling <b>SetParent</b>. 
     * 
     *  When you change the parent of a window, you should synchronize the UISTATE of both windows. For more information, see <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-changeuistate">WM_CHANGEUISTATE</a> and <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-updateuistate">WM_UPDATEUISTATE</a>. 
     * 
     * Unexpected behavior or errors may occur if <i>hWndNewParent</i> and <i>hWndChild</i> are running in different DPI awareness modes. The table below outlines this behavior:
     * 
     * <table>
     * <tr>
     * <th>Operation</th>
     * <th>Windows8.1</th>
     * <th>Windows 10 (1607 and earlier)</th>
     * <th>Windows 10 (1703 and later)</th>
     * </tr>
     * <tr>
     * <td>SetParent (In-Proc) </td>
     * <td>N/A </td>
     * <td><b>Forced reset</b> 
     * (of current process)</td>
     * <td><b>Fail</b> 
     * (ERROR_INVALID_STATE)</td>
     * </tr>
     * <tr>
     * <td>SetParent (Cross-Proc) </td>
     * <td><b>Forced reset</b> 
     * (of child window's process)</td>
     * <td><b>Forced reset</b> 
     * (of child window's process)</td>
     * <td><b>Forced reset</b> 
     * (of child window's process)</td>
     * </tr>
     * </table>
     * 
     * 
     *  For more information on DPI awareness, see <a href="https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows">the Windows High DPI documentation.</a>
     * @param {Pointer<Void>} hWndChild Type: <b>HWND</b>
     * 
     * A handle to the child window.
     * @param {Pointer<Void>} hWndNewParent Type: <b>HWND</b>
     * 
     * A handle to the new parent window. If this parameter is <b>NULL</b>, the desktop window becomes the new parent window. 
     * 					 If this parameter is <b>HWND_MESSAGE</b>, the child window becomes a <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only window</a>.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the previous parent window.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setparent
     * @since windows5.0
     */
    static SetParent(hWndChild, hWndNewParent) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetParent", "ptr", hWndChild, "ptr", hWndNewParent)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function.
     * @remarks
     * If a child window has created child windows of its own, <b>EnumChildWindows</b> enumerates those windows as well. 
     * 
     * A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The function does not enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the parent window whose child windows are to be enumerated. If this parameter is <b>NULL</b>, this function is equivalent to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumwindows">EnumWindows</a>.
     * @param {Pointer<WNDENUMPROC>} lpEnumFunc Type: <b>WNDENUMPROC</b>
     * 
     * A pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633493(v=vs.85)">EnumChildProc</a>.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * An application-defined value to be passed to the callback function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The return value is not used.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumchildwindows
     * @since windows5.0
     */
    static EnumChildWindows(hWndParent, lpEnumFunc, lParam) {
        result := DllCall("USER32.dll\EnumChildWindows", "ptr", hWndParent, "ptr", lpEnumFunc, "ptr", lParam, "int")
        return result
    }

    /**
     * Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search. (ANSI)
     * @remarks
     * If the <i>lpWindowName</i> parameter is not <b>NULL</b>, <b>FindWindow</b> calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> function to retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks for <b>GetWindowText</b>.
     * @param {Pointer<Byte>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * The class name or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. 
     * 
     * If <i>lpClassName</i> points to a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names. 
     * 
     * If <i>lpClassName</i> is <b>NULL</b>, it finds any window whose title matches the <i>lpWindowName</i> parameter.
     * @param {Pointer<Byte>} lpWindowName Type: <b>LPCTSTR</b>
     * 
     * The window name (the window's title). If this parameter is <b>NULL</b>, all window names match.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the window that has the specified class name and window name.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-findwindowa
     * @since windows5.0
     */
    static FindWindowA(lpClassName, lpWindowName) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName
        lpWindowName := lpWindowName is String? StrPtr(lpWindowName) : lpWindowName

        A_LastError := 0

        result := DllCall("USER32.dll\FindWindowA", "ptr", lpClassName, "ptr", lpWindowName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows. This function does not perform a case-sensitive search. (Unicode)
     * @remarks
     * If the <i>lpWindowName</i> parameter is not <b>NULL</b>, <b>FindWindow</b> calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> function to retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks for <b>GetWindowText</b>.
     * @param {Pointer<Char>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * The class name or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be in the low-order word of <i>lpClassName</i>; the high-order word must be zero. 
     * 
     * If <i>lpClassName</i> points to a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names. 
     * 
     * If <i>lpClassName</i> is <b>NULL</b>, it finds any window whose title matches the <i>lpWindowName</i> parameter.
     * @param {Pointer<Char>} lpWindowName Type: <b>LPCTSTR</b>
     * 
     * The window name (the window's title). If this parameter is <b>NULL</b>, all window names match.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the window that has the specified class name and window name.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-findwindoww
     * @since windows5.0
     */
    static FindWindowW(lpClassName, lpWindowName) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName
        lpWindowName := lpWindowName is String? StrPtr(lpWindowName) : lpWindowName

        A_LastError := 0

        result := DllCall("USER32.dll\FindWindowW", "ptr", lpClassName, "ptr", lpWindowName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows, beginning with the one following the specified child window. This function does not perform a case-sensitive search. (ANSI)
     * @remarks
     * The FindWindowEx function searches only direct child windows. It does not search other descendants.
     * 
     * If the <i>lpszWindow</i> parameter is not <b>NULL</b>, <b>FindWindowEx</b> calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> function to retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks section of <b>GetWindowText</b>.
     * 
     * An application can call this function in the following way.
     * 
     * <c>FindWindowEx( NULL, NULL, MAKEINTATOM(0x8000), NULL );</c>
     * 
     * Note that 0x8000 is the atom for a menu class. When an application calls this function, the function checks whether a context menu is being displayed that the application created.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines FindWindowEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the parent window whose child windows are to be searched.
     * 
     * If <i>hwndParent</i> is <b>NULL</b>, the function uses the desktop window as the parent window. The function searches among windows that are child windows of the desktop. 
     * 
     * If <i>hwndParent</i> is <b>HWND_MESSAGE</b>, the function searches all <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only windows</a>.
     * @param {Pointer<Void>} hWndChildAfter Type: <b>HWND</b>
     * 
     * A handle to a child window. The search begins with the next child window in the Z order. The child window must be a direct child window of <i>hwndParent</i>, not just a descendant window. 
     * 
     * If <i>hwndChildAfter</i> is <b>NULL</b>, the search begins with the first child window of <i>hwndParent</i>. 
     * 
     * Note that if both <i>hwndParent</i> and <i>hwndChildAfter</i> are <b>NULL</b>, the function searches all top-level and message-only windows.
     * @param {Pointer<Byte>} lpszClass Type: <b>LPCTSTR</b>
     * 
     * The class name or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be placed in the low-order word of <i>lpszClass</i>; the high-order word must be zero.
     * 
     *  If <i>lpszClass</i> is a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names, or it can be <c>MAKEINTATOM(0x8000)</c>. In this latter case, 0x8000 is the atom for a menu class. For more information, see the Remarks section of this topic.
     * @param {Pointer<Byte>} lpszWindow Type: <b>LPCTSTR</b>
     * 
     * The window name (the window's title). If this parameter is <b>NULL</b>, all window names match.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the window that has the specified class and window names.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-findwindowexa
     * @since windows5.0
     */
    static FindWindowExA(hWndParent, hWndChildAfter, lpszClass, lpszWindow) {
        lpszClass := lpszClass is String? StrPtr(lpszClass) : lpszClass
        lpszWindow := lpszWindow is String? StrPtr(lpszWindow) : lpszWindow

        A_LastError := 0

        result := DllCall("USER32.dll\FindWindowExA", "ptr", hWndParent, "ptr", hWndChildAfter, "ptr", lpszClass, "ptr", lpszWindow)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows, beginning with the one following the specified child window. This function does not perform a case-sensitive search. (Unicode)
     * @remarks
     * The FindWindowEx function searches only direct child windows. It does not search other descendants.
     * 
     * If the <i>lpszWindow</i> parameter is not <b>NULL</b>, <b>FindWindowEx</b> calls the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> function to retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks section of <b>GetWindowText</b>.
     * 
     * An application can call this function in the following way.
     * 
     * <c>FindWindowEx( NULL, NULL, MAKEINTATOM(0x8000), NULL );</c>
     * 
     * Note that 0x8000 is the atom for a menu class. When an application calls this function, the function checks whether a context menu is being displayed that the application created.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines FindWindowEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the parent window whose child windows are to be searched.
     * 
     * If <i>hwndParent</i> is <b>NULL</b>, the function uses the desktop window as the parent window. The function searches among windows that are child windows of the desktop. 
     * 
     * If <i>hwndParent</i> is <b>HWND_MESSAGE</b>, the function searches all <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">message-only windows</a>.
     * @param {Pointer<Void>} hWndChildAfter Type: <b>HWND</b>
     * 
     * A handle to a child window. The search begins with the next child window in the Z order. The child window must be a direct child window of <i>hwndParent</i>, not just a descendant window. 
     * 
     * If <i>hwndChildAfter</i> is <b>NULL</b>, the search begins with the first child window of <i>hwndParent</i>. 
     * 
     * Note that if both <i>hwndParent</i> and <i>hwndChildAfter</i> are <b>NULL</b>, the function searches all top-level and message-only windows.
     * @param {Pointer<Char>} lpszClass Type: <b>LPCTSTR</b>
     * 
     * The class name or a class atom created by a previous call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function. The atom must be placed in the low-order word of <i>lpszClass</i>; the high-order word must be zero.
     * 
     *  If <i>lpszClass</i> is a string, it specifies the window class name. The class name can be any name registered with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassa">RegisterClass</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a>, or any of the predefined control-class names, or it can be <c>MAKEINTATOM(0x8000)</c>. In this latter case, 0x8000 is the atom for a menu class. For more information, see the Remarks section of this topic.
     * @param {Pointer<Char>} lpszWindow Type: <b>LPCTSTR</b>
     * 
     * The window name (the window's title). If this parameter is <b>NULL</b>, all window names match.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the window that has the specified class and window names.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-findwindowexw
     * @since windows5.0
     */
    static FindWindowExW(hWndParent, hWndChildAfter, lpszClass, lpszWindow) {
        lpszClass := lpszClass is String? StrPtr(lpszClass) : lpszClass
        lpszWindow := lpszWindow is String? StrPtr(lpszWindow) : lpszWindow

        A_LastError := 0

        result := DllCall("USER32.dll\FindWindowExW", "ptr", hWndParent, "ptr", hWndChildAfter, "ptr", lpszClass, "ptr", lpszWindow)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a handle to the Shell's desktop window.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is the handle of the Shell's desktop window. If no Shell process is present, the return value is <b>NULL</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getshellwindow
     * @since windows5.0
     */
    static GetShellWindow() {
        result := DllCall("USER32.dll\GetShellWindow")
        return result
    }

    /**
     * Registers a specified Shell window to receive certain messages for events or notifications that are useful to Shell applications.
     * @remarks
     * As with normal window messages, the second parameter of the window procedure identifies the message as a <b>WM_SHELLHOOKMESSAGE</b>. However, for these Shell hook messages, the message value is not a pre-defined constant like other message IDs such as <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a>. The value must be obtained dynamically using a call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> as shown here:
     * 
     *                 
     * 
     * <c>RegisterWindowMessage(TEXT("SHELLHOOK"));</c>
     * 
     * This precludes handling these messages using a traditional switch statement which requires  ID values that are known at compile time.  For handling Shell hook messages, the normal practice is to code an If statement in the default section of your switch statement and then handle the message if the value of the message ID is the same as the value
     * obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerwindowmessagea">RegisterWindowMessage</a> call.
     * 
     * The following table describes the <i>wParam</i> and <i>lParam</i> parameter values passed to the window procedure for the Shell hook messages.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>wParam</th>
     * <th>lParam</th>
     * </tr>
     * <tr>
     * <td><b>HSHELL_GETMINRECT</b></td>
     * <td>A pointer to a <b>SHELLHOOKINFO</b> structure.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_WINDOWACTIVATED</b></td>
     * <td>A handle to the activated window.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_RUDEAPPACTIVATED</b></td>
     * <td>A handle to the activated window.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_WINDOWREPLACING</b></td>
     * <td>A handle to the window replacing the top-level window.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_WINDOWREPLACED</b></td>
     * <td>A handle to the window being replaced.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_WINDOWCREATED</b></td>
     * <td>A handle to the window being created.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_WINDOWDESTROYED</b></td>
     * <td>A handle to the top-level window being destroyed.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_ACTIVATESHELLWINDOW</b></td>
     * <td>Not used.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_TASKMAN</b></td>
     * <td>Can be ignored.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_REDRAW</b></td>
     * <td>A handle to the window that needs to be redrawn.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_FLASH</b></td>
     * <td>A handle to the window that needs to be flashed.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_ENDTASK</b></td>
     * <td>A handle to the window that should be forced to exit.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_APPCOMMAND</b></td>
     * <td>The APPCOMMAND which has been unhandled by the application or other hooks. See <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-appcommand">WM_APPCOMMAND</a> and use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-get_appcommand_lparam">GET_APPCOMMAND_LPARAM</a> macro to retrieve this parameter.</td>
     * </tr>
     * <tr>
     * <td><b>HSHELL_MONITORCHANGED                     </b></td>
     * <td>A handle to the window that moved to a different monitor.</td>
     * </tr>
     * </table>
     * 
     * 
     * This function was not included in the SDK headers and libraries until WindowsXP with Service Pack1 (SP1) and Windows Server2003. If you do not have a header file and import library for this function, you can call the function using <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window to register for Shell hook messages.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the function succeeds; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registershellhookwindow
     * @since windows5.0
     */
    static RegisterShellHookWindow(hwnd) {
        result := DllCall("USER32.dll\RegisterShellHookWindow", "ptr", hwnd, "int")
        return result
    }

    /**
     * Unregisters a specified Shell window that is registered to receive Shell hook messages.
     * @remarks
     * This function was not included in the SDK headers and libraries until WindowsXP with Service Pack1 (SP1) and Windows Server2003. If you do not have a header file and import library for this function, you can call the function using <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window to be unregistered. The window was registered with a call to the
     * 		<a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registershellhookwindow">RegisterShellHookWindow</a> function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the function succeeds; <b>FALSE</b> if the
     * 				function fails.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-deregistershellhookwindow
     * @since windows5.0
     */
    static DeregisterShellHookWindow(hwnd) {
        result := DllCall("USER32.dll\DeregisterShellHookWindow", "ptr", hwnd, "int")
        return result
    }

    /**
     * Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE.
     * @remarks
     * The <b>EnumWindows</b> function does not enumerate child windows, with the exception of a few top-level windows owned by the system that have the <b>WS_CHILD</b> style.
     * 
     * This function is more reliable than calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindow">GetWindow</a> function in a loop. An application that calls <b>GetWindow</b> to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed. 
     * 
     * <div class="alert"><b>Note</b>For Windows8 and later, <b>EnumWindows</b> enumerates only top-level windows of desktop apps.</div>
     * <div></div>
     * @param {Pointer<WNDENUMPROC>} lpEnumFunc Type: <b>WNDENUMPROC</b>
     * 
     * A pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633498(v=vs.85)">EnumWindowsProc</a>.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * An application-defined value to be passed to the callback function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633498(v=vs.85)">EnumWindowsProc</a> returns zero, the return value is also zero. In this case, the callback function should call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> to obtain a meaningful error code to be returned to the caller of <b>EnumWindows</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumwindows
     * @since windows5.0
     */
    static EnumWindows(lpEnumFunc, lParam) {
        A_LastError := 0

        result := DllCall("USER32.dll\EnumWindows", "ptr", lpEnumFunc, "ptr", lParam, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback function.
     * @param {Integer} dwThreadId Type: <b>DWORD</b>
     * 
     * The identifier of the thread whose windows are to be enumerated.
     * @param {Pointer<WNDENUMPROC>} lpfn Type: <b>WNDENUMPROC</b>
     * 
     * A pointer to an application-defined callback function. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms633496(v=vs.85)">EnumThreadWndProc</a>.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * An application-defined value to be passed to the callback function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the callback function returns <b>TRUE</b> for all windows in the thread specified by <i>dwThreadId</i>, the return value is <b>TRUE</b>. If the callback function returns <b>FALSE</b> on any enumerated window, or if there are no windows found in the thread specified by <i>dwThreadId</i>, the return value is <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-enumthreadwindows
     * @since windows5.0
     */
    static EnumThreadWindows(dwThreadId, lpfn, lParam) {
        result := DllCall("USER32.dll\EnumThreadWindows", "uint", dwThreadId, "ptr", lpfn, "ptr", lParam, "int")
        return result
    }

    /**
     * Retrieves the name of the class to which the specified window belongs. (GetClassNameA)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetClassName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Pointer<Byte>} lpClassName Type: <b>LPTSTR</b>
     * 
     * The class name string.
     * @param {Integer} nMaxCount Type: <b>int</b>
     * 
     * The length of the *lpClassName* buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to `nMaxCount-1` characters.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the number of 
     * 						characters copied to the buffer, not including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassnamea
     * @since windows5.0
     */
    static GetClassNameA(hWnd, lpClassName, nMaxCount) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName

        A_LastError := 0

        result := DllCall("USER32.dll\GetClassNameA", "ptr", hWnd, "ptr", lpClassName, "int", nMaxCount)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the name of the class to which the specified window belongs. (GetClassNameW)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetClassName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window and, indirectly, the class to which the window belongs.
     * @param {Pointer<Char>} lpClassName Type: <b>LPTSTR</b>
     * 
     * The class name string.
     * @param {Integer} nMaxCount Type: <b>int</b>
     * 
     * The length of the *lpClassName* buffer, in characters. The buffer must be large enough to include the terminating null character; otherwise, the class name string is truncated to `nMaxCount-1` characters.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the number of 
     * 						characters copied to the buffer, not including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getclassnamew
     * @since windows5.0
     */
    static GetClassNameW(hWnd, lpClassName, nMaxCount) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName

        A_LastError := 0

        result := DllCall("USER32.dll\GetClassNameW", "ptr", hWnd, "ptr", lpClassName, "int", nMaxCount)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Examines the Z order of the child windows associated with the specified parent window and retrieves a handle to the child window at the top of the Z order.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the parent window whose child windows are to be examined. If this parameter is <b>NULL</b>, the function returns a handle to the window at the top of the Z order.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a handle to the child window at the top of the Z order. If the specified window has no child windows, the return value is <b>NULL</b>. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-gettopwindow
     * @since windows5.0
     */
    static GetTopWindow(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetTopWindow", "ptr", hWnd)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window.
     * @param {Pointer<UInt32>} lpdwProcessId Type: <b>LPDWORD</b>
     * 
     * A pointer to a variable that receives the process identifier. If this parameter is not <b>NULL</b>, <b>GetWindowThreadProcessId</b> copies the identifier of the process to the variable; otherwise, it does not. If the function fails, the value of the variable is unchanged.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the identifier of the thread that created the window. If the window handle is invalid, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowthreadprocessid
     * @since windows5.0
     */
    static GetWindowThreadProcessId(hWnd, lpdwProcessId) {
        result := DllCall("USER32.dll\GetWindowThreadProcessId", "ptr", hWnd, "uint*", lpdwProcessId, "uint")
        return result
    }

    /**
     * Determines whether the calling thread is already a GUI thread. It can also optionally convert the thread to a GUI thread.
     * @param {Integer} bConvert Type: <b>BOOL</b>
     * 
     * If <b>TRUE</b> and the thread is not a GUI thread, convert the thread to a GUI thread.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * The function returns a nonzero value in the following situations: 
     * 
     * <ul>
     * <li>If the calling thread is already a GUI thread.</li>
     * <li>If <i>bConvert</i> is <b>TRUE</b> and the function successfully converts the thread to a GUI thread.</li>
     * </ul>
     * Otherwise, the function returns zero.
     * 
     * If <i>bConvert</i> is <b>TRUE</b> and the function cannot successfully convert the thread to a GUI thread,  <b>IsGUIThread</b> returns <b>ERROR_NOT_ENOUGH_MEMORY</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-isguithread
     * @since windows5.1.2600
     */
    static IsGUIThread(bConvert) {
        result := DllCall("USER32.dll\IsGUIThread", "int", bConvert, "int")
        return result
    }

    /**
     * Determines which pop-up window owned by the specified window was most recently active.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the owner window.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value identifies the most recently active pop-up window. The return value is the same as the <i>hWnd</i> parameter, if any of the following conditions are met: 
     * 
     * <ul>
     * <li>The window identified by hWnd was most recently active.</li>
     * <li>The window identified by hWnd does not own any pop-up windows.</li>
     * <li>The window identifies by hWnd is not a top-level window, or it is owned by another window.</li>
     * </ul>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getlastactivepopup
     * @since windows5.0
     */
    static GetLastActivePopup(hWnd) {
        result := DllCall("USER32.dll\GetLastActivePopup", "ptr", hWnd)
        return result
    }

    /**
     * Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-enumchildwindows">EnumChildWindows</a> function is more reliable than calling <b>GetWindow</b> in a loop. An application that calls <b>GetWindow</b> to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to a window. The window handle retrieved is relative to this window, based on the value of the <i>uCmd</i> parameter.
     * @param {Integer} uCmd Type: <b>UINT</b>
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the specified window, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindow
     * @since windows5.0
     */
    static GetWindow(hWnd, uCmd) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindow", "ptr", hWnd, "uint", uCmd)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Integer} nFilterType 
     * @param {Pointer<HOOKPROC>} pfnFilterProc 
     * @returns {Pointer<Void>} 
     */
    static SetWindowsHookA(nFilterType, pfnFilterProc) {
        result := DllCall("USER32.dll\SetWindowsHookA", "int", nFilterType, "ptr", pfnFilterProc)
        return result
    }

    /**
     * 
     * @param {Integer} nFilterType 
     * @param {Pointer<HOOKPROC>} pfnFilterProc 
     * @returns {Pointer<Void>} 
     */
    static SetWindowsHookW(nFilterType, pfnFilterProc) {
        result := DllCall("USER32.dll\SetWindowsHookW", "int", nFilterType, "ptr", pfnFilterProc)
        return result
    }

    /**
     * 
     * @param {Integer} nCode 
     * @param {Pointer<HOOKPROC>} pfnFilterProc 
     * @returns {Integer} 
     */
    static UnhookWindowsHook(nCode, pfnFilterProc) {
        result := DllCall("USER32.dll\UnhookWindowsHook", "int", nCode, "ptr", pfnFilterProc, "int")
        return result
    }

    /**
     * Installs an application-defined hook procedure into a hook chain. (ANSI)
     * @remarks
     * <b>SetWindowsHookEx</b> can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call <b>SetWindowsHookEx</b> to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call <b>SetWindowsHookEx</b> to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.
     *         
     * 
     * Because hooks run in the context of an application, they must match the "bitness" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as "hooked." However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called <b>SetWindowsHookEx</b>. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.
     *  
     * 
     * 
     * If a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.
     *  
     * 
     * 
     * To hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.
     * 
     * 
     * An error may occur if the <i>hMod</i> parameter is <b>NULL</b> and the <i>dwThreadId</i> parameter is zero or specifies the identifier of a thread created by another process. 
     * 
     * Calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callnexthookex">CallNextHookEx</a> function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call <b>CallNextHookEx</b> unless you absolutely need to prevent the notification from being seen by other applications. 
     * 
     * Before terminating, an application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unhookwindowshookex">UnhookWindowsHookEx</a> function to free system resources associated with the hook. 
     * 
     * The scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table. 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Hook</th>
     * <th>Scope</th>
     * </tr>
     * <tr>
     * <td><b>WH_CALLWNDPROC</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_CALLWNDPROCRET</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_CBT</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_DEBUG</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_FOREGROUNDIDLE</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_GETMESSAGE</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_JOURNALPLAYBACK</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_JOURNALRECORD</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_KEYBOARD</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_KEYBOARD_LL</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_MOUSE</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_MOUSE_LL</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_MSGFILTER</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_SHELL</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_SYSMSGFILTER</b></td>
     * <td>Global only</td>
     * </tr>
     * </table>
     * 
     * 
     * For a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.
     * 
     * The global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure. 
     * 
     * <b>Windows Store app development</b> If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:
     * 
     * <ul>
     * <li>WH_JOURNALPLAYBACK</li>
     * <li>WH_JOURNALRECORD
     * 
     * </li>
     * <li>WH_KEYBOARD
     * 
     * </li>
     * <li>WH_KEYBOARD_LL
     * 
     * </li>
     * <li>WH_MOUSE
     * 
     * </li>
     * <li>WH_MOUSE_LL
     * 
     * </li>
     * </ul>
     * This behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.
     * @param {Integer} idHook Type: <b>int</b>
     * @param {Pointer<HOOKPROC>} lpfn Type: <b>HOOKPROC</b>
     * 
     * A pointer to the hook procedure. If the <i>dwThreadId</i> parameter is zero or specifies the identifier of a thread created by a different process, the <i>lpfn</i> parameter must point to a hook procedure in a DLL. Otherwise, <i>lpfn</i> can point to a hook procedure in the code associated with the current process.
     * @param {Pointer<Void>} hmod Type: <b>HINSTANCE</b>
     * 
     * A handle to the DLL containing the hook procedure pointed to by the <i>lpfn</i> parameter. The <i>hMod</i> parameter must be set to <b>NULL</b> if the <i>dwThreadId</i> parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.
     * @param {Integer} dwThreadId Type: <b>DWORD</b>
     * 
     * The identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.
     * @returns {Pointer<Void>} Type: <b>HHOOK</b>
     * 
     * If the function succeeds, the return value is the handle to the hook procedure. 
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowshookexa
     * @since windows5.0
     */
    static SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowsHookExA", "int", idHook, "ptr", lpfn, "ptr", hmod, "uint", dwThreadId)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Installs an application-defined hook procedure into a hook chain. (Unicode)
     * @remarks
     * <b>SetWindowsHookEx</b> can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call <b>SetWindowsHookEx</b> to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call <b>SetWindowsHookEx</b> to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.
     *         
     * 
     * Because hooks run in the context of an application, they must match the "bitness" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as "hooked." However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called <b>SetWindowsHookEx</b>. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.
     *  
     * 
     * 
     * If a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.
     *  
     * 
     * 
     * To hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.
     * 
     * 
     * An error may occur if the <i>hMod</i> parameter is <b>NULL</b> and the <i>dwThreadId</i> parameter is zero or specifies the identifier of a thread created by another process. 
     * 
     * Calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-callnexthookex">CallNextHookEx</a> function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call <b>CallNextHookEx</b> unless you absolutely need to prevent the notification from being seen by other applications. 
     * 
     * Before terminating, an application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-unhookwindowshookex">UnhookWindowsHookEx</a> function to free system resources associated with the hook. 
     * 
     * The scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table. 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Hook</th>
     * <th>Scope</th>
     * </tr>
     * <tr>
     * <td><b>WH_CALLWNDPROC</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_CALLWNDPROCRET</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_CBT</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_DEBUG</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_FOREGROUNDIDLE</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_GETMESSAGE</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_JOURNALPLAYBACK</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_JOURNALRECORD</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_KEYBOARD</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_KEYBOARD_LL</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_MOUSE</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_MOUSE_LL</b></td>
     * <td>Global only</td>
     * </tr>
     * <tr>
     * <td><b>WH_MSGFILTER</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_SHELL</b></td>
     * <td>Thread or global</td>
     * </tr>
     * <tr>
     * <td><b>WH_SYSMSGFILTER</b></td>
     * <td>Global only</td>
     * </tr>
     * </table>
     * 
     * 
     * For a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.
     * 
     * The global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure. 
     * 
     * <b>Windows Store app development</b> If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:
     * 
     * <ul>
     * <li>WH_JOURNALPLAYBACK</li>
     * <li>WH_JOURNALRECORD
     * 
     * </li>
     * <li>WH_KEYBOARD
     * 
     * </li>
     * <li>WH_KEYBOARD_LL
     * 
     * </li>
     * <li>WH_MOUSE
     * 
     * </li>
     * <li>WH_MOUSE_LL
     * 
     * </li>
     * </ul>
     * This behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.
     * @param {Integer} idHook Type: <b>int</b>
     * @param {Pointer<HOOKPROC>} lpfn Type: <b>HOOKPROC</b>
     * 
     * A pointer to the hook procedure. If the <i>dwThreadId</i> parameter is zero or specifies the identifier of a thread created by a different process, the <i>lpfn</i> parameter must point to a hook procedure in a DLL. Otherwise, <i>lpfn</i> can point to a hook procedure in the code associated with the current process.
     * @param {Pointer<Void>} hmod Type: <b>HINSTANCE</b>
     * 
     * A handle to the DLL containing the hook procedure pointed to by the <i>lpfn</i> parameter. The <i>hMod</i> parameter must be set to <b>NULL</b> if the <i>dwThreadId</i> parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.
     * @param {Integer} dwThreadId Type: <b>DWORD</b>
     * 
     * The identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.
     * @returns {Pointer<Void>} Type: <b>HHOOK</b>
     * 
     * If the function succeeds, the return value is the handle to the hook procedure. 
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setwindowshookexw
     * @since windows5.0
     */
    static SetWindowsHookExW(idHook, lpfn, hmod, dwThreadId) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetWindowsHookExW", "int", idHook, "ptr", lpfn, "ptr", hmod, "uint", dwThreadId)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function.
     * @remarks
     * The hook procedure can be in the state of being called by another thread even after <b>UnhookWindowsHookEx</b> returns. If the hook procedure is not being called concurrently, the hook procedure is removed immediately before <b>UnhookWindowsHookEx</b> returns.
     * @param {Pointer<Void>} hhk Type: <b>HHOOK</b>
     * 
     * A handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setwindowshookexa">SetWindowsHookEx</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-unhookwindowshookex
     * @since windows5.0
     */
    static UnhookWindowsHookEx(hhk) {
        A_LastError := 0

        result := DllCall("USER32.dll\UnhookWindowsHookEx", "ptr", hhk, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either before or after processing the hook information.
     * @remarks
     * Hook procedures are installed in chains for particular hook types. <b>CallNextHookEx</b> calls the next hook in the chain. 
     * 
     * Calling <b>CallNextHookEx</b> is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call <b>CallNextHookEx</b> unless you absolutely need to prevent the notification from being seen by other applications.
     * @param {Pointer<Void>} hhk Type: <b>HHOOK</b>
     * 
     * This parameter is ignored.
     * @param {Integer} nCode Type: <b>int</b>
     * 
     * The hook code passed to the current hook procedure. The next hook procedure uses this code to determine how to process the hook information.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * The <i>wParam</i> value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * The <i>lParam</i> value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * This value is returned by the next hook procedure in the chain. The current hook procedure must also return this value. The meaning of the return value depends on the hook type. For more information, see the descriptions of the individual hook procedures.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-callnexthookex
     * @since windows5.0
     */
    static CallNextHookEx(hhk, nCode, wParam, lParam) {
        result := DllCall("USER32.dll\CallNextHookEx", "ptr", hhk, "int", nCode, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Checks a specified menu item and makes it a radio item. At the same time, the function clears all other menu items in the associated group and clears the radio-item type flag for those items.
     * @remarks
     * The <b>CheckMenuRadioItem</b> function sets the <b>MFT_RADIOCHECK</b> type flag and the <b>MFS_CHECKED</b> state for the item specified by <i>idCheck</i> and, at the same time, clears both flags for all other items in the group. The selected item is displayed using a bullet bitmap instead of a check-mark bitmap.
     * 
     * For more information about menu item type and state flags, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menuiteminfoa">MENUITEMINFO</a> structure.
     * @param {Pointer<Void>} hmenu Type: <b>HMENU</b>
     * 
     * A handle to the menu that contains the group of menu items.
     * @param {Integer} first Type: <b>UINT</b>
     * 
     * The identifier or position of the first menu item in the group.
     * @param {Integer} last Type: <b>UINT</b>
     * 
     * The identifier or position of the last menu item in the group.
     * @param {Integer} check Type: <b>UINT</b>
     * 
     * The identifier or position of the menu item to check.
     * @param {Integer} flags Type: <b>UINT</b>
     * 
     * Indicates the meaning of <i>idFirst</i>, <i>idLast</i>, and <i>idCheck</i>. If this parameter is <b>MF_BYCOMMAND</b>, the other parameters specify menu item identifiers. If it is <b>MF_BYPOSITION</b>, the other parameters specify the menu item positions.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-checkmenuradioitem
     * @since windows5.0
     */
    static CheckMenuRadioItem(hmenu, first, last, check, flags) {
        A_LastError := 0

        result := DllCall("USER32.dll\CheckMenuRadioItem", "ptr", hmenu, "uint", first, "uint", last, "uint", check, "uint", flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified cursor resource from the executable (.EXE) file associated with an application instance. (ANSI)
     * @remarks
     * The <b>LoadCursor</b> function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the existing resource. This function returns a valid cursor handle only if the <i>lpCursorName</i> parameter is a pointer to a cursor resource. If <i>lpCursorName</i> is a pointer to any type of resource other than a cursor (such as an icon), the return value is not <b>NULL</b>, even though it is not a valid cursor handle. 
     * 
     * The <b>LoadCursor</b> function searches the cursor resource most appropriate for the cursor for the current display device. The cursor resource can be a color or monochrome bitmap. 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to an instance of the module whose executable file contains the cursor to be loaded.
     * @param {Pointer<Byte>} lpCursorName Type: <b>LPCTSTR</b>
     * 
     * The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro can also be used to create this value. To use one of the predefined cursors, the application must set the <i>hInstance</i> parameter to <b>NULL</b> and the <i>lpCursorName</i> parameter to one the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_APPSTARTING"></a><a id="idc_appstarting"></a><dl>
     * <dt><b>IDC_APPSTARTING</b></dt>
     * <dt>MAKEINTRESOURCE(32650)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Standard arrow and small hourglass
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_ARROW"></a><a id="idc_arrow"></a><dl>
     * <dt><b>IDC_ARROW</b></dt>
     * <dt>MAKEINTRESOURCE(32512)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Standard arrow
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_CROSS"></a><a id="idc_cross"></a><dl>
     * <dt><b>IDC_CROSS</b></dt>
     * <dt>MAKEINTRESOURCE(32515)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Crosshair
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_HAND"></a><a id="idc_hand"></a><dl>
     * <dt><b>IDC_HAND</b></dt>
     * <dt>MAKEINTRESOURCE(32649)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Hand
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_HELP"></a><a id="idc_help"></a><dl>
     * <dt><b>IDC_HELP</b></dt>
     * <dt>MAKEINTRESOURCE(32651)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Arrow and question mark
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_IBEAM"></a><a id="idc_ibeam"></a><dl>
     * <dt><b>IDC_IBEAM</b></dt>
     * <dt>MAKEINTRESOURCE(32513)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * I-beam
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_ICON"></a><a id="idc_icon"></a><dl>
     * <dt><b>IDC_ICON</b></dt>
     * <dt>MAKEINTRESOURCE(32641)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obsolete for applications marked version 4.0 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_NO"></a><a id="idc_no"></a><dl>
     * <dt><b>IDC_NO</b></dt>
     * <dt>MAKEINTRESOURCE(32648)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Slashed circle
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZE"></a><a id="idc_size"></a><dl>
     * <dt><b>IDC_SIZE</b></dt>
     * <dt>MAKEINTRESOURCE(32640)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obsolete for applications marked version 4.0 or later. Use <b>IDC_SIZEALL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZEALL"></a><a id="idc_sizeall"></a><dl>
     * <dt><b>IDC_SIZEALL</b></dt>
     * <dt>MAKEINTRESOURCE(32646)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Four-pointed arrow pointing north, south, east, and west
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZENESW"></a><a id="idc_sizenesw"></a><dl>
     * <dt><b>IDC_SIZENESW</b></dt>
     * <dt>MAKEINTRESOURCE(32643)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing northeast and southwest
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZENS"></a><a id="idc_sizens"></a><dl>
     * <dt><b>IDC_SIZENS</b></dt>
     * <dt>MAKEINTRESOURCE(32645)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing north and south
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZENWSE"></a><a id="idc_sizenwse"></a><dl>
     * <dt><b>IDC_SIZENWSE</b></dt>
     * <dt>MAKEINTRESOURCE(32642)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing northwest and southeast
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZEWE"></a><a id="idc_sizewe"></a><dl>
     * <dt><b>IDC_SIZEWE</b></dt>
     * <dt>MAKEINTRESOURCE(32644)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing west and east
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_UPARROW"></a><a id="idc_uparrow"></a><dl>
     * <dt><b>IDC_UPARROW</b></dt>
     * <dt>MAKEINTRESOURCE(32516)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Vertical arrow
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_WAIT"></a><a id="idc_wait"></a><dl>
     * <dt><b>IDC_WAIT</b></dt>
     * <dt>MAKEINTRESOURCE(32514)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Hourglass
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} Type: <b>HCURSOR</b>
     * 
     * If the function succeeds, the return value is the handle to the newly loaded cursor.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursora
     * @since windows5.0
     */
    static LoadCursorA(hInstance, lpCursorName) {
        lpCursorName := lpCursorName is String? StrPtr(lpCursorName) : lpCursorName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadCursorA", "ptr", hInstance, "ptr", lpCursorName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified cursor resource from the executable (.EXE) file associated with an application instance. (Unicode)
     * @remarks
     * The <b>LoadCursor</b> function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the existing resource. This function returns a valid cursor handle only if the <i>lpCursorName</i> parameter is a pointer to a cursor resource. If <i>lpCursorName</i> is a pointer to any type of resource other than a cursor (such as an icon), the return value is not <b>NULL</b>, even though it is not a valid cursor handle. 
     * 
     * The <b>LoadCursor</b> function searches the cursor resource most appropriate for the cursor for the current display device. The cursor resource can be a color or monochrome bitmap. 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to an instance of the module whose executable file contains the cursor to be loaded.
     * @param {Pointer<Char>} lpCursorName Type: <b>LPCTSTR</b>
     * 
     * The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro can also be used to create this value. To use one of the predefined cursors, the application must set the <i>hInstance</i> parameter to <b>NULL</b> and the <i>lpCursorName</i> parameter to one the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_APPSTARTING"></a><a id="idc_appstarting"></a><dl>
     * <dt><b>IDC_APPSTARTING</b></dt>
     * <dt>MAKEINTRESOURCE(32650)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Standard arrow and small hourglass
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_ARROW"></a><a id="idc_arrow"></a><dl>
     * <dt><b>IDC_ARROW</b></dt>
     * <dt>MAKEINTRESOURCE(32512)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Standard arrow
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_CROSS"></a><a id="idc_cross"></a><dl>
     * <dt><b>IDC_CROSS</b></dt>
     * <dt>MAKEINTRESOURCE(32515)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Crosshair
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_HAND"></a><a id="idc_hand"></a><dl>
     * <dt><b>IDC_HAND</b></dt>
     * <dt>MAKEINTRESOURCE(32649)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Hand
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_HELP"></a><a id="idc_help"></a><dl>
     * <dt><b>IDC_HELP</b></dt>
     * <dt>MAKEINTRESOURCE(32651)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Arrow and question mark
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_IBEAM"></a><a id="idc_ibeam"></a><dl>
     * <dt><b>IDC_IBEAM</b></dt>
     * <dt>MAKEINTRESOURCE(32513)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * I-beam
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_ICON"></a><a id="idc_icon"></a><dl>
     * <dt><b>IDC_ICON</b></dt>
     * <dt>MAKEINTRESOURCE(32641)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obsolete for applications marked version 4.0 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_NO"></a><a id="idc_no"></a><dl>
     * <dt><b>IDC_NO</b></dt>
     * <dt>MAKEINTRESOURCE(32648)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Slashed circle
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZE"></a><a id="idc_size"></a><dl>
     * <dt><b>IDC_SIZE</b></dt>
     * <dt>MAKEINTRESOURCE(32640)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Obsolete for applications marked version 4.0 or later. Use <b>IDC_SIZEALL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZEALL"></a><a id="idc_sizeall"></a><dl>
     * <dt><b>IDC_SIZEALL</b></dt>
     * <dt>MAKEINTRESOURCE(32646)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Four-pointed arrow pointing north, south, east, and west
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZENESW"></a><a id="idc_sizenesw"></a><dl>
     * <dt><b>IDC_SIZENESW</b></dt>
     * <dt>MAKEINTRESOURCE(32643)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing northeast and southwest
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZENS"></a><a id="idc_sizens"></a><dl>
     * <dt><b>IDC_SIZENS</b></dt>
     * <dt>MAKEINTRESOURCE(32645)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing north and south
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZENWSE"></a><a id="idc_sizenwse"></a><dl>
     * <dt><b>IDC_SIZENWSE</b></dt>
     * <dt>MAKEINTRESOURCE(32642)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing northwest and southeast
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_SIZEWE"></a><a id="idc_sizewe"></a><dl>
     * <dt><b>IDC_SIZEWE</b></dt>
     * <dt>MAKEINTRESOURCE(32644)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Double-pointed arrow pointing west and east
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_UPARROW"></a><a id="idc_uparrow"></a><dl>
     * <dt><b>IDC_UPARROW</b></dt>
     * <dt>MAKEINTRESOURCE(32516)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Vertical arrow
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IDC_WAIT"></a><a id="idc_wait"></a><dl>
     * <dt><b>IDC_WAIT</b></dt>
     * <dt>MAKEINTRESOURCE(32514)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Hourglass
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} Type: <b>HCURSOR</b>
     * 
     * If the function succeeds, the return value is the handle to the newly loaded cursor.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorw
     * @since windows5.0
     */
    static LoadCursorW(hInstance, lpCursorName) {
        lpCursorName := lpCursorName is String? StrPtr(lpCursorName) : lpCursorName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadCursorW", "ptr", hInstance, "ptr", lpCursorName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a cursor based on data contained in a file. (ANSI)
     * @remarks
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines LoadCursorFromFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName Type: <b>LPCTSTR</b>
     * 
     * The source of the file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.
     * 
     * If the high-order word of <i>lpFileName</i> is nonzero, it is a pointer to a string that is a fully qualified name of a file containing cursor data.
     * @returns {Pointer<Void>} Type: <b>HCURSOR</b>
     * 
     * If the function is successful, the return value is a handle to the new cursor.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 						<b>GetLastError</b> may return the following value.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorfromfilea
     * @since windows5.0
     */
    static LoadCursorFromFileA(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadCursorFromFileA", "ptr", lpFileName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a cursor based on data contained in a file. (Unicode)
     * @remarks
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines LoadCursorFromFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName Type: <b>LPCTSTR</b>
     * 
     * The source of the file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.
     * 
     * If the high-order word of <i>lpFileName</i> is nonzero, it is a pointer to a string that is a fully qualified name of a file containing cursor data.
     * @returns {Pointer<Void>} Type: <b>HCURSOR</b>
     * 
     * If the function is successful, the return value is a handle to the new cursor.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 						<b>GetLastError</b> may return the following value.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file cannot be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadcursorfromfilew
     * @since windows5.0
     */
    static LoadCursorFromFileW(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadCursorFromFileW", "ptr", lpFileName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a cursor having the specified size, bit patterns, and hot spot.
     * @remarks
     * The <i>nWidth</i> and <i>nHeight</i> parameters must specify a width and height that are supported by the current display driver, because the system cannot create cursors of other sizes. To determine the width and height supported by the display driver, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> function, specifying the <b>SM_CXCURSOR</b> or <b>SM_CYCURSOR</b> value. 
     * 
     * Before closing, an application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroycursor">DestroyCursor</a> function to free any system resources associated with the cursor.
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is in terms of physical coordinates, and  is not affected by the DPI of the calling thread. Note that the cursor created may still be scaled to match the DPI of any given window it is drawn into.
     * @param {Pointer<Void>} hInst Type: <b>HINSTANCE</b>
     * 
     * A handle to the current instance of the application creating the cursor.
     * @param {Integer} xHotSpot Type: <b>int</b>
     * 
     * The horizontal position of the cursor's hot spot.
     * @param {Integer} yHotSpot Type: <b>int</b>
     * 
     * The vertical position of the cursor's hot spot.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The width of the cursor, in pixels.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The height of the cursor, in pixels.
     * @param {Pointer<Void>} pvANDPlane Type: <b>const VOID*</b>
     * 
     * An array of bytes that contains the bit values for the AND mask of the cursor, as in a <a href="https://docs.microsoft.com/windows/win32/gdi/device-dependent-bitmaps">device-dependent</a> monochrome bitmap.
     * @param {Pointer<Void>} pvXORPlane Type: <b>const VOID*</b>
     * 
     * An array of bytes that contains the bit values for the XOR mask of the cursor, as in a <a href="https://docs.microsoft.com/windows/win32/gdi/device-dependent-bitmaps">device-dependent</a> monochrome bitmap.
     * @returns {Pointer<Void>} Type: <b>HCURSOR</b>
     * 
     * If the function succeeds, the return value is a handle to the cursor.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createcursor
     * @since windows5.0
     */
    static CreateCursor(hInst, xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateCursor", "ptr", hInst, "int", xHotSpot, "int", yHotSpot, "int", nWidth, "int", nHeight, "ptr", pvANDPlane, "ptr", pvXORPlane)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.
     * @remarks
     * The <b>DestroyCursor</b> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor: 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursora">LoadCursor</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursorfromfilea">LoadCursorFromFile</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> (if you use the <b>LR_SHARED</b> flag) </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyimage">CopyImage</a> (if you use the <b>LR_COPYRETURNORG</b> flag and the <i>hImage</i> parameter is a shared cursor) </li>
     * </ul>
     * @param {Pointer<Void>} hCursor Type: <b>HCURSOR</b>
     * 
     * A handle to the cursor to be destroyed. The cursor must not be in use.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroycursor
     * @since windows5.0
     */
    static DestroyCursor(hCursor) {
        A_LastError := 0

        result := DllCall("USER32.dll\DestroyCursor", "ptr", hCursor, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enables an application to customize the system cursors. It replaces the contents of the system cursor specified by the id parameter with the contents of the cursor specified by the hcur parameter and then destroys hcur.
     * @remarks
     * For an application to use any of the OCR_ constants, the constant <b>OEMRESOURCE</b> must be defined before the Windows.h header file is included.
     * @param {Pointer<Void>} hcur Type: <b>HCURSOR</b>
     * 
     * A handle to the cursor. The function replaces the contents of the system cursor specified by <i>id</i> with the contents of the cursor handled by <i>hcur</i>.
     * 
     * The system destroys <i>hcur</i> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroycursor">DestroyCursor</a> function. Therefore, <i>hcur</i> cannot be a cursor loaded using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursora">LoadCursor</a> function. To specify a cursor loaded from a resource, copy the cursor using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copycursor">CopyCursor</a> function, then pass the copy to <b>SetSystemCursor</b>.
     * @param {Integer} id Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setsystemcursor
     * @since windows5.0
     */
    static SetSystemCursor(hcur, id) {
        A_LastError := 0

        result := DllCall("USER32.dll\SetSystemCursor", "ptr", hcur, "uint", id, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified icon resource from the executable (.exe) file associated with an application instance. (ANSI)
     * @remarks
     * <b>LoadIcon</b> loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome bitmap. 
     * 
     * <b>LoadIcon</b> can only load an icon whose size conforms to the <b>SM_CXICON</b> and <b>SM_CYICON</b> system metric values. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function to load icons of other sizes.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines LoadIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be <b>NULL</b> when a standard icon is being loaded.
     * @param {Pointer<Byte>} lpIconName Type: <b>LPCTSTR</b>
     * 
     * The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order word and zero in the high-order word. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is a handle to the newly loaded icon.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadicona
     * @since windows5.0
     */
    static LoadIconA(hInstance, lpIconName) {
        lpIconName := lpIconName is String? StrPtr(lpIconName) : lpIconName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadIconA", "ptr", hInstance, "ptr", lpIconName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads the specified icon resource from the executable (.exe) file associated with an application instance. (Unicode)
     * @remarks
     * <b>LoadIcon</b> loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource. The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome bitmap. 
     * 
     * <b>LoadIcon</b> can only load an icon whose size conforms to the <b>SM_CXICON</b> and <b>SM_CYICON</b> system metric values. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function to load icons of other sizes.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines LoadIcon as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be <b>NULL</b> when a standard icon is being loaded.
     * @param {Pointer<Char>} lpIconName Type: <b>LPCTSTR</b>
     * 
     * The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order word and zero in the high-order word. Use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to create this value.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is a handle to the newly loaded icon.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadiconw
     * @since windows5.0
     */
    static LoadIconW(hInstance, lpIconName) {
        lpIconName := lpIconName is String? StrPtr(lpIconName) : lpIconName

        A_LastError := 0

        result := DllCall("USER32.dll\LoadIconW", "ptr", hInstance, "ptr", lpIconName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an array of handles to icons that are extracted from a specified file. (ANSI)
     * @remarks
     * This function extracts from executable (.exe), DLL (.dll),
     *       icon (.ico), cursor (.cur), animated cursor (.ani), and bitmap (.bmp) files.
     *       Extractions from Windows 3.x 16-bit executables (.exe or .dll) are
     *       also supported.
     * 
     * The <i>cxIcon</i> and
     *       <i>cyIcon</i> parameters specify the
     *       size of the icons to extract.  Two sizes can be extracted by putting the
     *       first size in the LOWORD of the parameter and the second size in the HIWORD.
     *       For example, <c>MAKELONG(24, 48)</c> for both the cxIcon and cyIcon parameters would extract
     *       both 24 and 48 size icons.
     * 
     * You must destroy all icons extracted by <b>PrivateExtractIcons</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function. 
     * 
     * This function was not included in the SDK headers and libraries until WindowsXPService Pack1 (SP1) and Windows Server2003. If you do not have a header file and import library for this function, you can call the function using <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines PrivateExtractIcons as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} szFileName Type: <b>LPCTSTR</b>
     * 
     * The path and name of the file
     * 				from which the icon(s) are to be extracted.
     * @param {Integer} nIconIndex Type: <b>int</b>
     * 
     * The zero-based index of the first icon to extract. For example,
     * 				  if this value is zero, the function extracts the first icon in the specified
     * 				  file.
     * @param {Integer} cxIcon Type: <b>int</b>
     * 
     * The horizontal icon size wanted. See Remarks.
     * @param {Integer} cyIcon Type: <b>int</b>
     * 
     * The vertical icon size wanted. See Remarks.
     * @param {Pointer<Void>} phicon Type: <b>HICON*</b>
     * 
     * A pointer to the returned array of icon handles.
     * @param {Pointer<UInt32>} piconid Type: <b>UINT*</b>
     * 
     * A pointer to a returned resource identifier for the icon that best
     * 				fits the current display device.  The returned identifier is 0xFFFFFFFF if the
     * 				identifier is not available for this format.  The returned identifier is 0 if
     * 				the identifier cannot otherwise be obtained.
     * @param {Integer} nIcons Type: <b>UINT</b>
     * 
     * The number of icons to extract from the file. This parameter
     * 				is only valid when extracting from .exe and .dll files.
     * @param {Integer} flags Type: <b>UINT</b>
     * 
     * Specifies flags that control this function.  These flags are the LR_*
     * 				flags used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the <i>phicon</i> parameter is <b>NULL</b> and this function succeeds, then the return
     * 				value is the number of icons in the file.  If the function fails then the
     * 				return value is 0.
     * 
     * If the <i>phicon</i> parameter is
     *         not <b>NULL</b> and the function succeeds, then the return value is the
     *         number of icons extracted.  Otherwise, the return value is 0xFFFFFFFF if the file
     *         is not found.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-privateextracticonsa
     * @since windows5.0
     */
    static PrivateExtractIconsA(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags) {
        szFileName := szFileName is String? StrPtr(szFileName) : szFileName

        result := DllCall("USER32.dll\PrivateExtractIconsA", "ptr", szFileName, "int", nIconIndex, "int", cxIcon, "int", cyIcon, "ptr", phicon, "uint*", piconid, "uint", nIcons, "uint", flags)
        return result
    }

    /**
     * Creates an array of handles to icons that are extracted from a specified file. (Unicode)
     * @remarks
     * This function extracts from executable (.exe), DLL (.dll),
     *       icon (.ico), cursor (.cur), animated cursor (.ani), and bitmap (.bmp) files.
     *       Extractions from Windows 3.x 16-bit executables (.exe or .dll) are
     *       also supported.
     * 
     * The <i>cxIcon</i> and
     *       <i>cyIcon</i> parameters specify the
     *       size of the icons to extract.  Two sizes can be extracted by putting the
     *       first size in the LOWORD of the parameter and the second size in the HIWORD.
     *       For example, <c>MAKELONG(24, 48)</c> for both the cxIcon and cyIcon parameters would extract
     *       both 24 and 48 size icons.
     * 
     * You must destroy all icons extracted by <b>PrivateExtractIcons</b> by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function. 
     * 
     * This function was not included in the SDK headers and libraries until WindowsXPService Pack1 (SP1) and Windows Server2003. If you do not have a header file and import library for this function, you can call the function using <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines PrivateExtractIcons as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} szFileName Type: <b>LPCTSTR</b>
     * 
     * The path and name of the file
     * 				from which the icon(s) are to be extracted.
     * @param {Integer} nIconIndex Type: <b>int</b>
     * 
     * The zero-based index of the first icon to extract. For example,
     * 				  if this value is zero, the function extracts the first icon in the specified
     * 				  file.
     * @param {Integer} cxIcon Type: <b>int</b>
     * 
     * The horizontal icon size wanted. See Remarks.
     * @param {Integer} cyIcon Type: <b>int</b>
     * 
     * The vertical icon size wanted. See Remarks.
     * @param {Pointer<Void>} phicon Type: <b>HICON*</b>
     * 
     * A pointer to the returned array of icon handles.
     * @param {Pointer<UInt32>} piconid Type: <b>UINT*</b>
     * 
     * A pointer to a returned resource identifier for the icon that best
     * 				fits the current display device.  The returned identifier is 0xFFFFFFFF if the
     * 				identifier is not available for this format.  The returned identifier is 0 if
     * 				the identifier cannot otherwise be obtained.
     * @param {Integer} nIcons Type: <b>UINT</b>
     * 
     * The number of icons to extract from the file. This parameter
     * 				is only valid when extracting from .exe and .dll files.
     * @param {Integer} flags Type: <b>UINT</b>
     * 
     * Specifies flags that control this function.  These flags are the LR_*
     * 				flags used by the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> function.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the <i>phicon</i> parameter is <b>NULL</b> and this function succeeds, then the return
     * 				value is the number of icons in the file.  If the function fails then the
     * 				return value is 0.
     * 
     * If the <i>phicon</i> parameter is
     *         not <b>NULL</b> and the function succeeds, then the return value is the
     *         number of icons extracted.  Otherwise, the return value is 0xFFFFFFFF if the file
     *         is not found.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-privateextracticonsw
     * @since windows5.0
     */
    static PrivateExtractIconsW(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags) {
        szFileName := szFileName is String? StrPtr(szFileName) : szFileName

        result := DllCall("USER32.dll\PrivateExtractIconsW", "ptr", szFileName, "int", nIconIndex, "int", cxIcon, "int", cyIcon, "ptr", phicon, "uint*", piconid, "uint", nIcons, "uint", flags)
        return result
    }

    /**
     * Creates an icon that has the specified size, colors, and bit patterns.
     * @remarks
     * For more information about <i>nWidth</i> and <i>nHeight</i> parameters see <a href="https://docs.microsoft.com/windows/desktop/menurc/about-icons#icon-sizes">Icon Sizes</a>. 
     * 
     * <b>CreateIcon</b> applies the following truth table to the AND and XOR bitmasks.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>AND bitmask</th>
     * <th>XOR bitmask</th>
     * <th>Display</th>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>0</td>
     * <td>Black </td>
     * </tr>
     * <tr>
     * <td>0</td>
     * <td>1</td>
     * <td>White </td>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>0</td>
     * <td>Screen </td>
     * </tr>
     * <tr>
     * <td>1</td>
     * <td>1</td>
     * <td>Reverse screen </td>
     * </tr>
     * </table>
     * 
     * When you are finished using the icon, destroy it using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the module creating the icon.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The width, in pixels, of the icon.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The height, in pixels, of the icon.
     * @param {Integer} cPlanes Type: <b>BYTE</b>
     * 
     * The number of planes in the XOR bitmask of the icon.
     * @param {Integer} cBitsPixel Type: <b>BYTE</b>
     * 
     * The number of bits-per-pixel in the XOR bitmask of the icon.
     * @param {Pointer<Byte>} lpbANDbits Type: <b>const BYTE*</b>
     * 
     * An array of bytes that contains the bit values for the AND bitmask of the icon. This bitmask describes a monochrome bitmap.
     * @param {Pointer<Byte>} lpbXORbits Type: <b>const BYTE*</b>
     * 
     * An array of bytes that contains the bit values for the XOR bitmask of the icon. This bitmask describes a monochrome or device-dependent color bitmap.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is a handle to an icon.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createicon
     * @since windows5.0
     */
    static CreateIcon(hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateIcon", "ptr", hInstance, "int", nWidth, "int", nHeight, "char", cPlanes, "char", cBitsPixel, "char*", lpbANDbits, "char*", lpbXORbits)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Destroys an icon and frees any memory the icon occupied.
     * @remarks
     * It is only necessary to call <b>DestroyIcon</b> for icons and cursors created with the following functions: <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if called without the <b>LR_SHARED</b> flag), <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyicon">CopyIcon</a>. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon. 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadicona">LoadIcon</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> (if you use the <b>LR_SHARED</b> flag) </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-copyimage">CopyImage</a> (if you use the <b>LR_COPYRETURNORG</b> flag and the <i>hImage</i> parameter is a shared icon) </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresource">CreateIconFromResource</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> (if you use the <b>LR_SHARED</b> flag)
     * 					</li>
     * </ul>
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * 
     * A handle to the icon to be destroyed. The icon must not be in use.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-destroyicon
     * @since windows5.0
     */
    static DestroyIcon(hIcon) {
        A_LastError := 0

        result := DllCall("USER32.dll\DestroyIcon", "ptr", hIcon, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches through icon or cursor data for the icon or cursor that best fits the current display device. (LookupIconIdFromDirectory)
     * @remarks
     * A resource file of type <b>RT_GROUP_ICON</b> (<b>RT_GROUP_CURSOR</b> indicates cursors) contains icon (or cursor) data in several device-dependent and device-independent formats. <b>LookupIconIdFromDirectory</b> searches the resource file for the icon (or cursor) that best fits the current display device and returns its integer identifier. The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a> functions use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro with this identifier to locate the resource in the module. 
     * 
     * The icon directory is loaded from a resource file with resource type <b>RT_GROUP_ICON</b> (or <b>RT_GROUP_CURSOR</b> for cursors), and an integer resource name for the specific icon to be loaded. <b>LookupIconIdFromDirectory</b> returns an integer identifier that is the resource name of the icon that best fits the current display device. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadicona">LoadIcon</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursora">LoadCursor</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a> functions use this function to search the specified resource data for the icon or cursor that best fits the current display device.
     * @param {Pointer<Byte>} presbits Type: <b>PBYTE</b>
     * 
     * The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <i>presbits</i> is not pointing to valid resource data.
     * @param {Integer} fIcon Type: <b>BOOL</b>
     * 
     * Indicates whether an icon or a cursor is sought. If this parameter is <b>TRUE</b>, the function is searching for an icon; if the parameter is <b>FALSE</b>, the function is searching for a cursor.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-lookupiconidfromdirectory
     * @since windows5.0
     */
    static LookupIconIdFromDirectory(presbits, fIcon) {
        A_LastError := 0

        result := DllCall("USER32.dll\LookupIconIdFromDirectory", "char*", presbits, "int", fIcon)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches through icon or cursor data for the icon or cursor that best fits the current display device. (LookupIconIdFromDirectoryEx)
     * @remarks
     * A resource file of type <b>RT_GROUP_ICON</b> (<b>RT_GROUP_CURSOR</b> indicates cursors) contains icon (or cursor) data in several device-dependent and device-independent formats. <b>LookupIconIdFromDirectoryEx</b> searches the resource file for the icon (or cursor) that best fits the current display device and returns its integer identifier. The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourcea">FindResource</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findresourceexa">FindResourceEx</a> functions use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro with this identifier to locate the resource in the module. 
     * 
     * The icon directory is loaded from a resource file with resource type <b>RT_GROUP_ICON</b> (or <b>RT_GROUP_CURSOR</b> for cursors), and an integer resource name for the specific icon to be loaded. <b>LookupIconIdFromDirectoryEx</b> returns an integer identifier that is the resource name of the icon that best fits the current display device. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadicona">LoadIcon</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-loadcursora">LoadCursor</a> functions use this function to search the specified resource data for the icon or cursor that best fits the current display device.
     * @param {Pointer<Byte>} presbits Type: <b>PBYTE</b>
     * 
     * The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or returns an undefined value if <i>presbits</i> is not pointing to valid resource data.
     * @param {Integer} fIcon Type: <b>BOOL</b>
     * 
     * Indicates whether an icon or a cursor is sought. If this parameter is <b>TRUE</b>, the function is searching for an icon; if the parameter is <b>FALSE</b>, the function is searching for a cursor.
     * @param {Integer} cxDesired Type: <b>int</b>
     * 
     * The desired width, in pixels, of the icon. If this parameter is zero, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value.
     * @param {Integer} cyDesired Type: <b>int</b>
     * 
     * The desired height, in pixels, of the icon. If this parameter is zero, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value.
     * @param {Integer} Flags Type: <b>UINT</b>
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display device. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-lookupiconidfromdirectoryex
     * @since windows5.0
     */
    static LookupIconIdFromDirectoryEx(presbits, fIcon, cxDesired, cyDesired, Flags) {
        A_LastError := 0

        result := DllCall("USER32.dll\LookupIconIdFromDirectoryEx", "char*", presbits, "int", fIcon, "int", cxDesired, "int", cyDesired, "uint", Flags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an icon or cursor from resource bits describing the icon. (CreateIconFromResource)
     * @remarks
     * The <b>CreateIconFromResource</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-geticoninfo">GetIconInfo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectory">LookupIconIdFromDirectory</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectoryex">LookupIconIdFromDirectoryEx</a> functions allow shell applications and icon browsers to examine and use resources throughout the system. 
     * 
     * The <b>CreateIconFromResource</b> function calls <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresourceex">CreateIconFromResourceEx</a> passing <c>LR_DEFAULTSIZE|LR_SHARED</c> as flags.
     * 
     * When you are finished using the icon, destroy it using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * @param {Pointer} presbits Type: <b>PBYTE</b>
     * 
     * The buffer containing the icon or cursor resource bits. These bits are typically loaded by calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectory">LookupIconIdFromDirectory</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectoryex">LookupIconIdFromDirectoryEx</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a> functions.
     * @param {Integer} dwResSize Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the set of bits pointed to by the <i>presbits</i> parameter.
     * @param {Integer} fIcon Type: <b>BOOL</b>
     * 
     * Indicates whether an icon or a cursor is to be created. If this parameter is <b>TRUE</b>, an icon is to be created. If it is <b>FALSE</b>, a cursor is to be created.
     * @param {Integer} dwVer Type: <b>DWORD</b>
     * 
     * The version number of the icon or cursor format for the resource bits pointed to by the <i>presbits</i> parameter. The value must be greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is a handle to the icon or cursor.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createiconfromresource
     * @since windows5.0
     */
    static CreateIconFromResource(presbits, dwResSize, fIcon, dwVer) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateIconFromResource", "ptr", presbits, "uint", dwResSize, "int", fIcon, "uint", dwVer)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an icon or cursor from resource bits describing the icon. (CreateIconFromResourceEx)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconfromresource">CreateIconFromResource</a>, <b>CreateIconFromResourceEx</b>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-createiconindirect">CreateIconIndirect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-geticoninfo">GetIconInfo</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectoryex">LookupIconIdFromDirectoryEx</a> functions allow shell applications and icon browsers to examine and use resources throughout the system. 
     * 
     * You should call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> for icons created with <b>CreateIconFromResourceEx</b>.
     * @param {Pointer} presbits Type: <b>PBYTE</b>
     * 
     * The icon or cursor resource bits. These bits are typically loaded by calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-lookupiconidfromdirectoryex">LookupIconIdFromDirectoryEx</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadresource">LoadResource</a> functions.
     * @param {Integer} dwResSize Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the set of bits pointed to by the <i>pbIconBits</i> parameter.
     * @param {Integer} fIcon Type: <b>BOOL</b>
     * 
     * Indicates whether an icon or a cursor is to be created. If this parameter is <b>TRUE</b>, an icon is to be created. If it is <b>FALSE</b>, a cursor is to be created.
     * @param {Integer} dwVer Type: <b>DWORD</b>
     * 
     * The version number of the icon or cursor format for the resource bits pointed to by the <i>pbIconBits</i> parameter. The value must be greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.
     * @param {Integer} cxDesired Type: <b>int</b>
     * 
     * The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value to set the width.
     * @param {Integer} cyDesired Type: <b>int</b>
     * 
     * The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value to set the height.
     * @param {Integer} Flags Type: <b>UINT</b>
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is a handle to the icon or cursor.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createiconfromresourceex
     * @since windows5.0
     */
    static CreateIconFromResourceEx(presbits, dwResSize, fIcon, dwVer, cxDesired, cyDesired, Flags) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateIconFromResourceEx", "ptr", presbits, "uint", dwResSize, "int", fIcon, "uint", dwVer, "int", cxDesired, "int", cyDesired, "uint", Flags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads an icon, cursor, animated cursor, or bitmap. (ANSI)
     * @remarks
     * If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-is_intresource">IS_INTRESOURCE</a>(<i>lpszName</i>) is <b>TRUE</b>, then <i>lpszName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string. If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource. For example, the string "#258" represents the identifier 258.
     * 
     * When you are finished using a bitmap, cursor, or icon you loaded without specifying the <b>LR_SHARED</b> flag, you can release its associated memory by calling one of the functions in the following table.
     * 
     *                 
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Resource</th>
     * <th>Release function</th>
     * </tr>
     * <tr>
     * <td>Bitmap</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a>
     * </td>
     * </tr>
     * <tr>
     * <td>Cursor</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroycursor">DestroyCursor</a>
     * </td>
     * </tr>
     * <tr>
     * <td>Icon</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a>
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * The system automatically deletes these resources when the process that created them terminates; however, calling the appropriate function saves memory and decreases the size of the process's working set.
     * @param {Pointer<Void>} hInst Type: <b>HINSTANCE</b>
     * 
     * A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. Note that as of  32-bit Windows, an instance handle (<b>HINSTANCE</b>), such as the application instance handle exposed by system function call of <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-winmain">WinMain</a>, and a module handle (<b>HMODULE</b>) are the same thing.
     * 
     * 
     * To load an OEM image, set this parameter to <b>NULL</b>.
     * 
     * To load a stand-alone resource (icon, cursor, or bitmap file)for example, c:\myimage.bmpset this parameter to <b>NULL</b>.
     * @param {Pointer<Byte>} name Type: <b>LPCTSTR</b>
     * 
     * The image to be loaded. If the <i>hinst</i> parameter is non-<b>NULL</b> and the <i>fuLoad</i> parameter omits <b>LR_LOADFROMFILE</b>, <i>lpszName</i> specifies the image resource in the <i>hinst</i> module. If the image resource is to be loaded by name from the module, the <i>lpszName</i> parameter is a pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to convert the image ordinal into a form that can be passed to the <b>LoadImage</b> function.
     * 
     * For more information, see the Remarks section below.
     * 
     * If the <i>hinst</i> parameter is <b>NULL</b> and the <i>fuLoad</i> parameter omits the <b>LR_LOADFROMFILE</b> value, the <i>lpszName</i> specifies the OEM image to load. The OEM image identifiers are defined in Winuser.h and have the following prefixes.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Prefix</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>OBM_</b></td>
     * <td>OEM bitmaps</td>
     * </tr>
     * <tr>
     * <td><b>OIC_</b></td>
     * <td>OEM icons</td>
     * </tr>
     * <tr>
     * <td><b>OCR_</b></td>
     * <td>OEM cursors</td>
     * </tr>
     * </table>
     * 
     * 
     * To pass these constants to the <b>LoadImage</b> function, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro. For example, to load the <b>OCR_NORMAL</b> cursor, pass <c>MAKEINTRESOURCE(OCR_NORMAL)</c> as the <i>lpszName</i> parameter, <b>NULL</b> as the <i>hinst</i> parameter, and <b>LR_SHARED</b> as one of the flags to the <i>fuLoad</i> parameter.
     * 
     * If the <i>fuLoad</i> parameter includes the <b>LR_LOADFROMFILE</b> value, <i>lpszName</i> is the name of the file that contains the  stand-alone resource (icon, cursor, or bitmap file). Therefore, set <i>hinst</i> to <b>NULL</b>.
     * @param {Integer} type Type: <b>UINT</b>
     * @param {Integer} cx Type: <b>int</b>
     * 
     * The width, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value to set the width. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource width.
     * @param {Integer} cy Type: <b>int</b>
     * 
     * The height, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value to set the height. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource height.
     * @param {Integer} fuLoad Type: <b>UINT</b>
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * If the function succeeds, the return value is the handle of the newly loaded image.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadimagea
     * @since windows5.0
     */
    static LoadImageA(hInst, name, type, cx, cy, fuLoad) {
        name := name is String? StrPtr(name) : name

        A_LastError := 0

        result := DllCall("USER32.dll\LoadImageA", "ptr", hInst, "ptr", name, "uint", type, "int", cx, "int", cy, "uint", fuLoad)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Loads an icon, cursor, animated cursor, or bitmap. (Unicode)
     * @remarks
     * If <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-is_intresource">IS_INTRESOURCE</a>(<i>lpszName</i>) is <b>TRUE</b>, then <i>lpszName</i> specifies the integer identifier of the given resource. Otherwise, it is a pointer to a null-terminated string.
     * 
     * If the first character of the string is a pound sign (#), then the remaining characters represent a decimal number that specifies the integer identifier of the resource. For example, the string "#258" represents the identifier 258.
     * 
     * When you are finished using a bitmap, cursor, or icon you loaded without specifying the <b>LR_SHARED</b> flag, you can release its associated memory by calling one of the functions in the following table.
     * 
     *                 
     * 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Resource</th>
     * <th>Release function</th>
     * </tr>
     * <tr>
     * <td>Bitmap</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a>
     * </td>
     * </tr>
     * <tr>
     * <td>Cursor</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroycursor">DestroyCursor</a>
     * </td>
     * </tr>
     * <tr>
     * <td>Icon</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a>
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * The system automatically deletes these resources when the process that created them terminates; however, calling the appropriate function saves memory and decreases the size of the process's working set.
     * @param {Pointer<Void>} hInst Type: <b>HINSTANCE</b>
     * 
     * A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>. Note that as of  32-bit Windows, an instance handle (<b>HINSTANCE</b>), such as the application instance handle exposed by system function call of <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-winmain">WinMain</a>, and a module handle (<b>HMODULE</b>) are the same thing.
     * 
     * 
     * To load an OEM image, set this parameter to <b>NULL</b>.
     * 
     * To load a stand-alone resource (icon, cursor, or bitmap file)for example, c:\myimage.bmpset this parameter to <b>NULL</b>.
     * @param {Pointer<Char>} name Type: <b>LPCTSTR</b>
     * 
     * The image to be loaded. If the <i>hinst</i> parameter is non-<b>NULL</b> and the <i>fuLoad</i> parameter omits <b>LR_LOADFROMFILE</b>, <i>lpszName</i> specifies the image resource in the <i>hinst</i> module. If the image resource is to be loaded by name from the module, the <i>lpszName</i> parameter is a pointer to a null-terminated string that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro to convert the image ordinal into a form that can be passed to the <b>LoadImage</b> function.
     * 
     * For more information, see the Remarks section below.
     * 
     * If the <i>hinst</i> parameter is <b>NULL</b> and the <i>fuLoad</i> parameter omits the <b>LR_LOADFROMFILE</b> value, the <i>lpszName</i> specifies the OEM image to load. The OEM image identifiers are defined in Winuser.h and have the following prefixes.
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Prefix</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>OBM_</b></td>
     * <td>OEM bitmaps</td>
     * </tr>
     * <tr>
     * <td><b>OIC_</b></td>
     * <td>OEM icons</td>
     * </tr>
     * <tr>
     * <td><b>OCR_</b></td>
     * <td>OEM cursors</td>
     * </tr>
     * </table>
     * 
     * 
     * To pass these constants to the <b>LoadImage</b> function, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> macro. For example, to load the <b>OCR_NORMAL</b> cursor, pass <c>MAKEINTRESOURCE(OCR_NORMAL)</c> as the <i>lpszName</i> parameter, <b>NULL</b> as the <i>hinst</i> parameter, and <b>LR_SHARED</b> as one of the flags to the <i>fuLoad</i> parameter.
     * 
     * If the <i>fuLoad</i> parameter includes the <b>LR_LOADFROMFILE</b> value, <i>lpszName</i> is the name of the file that contains the  stand-alone resource (icon, cursor, or bitmap file). Therefore, set <i>hinst</i> to <b>NULL</b>.
     * @param {Integer} type Type: <b>UINT</b>
     * @param {Integer} cx Type: <b>int</b>
     * 
     * The width, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CXICON</b> or <b>SM_CXCURSOR</b> system metric value to set the width. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource width.
     * @param {Integer} cy Type: <b>int</b>
     * 
     * The height, in pixels, of the icon or cursor. If this parameter is zero and the <i>fuLoad</i> parameter is <b>LR_DEFAULTSIZE</b>, the function uses the <b>SM_CYICON</b> or <b>SM_CYCURSOR</b> system metric value to set the height. If this parameter is zero and <b>LR_DEFAULTSIZE</b> is not used, the function uses the actual resource height.
     * @param {Integer} fuLoad Type: <b>UINT</b>
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * If the function succeeds, the return value is the handle of the newly loaded image.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-loadimagew
     * @since windows5.0
     */
    static LoadImageW(hInst, name, type, cx, cy, fuLoad) {
        name := name is String? StrPtr(name) : name

        A_LastError := 0

        result := DllCall("USER32.dll\LoadImageW", "ptr", hInst, "ptr", name, "uint", type, "int", cx, "int", cy, "uint", fuLoad)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one. If necessary, the function stretches the bits to fit the desired size of the new image.
     * @remarks
     * When you are finished using the resource, you can release its associated memory by calling one of the functions in the following table. 
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Resource</th>
     * <th>Release function</th>
     * </tr>
     * <tr>
     * <td>Bitmap</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-deleteobject">DeleteObject</a>
     * </td>
     * </tr>
     * <tr>
     * <td>Cursor</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroycursor">DestroyCursor</a>
     * </td>
     * </tr>
     * <tr>
     * <td>Icon</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a>
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The system automatically deletes the resource when its process terminates, however, calling the appropriate function saves memory and decreases the size of the process's working set.
     * @param {Pointer<Void>} h Type: <b>HANDLE</b>
     * 
     * A handle to the image to be copied.
     * @param {Integer} type Type: <b>UINT</b>
     * @param {Integer} cx Type: <b>int</b>
     * 
     * The desired width, in pixels, of the image. If this is zero, then the returned image will have the same width as the original <i>hImage</i>.
     * @param {Integer} cy Type: <b>int</b>
     * 
     * The desired height, in pixels, of the image. If this is zero, then the returned image will have the same height as the original <i>hImage</i>.
     * @param {Integer} flags Type: <b>UINT</b>
     * @returns {Pointer<Void>} Type: <b>HANDLE</b>
     * 
     * If the function succeeds, the return value is the handle to the newly created image.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyimage
     * @since windows5.0
     */
    static CopyImage(h, type, cx, cy, flags) {
        A_LastError := 0

        result := DllCall("USER32.dll\CopyImage", "ptr", h, "uint", type, "int", cx, "int", cy, "uint", flags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Draws an icon or cursor into the specified device context, performing the specified raster operations, and stretching or compressing the icon or cursor as specified.
     * @remarks
     * The <b>DrawIconEx</b> function places the icon's upper-left corner at the location specified by the <i>xLeft</i> and <i>yTop</i> parameters. The location is subject to the current mapping mode of the device context.
     * 
     * If only one of the <b>DI_IMAGE</b> and <b>DI_MASK</b> flags is set, then the corresponding bitmap is drawn with the <b>SRCCOPY</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt">raster operation code</a>.
     * 
     * If both the <b>DI_IMAGE</b> and <b>DI_MASK</b> flags are set:
     * * If the icon or cursor is a 32-bit alpha-blended icon or cursor, then the image is drawn with <b>AC_SRC_OVER</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/ns-wingdi-blendfunction">blend function</a> and the mask is ignored.
     * * For all other icons or cursors, the mask is drawn with the <b>SRCAND</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt">raster operation code</a>, and the image is drawn with the <b>SRCINVERT</b> <a href="https://docs.microsoft.com/windows/win32/api/wingdi/nf-wingdi-bitblt">raster operation code</a>
     * 
     * To duplicate <c>DrawIcon (hDC, X, Y, hIcon)</c>, call <b>DrawIconEx</b> as follows:
     * 
     * ``` syntax
     * DrawIconEx (hDC, X, Y, hIcon, 0, 0, 0, NULL, DI_NORMAL | DI_COMPAT | DI_DEFAULTSIZE); 
     * ```
     * @param {Pointer<Void>} hdc Type: <b>HDC</b>
     * 
     * A handle to the device context into which the icon or cursor will be drawn.
     * @param {Integer} xLeft Type: <b>int</b>
     * 
     * The logical x-coordinate of the upper-left corner of the icon or cursor.
     * @param {Integer} yTop Type: <b>int</b>
     * 
     * The logical y-coordinate of the upper-left corner of the icon or cursor.
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * 
     * A handle to the icon or cursor to be drawn. This parameter can identify an animated cursor.
     * @param {Integer} cxWidth Type: <b>int</b>
     * 
     * The logical width of the icon or cursor. If this parameter is zero and the <i>diFlags</i> parameter is <b>DI_DEFAULTSIZE</b>, the function uses the <b>SM_CXICON</b> system metric value to set the width. If this parameter is zero and <b>DI_DEFAULTSIZE</b> is not used, the function uses the actual resource width.
     * @param {Integer} cyWidth Type: <b>int</b>
     * 
     * The logical height of the icon or cursor. If this parameter is zero and the <i>diFlags</i> parameter is <b>DI_DEFAULTSIZE</b>, the function uses the <b>SM_CYICON</b> system metric value to set the width. If this parameter is zero and <b>DI_DEFAULTSIZE</b> is not used, the function uses the actual resource height.
     * @param {Integer} istepIfAniCur Type: <b>UINT</b>
     * 
     * The index of the frame to draw, if <i>hIcon</i> identifies an animated cursor. This parameter is ignored if <i>hIcon</i> does not identify an animated cursor.
     * @param {Pointer<Void>} hbrFlickerFreeDraw Type: <b>HBRUSH</b>
     * 
     * A handle to a brush that the system uses for flicker-free drawing. If <i>hbrFlickerFreeDraw</i> is a valid brush handle, the system creates an offscreen bitmap using the specified brush for the background color, draws the icon or cursor into the bitmap, and then copies the bitmap into the device context identified by <i>hdc</i>. If <i>hbrFlickerFreeDraw</i> is <b>NULL</b>, the system draws the icon or cursor directly into the device context.
     * @param {Integer} diFlags Type: <b>UINT</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-drawiconex
     * @since windows5.0
     */
    static DrawIconEx(hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags) {
        A_LastError := 0

        result := DllCall("USER32.dll\DrawIconEx", "ptr", hdc, "int", xLeft, "int", yTop, "ptr", hIcon, "int", cxWidth, "int", cyWidth, "uint", istepIfAniCur, "ptr", hbrFlickerFreeDraw, "uint", diFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an icon or cursor from an ICONINFO structure.
     * @remarks
     * The system copies the bitmaps in the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure before creating the icon or cursor. Because the system may temporarily select the bitmaps in a device context, the <b>hbmMask</b> and <b>hbmColor</b> members of the <b>ICONINFO</b> structure should not already be selected into a device context. The application must continue to manage the original bitmaps and delete them when they are no longer necessary. 
     * 
     * When you are finished using the icon, destroy it using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function.
     * @param {Pointer<ICONINFO>} piconinfo Type: <b>PICONINFO</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure the function uses to create the icon or cursor.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is a handle to the icon or cursor that is created.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createiconindirect
     * @since windows5.0
     */
    static CreateIconIndirect(piconinfo) {
        A_LastError := 0

        result := DllCall("USER32.dll\CreateIconIndirect", "ptr", piconinfo)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies the specified icon from another module to the current module.
     * @remarks
     * The <b>CopyIcon</b> function enables an application or DLL to get its own handle to an icon owned by another module. If the other module is freed, the application icon will still be able to use the icon. 
     * 
     * Before closing, an application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-destroyicon">DestroyIcon</a> function to free any system resources associated with the icon.
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * 
     * A handle to the icon to be copied.
     * @returns {Pointer<Void>} Type: <b>HICON</b>
     * 
     * If the function succeeds, the return value is a handle to the duplicate icon.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-copyicon
     * @since windows5.0
     */
    static CopyIcon(hIcon) {
        A_LastError := 0

        result := DllCall("USER32.dll\CopyIcon", "ptr", hIcon)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified icon or cursor.
     * @remarks
     * <b>GetIconInfo</b> creates bitmaps for the <b>hbmMask</b> and <b>hbmColor</b> or members of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a>. The calling application must manage these bitmaps and delete them when they are no longer necessary.
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.
     * @param {Pointer<Void>} hIcon Type: <b>HICON</b>
     * @param {Pointer<ICONINFO>} piconinfo Type: <b>PICONINFO</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure. The function fills in the structure's members.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero and the function fills in the members of the specified <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfo">ICONINFO</a> structure.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfo
     * @since windows5.0
     */
    static GetIconInfo(hIcon, piconinfo) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetIconInfo", "ptr", hIcon, "ptr", piconinfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified icon or cursor. GetIconInfoEx extends GetIconInfo by using the newer ICONINFOEX structure. (ANSI)
     * @remarks
     * <b>GetIconInfoEx</b> creates bitmaps for the <b>hbmMask</b> and <b>hbmColor</b> or members of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfoexa">ICONINFOEX</a>. The calling application must manage these bitmaps and delete them when they are no longer necessary.
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetIconInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hicon Type: <b>HICON</b>
     * @param {Pointer<ICONINFOEXA>} piconinfo Type: <b>PICONINFOEX</b>
     * 
     * When this method returns, contains a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfoexa">ICONINFOEX</a> structure. The function fills in the structure's members.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> indicates success, <b>FALSE</b> indicates failure.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexa
     * @since windows6.0.6000
     */
    static GetIconInfoExA(hicon, piconinfo) {
        result := DllCall("USER32.dll\GetIconInfoExA", "ptr", hicon, "ptr", piconinfo, "int")
        return result
    }

    /**
     * Retrieves information about the specified icon or cursor. GetIconInfoEx extends GetIconInfo by using the newer ICONINFOEX structure. (Unicode)
     * @remarks
     * <b>GetIconInfoEx</b> creates bitmaps for the <b>hbmMask</b> and <b>hbmColor</b> or members of <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfoexa">ICONINFOEX</a>. The calling application must manage these bitmaps and delete them when they are no longer necessary.
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * This API does not participate in DPI virtualization. The output returned is not affected by the DPI of the calling thread.
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetIconInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hicon Type: <b>HICON</b>
     * @param {Pointer<ICONINFOEXW>} piconinfo Type: <b>PICONINFOEX</b>
     * 
     * When this method returns, contains a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconinfoexa">ICONINFOEX</a> structure. The function fills in the structure's members.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> indicates success, <b>FALSE</b> indicates failure.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-geticoninfoexw
     * @since windows6.0.6000
     */
    static GetIconInfoExW(hicon, piconinfo) {
        result := DllCall("USER32.dll\GetIconInfoExW", "ptr", hicon, "ptr", piconinfo, "int")
        return result
    }

    /**
     * Determines whether a message is intended for the specified dialog box and, if it is, processes the message. (ANSI)
     * @remarks
     * Although the <b>IsDialogMessage</b> function is intended for modeless dialog boxes, you can use it with any window that contains controls, enabling the windows to provide the same keyboard selection as is used in a dialog box. 
     * 
     * When <b>IsDialogMessage</b> processes a message, it checks for keyboard messages and converts them into selections for the corresponding dialog box. For example, the TAB key, when pressed, selects the next control or group of controls, and the DOWN ARROW key, when pressed, selects the next control in a group. 
     * 
     * Because the <b>IsDialogMessage</b> function performs all necessary translating and dispatching of messages, a message processed by <b>IsDialogMessage</b> must not be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translatemessage">TranslateMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a> function. 
     * 
     * <b>IsDialogMessage</b> sends <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-getdlgcode">WM_GETDLGCODE</a> messages to the dialog box procedure to determine which keys should be processed. 
     * 
     * <b>IsDialogMessage</b> can send <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dm-getdefid">DM_GETDEFID</a> and <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dm-setdefid">DM_SETDEFID</a> messages to the window. These messages are defined in the Winuser.h header file as <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> and <b>WM_USER</b> + 1, so conflicts are possible with application-defined messages having the same values. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines IsDialogMessage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains the message to be checked.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the message has been processed, the return value is nonzero.
     * 
     * If the message has not been processed, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-isdialogmessagea
     * @since windows5.0
     */
    static IsDialogMessageA(hDlg, lpMsg) {
        result := DllCall("USER32.dll\IsDialogMessageA", "ptr", hDlg, "ptr", lpMsg, "int")
        return result
    }

    /**
     * Determines whether a message is intended for the specified dialog box and, if it is, processes the message. (Unicode)
     * @remarks
     * Although the <b>IsDialogMessage</b> function is intended for modeless dialog boxes, you can use it with any window that contains controls, enabling the windows to provide the same keyboard selection as is used in a dialog box. 
     * 
     * When <b>IsDialogMessage</b> processes a message, it checks for keyboard messages and converts them into selections for the corresponding dialog box. For example, the TAB key, when pressed, selects the next control or group of controls, and the DOWN ARROW key, when pressed, selects the next control in a group. 
     * 
     * Because the <b>IsDialogMessage</b> function performs all necessary translating and dispatching of messages, a message processed by <b>IsDialogMessage</b> must not be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-translatemessage">TranslateMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-dispatchmessage">DispatchMessage</a> function. 
     * 
     * <b>IsDialogMessage</b> sends <a href="https://docs.microsoft.com/windows/desktop/dlgbox/wm-getdlgcode">WM_GETDLGCODE</a> messages to the dialog box procedure to determine which keys should be processed. 
     * 
     * <b>IsDialogMessage</b> can send <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dm-getdefid">DM_GETDEFID</a> and <a href="https://docs.microsoft.com/windows/desktop/dlgbox/dm-setdefid">DM_SETDEFID</a> messages to the window. These messages are defined in the Winuser.h header file as <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-user">WM_USER</a> and <b>WM_USER</b> + 1, so conflicts are possible with application-defined messages having the same values. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines IsDialogMessage as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to the dialog box.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure that contains the message to be checked.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the message has been processed, the return value is nonzero.
     * 
     * If the message has not been processed, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-isdialogmessagew
     * @since windows5.0
     */
    static IsDialogMessageW(hDlg, lpMsg) {
        result := DllCall("USER32.dll\IsDialogMessageW", "ptr", hDlg, "ptr", lpMsg, "int")
        return result
    }

    /**
     * Converts the specified dialog box units to screen units (pixels).
     * @remarks
     * The <b>MapDialogRect</b> function assumes that the initial coordinates in the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure represent dialog box units. To convert these coordinates from dialog box units to pixels, the function retrieves the current horizontal and vertical base units for the dialog box, then applies the following formulas:
     * 				
     * 				
     * 
     * 
     * ``` syntax
     * 
     * left   = MulDiv(left,   baseunitX, 4);
     * right  = MulDiv(right,  baseunitX, 4);
     * top    = MulDiv(top,    baseunitY, 8);
     * bottom = MulDiv(bottom, baseunitY, 8);
     * ```
     * 
     * If the dialog box template has the <a href="https://docs.microsoft.com/windows/desktop/dlgbox/about-dialog-boxes">DS_SETFONT</a> or <b>DS_SHELLFONT</b> style, the base units are the average width and height, in pixels, of the characters in the font specified by the template.
     * @param {Pointer<Void>} hDlg Type: <b>HWND</b>
     * 
     * A handle to a dialog box. This function accepts only handles returned by one of the dialog box creation functions; handles for other windows are not valid.
     * @param {Pointer<RECT>} lpRect Type: <b>LPRECT</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that contains the dialog box coordinates to be converted.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-mapdialogrect
     * @since windows5.0
     */
    static MapDialogRect(hDlg, lpRect) {
        A_LastError := 0

        result := DllCall("USER32.dll\MapDialogRect", "ptr", hDlg, "ptr", lpRect, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetScrollInfo function retrieves the parameters of a scroll bar, including the minimum and maximum scrolling positions, the page size, and the position of the scroll box (thumb).
     * @remarks
     * The <b>GetScrollInfo</b> function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll bar position, <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-hscroll">WM_HSCROLL</a> and <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-vscroll">WM_VSCROLL</a>, provide only 16 bits of position data, the functions <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setscrollinfo">SetScrollInfo</a> and <b>GetScrollInfo</b> provide 32 bits of scroll bar position data. Thus, an application can call <b>GetScrollInfo</b> while processing either the <b>WM_HSCROLL</b> or <b>WM_VSCROLL</b> messages to obtain 32-bit scroll bar position data. 
     * 
     * To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-hscroll">WM_HSCROLL</a> or <a href="https://docs.microsoft.com/windows/desktop/Controls/wm-vscroll">WM_VSCROLL</a> message, call <b>GetScrollInfo</b> with the SIF_TRACKPOS value in the 
     * 				<b>fMask</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-scrollinfo">SCROLLINFO</a> structure. The function returns the tracking position of the scroll box in the 
     * 				<b>nTrackPos</b> member of the <b>SCROLLINFO</b> structure. This allows you to get the position of the scroll box as the user moves it. The following sample code illustrates the technique.
     * 
     * 
     * ```
     * SCROLLINFO si;
     * case WM_HSCROLL:
     *     switch(LOWORD(wparam)) {
     *         case SB_THUMBTRACK:
     *           // Initialize SCROLLINFO structure
     *  
     *             ZeroMemory(&si, sizeof(si));
     *             si.cbSize = sizeof(si);
     *             si.fMask = SIF_TRACKPOS;
     *  
     *           // Call GetScrollInfo to get current tracking 
     *           //    position in si.nTrackPos
     *  
     *             if (!GetScrollInfo(hwnd, SB_HORZ, &si) )
     *                 return 1; // GetScrollInfo failed
     *             break;
     *         .
     *         .
     *         .
     *     }
     * ```
     * 
     * 
     * If the <i>fnBar</i> parameter is SB_CTL and the window specified by the <i>hwnd</i> parameter is not a system scroll bar control, the system sends the <a href="https://docs.microsoft.com/windows/desktop/Controls/sbm-getscrollinfo">SBM_GETSCROLLINFO</a> message to the window to obtain scroll bar information. This allows <b>GetScrollInfo</b> to operate on a custom control that mimics a scroll bar. If the window does not handle the <b>SBM_GETSCROLLINFO</b> message, the <b>GetScrollInfo</b> function fails.
     * @param {Pointer<Void>} hwnd Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b>
     * 
     * Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the 
     * 					<i>fnBar</i> parameter.
     * @param {Integer} nBar Type: <b>int</b>
     * @param {Pointer<SCROLLINFO>} lpsi Type: <b>LPSCROLLINFO</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-scrollinfo">SCROLLINFO</a> structure. Before calling <b>GetScrollInfo</b>, set the 
     * 					<b>cbSize</b> member to 
     * 					<b>sizeof</b>(<b>SCROLLINFO</b>), and set the 
     * 					<b>fMask</b> member to specify the scroll bar parameters to retrieve. Before returning, the function copies the specified parameters to the appropriate members of the structure.
     * 
     * The
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b>
     * 
     * If the function retrieved any values, the return value is nonzero.
     * 
     * If the function does not retrieve any values, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getscrollinfo
     * @since windows6.0.6000
     */
    static GetScrollInfo(hwnd, nBar, lpsi) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetScrollInfo", "ptr", hwnd, "int", nBar, "ptr", lpsi, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Provides default processing for any window messages that the window procedure of a multiple-document interface (MDI) frame window does not process. (ANSI)
     * @remarks
     * When an application's window procedure does not handle a message, it typically passes the message to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function to process the message. MDI applications use the <b>DefFrameProc</b> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defmdichildproca">DefMDIChildProc</a> functions instead of <b>DefWindowProc</b> to provide default message processing. All messages that an application would usually pass to <b>DefWindowProc</b> (such as nonclient messages and the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message) should be passed to <b>DefFrameProc</b> instead. The <b>DefFrameProc</b> function also handles the following messages. 
     * 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Message</th>
     * <th>Response</th>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a>
     * </td>
     * <td>Activates the MDI child window that the user chooses. This message is sent when the user chooses an MDI child window from the window menu of the MDI frame window. The window identifier accompanying this message identifies the MDI child window to be activated.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a>
     * </td>
     * <td>Opens the window menu of the active MDI child window when the user presses the ALT+  (minus) key combination.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-setfocus">WM_SETFOCUS</a>
     * </td>
     * <td>Passes the keyboard focus to the MDI client window, which in turn passes it to the active MDI child window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-size">WM_SIZE</a>
     * </td>
     * <td>Resizes the MDI client window to fit in the new frame window's client area. If the frame window procedure sizes the MDI client window to a different size, it should not pass the message to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DefFrameProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the MDI frame window.
     * @param {Pointer<Void>} hWndMDIClient Type: <b>HWND</b>
     * 
     * A handle to the MDI client window.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to be processed.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message. If the <i>hWndMDIClient</i> parameter is <b>NULL</b>, the return value is the same as for the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defframeproca
     * @since windows5.0
     */
    static DefFrameProcA(hWnd, hWndMDIClient, uMsg, wParam, lParam) {
        result := DllCall("USER32.dll\DefFrameProcA", "ptr", hWnd, "ptr", hWndMDIClient, "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Provides default processing for any window messages that the window procedure of a multiple-document interface (MDI) frame window does not process. (Unicode)
     * @remarks
     * When an application's window procedure does not handle a message, it typically passes the message to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function to process the message. MDI applications use the <b>DefFrameProc</b> and <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defmdichildproca">DefMDIChildProc</a> functions instead of <b>DefWindowProc</b> to provide default message processing. All messages that an application would usually pass to <b>DefWindowProc</b> (such as nonclient messages and the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message) should be passed to <b>DefFrameProc</b> instead. The <b>DefFrameProc</b> function also handles the following messages. 
     * 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Message</th>
     * <th>Response</th>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-command">WM_COMMAND</a>
     * </td>
     * <td>Activates the MDI child window that the user chooses. This message is sent when the user chooses an MDI child window from the window menu of the MDI frame window. The window identifier accompanying this message identifies the MDI child window to be activated.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a>
     * </td>
     * <td>Opens the window menu of the active MDI child window when the user presses the ALT+  (minus) key combination.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-setfocus">WM_SETFOCUS</a>
     * </td>
     * <td>Passes the keyboard focus to the MDI client window, which in turn passes it to the active MDI child window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-size">WM_SIZE</a>
     * </td>
     * <td>Resizes the MDI client window to fit in the new frame window's client area. If the frame window procedure sizes the MDI client window to a different size, it should not pass the message to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DefFrameProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the MDI frame window.
     * @param {Pointer<Void>} hWndMDIClient Type: <b>HWND</b>
     * 
     * A handle to the MDI client window.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to be processed.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message. If the <i>hWndMDIClient</i> parameter is <b>NULL</b>, the return value is the same as for the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defframeprocw
     * @since windows5.0
     */
    static DefFrameProcW(hWnd, hWndMDIClient, uMsg, wParam, lParam) {
        result := DllCall("USER32.dll\DefFrameProcW", "ptr", hWnd, "ptr", hWndMDIClient, "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Provides default processing for any window message that the window procedure of a multiple-document interface (MDI) child window does not process. (ANSI)
     * @remarks
     * The <b>DefMDIChildProc</b> function assumes that the parent window of the MDI child window identified by the <i>hWnd</i> parameter was created with the <b>MDICLIENT</b> class. 
     * 
     * When an application's window procedure does not handle a message, it typically passes the message to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function to process the message. MDI applications use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defframeproca">DefFrameProc</a> and <b>DefMDIChildProc</b> functions instead of <b>DefWindowProc</b> to provide default message processing. All messages that an application would usually pass to <b>DefWindowProc</b> (such as nonclient messages and the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message) should be passed to <b>DefMDIChildProc</b> instead. In addition, <b>DefMDIChildProc</b> also handles the following messages. 
     * 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Message</th>
     * <th>Response</th>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-childactivate">WM_CHILDACTIVATE</a>
     * </td>
     * <td>Performs activation processing when MDI child windows are sized, moved, or displayed. This message must be passed.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-getminmaxinfo">WM_GETMINMAXINFO</a>
     * </td>
     * <td>Calculates the size of a maximized MDI child window, based on the current size of the MDI client window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a>
     * </td>
     * <td>Passes the message to the MDI frame window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-move">WM_MOVE</a>
     * </td>
     * <td>Recalculates MDI client scroll bars if they are present.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-setfocus">WM_SETFOCUS</a>
     * </td>
     * <td>Activates the child window if it is not the active MDI child window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-size">WM_SIZE</a>
     * </td>
     * <td>Performs operations necessary for changing the size of a window, especially for maximizing or restoring an MDI child window. Failing to pass this message to the <b>DefMDIChildProc</b> function produces highly undesirable results.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syscommand">WM_SYSCOMMAND</a>
     * </td>
     * <td>Handles window menu commands: <b>SC_NEXTWINDOW</b>, <b>SC_PREVWINDOW</b>, <b>SC_MOVE</b>, <b>SC_SIZE</b>, and <b>SC_MAXIMIZE</b>.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DefMDIChildProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the MDI child window.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to be processed.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defmdichildproca
     * @since windows5.0
     */
    static DefMDIChildProcA(hWnd, uMsg, wParam, lParam) {
        result := DllCall("USER32.dll\DefMDIChildProcA", "ptr", hWnd, "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Provides default processing for any window message that the window procedure of a multiple-document interface (MDI) child window does not process. (Unicode)
     * @remarks
     * The <b>DefMDIChildProc</b> function assumes that the parent window of the MDI child window identified by the <i>hWnd</i> parameter was created with the <b>MDICLIENT</b> class. 
     * 
     * When an application's window procedure does not handle a message, it typically passes the message to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defwindowproca">DefWindowProc</a> function to process the message. MDI applications use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-defframeproca">DefFrameProc</a> and <b>DefMDIChildProc</b> functions instead of <b>DefWindowProc</b> to provide default message processing. All messages that an application would usually pass to <b>DefWindowProc</b> (such as nonclient messages and the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a> message) should be passed to <b>DefMDIChildProc</b> instead. In addition, <b>DefMDIChildProc</b> also handles the following messages. 
     * 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Message</th>
     * <th>Response</th>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-childactivate">WM_CHILDACTIVATE</a>
     * </td>
     * <td>Performs activation processing when MDI child windows are sized, moved, or displayed. This message must be passed.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-getminmaxinfo">WM_GETMINMAXINFO</a>
     * </td>
     * <td>Calculates the size of a maximized MDI child window, based on the current size of the MDI client window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-menuchar">WM_MENUCHAR</a>
     * </td>
     * <td>Passes the message to the MDI frame window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-move">WM_MOVE</a>
     * </td>
     * <td>Recalculates MDI client scroll bars if they are present.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-setfocus">WM_SETFOCUS</a>
     * </td>
     * <td>Activates the child window if it is not the active MDI child window.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-size">WM_SIZE</a>
     * </td>
     * <td>Performs operations necessary for changing the size of a window, especially for maximizing or restoring an MDI child window. Failing to pass this message to the <b>DefMDIChildProc</b> function produces highly undesirable results.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/menurc/wm-syscommand">WM_SYSCOMMAND</a>
     * </td>
     * <td>Handles window menu commands: <b>SC_NEXTWINDOW</b>, <b>SC_PREVWINDOW</b>, <b>SC_MOVE</b>, <b>SC_SIZE</b>, and <b>SC_MAXIMIZE</b>.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines DefMDIChildProc as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the MDI child window.
     * @param {Integer} uMsg Type: <b>UINT</b>
     * 
     * The message to be processed.
     * @param {Pointer} wParam Type: <b>WPARAM</b>
     * 
     * Additional message-specific information.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * Additional message-specific information.
     * @returns {Pointer} Type: <b>LRESULT</b>
     * 
     * The return value specifies the result of the message processing and depends on the message.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-defmdichildprocw
     * @since windows5.0
     */
    static DefMDIChildProcW(hWnd, uMsg, wParam, lParam) {
        result := DllCall("USER32.dll\DefMDIChildProcW", "ptr", hWnd, "uint", uMsg, "ptr", wParam, "ptr", lParam, "ptr")
        return result
    }

    /**
     * Processes accelerator keystrokes for window menu commands of the multiple-document interface (MDI) child windows associated with the specified MDI client window.
     * @param {Pointer<Void>} hWndClient Type: <b>HWND</b>
     * 
     * A handle to the MDI client window.
     * @param {Pointer<MSG>} lpMsg Type: <b>LPMSG</b>
     * 
     * A pointer to a message retrieved by using the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmessage">GetMessage</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-peekmessagea">PeekMessage</a> function. The message must be an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-msg">MSG</a> structure and contain message information from the application's message queue.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the message is translated into a system command, the return value is nonzero.
     * 
     * If the message is not translated into a system command, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-translatemdisysaccel
     * @since windows5.0
     */
    static TranslateMDISysAccel(hWndClient, lpMsg) {
        result := DllCall("USER32.dll\TranslateMDISysAccel", "ptr", hWndClient, "ptr", lpMsg, "int")
        return result
    }

    /**
     * Arranges all the minimized (iconic) child windows of the specified parent window.
     * @remarks
     * An application that maintains its own minimized child windows can use the <b>ArrangeIconicWindows</b> function to arrange icons in a parent window. This function can also arrange icons on the desktop. To retrieve the window handle to the desktop window, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdesktopwindow">GetDesktopWindow</a> function. 
     * 
     * An application sends the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-mdiiconarrange">WM_MDIICONARRANGE</a> message to the multiple-document interface (MDI) client window to prompt the client window to arrange its minimized MDI child windows.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the parent window.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the return value is the height of one row of icons. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-arrangeiconicwindows
     * @since windows5.0
     */
    static ArrangeIconicWindows(hWnd) {
        A_LastError := 0

        result := DllCall("USER32.dll\ArrangeIconicWindows", "ptr", hWnd)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a multiple-document interface (MDI) child window. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines CreateMDIWindow as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * The window class of the MDI child window. The class name must have been registered by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.
     * @param {Pointer<Byte>} lpWindowName Type: <b>LPCTSTR</b>
     * 
     * The window name. The system displays the name in the title bar of the child window.
     * @param {Integer} dwStyle Type: <b>DWORD</b>
     * @param {Integer} X Type: <b>int</b>
     * 
     * The initial horizontal position, in client coordinates, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b> ((int)0x80000000), the MDI child window is assigned the default horizontal position.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The initial vertical position, in client coordinates, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default vertical position.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The initial width, in device units, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default width.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The initial height, in device units, of the MDI child window. If this parameter is set to <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default height.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the MDI client window that will be the parent of the new MDI child window.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the application creating the MDI child window.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * An application-defined value.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the handle to the created window.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createmdiwindowa
     * @since windows5.0
     */
    static CreateMDIWindowA(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName
        lpWindowName := lpWindowName is String? StrPtr(lpWindowName) : lpWindowName

        A_LastError := 0

        result := DllCall("USER32.dll\CreateMDIWindowA", "ptr", lpClassName, "ptr", lpWindowName, "uint", dwStyle, "int", X, "int", Y, "int", nWidth, "int", nHeight, "ptr", hWndParent, "ptr", hInstance, "ptr", lParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a multiple-document interface (MDI) child window. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines CreateMDIWindow as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpClassName Type: <b>LPCTSTR</b>
     * 
     * The window class of the MDI child window. The class name must have been registered by a call to the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-registerclassexa">RegisterClassEx</a> function.
     * @param {Pointer<Char>} lpWindowName Type: <b>LPCTSTR</b>
     * 
     * The window name. The system displays the name in the title bar of the child window.
     * @param {Integer} dwStyle Type: <b>DWORD</b>
     * @param {Integer} X Type: <b>int</b>
     * 
     * The initial horizontal position, in client coordinates, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b> ((int)0x80000000), the MDI child window is assigned the default horizontal position.
     * @param {Integer} Y Type: <b>int</b>
     * 
     * The initial vertical position, in client coordinates, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default vertical position.
     * @param {Integer} nWidth Type: <b>int</b>
     * 
     * The initial width, in device units, of the MDI child window. If this parameter is <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default width.
     * @param {Integer} nHeight Type: <b>int</b>
     * 
     * The initial height, in device units, of the MDI child window. If this parameter is set to <b>CW_USEDEFAULT</b>, the MDI child window is assigned the default height.
     * @param {Pointer<Void>} hWndParent Type: <b>HWND</b>
     * 
     * A handle to the MDI client window that will be the parent of the new MDI child window.
     * @param {Pointer<Void>} hInstance Type: <b>HINSTANCE</b>
     * 
     * A handle to the instance of the application creating the MDI child window.
     * @param {Pointer} lParam Type: <b>LPARAM</b>
     * 
     * An application-defined value.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * If the function succeeds, the return value is the handle to the created window.
     * 
     * If the function fails, the return value is <b>NULL</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-createmdiwindoww
     * @since windows5.0
     */
    static CreateMDIWindowW(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam) {
        lpClassName := lpClassName is String? StrPtr(lpClassName) : lpClassName
        lpWindowName := lpWindowName is String? StrPtr(lpWindowName) : lpWindowName

        A_LastError := 0

        result := DllCall("USER32.dll\CreateMDIWindowW", "ptr", lpClassName, "ptr", lpWindowName, "uint", dwStyle, "int", X, "int", Y, "int", nWidth, "int", nHeight, "ptr", hWndParent, "ptr", hInstance, "ptr", lParam)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Tiles the specified child windows of the specified parent window.
     * @remarks
     * Calling <b>TileWindows</b> causes all maximized windows to be restored to their previous size.
     * @param {Pointer<Void>} hwndParent Type: <b>HWND</b>
     * 
     * A handle to the parent window. If this parameter is <b>NULL</b>, the desktop window is assumed.
     * @param {Integer} wHow Type: <b>UINT</b>
     * @param {Pointer<RECT>} lpRect Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. If this parameter is <b>NULL</b>, the client area of the parent window is used.
     * @param {Integer} cKids Type: <b>UINT</b>
     * 
     * The number of elements in the array specified by the <i>lpKids</i> parameter. This parameter is ignored if <i>lpKids</i> is <b>NULL</b>.
     * @param {Pointer<Void>} lpKids Type: <b>const HWND*</b>
     * 
     * An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style <b>WS_EX_TOPMOST</b> or <b>WS_EX_TOOLWINDOW</b>, the child window is not arranged. If this parameter is <b>NULL</b>, all child windows of the specified parent window (or of the desktop window) are arranged.
     * @returns {Integer} Type: <b>WORD</b>
     * 
     * If the function succeeds, the return value is the number of windows arranged.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-tilewindows
     * @since windows5.0
     */
    static TileWindows(hwndParent, wHow, lpRect, cKids, lpKids) {
        A_LastError := 0

        result := DllCall("USER32.dll\TileWindows", "ptr", hwndParent, "uint", wHow, "ptr", lpRect, "uint", cKids, "ptr", lpKids, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Cascades the specified child windows of the specified parent window.
     * @remarks
     * By default, <b>CascadeWindows</b> arranges the windows in the order provided by the <i>lpKids</i> array, but preserves the <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-features">Z-Order</a>. If you specify the <b>MDITILE_ZORDER</b> flag, <b>CascadeWindows</b> arranges the windows in Z order. 
     * 
     * Calling <b>CascadeWindows</b> causes all maximized windows to be restored to their previous size.
     * @param {Pointer<Void>} hwndParent Type: <b>HWND</b>
     * 
     * A handle to the parent window. If this parameter is <b>NULL</b>, the desktop window is assumed.
     * @param {Integer} wHow Type: <b>UINT</b>
     * @param {Pointer<RECT>} lpRect Type: <b>const <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a>*</b>
     * 
     * A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. This parameter can be <b>NULL</b>, in which case the client area of the parent window is used.
     * @param {Integer} cKids Type: <b>UINT</b>
     * 
     * The number of elements in the array specified by the 
     * <i>lpKids</i> parameter. This parameter is ignored if <i>lpKids</i> is <b>NULL</b>.
     * @param {Pointer<Void>} lpKids Type: <b>const HWND*</b>
     * 
     * An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style <b>WS_EX_TOPMOST</b> or <b>WS_EX_TOOLWINDOW</b>, the child window is not arranged. If this parameter is <b>NULL</b>, all child windows of the specified parent window (or of the desktop window) are arranged.
     * @returns {Integer} Type: <b>WORD</b>
     * 
     * If the function succeeds, the return value is the number of windows arranged.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-cascadewindows
     * @since windows5.0
     */
    static CascadeWindows(hwndParent, wHow, lpRect, cKids, lpKids) {
        A_LastError := 0

        result := DllCall("USER32.dll\CascadeWindows", "ptr", hwndParent, "uint", wHow, "ptr", lpRect, "uint", cKids, "ptr", lpKids, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves or sets the value of one of the system-wide parameters. (ANSI)
     * @remarks
     * This function is intended for use with applications that allow the user to customize the environment.
     * 
     * A keyboard layout name should be derived from the hexadecimal value of the language identifier corresponding to the layout. For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout, such as the Dvorak layout, are named "00010409", "00020409" and so on. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <b>MAKELANGID</b> macro.
     * 
     * There is a difference between the High Contrast color scheme and the High Contrast Mode. The High Contrast color scheme changes the system colors to colors that have obvious contrast; you switch to this color scheme by using the Display Options in the control panel. The High Contrast Mode, which uses <b>SPI_GETHIGHCONTRAST</b> and <b>SPI_SETHIGHCONTRAST</b>, advises applications to modify their appearance for visually-impaired users. It involves such things as audible warning to users and customized color scheme (using the Accessibility Options in the control panel). For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-highcontrasta">HIGHCONTRAST</a>. For more information on general accessibility features, see <a href="https://docs.microsoft.com/windows/desktop/accessibility">Accessibility</a>.
     * 
     * During the time that the primary button is held down to activate the Mouse ClickLock feature, the user can move the mouse. After the primary button is locked down, releasing the primary button does not result in a <b>WM_LBUTTONUP</b> message. Thus, it will appear to an application that the primary button is still down. Any subsequent button message releases the primary button, sending a <b>WM_LBUTTONUP</b> message to the application, thus the button can be unlocked programmatically or through the user clicking any button.
     * 
     * This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfofordpi">SystemParametersInfoForDPI</a>. For more information on DPI awareness, see <a href="https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows">the Windows High DPI documentation.</a>
     * @param {Integer} uiAction Type: <b>UINT</b>
     * 
     * The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:
     * 
     * <ul>
     * <li>Accessibility parameters</li>
     * <li>Desktop parameters</li>
     * <li>Icon parameters</li>
     * <li>Input parameters</li>
     * <li>Menu parameters</li>
     * <li>Power parameters</li>
     * <li>Screen saver parameters</li>
     * <li>Time-out parameters</li>
     * <li>UI effect parameters</li>
     * <li>Window parameters</li>
     * </ul>
     * 
     * 
     * The following are the accessibility parameters.
     * 
     * <table>
     * <tr>
     * <th>Accessibility parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACCESSTIMEOUT"></a><a id="spi_getaccesstimeout"></a><dl>
     * <dt><b>SPI_GETACCESSTIMEOUT</b></dt>
     * <dt>0x003C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the time-out period associated with the accessibility features. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accesstimeout">ACCESSTIMEOUT</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ACCESSTIMEOUT)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETAUDIODESCRIPTION"></a><a id="spi_getaudiodescription"></a><dl>
     * <dt><b>SPI_GETAUDIODESCRIPTION</b></dt>
     * <dt>0x0074</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether audio descriptions are enabled or disabled. The <i>pvParam</i> parameter is a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-audiodescription">AUDIODESCRIPTION</a> structure. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(AUDIODESCRIPTION)</c>.
     * 
     * While it is possible for users who have visual impairments to hear the audio in video content, there is a lot of action in video that does not have corresponding audio. Specific audio description of what is happening in a video helps these users understand the content better. This flag enables you to determine whether audio descriptions have been enabled and in which language.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCLIENTAREAANIMATION"></a><a id="spi_getclientareaanimation"></a><dl>
     * <dt><b>SPI_GETCLIENTAREAANIMATION</b></dt>
     * <dt>0x1042</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether animations are enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if animations are enabled, or <b>FALSE</b> otherwise.
     * 
     * Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive epilepsy. This flag enables you to determine whether such animations have been disabled in the client area.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDISABLEOVERLAPPEDCONTENT"></a><a id="spi_getdisableoverlappedcontent"></a><dl>
     * <dt><b>SPI_GETDISABLEOVERLAPPEDCONTENT</b></dt>
     * <dt>0x1040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether overlapped content is enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency can reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on the screen. This flag enables you to determine whether such overlapped content has been disabled.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFILTERKEYS"></a><a id="spi_getfilterkeys"></a><dl>
     * <dt><b>SPI_GETFILTERKEYS</b></dt>
     * <dt>0x0032</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the FilterKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-filterkeys">FILTERKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(FILTERKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOCUSBORDERHEIGHT"></a><a id="spi_getfocusborderheight"></a><dl>
     * <dt><b>SPI_GETFOCUSBORDERHEIGHT</b></dt>
     * <dt>0x2010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the height, in pixels, of the top and bottom edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a>. The <i>pvParam</i> parameter must point to a <b>UINT</b> value.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOCUSBORDERWIDTH"></a><a id="spi_getfocusborderwidth"></a><dl>
     * <dt><b>SPI_GETFOCUSBORDERWIDTH</b></dt>
     * <dt>0x200E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the width, in pixels, of the left and right edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a>. The <i>pvParam</i> parameter must point to a <b>UINT</b>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETHIGHCONTRAST"></a><a id="spi_gethighcontrast"></a><dl>
     * <dt><b>SPI_GETHIGHCONTRAST</b></dt>
     * <dt>0x0042</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the HighContrast accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-highcontrasta">HIGHCONTRAST</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(HIGHCONTRAST)</c>.
     * 
     * For a general discussion, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLOGICALDPIOVERRIDE"></a><a id="spi_getlogicaldpioverride"></a><dl>
     * <dt><b>SPI_GETLOGICALDPIOVERRIDE</b></dt>
     * <dt>0x009E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves a value that determines whether Windows8 is displaying apps using the default scaling plateau for the hardware or going to the next higher plateau. This value is based on the current "Make everything on your screen bigger" setting, found in the <b>Ease of Access</b> section of <b>PC settings</b>: 1 is on, 0 is off.
     * 
     * Apps can provide text and image resources for each of several scaling plateaus: 100%, 140%, and 180%. Providing separate resources optimized for a particular scale avoids distortion due to resizing. Windows8 determines the appropriate scaling plateau based on a number of factors, including screen size and pixel density. When "Make everything on your screen bigger" is selected (SPI_GETLOGICALDPIOVERRIDE returns a value of 1), Windows uses resources from the next higher plateau. For example, in the case of hardware that Windows determines should use a scale of <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">SCALE_100_PERCENT</a>, this override causes Windows to use the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">SCALE_140_PERCENT</a> scale value, assuming that it does not violate other constraints.
     * 
     * <div class="alert"><b>Note</b>You should not use this value. It might be altered or unavailable in subsequent versions of Windows. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-getscalefactorfordevice">GetScaleFactorForDevice</a> function or the <a href="https://docs.microsoft.com/uwp/api/Windows.Graphics.Display.DisplayProperties">DisplayProperties</a> class to retrieve the preferred scaling factor. Desktop applications should use desktop logical DPI rather than scale factor. Desktop logical DPI can be retrieved through the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps">GetDeviceCaps</a> function.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMESSAGEDURATION"></a><a id="spi_getmessageduration"></a><dl>
     * <dt><b>SPI_GETMESSAGEDURATION</b></dt>
     * <dt>0x2016</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time that notification pop-ups should be displayed, in seconds. The <i>pvParam</i> parameter must point to a <b>ULONG</b> that receives the message duration.
     * 
     * Users with visual impairments or cognitive conditions such as ADHD and dyslexia might need a longer time to read the text in notification messages. This flag enables you to retrieve the message duration.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSECLICKLOCK"></a><a id="spi_getmouseclicklock"></a><dl>
     * <dt><b>SPI_GETMOUSECLICKLOCK</b></dt>
     * <dt>0x101E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the state of the Mouse ClickLock feature. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSECLICKLOCKTIME"></a><a id="spi_getmouseclicklocktime"></a><dl>
     * <dt><b>SPI_GETMOUSECLICKLOCKTIME</b></dt>
     * <dt>0x2008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time delay before the primary mouse button is locked. The <i>pvParam</i> parameter must point to <b>DWORD</b> that receives the time delay, in milliseconds. This is only enabled if <b>SPI_SETMOUSECLICKLOCK</b> is set to <b>TRUE</b>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEKEYS"></a><a id="spi_getmousekeys"></a><dl>
     * <dt><b>SPI_GETMOUSEKEYS</b></dt>
     * <dt>0x0036</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the MouseKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mousekeys">MOUSEKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MOUSEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSESONAR"></a><a id="spi_getmousesonar"></a><dl>
     * <dt><b>SPI_GETMOUSESONAR</b></dt>
     * <dt>0x101C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the state of the Mouse Sonar feature. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> otherwise. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEVANISH"></a><a id="spi_getmousevanish"></a><dl>
     * <dt><b>SPI_GETMOUSEVANISH</b></dt>
     * <dt>0x1020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the state of the Mouse Vanish feature. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> otherwise. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENREADER"></a><a id="spi_getscreenreader"></a><dl>
     * <dt><b>SPI_GETSCREENREADER</b></dt>
     * <dt>0x0046</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a screen reviewer utility is running. A screen reviewer utility directs textual information to an output device, such as a speech synthesizer or Braille display. When this flag is set, an application should provide textual information in situations where it would otherwise present the information  graphically.
     * 
     * The <i>pvParam</i> parameter is a pointer to a <b>BOOL</b> variable that receives <b>TRUE</b> if a screen reviewer utility is running, or <b>FALSE</b> otherwise.
     * 
     * <div class="alert"><b>Note</b>Narrator, the screen reader that is included with Windows, does not set the <b>SPI_SETSCREENREADER</b> or <b>SPI_GETSCREENREADER</b> flags.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSERIALKEYS"></a><a id="spi_getserialkeys"></a><dl>
     * <dt><b>SPI_GETSERIALKEYS</b></dt>
     * <dt>0x003E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>The user should control this setting through the Control Panel.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSHOWSOUNDS"></a><a id="spi_getshowsounds"></a><dl>
     * <dt><b>SPI_GETSHOWSOUNDS</b></dt>
     * <dt>0x0038</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the Show Sounds accessibility flag is on or off. If it is on, the user requires an application to present information visually in situations where it would otherwise present the information only in audible form. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the feature is on, or <b>FALSE</b> if it is off.
     * 
     * Using this value is equivalent to calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with <b>SM_SHOWSOUNDS</b>. That is the recommended call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSOUNDSENTRY"></a><a id="spi_getsoundsentry"></a><dl>
     * <dt><b>SPI_GETSOUNDSENTRY</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the SoundSentry accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-soundsentrya">SOUNDSENTRY</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(SOUNDSENTRY)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSTICKYKEYS"></a><a id="spi_getstickykeys"></a><dl>
     * <dt><b>SPI_GETSTICKYKEYS</b></dt>
     * <dt>0x003A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the StickyKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-stickykeys">STICKYKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(STICKYKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTOGGLEKEYS"></a><a id="spi_gettogglekeys"></a><dl>
     * <dt><b>SPI_GETTOGGLEKEYS</b></dt>
     * <dt>0x0034</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the ToggleKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-togglekeys">TOGGLEKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(TOGGLEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACCESSTIMEOUT"></a><a id="spi_setaccesstimeout"></a><dl>
     * <dt><b>SPI_SETACCESSTIMEOUT</b></dt>
     * <dt>0x003D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the time-out period associated with the accessibility features. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accesstimeout">ACCESSTIMEOUT</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ACCESSTIMEOUT)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETAUDIODESCRIPTION"></a><a id="spi_setaudiodescription"></a><dl>
     * <dt><b>SPI_SETAUDIODESCRIPTION</b></dt>
     * <dt>0x0075</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the audio descriptions feature on or off. The <i>pvParam</i> parameter is a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-audiodescription">AUDIODESCRIPTION</a> structure.
     * 
     * While it is possible for users who are visually impaired to hear the audio in video content, there is a lot of action in video that does not have corresponding audio. Specific audio description of what is happening in a video helps these users understand the content better. This flag enables you to enable or disable audio descriptions in the languages they are provided in.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCLIENTAREAANIMATION"></a><a id="spi_setclientareaanimation"></a><dl>
     * <dt><b>SPI_SETCLIENTAREAANIMATION</b></dt>
     * <dt>0x1043</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns client area animations on or off. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable animations and other transient effects in the client area, or <b>FALSE</b> to disable them.
     * 
     * Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive epilepsy. This flag enables you to enable or disable all such animations.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDISABLEOVERLAPPEDCONTENT"></a><a id="spi_setdisableoverlappedcontent"></a><dl>
     * <dt><b>SPI_SETDISABLEOVERLAPPEDCONTENT</b></dt>
     * <dt>0x1041</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns overlapped content (such as background images and watermarks) on or off. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to disable overlapped content, or <b>FALSE</b> to enable overlapped content.
     * 
     * Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency can reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on the screen. This flag enables you to enable or disable all such overlapped content.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFILTERKEYS"></a><a id="spi_setfilterkeys"></a><dl>
     * <dt><b>SPI_SETFILTERKEYS</b></dt>
     * <dt>0x0033</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the FilterKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-filterkeys">FILTERKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(FILTERKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOCUSBORDERHEIGHT"></a><a id="spi_setfocusborderheight"></a><dl>
     * <dt><b>SPI_SETFOCUSBORDERHEIGHT</b></dt>
     * <dt>0x2011</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height of the top and bottom edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a> to the value of the <i>pvParam</i> parameter.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOCUSBORDERWIDTH"></a><a id="spi_setfocusborderwidth"></a><dl>
     * <dt><b>SPI_SETFOCUSBORDERWIDTH</b></dt>
     * <dt>0x200F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height of the left and right edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a> to the value of the <i>pvParam</i> parameter.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETHIGHCONTRAST"></a><a id="spi_sethighcontrast"></a><dl>
     * <dt><b>SPI_SETHIGHCONTRAST</b></dt>
     * <dt>0x0043</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the HighContrast accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-highcontrasta">HIGHCONTRAST</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(HIGHCONTRAST)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLOGICALDPIOVERRIDE"></a><a id="spi_setlogicaldpioverride"></a><dl>
     * <dt><b>SPI_SETLOGICALDPIOVERRIDE</b></dt>
     * <dt>0x009F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMESSAGEDURATION"></a><a id="spi_setmessageduration"></a><dl>
     * <dt><b>SPI_SETMESSAGEDURATION</b></dt>
     * <dt>0x2017</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the time that notification pop-ups should be displayed, in seconds. The <i>pvParam</i> parameter specifies the message duration.
     * 
     * Users with visual impairments or cognitive conditions such as ADHD and dyslexia might need a longer time to read the text in notification messages. This flag enables you to set the message duration.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSECLICKLOCK"></a><a id="spi_setmouseclicklock"></a><dl>
     * <dt><b>SPI_SETMOUSECLICKLOCK</b></dt>
     * <dt>0x101F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the Mouse ClickLock accessibility feature on or off. This feature temporarily locks down the primary mouse button when that button is clicked and held down for the time specified by <b>SPI_SETMOUSECLICKLOCKTIME</b>. The <i>pvParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off. The default is off. For more information, see Remarks and <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">AboutMouse Input</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSECLICKLOCKTIME"></a><a id="spi_setmouseclicklocktime"></a><dl>
     * <dt><b>SPI_SETMOUSECLICKLOCKTIME</b></dt>
     * <dt>0x2009</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adjusts the time delay before the primary mouse button is locked. The <i>uiParam</i> parameter should be set to 0. The <i>pvParam</i> parameter points to a <b>DWORD</b> that specifies the time delay in milliseconds. For example, specify 1000 for a 1 second delay. The default is 1200. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEKEYS"></a><a id="spi_setmousekeys"></a><dl>
     * <dt><b>SPI_SETMOUSEKEYS</b></dt>
     * <dt>0x0037</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the MouseKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mousekeys">MOUSEKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MOUSEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSESONAR"></a><a id="spi_setmousesonar"></a><dl>
     * <dt><b>SPI_SETMOUSESONAR</b></dt>
     * <dt>0x101D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the Sonar accessibility feature on or off. This feature briefly shows several concentric circles around the mouse pointer when the user presses and releases the CTRL key. The <i>pvParam</i> parameter specifies <b>TRUE</b> for on and <b>FALSE</b> for off. The default is off. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEVANISH"></a><a id="spi_setmousevanish"></a><dl>
     * <dt><b>SPI_SETMOUSEVANISH</b></dt>
     * <dt>0x1021</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the Vanish feature on or off. This feature hides the mouse pointer when the user types; the pointer reappears when the user moves the mouse. The <i>pvParam</i> parameter specifies <b>TRUE</b> for on and <b>FALSE</b> for off. The default is off. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENREADER"></a><a id="spi_setscreenreader"></a><dl>
     * <dt><b>SPI_SETSCREENREADER</b></dt>
     * <dt>0x0047</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a screen review utility is running. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * <div class="alert"><b>Note</b>Narrator, the screen reader that is included with Windows, does not set the <b>SPI_SETSCREENREADER</b> or <b>SPI_GETSCREENREADER</b> flags.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSERIALKEYS"></a><a id="spi_setserialkeys"></a><dl>
     * <dt><b>SPI_SETSERIALKEYS</b></dt>
     * <dt>0x003F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>The user should control this setting through the Control Panel.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSHOWSOUNDS"></a><a id="spi_setshowsounds"></a><dl>
     * <dt><b>SPI_SETSHOWSOUNDS</b></dt>
     * <dt>0x0039</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the ShowSounds accessibility feature on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSOUNDSENTRY"></a><a id="spi_setsoundsentry"></a><dl>
     * <dt><b>SPI_SETSOUNDSENTRY</b></dt>
     * <dt>0x0041</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the <b>SoundSentry</b> accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-soundsentrya">SOUNDSENTRY</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(SOUNDSENTRY)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSTICKYKEYS"></a><a id="spi_setstickykeys"></a><dl>
     * <dt><b>SPI_SETSTICKYKEYS</b></dt>
     * <dt>0x003B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the StickyKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-stickykeys">STICKYKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(STICKYKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTOGGLEKEYS"></a><a id="spi_settogglekeys"></a><dl>
     * <dt><b>SPI_SETTOGGLEKEYS</b></dt>
     * <dt>0x0035</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the ToggleKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-togglekeys">TOGGLEKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(TOGGLEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the desktop parameters.
     * 
     * <table>
     * <tr>
     * <th>Desktop parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCLEARTYPE"></a><a id="spi_getcleartype"></a><dl>
     * <dt><b>SPI_GETCLEARTYPE</b></dt>
     * <dt>0x1048</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether ClearType is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if ClearType is enabled, or <b>FALSE</b> otherwise.
     * 
     * ClearType is a software technology that improves the readability of text on liquid crystal display (LCD) monitors.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDESKWALLPAPER"></a><a id="spi_getdeskwallpaper"></a><dl>
     * <dt><b>SPI_GETDESKWALLPAPER</b></dt>
     * <dt>0x0073</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the full path of the bitmap file for the desktop wallpaper. The <i>pvParam</i> parameter must point to a buffer to receive the null-terminated path string. Set the <i>uiParam</i> parameter to the size, in characters, of the <i>pvParam</i> buffer. The returned string will not exceed <b>MAX_PATH</b> characters. If there is no desktop wallpaper, the returned string is empty.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDROPSHADOW"></a><a id="spi_getdropshadow"></a><dl>
     * <dt><b>SPI_GETDROPSHADOW</b></dt>
     * <dt>0x1024</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the drop shadow effect is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that returns <b>TRUE</b> if enabled or <b>FALSE</b> if disabled.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFLATMENU"></a><a id="spi_getflatmenu"></a><dl>
     * <dt><b>SPI_GETFLATMENU</b></dt>
     * <dt>0x1022</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether native User menus have flat menu appearance. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that returns <b>TRUE</b> if the flat menu appearance is set, or <b>FALSE</b> otherwise.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHING"></a><a id="spi_getfontsmoothing"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHING</b></dt>
     * <dt>0x004A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the font smoothing feature is enabled. This feature uses font antialiasing to make font curves appear smoother by painting pixels at different gray levels.
     * 
     * The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the feature is enabled, or <b>FALSE</b> if  it is not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHINGCONTRAST"></a><a id="spi_getfontsmoothingcontrast"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHINGCONTRAST</b></dt>
     * <dt>0x200C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves a contrast value that is used in <a href="https://www.microsoft.com/typography/WhatIsClearType.mspx">ClearType</a> smoothing. The <i>pvParam</i> parameter must point to a <b>UINT</b> that receives the information. Valid contrast values are from 1000 to 2200. The default value is 1400.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHINGORIENTATION"></a><a id="spi_getfontsmoothingorientation"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHINGORIENTATION</b></dt>
     * <dt>0x2012</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the font smoothing orientation. The <i>pvParam</i> parameter must point to a <b>UINT</b> that receives the information. The possible values are <b>FE_FONTSMOOTHINGORIENTATIONBGR</b> (blue-green-red) and <b>FE_FONTSMOOTHINGORIENTATIONRGB</b> (red-green-blue).
     * 
     * <b>WindowsXP/2000:</b>This parameter is not supported until WindowsXP with SP2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHINGTYPE"></a><a id="spi_getfontsmoothingtype"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHINGTYPE</b></dt>
     * <dt>0x200A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type of font smoothing. The <i>pvParam</i> parameter must point to a <b>UINT</b> that receives the information. The possible values are <b>FE_FONTSMOOTHINGSTANDARD</b> and <b>FE_FONTSMOOTHINGCLEARTYPE</b>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWORKAREA"></a><a id="spi_getworkarea"></a><dl>
     * <dt><b>SPI_GETWORKAREA</b></dt>
     * <dt>0x0030</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the size of the work area on the primary display monitor. The work area is the portion of the screen not obscured by the system taskbar or by application desktop toolbars. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the coordinates of the work area, expressed in physical pixel size. Any DPI virtualization mode of the caller has no effect on this output.
     * 
     * To get the work area of a monitor other than the primary display monitor, call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmonitorinfoa">GetMonitorInfo</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCLEARTYPE"></a><a id="spi_setcleartype"></a><dl>
     * <dt><b>SPI_SETCLEARTYPE</b></dt>
     * <dt>0x1049</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns ClearType on or off. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable ClearType, or <b>FALSE</b> to disable it.
     * 
     * ClearType is a software technology that improves the readability of text on LCD monitors.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCURSORS"></a><a id="spi_setcursors"></a><dl>
     * <dt><b>SPI_SETCURSORS</b></dt>
     * <dt>0x0057</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reloads the system cursors. Set the <i>uiParam</i> parameter to zero and the <i>pvParam</i> parameter to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDESKPATTERN"></a><a id="spi_setdeskpattern"></a><dl>
     * <dt><b>SPI_SETDESKPATTERN</b></dt>
     * <dt>0x0015</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current desktop pattern by causing Windows to read the <b>Pattern=</b> setting from the WIN.INI file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDESKWALLPAPER"></a><a id="spi_setdeskwallpaper"></a><dl>
     * <dt><b>SPI_SETDESKWALLPAPER</b></dt>
     * <dt>0x0014</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <div class="alert"><b>Note</b>When the <b>SPI_SETDESKWALLPAPER</b> flag is used, <b>SystemParametersInfo</b> returns <b>TRUE</b> unless there is an error (like when the specified file doesn't exist).</div>
     * <div></div>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDROPSHADOW"></a><a id="spi_setdropshadow"></a><dl>
     * <dt><b>SPI_SETDROPSHADOW</b></dt>
     * <dt>0x1025</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the drop shadow effect. Set <i>pvParam</i> to <b>TRUE</b> to enable the drop shadow effect or <b>FALSE</b> to disable it. You must also have <b>CS_DROPSHADOW</b> in the window class style.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFLATMENU"></a><a id="spi_setflatmenu"></a><dl>
     * <dt><b>SPI_SETFLATMENU</b></dt>
     * <dt>0x1023</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables flat menu appearance for native User menus. Set <i>pvParam</i> to <b>TRUE</b> to enable flat menu appearance or <b>FALSE</b> to disable it.
     * 
     * When enabled, the menu bar uses <b>COLOR_MENUBAR</b> for the menubar background, <b>COLOR_MENU</b> for the menu-popup background, <b>COLOR_MENUHILIGHT</b> for the fill of the current menu selection, and <b>COLOR_HILIGHT</b> for the outline of the current menu selection. If disabled, menus are drawn using the same metrics and colors as in Windows2000.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHING"></a><a id="spi_setfontsmoothing"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHING</b></dt>
     * <dt>0x004B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the font smoothing feature, which uses font antialiasing to make font curves appear smoother by painting pixels at different gray levels.
     * 
     * To enable the feature, set the <i>uiParam</i> parameter to <b>TRUE</b>. To disable the feature, set <i>uiParam</i> to <b>FALSE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHINGCONTRAST"></a><a id="spi_setfontsmoothingcontrast"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHINGCONTRAST</b></dt>
     * <dt>0x200D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the contrast value used in <a href="https://www.microsoft.com/typography/WhatIsClearType.mspx">ClearType</a> smoothing. The <i>pvParam</i> parameter is the contrast value. Valid contrast values are from 1000 to 2200. The default value is 1400.
     * 
     * <b>SPI_SETFONTSMOOTHINGTYPE</b> must also be set to <b>FE_FONTSMOOTHINGCLEARTYPE</b>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHINGORIENTATION"></a><a id="spi_setfontsmoothingorientation"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHINGORIENTATION</b></dt>
     * <dt>0x2013</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the font smoothing orientation. The <i>pvParam</i> parameter is either <b>FE_FONTSMOOTHINGORIENTATIONBGR</b> (blue-green-red) or <b>FE_FONTSMOOTHINGORIENTATIONRGB</b> (red-green-blue).
     * 
     * <b>WindowsXP/2000:</b>This parameter is not supported until WindowsXP with SP2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHINGTYPE"></a><a id="spi_setfontsmoothingtype"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHINGTYPE</b></dt>
     * <dt>0x200B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the font smoothing type. The <i>pvParam</i> parameter is either <b>FE_FONTSMOOTHINGSTANDARD</b>, if standard anti-aliasing is used, or <b>FE_FONTSMOOTHINGCLEARTYPE</b>, if <a href="https://www.microsoft.com/typography/WhatIsClearType.mspx">ClearType</a> is used. The default is <b>FE_FONTSMOOTHINGSTANDARD</b>.
     * 
     * <b>SPI_SETFONTSMOOTHING</b> must also be set.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWORKAREA"></a><a id="spi_setworkarea"></a><dl>
     * <dt><b>SPI_SETWORKAREA</b></dt>
     * <dt>0x002F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the size of the work area. The work area is the portion of the screen not obscured by the system taskbar or by application desktop toolbars. The <i>pvParam</i> parameter is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the new work area rectangle, expressed in virtual screen coordinates. In a system with multiple display monitors, the function sets the work area of the monitor that contains the specified rectangle.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the icon parameters.
     * 
     * <table>
     * <tr>
     * <th>Icon parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETICONMETRICS"></a><a id="spi_geticonmetrics"></a><dl>
     * <dt><b>SPI_GETICONMETRICS</b></dt>
     * <dt>0x002D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the metrics associated with icons. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconmetricsa">ICONMETRICS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ICONMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETICONTITLELOGFONT"></a><a id="spi_geticontitlelogfont"></a><dl>
     * <dt><b>SPI_GETICONTITLELOGFONT</b></dt>
     * <dt>0x001F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the logical font information for the current icon-title font. The <i>uiParam</i> parameter specifies the size of a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure, and the <i>pvParam</i> parameter must point to the <b>LOGFONT</b> structure to fill in.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETICONTITLEWRAP"></a><a id="spi_geticontitlewrap"></a><dl>
     * <dt><b>SPI_GETICONTITLEWRAP</b></dt>
     * <dt>0x0019</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether icon-title wrapping is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_ICONHORIZONTALSPACING"></a><a id="spi_iconhorizontalspacing"></a><dl>
     * <dt><b>SPI_ICONHORIZONTALSPACING</b></dt>
     * <dt>0x000D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets or retrieves the width, in pixels, of an icon cell. The system uses this rectangle to arrange icons in large icon view.
     * 
     * To set this value, set <i>uiParam</i> to the new value and set <i>pvParam</i> to <b>NULL</b>. You cannot set this value to less than <b>SM_CXICON</b>.
     * 
     * To retrieve this value, <i>pvParam</i> must point to an integer that receives the  current value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_ICONVERTICALSPACING"></a><a id="spi_iconverticalspacing"></a><dl>
     * <dt><b>SPI_ICONVERTICALSPACING</b></dt>
     * <dt>0x0018</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets or retrieves the height, in pixels, of an icon cell.
     * 
     * To set this value, set <i>uiParam</i> to the new value and set <i>pvParam</i> to <b>NULL</b>. You cannot set this value to less than <b>SM_CYICON</b>.
     * 
     * To retrieve this value, <i>pvParam</i> must point to an integer that receives the  current value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONMETRICS"></a><a id="spi_seticonmetrics"></a><dl>
     * <dt><b>SPI_SETICONMETRICS</b></dt>
     * <dt>0x002E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the metrics associated with icons. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconmetricsa">ICONMETRICS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ICONMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONS"></a><a id="spi_seticons"></a><dl>
     * <dt><b>SPI_SETICONS</b></dt>
     * <dt>0x0058</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reloads the system icons. Set the <i>uiParam</i> parameter to zero and the <i>pvParam</i> parameter to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONTITLELOGFONT"></a><a id="spi_seticontitlelogfont"></a><dl>
     * <dt><b>SPI_SETICONTITLELOGFONT</b></dt>
     * <dt>0x0022</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the font that is used for icon titles. The <i>uiParam</i> parameter specifies the size of a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure, and the <i>pvParam</i> parameter must point to a <b>LOGFONT</b> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONTITLEWRAP"></a><a id="spi_seticontitlewrap"></a><dl>
     * <dt><b>SPI_SETICONTITLEWRAP</b></dt>
     * <dt>0x001A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns icon-title wrapping on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the input parameters. They include parameters related to the keyboard, mouse, pen, input language, and the warning beeper.
     * 
     * <table>
     * <tr>
     * <th>Input parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETBEEP"></a><a id="spi_getbeep"></a><dl>
     * <dt><b>SPI_GETBEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the warning beeper is on.
     * 
     * The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the beeper is on, or <b>FALSE</b> if it is off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETBLOCKSENDINPUTRESETS"></a><a id="spi_getblocksendinputresets"></a><dl>
     * <dt><b>SPI_GETBLOCKSENDINPUTRESETS</b></dt>
     * <dt>0x1026</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves a <b>BOOL</b> indicating whether an application can reset the screensaver's timer by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendinput">SendInput</a> function to simulate keyboard or mouse input. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the simulated input will be blocked, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCONTACTVISUALIZATION"></a><a id="spi_getcontactvisualization"></a><dl>
     * <dt><b>SPI_GETCONTACTVISUALIZATION</b></dt>
     * <dt>0x2018</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current contact visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that receives the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/contact-visualization">Contact Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDEFAULTINPUTLANG"></a><a id="spi_getdefaultinputlang"></a><dl>
     * <dt><b>SPI_GETDEFAULTINPUTLANG</b></dt>
     * <dt>0x0059</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the input locale identifier for the system default input language. The <i>pvParam</i> parameter must point to an <b>HKL</b> variable that receives this value. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-keyboard-input">Languages, Locales, and Keyboard Layouts</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETGESTUREVISUALIZATION"></a><a id="spi_getgesturevisualization"></a><dl>
     * <dt><b>SPI_GETGESTUREVISUALIZATION</b></dt>
     * <dt>0x201A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that receives the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/gesture-visualization">Gesture Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDCUES"></a><a id="spi_getkeyboardcues"></a><dl>
     * <dt><b>SPI_GETKEYBOARDCUES</b></dt>
     * <dt>0x100A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether menu access keys are always underlined. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if menu access keys are always underlined, and <b>FALSE</b> if they are underlined only when the menu is activated by the keyboard.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDDELAY"></a><a id="spi_getkeyboarddelay"></a><dl>
     * <dt><b>SPI_GETKEYBOARDDELAY</b></dt>
     * <dt>0x0016</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the keyboard repeat-delay setting, which is a value in the range from 0 (approximately 250 ms delay) through 3 (approximately 1 second delay). The actual delay associated with each value may vary depending on the hardware. The <i>pvParam</i> parameter must point to an integer variable that receives the setting.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDPREF"></a><a id="spi_getkeyboardpref"></a><dl>
     * <dt><b>SPI_GETKEYBOARDPREF</b></dt>
     * <dt>0x0044</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the user relies on the keyboard instead of the mouse, and wants applications to display keyboard interfaces that would otherwise be hidden. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the user relies on the keyboard; or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDSPEED"></a><a id="spi_getkeyboardspeed"></a><dl>
     * <dt><b>SPI_GETKEYBOARDSPEED</b></dt>
     * <dt>0x000A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the keyboard repeat-speed setting, which is a value in the range from 0 (approximately 2.5 repetitions per second) through 31 (approximately 30 repetitions per second). The actual repeat rates are hardware-dependent and may vary from a linear scale by as much as 20%. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the setting.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSE"></a><a id="spi_getmouse"></a><dl>
     * <dt><b>SPI_GETMOUSE</b></dt>
     * <dt>0x0003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the two mouse threshold values and the mouse acceleration. The <i>pvParam</i> parameter must point to an array of three integers that receives these values. See <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-mouse_event">mouse_event</a> for further information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEHOVERHEIGHT"></a><a id="spi_getmousehoverheight"></a><dl>
     * <dt><b>SPI_GETMOUSEHOVERHEIGHT</b></dt>
     * <dt>0x0064</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the height, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the height.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEHOVERTIME"></a><a id="spi_getmousehovertime"></a><dl>
     * <dt><b>SPI_GETMOUSEHOVERTIME</b></dt>
     * <dt>0x0066</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEHOVERWIDTH"></a><a id="spi_getmousehoverwidth"></a><dl>
     * <dt><b>SPI_GETMOUSEHOVERWIDTH</b></dt>
     * <dt>0x0062</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the width, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the width.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSESPEED"></a><a id="spi_getmousespeed"></a><dl>
     * <dt><b>SPI_GETMOUSESPEED</b></dt>
     * <dt>0x0070</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current mouse speed. The mouse speed determines how far the pointer will move based on the distance the mouse moves. The <i>pvParam</i> parameter must point to an integer that receives a value which ranges between 1 (slowest) and 20 (fastest). A value of 10 is the default. The value can be set by an end-user using the mouse control panel application or by an application using <b>SPI_SETMOUSESPEED</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSETRAILS"></a><a id="spi_getmousetrails"></a><dl>
     * <dt><b>SPI_GETMOUSETRAILS</b></dt>
     * <dt>0x005E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the Mouse Trails feature is enabled. This feature improves the visibility of mouse cursor movements by briefly showing a trail of cursors and quickly erasing them.
     * 
     * The <i>pvParam</i> parameter must point to an integer variable that receives a value. if  the value is zero or 1, the feature is disabled. If the value is greater than 1, the feature is enabled and the value indicates the number of cursors drawn in the trail. The <i>uiParam</i> parameter is not used.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEWHEELROUTING"></a><a id="spi_getmousewheelrouting"></a><dl>
     * <dt><b>SPI_GETMOUSEWHEELROUTING</b></dt>
     * <dt>0x201C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the routing setting for mouse wheel input. The routing setting determines whether mouse wheel input is sent to the app with focus (foreground) or the app under the mouse cursor.
     * 
     * The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the routing option. The <i>uiParam</i> parameter is not used.
     * 
     * If  the value is zero (MOUSEWHEEL_ROUTING_FOCUS), mouse wheel input is delivered to the app with focus. If the value is 1 (MOUSEWHEEL_ROUTING_HYBRID), mouse wheel input is delivered to the app with focus (desktop apps) or the app under the mouse pointer (Windows Store apps).
     *  
     * <b>Starting with Windows10:</b> If the value is 2 (MOUSEWHEEL_ROUTING_MOUSE_POS), mouse wheel input is delivered to the app under the mouse pointer. This is the new default, and MOUSEWHEEL_ROUTING_HYBRID is no longer available in Settings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENVISUALIZATION"></a><a id="spi_getpenvisualization"></a><dl>
     * <dt><b>SPI_GETPENVISUALIZATION</b></dt>
     * <dt>0x201E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current pen gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that receives the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/pen-visualization">Pen Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSNAPTODEFBUTTON"></a><a id="spi_getsnaptodefbutton"></a><dl>
     * <dt><b>SPI_GETSNAPTODEFBUTTON</b></dt>
     * <dt>0x005F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the snap-to-default-button feature is enabled. If enabled, the mouse cursor automatically moves to the default button, such as <b>OK</b> or <b>Apply</b>, of a dialog box. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the feature is on, or <b>FALSE</b> if it is off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSYSTEMLANGUAGEBAR"></a><a id="spi_getsystemlanguagebar"></a><dl>
     * <dt><b>SPI_GETSYSTEMLANGUAGEBAR</b></dt>
     * <dt>0x1050</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Determines whether the system language bar is enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the language bar is enabled, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTHREADLOCALINPUTSETTINGS"></a><a id="spi_getthreadlocalinputsettings"></a><dl>
     * <dt><b>SPI_GETTHREADLOCALINPUTSETTINGS</b></dt>
     * <dt>0x104E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Determines whether the active input settings have Local (per-thread, <b>TRUE</b>) or Global (session, <b>FALSE</b>) scope. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWHEELSCROLLCHARS"></a><a id="spi_getwheelscrollchars"></a><dl>
     * <dt><b>SPI_GETWHEELSCROLLCHARS</b></dt>
     * <dt>0x006C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of characters to scroll when the horizontal mouse wheel is moved. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the number of lines. The default value is 3.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWHEELSCROLLLINES"></a><a id="spi_getwheelscrolllines"></a><dl>
     * <dt><b>SPI_GETWHEELSCROLLLINES</b></dt>
     * <dt>0x0068</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of lines to scroll when the vertical mouse wheel is moved. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the number of lines. The default value is 3.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETBEEP"></a><a id="spi_setbeep"></a><dl>
     * <dt><b>SPI_SETBEEP</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the warning beeper on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETBLOCKSENDINPUTRESETS"></a><a id="spi_setblocksendinputresets"></a><dl>
     * <dt><b>SPI_SETBLOCKSENDINPUTRESETS</b></dt>
     * <dt>0x1027</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether an application can reset the screensaver's timer by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendinput">SendInput</a> function to simulate keyboard or mouse input. The <i>uiParam</i> parameter specifies <b>TRUE</b> if the screensaver will not be deactivated by simulated input, or <b>FALSE</b> if the screensaver will be deactivated by simulated input.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCONTACTVISUALIZATION"></a><a id="spi_setcontactvisualization"></a><dl>
     * <dt><b>SPI_SETCONTACTVISUALIZATION</b></dt>
     * <dt>0x2019</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current contact visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that identifies the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/contact-visualization">Contact Visualization</a>.
     * 
     * <div class="alert"><b>Note</b>If contact visualizations are disabled, gesture visualizations cannot be enabled.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDEFAULTINPUTLANG"></a><a id="spi_setdefaultinputlang"></a><dl>
     * <dt><b>SPI_SETDEFAULTINPUTLANG</b></dt>
     * <dt>0x005A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the default input language for the system shell and applications. The specified language must be displayable using the current system character set. The <i>pvParam</i> parameter must point to an <b>HKL</b> variable that contains the input locale identifier for the default language. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-keyboard-input">Languages, Locales, and Keyboard Layouts</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOUBLECLICKTIME"></a><a id="spi_setdoubleclicktime"></a><dl>
     * <dt><b>SPI_SETDOUBLECLICKTIME</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the double-click time for the mouse to the value of the <i>uiParam</i> parameter. If the <i>uiParam</i> value is greater than 5000 milliseconds, the system sets the double-click time to 5000 milliseconds.
     * 
     * The double-click time is the maximum number of milliseconds that can occur between the first and second clicks of a double-click. You can also call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setdoubleclicktime">SetDoubleClickTime</a> function to set the double-click time. To get the current double-click time, call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdoubleclicktime">GetDoubleClickTime</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOUBLECLKHEIGHT"></a><a id="spi_setdoubleclkheight"></a><dl>
     * <dt><b>SPI_SETDOUBLECLKHEIGHT</b></dt>
     * <dt>0x001E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height of the double-click rectangle to the value of the <i>uiParam</i> parameter.
     * 
     * The double-click rectangle is the rectangle within which the second click of a double-click must fall for it to be registered as a double-click.
     * 
     * To retrieve the height of the double-click rectangle, call  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CYDOUBLECLK</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOUBLECLKWIDTH"></a><a id="spi_setdoubleclkwidth"></a><dl>
     * <dt><b>SPI_SETDOUBLECLKWIDTH</b></dt>
     * <dt>0x001D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the width of the double-click rectangle to the value of the <i>uiParam</i> parameter.
     * 
     * The double-click rectangle is the rectangle within which the second click of a double-click must fall for it to be registered as a double-click.
     * 
     * To retrieve the width of the double-click rectangle, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CXDOUBLECLK</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETGESTUREVISUALIZATION"></a><a id="spi_setgesturevisualization"></a><dl>
     * <dt><b>SPI_SETGESTUREVISUALIZATION</b></dt>
     * <dt>0x201B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that identifies the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/gesture-visualization">Gesture Visualization</a>.
     * 
     * <div class="alert"><b>Note</b>If contact visualizations are disabled, gesture visualizations cannot be enabled.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDCUES"></a><a id="spi_setkeyboardcues"></a><dl>
     * <dt><b>SPI_SETKEYBOARDCUES</b></dt>
     * <dt>0x100B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the underlining of menu access key letters. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to always underline menu access keys, or <b>FALSE</b> to underline menu access keys only when the menu is activated from the keyboard.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDDELAY"></a><a id="spi_setkeyboarddelay"></a><dl>
     * <dt><b>SPI_SETKEYBOARDDELAY</b></dt>
     * <dt>0x0017</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the keyboard repeat-delay setting. The <i>uiParam</i> parameter must specify 0, 1, 2, or 3, where zero sets the shortest delay approximately 250 ms) and 3 sets the longest delay (approximately 1 second). The actual delay associated with each value may vary depending on the hardware.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDPREF"></a><a id="spi_setkeyboardpref"></a><dl>
     * <dt><b>SPI_SETKEYBOARDPREF</b></dt>
     * <dt>0x0045</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the keyboard preference. The <i>uiParam</i> parameter specifies <b>TRUE</b> if the user relies on the keyboard instead of the mouse, and wants applications to display keyboard interfaces that would otherwise be hidden; <i>uiParam</i> is <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDSPEED"></a><a id="spi_setkeyboardspeed"></a><dl>
     * <dt><b>SPI_SETKEYBOARDSPEED</b></dt>
     * <dt>0x000B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the keyboard repeat-speed setting. The <i>uiParam</i> parameter must specify a value in the range from 0 (approximately 2.5 repetitions per second) through 31 (approximately 30 repetitions per second). The actual repeat rates are hardware-dependent and may vary from a linear scale by as much as 20%. If <i>uiParam</i> is greater than 31, the parameter is set to 31.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLANGTOGGLE"></a><a id="spi_setlangtoggle"></a><dl>
     * <dt><b>SPI_SETLANGTOGGLE</b></dt>
     * <dt>0x005B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the hot key set for switching between input languages. The <i>uiParam</i> and <i>pvParam</i> parameters are not used. The value sets the shortcut keys in the keyboard property sheets by reading the registry again. The registry must be set before this flag is used. the path in the registry is 
     *                                     <b>HKEY_CURRENT_USER</b>&#92;<b>Keyboard Layout</b>&#92;<b>Toggle</b></p>. Valid values are "1" = ALT+SHIFT, "2" = CTRL+SHIFT, and "3" = none.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSE"></a><a id="spi_setmouse"></a><dl>
     * <dt><b>SPI_SETMOUSE</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the two mouse threshold values and the mouse acceleration. The <i>pvParam</i> parameter must point to an array of three integers that specifies these values. See <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-mouse_event">mouse_event</a> for further information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEBUTTONSWAP"></a><a id="spi_setmousebuttonswap"></a><dl>
     * <dt><b>SPI_SETMOUSEBUTTONSWAP</b></dt>
     * <dt>0x0021</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Swaps or restores the meaning of the left and right mouse buttons. The <i>uiParam</i> parameter specifies <b>TRUE</b> to swap the meanings of the buttons, or <b>FALSE</b> to restore their original meanings.
     * 
     * To retrieve the current setting, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_SWAPBUTTON</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEHOVERHEIGHT"></a><a id="spi_setmousehoverheight"></a><dl>
     * <dt><b>SPI_SETMOUSEHOVERHEIGHT</b></dt>
     * <dt>0x0065</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. Set the <i>uiParam</i> parameter to the new height.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEHOVERTIME"></a><a id="spi_setmousehovertime"></a><dl>
     * <dt><b>SPI_SETMOUSEHOVERTIME</b></dt>
     * <dt>0x0067</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. This is used only if you pass <b>HOVER_DEFAULT</b> in the <i>dwHoverTime</i> parameter in the call to <b>TrackMouseEvent</b>. Set the <i>uiParam</i> parameter to the new time.
     * 
     * The time specified should be between <b>USER_TIMER_MAXIMUM</b> and <b>USER_TIMER_MINIMUM</b>. If <i>uiParam</i> is less than <b>USER_TIMER_MINIMUM</b>, the function will use <b>USER_TIMER_MINIMUM</b>. If <i>uiParam</i> is greater than <b>USER_TIMER_MAXIMUM</b>, the function will be <b>USER_TIMER_MAXIMUM</b>.               
     * 
     * <b>Windows Server2003 and WindowsXP:</b>The operating system does not enforce the use of <b>USER_TIMER_MAXIMUM</b> and <b>USER_TIMER_MINIMUM</b> until Windows Server2003 with SP1 and WindowsXP with SP2.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEHOVERWIDTH"></a><a id="spi_setmousehoverwidth"></a><dl>
     * <dt><b>SPI_SETMOUSEHOVERWIDTH</b></dt>
     * <dt>0x0063</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the width, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. Set the <i>uiParam</i> parameter to the new width.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSESPEED"></a><a id="spi_setmousespeed"></a><dl>
     * <dt><b>SPI_SETMOUSESPEED</b></dt>
     * <dt>0x0071</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current mouse speed. The <i>pvParam</i> parameter is an integer between 1 (slowest) and 20 (fastest). A value of 10 is the default. This value is typically set using the mouse control panel application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSETRAILS"></a><a id="spi_setmousetrails"></a><dl>
     * <dt><b>SPI_SETMOUSETRAILS</b></dt>
     * <dt>0x005D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the Mouse Trails feature, which improves the visibility of mouse cursor movements by briefly showing a trail of cursors and quickly erasing them.
     * 
     * To disable the feature, set the <i>uiParam</i> parameter to zero or 1. To enable the  feature, set <i>uiParam</i> to a value greater than 1 to indicate the number of cursors drawn in the trail.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEWHEELROUTING"></a><a id="spi_setmousewheelrouting"></a><dl>
     * <dt><b>SPI_SETMOUSEWHEELROUTING</b></dt>
     * <dt>0x201D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the routing setting for mouse wheel input. The routing setting determines whether mouse wheel input is sent to the app with focus (foreground) or the app under the mouse cursor.
     * 
     * The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the routing option. Set the <i>uiParam</i> parameter to zero.
     *  
     * If  the value is zero (MOUSEWHEEL_ROUTING_FOCUS), mouse wheel input is delivered to the app with focus. If the value is 1 (MOUSEWHEEL_ROUTING_HYBRID), mouse wheel input is delivered to the app with focus (desktop apps) or the app under the mouse pointer (Windows Store apps).
     *  
     * <b>Starting with Windows10:</b> If the value is 2 (MOUSEWHEEL_ROUTING_MOUSE_POS), mouse wheel input is delivered to the app under the mouse pointer. This is the new default, and MOUSEWHEEL_ROUTING_HYBRID is no longer available in Settings.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENVISUALIZATION"></a><a id="spi_setpenvisualization"></a><dl>
     * <dt><b>SPI_SETPENVISUALIZATION</b></dt>
     * <dt>0x201F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current pen gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that identifies the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/pen-visualization">Pen Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSNAPTODEFBUTTON"></a><a id="spi_setsnaptodefbutton"></a><dl>
     * <dt><b>SPI_SETSNAPTODEFBUTTON</b></dt>
     * <dt>0x0060</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the snap-to-default-button feature. If enabled, the mouse cursor automatically moves to the default button, such as <b>OK</b> or <b>Apply</b>, of a dialog box. Set the <i>uiParam</i> parameter to <b>TRUE</b> to enable the feature, or <b>FALSE</b> to disable it. Applications should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function when displaying a dialog box so the dialog manager can position the mouse cursor.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSYSTEMLANGUAGEBAR"></a><a id="spi_setsystemlanguagebar"></a><dl>
     * <dt><b>SPI_SETSYSTEMLANGUAGEBAR</b></dt>
     * <dt>0x1051</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Turns the legacy language bar feature on or off. The <i>pvParam</i> parameter is a pointer to a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable the legacy language bar, or <b>FALSE</b> to disable it. The flag is supported on Windows8 where the legacy language bar is replaced by Input Switcher and therefore turned off by default. Turning the legacy language bar on is provided for compatibility reasons and has no effect on the Input Switcher.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTHREADLOCALINPUTSETTINGS"></a><a id="spi_setthreadlocalinputsettings"></a><dl>
     * <dt><b>SPI_SETTHREADLOCALINPUTSETTINGS</b></dt>
     * <dt>0x104F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Determines whether the active input settings have Local (per-thread, <b>TRUE</b>) or Global (session, <b>FALSE</b>) scope. The <i>pvParam</i> parameter must be a <b>BOOL</b> variable, casted by PVOID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWHEELSCROLLCHARS"></a><a id="spi_setwheelscrollchars"></a><dl>
     * <dt><b>SPI_SETWHEELSCROLLCHARS</b></dt>
     * <dt>0x006D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the number of characters to scroll when the horizontal mouse wheel is moved. The number of characters is set from the <i>uiParam</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWHEELSCROLLLINES"></a><a id="spi_setwheelscrolllines"></a><dl>
     * <dt><b>SPI_SETWHEELSCROLLLINES</b></dt>
     * <dt>0x0069</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the number of lines to scroll when the vertical mouse wheel is moved. The number of lines is set from the <i>uiParam</i> parameter.
     * 
     * The number of lines is the suggested number of lines to scroll when the mouse wheel is rolled without using modifier keys. If the number is 0, then no scrolling should occur. If the number of lines to scroll is  greater than the number of lines viewable, and in particular if it is <b>WHEEL_PAGESCROLL</b> (#defined as <b>UINT_MAX</b>), the scroll operation should be interpreted as clicking once in the page down or page up regions of the scroll bar.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the menu parameters.
     * 
     * <table>
     * <tr>
     * <th>Menu parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUDROPALIGNMENT"></a><a id="spi_getmenudropalignment"></a><dl>
     * <dt><b>SPI_GETMENUDROPALIGNMENT</b></dt>
     * <dt>0x001B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether pop-up menus are left-aligned or right-aligned, relative to the corresponding menu-bar item. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if right-aligned, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUFADE"></a><a id="spi_getmenufade"></a><dl>
     * <dt><b>SPI_GETMENUFADE</b></dt>
     * <dt>0x1012</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether menu fade animation is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> when fade animation is enabled and <b>FALSE</b> when it isdisabled. If fade animation is disabled, menus use slide animation. This flag is ignored unless menu animation is enabled, which you can do using the <b>SPI_SETMENUANIMATION</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUSHOWDELAY"></a><a id="spi_getmenushowdelay"></a><dl>
     * <dt><b>SPI_GETMENUSHOWDELAY</b></dt>
     * <dt>0x006A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse cursor is over a submenu item. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the time of the delay.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUDROPALIGNMENT"></a><a id="spi_setmenudropalignment"></a><dl>
     * <dt><b>SPI_SETMENUDROPALIGNMENT</b></dt>
     * <dt>0x001C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the alignment value of pop-up menus. The <i>uiParam</i> parameter specifies <b>TRUE</b> for right alignment, or <b>FALSE</b> for left alignment.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUFADE"></a><a id="spi_setmenufade"></a><dl>
     * <dt><b>SPI_SETMENUFADE</b></dt>
     * <dt>0x1013</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables menu fade animation. Set <i>pvParam</i> to <b>TRUE</b> to enable the menu fade effect or <b>FALSE</b> to disable it. If fade animation is disabled, menus use slide animation. he The menu fade effect is possible only if the system has a color depth of more than 256 colors. This flag is ignored unless <b>SPI_MENUANIMATION</b> is also set. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUSHOWDELAY"></a><a id="spi_setmenushowdelay"></a><dl>
     * <dt><b>SPI_SETMENUSHOWDELAY</b></dt>
     * <dt>0x006B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets <i>uiParam</i> to the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse cursor is over a submenu item.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the power parameters.
     * 
     * Beginning with Windows Server2008 and WindowsVista, these power parameters are not supported. Instead, to determine the current display power state, an application should register for <b>GUID_MONITOR_POWER_STATE</b> notifications. To determine the current display power down time-out, an application should register for notification of changes to the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Power/registering-for-power-events">Registering for Power Events</a>.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>To determine the current display power state, use the following power parameters.
     * 
     * <table>
     * <tr>
     * <th>Power parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLOWPOWERACTIVE"></a><a id="spi_getlowpoweractive"></a><dl>
     * <dt><b>SPI_GETLOWPOWERACTIVE</b></dt>
     * <dt>0x0053</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Determines whether the low-power phase of screen saving is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> if disabled. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLOWPOWERTIMEOUT"></a><a id="spi_getlowpowertimeout"></a><dl>
     * <dt><b>SPI_GETLOWPOWERTIMEOUT</b></dt>
     * <dt>0x004F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Retrieves the time-out value for the low-power phase of screen saving. The <i>pvParam</i> parameter must point to an integer variable that receives the value. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPOWEROFFACTIVE"></a><a id="spi_getpoweroffactive"></a><dl>
     * <dt><b>SPI_GETPOWEROFFACTIVE</b></dt>
     * <dt>0x0054</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. When the power-off phase of screen saving is enabled, the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting is greater than zero.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Determines whether the power-off phase of screen saving is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> if disabled. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPOWEROFFTIMEOUT"></a><a id="spi_getpowerofftimeout"></a><dl>
     * <dt><b>SPI_GETPOWEROFFTIMEOUT</b></dt>
     * <dt>0x0050</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. Instead, check the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Retrieves the time-out value for the power-off phase of screen saving. The <i>pvParam</i> parameter must point to an integer variable that receives the value. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLOWPOWERACTIVE"></a><a id="spi_setlowpoweractive"></a><dl>
     * <dt><b>SPI_SETLOWPOWERACTIVE</b></dt>
     * <dt>0x0055</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Activates or deactivates the low-power phase of screen saving. Set <i>uiParam</i> to 1 to activate, or zero to deactivate. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLOWPOWERTIMEOUT"></a><a id="spi_setlowpowertimeout"></a><dl>
     * <dt><b>SPI_SETLOWPOWERTIMEOUT</b></dt>
     * <dt>0x0051</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Sets the time-out value, in seconds, for the low-power phase of screen saving. The <i>uiParam</i> parameter specifies the new value. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPOWEROFFACTIVE"></a><a id="spi_setpoweroffactive"></a><dl>
     * <dt><b>SPI_SETPOWEROFFACTIVE</b></dt>
     * <dt>0x0056</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. Instead, set the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Activates or deactivates the power-off phase of screen saving. Set <i>uiParam</i> to 1 to activate, or zero to deactivate. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPOWEROFFTIMEOUT"></a><a id="spi_setpowerofftimeout"></a><dl>
     * <dt><b>SPI_SETPOWEROFFTIMEOUT</b></dt>
     * <dt>0x0052</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. Instead, set the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting to a time-out value.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Sets the time-out value, in seconds, for the power-off phase of screen saving. The <i>uiParam</i> parameter specifies the new value. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the screen saver parameters.
     * 
     * <table>
     * <tr>
     * <th>Screen saver parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVEACTIVE"></a><a id="spi_getscreensaveactive"></a><dl>
     * <dt><b>SPI_GETSCREENSAVEACTIVE</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether screen saving is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if screen saving is enabled, or <b>FALSE</b> otherwise.
     * 
     * <b>Windows7, Windows Server2008R2 and Windows2000:</b>The function returns <b>TRUE</b> even when screen saving is not enabled. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVERRUNNING"></a><a id="spi_getscreensaverrunning"></a><dl>
     * <dt><b>SPI_GETSCREENSAVERRUNNING</b></dt>
     * <dt>0x0072</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a screen saver is currently running on the window station of the calling process. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if a screen saver is currently running, or <b>FALSE</b> otherwise. Note that only the interactive window station, WinSta0, can have a screen saver running.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVESECURE"></a><a id="spi_getscreensavesecure"></a><dl>
     * <dt><b>SPI_GETSCREENSAVESECURE</b></dt>
     * <dt>0x0076</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the screen saver  requires a password to display the Windows desktop. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the screen saver requires a password, or <b>FALSE</b> otherwise. The <i>uiParam</i> parameter is ignored.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVETIMEOUT"></a><a id="spi_getscreensavetimeout"></a><dl>
     * <dt><b>SPI_GETSCREENSAVETIMEOUT</b></dt>
     * <dt>0x000E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the screen saver time-out value, in seconds. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENSAVEACTIVE"></a><a id="spi_setscreensaveactive"></a><dl>
     * <dt><b>SPI_SETSCREENSAVEACTIVE</b></dt>
     * <dt>0x0011</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the state of the screen saver. The <i>uiParam</i> parameter specifies <b>TRUE</b> to activate screen saving, or <b>FALSE</b> to deactivate it.
     * 
     * If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENSAVESECURE"></a><a id="spi_setscreensavesecure"></a><dl>
     * <dt><b>SPI_SETSCREENSAVESECURE</b></dt>
     * <dt>0x0077</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether the screen saver requires the user to enter a password to display the Windows desktop. The <i>uiParam</i> parameter is a <b>BOOL</b> variable. The <i>pvParam</i> parameter is ignored. Set <i>uiParam</i> to <b>TRUE</b> to require a password, or <b>FALSE</b> to not require a password.
     * 
     * If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENSAVETIMEOUT"></a><a id="spi_setscreensavetimeout"></a><dl>
     * <dt><b>SPI_SETSCREENSAVETIMEOUT</b></dt>
     * <dt>0x000F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the screen saver time-out value to the value of the <i>uiParam</i> parameter. This value is the amount of time, in seconds, that the system must be idle before the screen saver activates.
     * 
     * If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the time-out parameters for applications and services.
     * 
     * <table>
     * <tr>
     * <th>Time-out parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETHUNGAPPTIMEOUT"></a><a id="spi_gethungapptimeout"></a><dl>
     * <dt><b>SPI_GETHUNGAPPTIMEOUT</b></dt>
     * <dt>0x0078</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of milliseconds that a thread can go without dispatching a message before the system considers it unresponsive. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWAITTOKILLTIMEOUT"></a><a id="spi_getwaittokilltimeout"></a><dl>
     * <dt><b>SPI_GETWAITTOKILLTIMEOUT</b></dt>
     * <dt>0x007A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of milliseconds that the system waits before terminating an application that does not respond to a shutdown request. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWAITTOKILLSERVICETIMEOUT"></a><a id="spi_getwaittokillservicetimeout"></a><dl>
     * <dt><b>SPI_GETWAITTOKILLSERVICETIMEOUT</b></dt>
     * <dt>0x007C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of milliseconds that the service control manager waits before terminating a service that does not respond to a shutdown request. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETHUNGAPPTIMEOUT"></a><a id="spi_sethungapptimeout"></a><dl>
     * <dt><b>SPI_SETHUNGAPPTIMEOUT</b></dt>
     * <dt>0x0079</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the hung application time-out to the value of the <i>uiParam</i> parameter. This value is the number of milliseconds that a thread can go without dispatching a message before the system considers it unresponsive.
     *                     
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWAITTOKILLTIMEOUT"></a><a id="spi_setwaittokilltimeout"></a><dl>
     * <dt><b>SPI_SETWAITTOKILLTIMEOUT</b></dt>
     * <dt>0x007B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the application shutdown request time-out to the value of the <i>uiParam</i> parameter. This value is the number of milliseconds that the system waits before terminating an application that does not respond to a shutdown request.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWAITTOKILLSERVICETIMEOUT"></a><a id="spi_setwaittokillservicetimeout"></a><dl>
     * <dt><b>SPI_SETWAITTOKILLSERVICETIMEOUT</b></dt>
     * <dt>0x007D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the service shutdown request time-out to the value of the <i>uiParam</i> parameter. This value is the number of milliseconds that the system waits before terminating a service that does not respond to a shutdown request.
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the UI effects. The <b>SPI_SETUIEFFECTS</b> value is used to enable or disable all UI effects at once. This table contains the complete list of UI effect values.
     * 
     * <table>
     * <tr>
     * <th>UI effects parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCOMBOBOXANIMATION"></a><a id="spi_getcomboboxanimation"></a><dl>
     * <dt><b>SPI_GETCOMBOBOXANIMATION</b></dt>
     * <dt>0x1004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the slide-open effect for combo boxes is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCURSORSHADOW"></a><a id="spi_getcursorshadow"></a><dl>
     * <dt><b>SPI_GETCURSORSHADOW</b></dt>
     * <dt>0x101A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the cursor has a shadow around it. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the shadow is enabled, <b>FALSE</b> if it is disabled. This effect appears only if the system has a color depth of more than 256 colors.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETGRADIENTCAPTIONS"></a><a id="spi_getgradientcaptions"></a><dl>
     * <dt><b>SPI_GETGRADIENTCAPTIONS</b></dt>
     * <dt>0x1008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the gradient effect for window title bars is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled. For more information about the gradient effect, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETHOTTRACKING"></a><a id="spi_gethottracking"></a><dl>
     * <dt><b>SPI_GETHOTTRACKING</b></dt>
     * <dt>0x100E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether hot tracking of user-interface elements, such as menu names on menu bars, is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled.
     * 
     * Hot tracking means that when the cursor moves over an item, it is highlighted but not selected. You can query this value to decide whether to use hot tracking in the user interface of your application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLISTBOXSMOOTHSCROLLING"></a><a id="spi_getlistboxsmoothscrolling"></a><dl>
     * <dt><b>SPI_GETLISTBOXSMOOTHSCROLLING</b></dt>
     * <dt>0x1006</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the smooth-scrolling effect for list boxes is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUANIMATION"></a><a id="spi_getmenuanimation"></a><dl>
     * <dt><b>SPI_GETMENUANIMATION</b></dt>
     * <dt>0x1002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the menu animation feature is enabled. This master switch must be on to enable menu animation effects. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if animation is enabled and <b>FALSE</b> if it is disabled.
     * 
     * If animation is enabled, <b>SPI_GETMENUFADE</b> indicates whether menus use fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUUNDERLINES"></a><a id="spi_getmenuunderlines"></a><dl>
     * <dt><b>SPI_GETMENUUNDERLINES</b></dt>
     * <dt>0x100A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>SPI_GETKEYBOARDCUES</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSELECTIONFADE"></a><a id="spi_getselectionfade"></a><dl>
     * <dt><b>SPI_GETSELECTIONFADE</b></dt>
     * <dt>0x1014</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the selection fade effect is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> if disabled.
     * 
     * The selection fade effect causes the menu item selected by the user to remain on the screen briefly while fading out after the menu is dismissed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTOOLTIPANIMATION"></a><a id="spi_gettooltipanimation"></a><dl>
     * <dt><b>SPI_GETTOOLTIPANIMATION</b></dt>
     * <dt>0x1016</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether ToolTip animation is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> if disabled. If ToolTip animation is enabled, <b>SPI_GETTOOLTIPFADE</b> indicates whether ToolTips use fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTOOLTIPFADE"></a><a id="spi_gettooltipfade"></a><dl>
     * <dt><b>SPI_GETTOOLTIPFADE</b></dt>
     * <dt>0x1018</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If <b>SPI_SETTOOLTIPANIMATION</b> is enabled, <b>SPI_GETTOOLTIPFADE</b> indicates whether ToolTip animation uses a fade effect or a slide effect. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for fade animation or <b>FALSE</b> for slide animation. For more information on slide and fade effects, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETUIEFFECTS"></a><a id="spi_getuieffects"></a><dl>
     * <dt><b>SPI_GETUIEFFECTS</b></dt>
     * <dt>0x103E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether UI effects are enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if all UI effects are enabled, or <b>FALSE</b> if they are disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCOMBOBOXANIMATION"></a><a id="spi_setcomboboxanimation"></a><dl>
     * <dt><b>SPI_SETCOMBOBOXANIMATION</b></dt>
     * <dt>0x1005</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the slide-open effect for combo boxes. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable the gradient effect, or <b>FALSE</b> to disable it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCURSORSHADOW"></a><a id="spi_setcursorshadow"></a><dl>
     * <dt><b>SPI_SETCURSORSHADOW</b></dt>
     * <dt>0x101B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables a shadow around the cursor. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable the shadow or <b>FALSE</b> to disable the shadow. This effect appears only if the system has a color depth of more than 256 colors.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETGRADIENTCAPTIONS"></a><a id="spi_setgradientcaptions"></a><dl>
     * <dt><b>SPI_SETGRADIENTCAPTIONS</b></dt>
     * <dt>0x1009</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the gradient effect for window title bars. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable it, or <b>FALSE</b> to disable it. The gradient effect is possible only if the system has a color depth of more than 256 colors. For more information about the gradient effect, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETHOTTRACKING"></a><a id="spi_sethottracking"></a><dl>
     * <dt><b>SPI_SETHOTTRACKING</b></dt>
     * <dt>0x100F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables hot tracking of user-interface elements such as menu names on menu bars. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable it, or <b>FALSE</b> to disable it.
     * 
     * Hot-tracking means that when the cursor moves over an item, it is highlighted but not selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLISTBOXSMOOTHSCROLLING"></a><a id="spi_setlistboxsmoothscrolling"></a><dl>
     * <dt><b>SPI_SETLISTBOXSMOOTHSCROLLING</b></dt>
     * <dt>0x1007</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the smooth-scrolling effect for list boxes. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable the smooth-scrolling effect, or <b>FALSE</b> to disable it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUANIMATION"></a><a id="spi_setmenuanimation"></a><dl>
     * <dt><b>SPI_SETMENUANIMATION</b></dt>
     * <dt>0x1003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables menu animation. This master switch must be on for any menu animation to occur. The <i>pvParam</i> parameter is a <b>BOOL</b> variable; set <i>pvParam</i> to <b>TRUE</b> to enable animation and <b>FALSE</b> to disable animation.
     * 
     * If animation is enabled, <b>SPI_GETMENUFADE</b> indicates whether menus use fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUUNDERLINES"></a><a id="spi_setmenuunderlines"></a><dl>
     * <dt><b>SPI_SETMENUUNDERLINES</b></dt>
     * <dt>0x100B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>SPI_SETKEYBOARDCUES</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSELECTIONFADE"></a><a id="spi_setselectionfade"></a><dl>
     * <dt><b>SPI_SETSELECTIONFADE</b></dt>
     * <dt>0x1015</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set <i>pvParam</i> to <b>TRUE</b> to enable the selection fade effect or <b>FALSE</b> to disable it.
     * 
     * The selection fade effect causes the menu item selected by the user to remain on the screen briefly while fading out after the menu is dismissed. The selection fade effect is possible only if the system has a color depth of more than 256 colors.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTOOLTIPANIMATION"></a><a id="spi_settooltipanimation"></a><dl>
     * <dt><b>SPI_SETTOOLTIPANIMATION</b></dt>
     * <dt>0x1017</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set <i>pvParam</i> to <b>TRUE</b> to enable ToolTip animation or <b>FALSE</b> to disable it. If enabled, you can use <b>SPI_SETTOOLTIPFADE</b> to specify fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTOOLTIPFADE"></a><a id="spi_settooltipfade"></a><dl>
     * <dt><b>SPI_SETTOOLTIPFADE</b></dt>
     * <dt>0x1019</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <b>SPI_SETTOOLTIPANIMATION</b> flag is enabled, use <b>SPI_SETTOOLTIPFADE</b> to indicate whether ToolTip animation uses a fade effect or a slide effect. Set <i>pvParam</i> to <b>TRUE</b> for fade animation or <b>FALSE</b> for slide animation. The tooltip fade effect is possible only if the system has a color depth of more than 256 colors. For more information on the slide and fade effects, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETUIEFFECTS"></a><a id="spi_setuieffects"></a><dl>
     * <dt><b>SPI_SETUIEFFECTS</b></dt>
     * <dt>0x103F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables UI effects. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable all UI effects or <b>FALSE</b> to disable all UI effects.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the window parameters.
     * 
     * <table>
     * <tr>
     * <th>Window parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACTIVEWINDOWTRACKING"></a><a id="spi_getactivewindowtracking"></a><dl>
     * <dt><b>SPI_GETACTIVEWINDOWTRACKING</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether active window tracking (activating the window the mouse is on) is on or off. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACTIVEWNDTRKZORDER"></a><a id="spi_getactivewndtrkzorder"></a><dl>
     * <dt><b>SPI_GETACTIVEWNDTRKZORDER</b></dt>
     * <dt>0x100C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether windows activated through active window tracking will be brought to the top. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACTIVEWNDTRKTIMEOUT"></a><a id="spi_getactivewndtrktimeout"></a><dl>
     * <dt><b>SPI_GETACTIVEWNDTRKTIMEOUT</b></dt>
     * <dt>0x2002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the active window tracking delay, in milliseconds. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETANIMATION"></a><a id="spi_getanimation"></a><dl>
     * <dt><b>SPI_GETANIMATION</b></dt>
     * <dt>0x0048</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the animation effects associated with user actions. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-animationinfo">ANIMATIONINFO</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ANIMATIONINFO)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETBORDER"></a><a id="spi_getborder"></a><dl>
     * <dt><b>SPI_GETBORDER</b></dt>
     * <dt>0x0005</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the border multiplier factor that determines the width of a window's sizing border. The <i>pvParam</i> parameter must point to an integer variable that receives this value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCARETWIDTH"></a><a id="spi_getcaretwidth"></a><dl>
     * <dt><b>SPI_GETCARETWIDTH</b></dt>
     * <dt>0x2006</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the caret width in edit controls, in pixels. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives this value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDOCKMOVING"></a><a id="spi_getdockmoving"></a><dl>
     * <dt><b>SPI_GETDOCKMOVING</b></dt>
     * <dt>0x0090</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a window is docked when it is moved to the top, left, or right edges of a monitor or monitor array. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDRAGFROMMAXIMIZE"></a><a id="spi_getdragfrommaximize"></a><dl>
     * <dt><b>SPI_GETDRAGFROMMAXIMIZE</b></dt>
     * <dt>0x008C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a maximized window is restored when its caption bar is dragged. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDRAGFULLWINDOWS"></a><a id="spi_getdragfullwindows"></a><dl>
     * <dt><b>SPI_GETDRAGFULLWINDOWS</b></dt>
     * <dt>0x0026</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether dragging of full windows is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOREGROUNDFLASHCOUNT"></a><a id="spi_getforegroundflashcount"></a><dl>
     * <dt><b>SPI_GETFOREGROUNDFLASHCOUNT</b></dt>
     * <dt>0x2004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of times <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> will flash the taskbar button when rejecting a foreground switch request. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOREGROUNDLOCKTIMEOUT"></a><a id="spi_getforegroundlocktimeout"></a><dl>
     * <dt><b>SPI_GETFOREGROUNDLOCKTIMEOUT</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the amount of time following user input, in milliseconds, during which the system will not allow applications to force themselves into the foreground. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMINIMIZEDMETRICS"></a><a id="spi_getminimizedmetrics"></a><dl>
     * <dt><b>SPI_GETMINIMIZEDMETRICS</b></dt>
     * <dt>0x002B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the metrics associated with minimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-minimizedmetrics">MINIMIZEDMETRICS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MINIMIZEDMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEDOCKTHRESHOLD"></a><a id="spi_getmousedockthreshold"></a><dl>
     * <dt><b>SPI_GETMOUSEDOCKTHRESHOLD</b></dt>
     * <dt>0x007E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a monitor or monitor array. The default threshold is 1. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the value.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEDRAGOUTTHRESHOLD"></a><a id="spi_getmousedragoutthreshold"></a><dl>
     * <dt><b>SPI_GETMOUSEDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0084</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a monitor or a monitor array toward the center. The default threshold is 20.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSESIDEMOVETHRESHOLD"></a><a id="spi_getmousesidemovethreshold"></a><dl>
     * <dt><b>SPI_GETMOUSESIDEMOVETHRESHOLD</b></dt>
     * <dt>0x0088</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels from the top of a monitor or a monitor array where a vertically maximized window  is restored when dragged with the mouse. The default threshold is 50.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETNONCLIENTMETRICS"></a><a id="spi_getnonclientmetrics"></a><dl>
     * <dt><b>SPI_GETNONCLIENTMETRICS</b></dt>
     * <dt>0x0029</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the metrics associated with the nonclient area of nonminimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa">NONCLIENTMETRICS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(NONCLIENTMETRICS)</c>.
     * 
     * <b>Windows Server 2003 and Windows XP/2000:  </b>See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa#remarks">NONCLIENTMETRICS</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENDOCKTHRESHOLD"></a><a id="spi_getpendockthreshold"></a><dl>
     * <dt><b>SPI_GETPENDOCKTHRESHOLD</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Retrieves the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a monitor or monitor array. The default is 30.</b>
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENDRAGOUTTHRESHOLD"></a><a id="spi_getpendragoutthreshold"></a><dl>
     * <dt><b>SPI_GETPENDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0086</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a monitor or monitor array toward its center. The default threshold is 30.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENSIDEMOVETHRESHOLD"></a><a id="spi_getpensidemovethreshold"></a><dl>
     * <dt><b>SPI_GETPENSIDEMOVETHRESHOLD</b></dt>
     * <dt>0x008A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels from the top of a monitor or monitor array where a vertically maximized window  is restored when dragged with the mouse. The default threshold is 50.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSHOWIMEUI"></a><a id="spi_getshowimeui"></a><dl>
     * <dt><b>SPI_GETSHOWIMEUI</b></dt>
     * <dt>0x006E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the IME status window is visible (on a per-user basis). The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the status window is visible, or <b>FALSE</b> if it is not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSNAPSIZING"></a><a id="spi_getsnapsizing"></a><dl>
     * <dt><b>SPI_GETSNAPSIZING</b></dt>
     * <dt>0x008E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a window is vertically maximized when it is sized to the top or bottom of a monitor or monitor array. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWINARRANGING"></a><a id="spi_getwinarranging"></a><dl>
     * <dt><b>SPI_GETWINARRANGING</b></dt>
     * <dt>0x0082</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether window arrangement is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by simplifying the default behavior of a window when it is dragged or sized.
     * 
     * The following parameters retrieve individual window arrangement settings:
     * 
     * <dl>
     * <dd><b>SPI_GETDOCKMOVING</b></dd>
     * <dd><b>SPI_GETMOUSEDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_GETMOUSEDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_GETMOUSESIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_GETPENDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_GETPENDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_GETPENSIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_GETSNAPSIZING</b></dd>
     * </dl>
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACTIVEWINDOWTRACKING"></a><a id="spi_setactivewindowtracking"></a><dl>
     * <dt><b>SPI_SETACTIVEWINDOWTRACKING</b></dt>
     * <dt>0x1001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets active window tracking (activating the window the mouse is on) either on or off. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACTIVEWNDTRKZORDER"></a><a id="spi_setactivewndtrkzorder"></a><dl>
     * <dt><b>SPI_SETACTIVEWNDTRKZORDER</b></dt>
     * <dt>0x100D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether or not windows activated through active window tracking should be brought to the top. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACTIVEWNDTRKTIMEOUT"></a><a id="spi_setactivewndtrktimeout"></a><dl>
     * <dt><b>SPI_SETACTIVEWNDTRKTIMEOUT</b></dt>
     * <dt>0x2003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the active window tracking delay. Set <i>pvParam</i> to the number of milliseconds to delay before activating the window under the mouse pointer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETANIMATION"></a><a id="spi_setanimation"></a><dl>
     * <dt><b>SPI_SETANIMATION</b></dt>
     * <dt>0x0049</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the animation effects associated with user actions. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-animationinfo">ANIMATIONINFO</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ANIMATIONINFO)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETBORDER"></a><a id="spi_setborder"></a><dl>
     * <dt><b>SPI_SETBORDER</b></dt>
     * <dt>0x0006</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the border multiplier factor that determines the width of a window's sizing border. The <i>uiParam</i> parameter specifies the new value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCARETWIDTH"></a><a id="spi_setcaretwidth"></a><dl>
     * <dt><b>SPI_SETCARETWIDTH</b></dt>
     * <dt>0x2007</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the caret width in edit controls. Set <i>pvParam</i> to the desired width, in pixels. The default and minimum value is 1.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOCKMOVING"></a><a id="spi_setdockmoving"></a><dl>
     * <dt><b>SPI_SETDOCKMOVING</b></dt>
     * <dt>0x0091</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether a window is docked when it is moved to the top, left, or right docking targets on a monitor or monitor array. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGFROMMAXIMIZE"></a><a id="spi_setdragfrommaximize"></a><dl>
     * <dt><b>SPI_SETDRAGFROMMAXIMIZE</b></dt>
     * <dt>0x008D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether a maximized window is restored when its caption bar is dragged. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGFULLWINDOWS"></a><a id="spi_setdragfullwindows"></a><dl>
     * <dt><b>SPI_SETDRAGFULLWINDOWS</b></dt>
     * <dt>0x0025</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets dragging of full windows either on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGHEIGHT"></a><a id="spi_setdragheight"></a><dl>
     * <dt><b>SPI_SETDRAGHEIGHT</b></dt>
     * <dt>0x004D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height, in pixels, of the rectangle used to detect the start of a drag operation. Set <i>uiParam</i> to the new value. To retrieve the drag height, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CYDRAG</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGWIDTH"></a><a id="spi_setdragwidth"></a><dl>
     * <dt><b>SPI_SETDRAGWIDTH</b></dt>
     * <dt>0x004C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the width, in pixels, of the rectangle used to detect the start of a drag operation. Set <i>uiParam</i> to the new value. To retrieve the drag width, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CXDRAG</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOREGROUNDFLASHCOUNT"></a><a id="spi_setforegroundflashcount"></a><dl>
     * <dt><b>SPI_SETFOREGROUNDFLASHCOUNT</b></dt>
     * <dt>0x2005</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the number of times <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> will flash the taskbar button when rejecting a foreground switch request. Set <i>pvParam</i> to the number of times to flash.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOREGROUNDLOCKTIMEOUT"></a><a id="spi_setforegroundlocktimeout"></a><dl>
     * <dt><b>SPI_SETFOREGROUNDLOCKTIMEOUT</b></dt>
     * <dt>0x2001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the amount of time following user input, in milliseconds, during which the system does not allow applications to force themselves into the foreground. Set <i>pvParam</i> to the new time-out value.
     * 
     * The calling thread must be able to change the foreground window, otherwise the call fails.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMINIMIZEDMETRICS"></a><a id="spi_setminimizedmetrics"></a><dl>
     * <dt><b>SPI_SETMINIMIZEDMETRICS</b></dt>
     * <dt>0x002C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the metrics associated with minimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-minimizedmetrics">MINIMIZEDMETRICS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MINIMIZEDMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEDOCKTHRESHOLD"></a><a id="spi_setmousedockthreshold"></a><dl>
     * <dt><b>SPI_SETMOUSEDOCKTHRESHOLD</b></dt>
     * <dt>0x007F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a monitor or monitor array. The default threshold is 1. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEDRAGOUTTHRESHOLD"></a><a id="spi_setmousedragoutthreshold"></a><dl>
     * <dt><b>SPI_SETMOUSEDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0085</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a monitor or monitor array to its center. The default threshold is 20. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSESIDEMOVETHRESHOLD"></a><a id="spi_setmousesidemovethreshold"></a><dl>
     * <dt><b>SPI_SETMOUSESIDEMOVETHRESHOLD</b></dt>
     * <dt>0x0089</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with the mouse. The default threshold is 50. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETNONCLIENTMETRICS"></a><a id="spi_setnonclientmetrics"></a><dl>
     * <dt><b>SPI_SETNONCLIENTMETRICS</b></dt>
     * <dt>0x002A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the metrics associated with the nonclient area of nonminimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa">NONCLIENTMETRICS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(NONCLIENTMETRICS)</c>. Also, the <b>lfHeight</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure must be a negative value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENDOCKTHRESHOLD"></a><a id="spi_setpendockthreshold"></a><dl>
     * <dt><b>SPI_SETPENDOCKTHRESHOLD</b></dt>
     * <dt>0x0081</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a monitor or monitor array. The default threshold is 30. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENDRAGOUTTHRESHOLD"></a><a id="spi_setpendragoutthreshold"></a><dl>
     * <dt><b>SPI_SETPENDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0087</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a monitor or monitor array to its center. The default threshold is 30. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENSIDEMOVETHRESHOLD"></a><a id="spi_setpensidemovethreshold"></a><dl>
     * <dt><b>SPI_SETPENSIDEMOVETHRESHOLD</b></dt>
     * <dt>0x008B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with a pen. The default threshold is 50. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSHOWIMEUI"></a><a id="spi_setshowimeui"></a><dl>
     * <dt><b>SPI_SETSHOWIMEUI</b></dt>
     * <dt>0x006F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether the IME status window is visible or not on a per-user basis. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSNAPSIZING"></a><a id="spi_setsnapsizing"></a><dl>
     * <dt><b>SPI_SETSNAPSIZING</b></dt>
     * <dt>0x008F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether a window is vertically maximized when it is sized to the top or bottom of the monitor. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWINARRANGING"></a><a id="spi_setwinarranging"></a><dl>
     * <dt><b>SPI_SETWINARRANGING</b></dt>
     * <dt>0x0083</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether window arrangement is enabled. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by simplifying the default behavior of a window when it is dragged or sized.
     * 
     * The following parameters set individual window arrangement settings:
     * 
     * <dl>
     * <dd><b>SPI_SETDOCKMOVING</b></dd>
     * <dd><b>SPI_SETMOUSEDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_SETMOUSEDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_SETMOUSESIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_SETPENDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_SETPENDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_SETPENSIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_SETSNAPSIZING</b></dd>
     * </dl>
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} uiParam Type: <b>UINT</b>
     * 
     * A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify zero for this parameter.
     * @param {Pointer<Void>} pvParam Type: <b>PVOID</b>
     * 
     * A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify <b>NULL</b> for this parameter. For information on the <b>PVOID</b> datatype, see <a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">Windows Data Types</a>.
     * @param {Integer} fWinIni Type: <b>UINT</b>
     * 
     * If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message is to be broadcast to all top-level windows to notify them of the change.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfoa
     * @since windows5.0
     */
    static SystemParametersInfoA(uiAction, uiParam, pvParam, fWinIni) {
        A_LastError := 0

        result := DllCall("USER32.dll\SystemParametersInfoA", "uint", uiAction, "uint", uiParam, "ptr", pvParam, "uint", fWinIni, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves or sets the value of one of the system-wide parameters. (Unicode)
     * @remarks
     * This function is intended for use with applications that allow the user to customize the environment.
     * 
     * A keyboard layout name should be derived from the hexadecimal value of the language identifier corresponding to the layout. For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout, such as the Dvorak layout, are named "00010409", "00020409" and so on. For a list of the primary language identifiers and sublanguage identifiers that make up a language identifier, see the <b>MAKELANGID</b> macro.
     * 
     * There is a difference between the High Contrast color scheme and the High Contrast Mode. The High Contrast color scheme changes the system colors to colors that have obvious contrast; you switch to this color scheme by using the Display Options in the control panel. The High Contrast Mode, which uses <b>SPI_GETHIGHCONTRAST</b> and <b>SPI_SETHIGHCONTRAST</b>, advises applications to modify their appearance for visually-impaired users. It involves such things as audible warning to users and customized color scheme (using the Accessibility Options in the control panel). For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-highcontrasta">HIGHCONTRAST</a>. For more information on general accessibility features, see <a href="https://docs.microsoft.com/windows/desktop/accessibility">Accessibility</a>.
     * 
     * During the time that the primary button is held down to activate the Mouse ClickLock feature, the user can move the mouse. After the primary button is locked down, releasing the primary button does not result in a <b>WM_LBUTTONUP</b> message. Thus, it will appear to an application that the primary button is still down. Any subsequent button message releases the primary button, sending a <b>WM_LBUTTONUP</b> message to the application, thus the button can be unlocked programmatically or through the user clicking any button.
     * 
     * This API is not DPI aware, and should not be used if the calling thread is per-monitor DPI aware. For the DPI-aware version of this API, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfofordpi">SystemParametersInfoForDPI</a>. For more information on DPI awareness, see <a href="https://docs.microsoft.com/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows">the Windows High DPI documentation.</a>
     * @param {Integer} uiAction Type: <b>UINT</b>
     * 
     * The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:                            
     * 
     * <ul>
     * <li>Accessibility parameters</li>
     * <li>Desktop parameters</li>
     * <li>Icon parameters</li>
     * <li>Input parameters</li>
     * <li>Menu parameters</li>
     * <li>Power parameters</li>
     * <li>Screen saver parameters</li>
     * <li>Time-out parameters</li>
     * <li>UI effect parameters</li>
     * <li>Window parameters</li>
     * </ul>
     * 
     * 
     * The following are the accessibility parameters.
     * 
     * <table>
     * <tr>
     * <th>Accessibility parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACCESSTIMEOUT"></a><a id="spi_getaccesstimeout"></a><dl>
     * <dt><b>SPI_GETACCESSTIMEOUT</b></dt>
     * <dt>0x003C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the time-out period associated with the accessibility features. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accesstimeout">ACCESSTIMEOUT</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ACCESSTIMEOUT)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETAUDIODESCRIPTION"></a><a id="spi_getaudiodescription"></a><dl>
     * <dt><b>SPI_GETAUDIODESCRIPTION</b></dt>
     * <dt>0x0074</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether audio descriptions are enabled or disabled. The <i>pvParam</i> parameter is a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-audiodescription">AUDIODESCRIPTION</a> structure. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(AUDIODESCRIPTION)</c>.
     * 
     * While it is possible for users who have visual impairments to hear the audio in video content, there is a lot of action in video that does not have corresponding audio. Specific audio description of what is happening in a video helps these users understand the content better. This flag enables you to determine whether audio descriptions have been enabled and in which language.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCLIENTAREAANIMATION"></a><a id="spi_getclientareaanimation"></a><dl>
     * <dt><b>SPI_GETCLIENTAREAANIMATION</b></dt>
     * <dt>0x1042</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether animations are enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if animations are enabled, or <b>FALSE</b> otherwise.
     * 
     * Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive epilepsy. This flag enables you to determine whether such animations have been disabled in the client area.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDISABLEOVERLAPPEDCONTENT"></a><a id="spi_getdisableoverlappedcontent"></a><dl>
     * <dt><b>SPI_GETDISABLEOVERLAPPEDCONTENT</b></dt>
     * <dt>0x1040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether overlapped content is enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency can reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on the screen. This flag enables you to determine whether such overlapped content has been disabled.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFILTERKEYS"></a><a id="spi_getfilterkeys"></a><dl>
     * <dt><b>SPI_GETFILTERKEYS</b></dt>
     * <dt>0x0032</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the FilterKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-filterkeys">FILTERKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(FILTERKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOCUSBORDERHEIGHT"></a><a id="spi_getfocusborderheight"></a><dl>
     * <dt><b>SPI_GETFOCUSBORDERHEIGHT</b></dt>
     * <dt>0x2010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the height, in pixels, of the top and bottom edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a>. The <i>pvParam</i> parameter must point to a <b>UINT</b> value.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOCUSBORDERWIDTH"></a><a id="spi_getfocusborderwidth"></a><dl>
     * <dt><b>SPI_GETFOCUSBORDERWIDTH</b></dt>
     * <dt>0x200E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the width, in pixels, of the left and right edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a>. The <i>pvParam</i> parameter must point to a <b>UINT</b>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETHIGHCONTRAST"></a><a id="spi_gethighcontrast"></a><dl>
     * <dt><b>SPI_GETHIGHCONTRAST</b></dt>
     * <dt>0x0042</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the HighContrast accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-highcontrasta">HIGHCONTRAST</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(HIGHCONTRAST)</c>.
     * 
     * For a general discussion, see Remarks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLOGICALDPIOVERRIDE"></a><a id="spi_getlogicaldpioverride"></a><dl>
     * <dt><b>SPI_GETLOGICALDPIOVERRIDE</b></dt>
     * <dt>0x009E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves a value that determines whether Windows8 is displaying apps using the default scaling plateau for the hardware or going to the next higher plateau. This value is based on the current "Make everything on your screen bigger" setting, found in the <b>Ease of Access</b> section of <b>PC settings</b>: 1 is on, 0 is off.
     * 
     * Apps can provide text and image resources for each of several scaling plateaus: 100%, 140%, and 180%. Providing separate resources optimized for a particular scale avoids distortion due to resizing. Windows8 determines the appropriate scaling plateau based on a number of factors, including screen size and pixel density. When "Make everything on your screen bigger" is selected (SPI_GETLOGICALDPIOVERRIDE returns a value of 1), Windows uses resources from the next higher plateau. For example, in the case of hardware that Windows determines should use a scale of <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">SCALE_100_PERCENT</a>, this override causes Windows to use the <a href="https://docs.microsoft.com/windows/desktop/api/shtypes/ne-shtypes-device_scale_factor">SCALE_140_PERCENT</a> scale value, assuming that it does not violate other constraints.
     * 
     * <div class="alert"><b>Note</b>You should not use this value. It might be altered or unavailable in subsequent versions of Windows. Instead, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellscalingapi/nf-shellscalingapi-getscalefactorfordevice">GetScaleFactorForDevice</a> function or the <a href="https://docs.microsoft.com/uwp/api/Windows.Graphics.Display.DisplayProperties">DisplayProperties</a> class to retrieve the preferred scaling factor. Desktop applications should use desktop logical DPI rather than scale factor. Desktop logical DPI can be retrieved through the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getdevicecaps">GetDeviceCaps</a> function.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMESSAGEDURATION"></a><a id="spi_getmessageduration"></a><dl>
     * <dt><b>SPI_GETMESSAGEDURATION</b></dt>
     * <dt>0x2016</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time that notification pop-ups should be displayed, in seconds. The <i>pvParam</i> parameter must point to a <b>ULONG</b> that receives the message duration.
     * 
     * Users with visual impairments or cognitive conditions such as ADHD and dyslexia might need a longer time to read the text in notification messages. This flag enables you to retrieve the message duration.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSECLICKLOCK"></a><a id="spi_getmouseclicklock"></a><dl>
     * <dt><b>SPI_GETMOUSECLICKLOCK</b></dt>
     * <dt>0x101E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the state of the Mouse ClickLock feature. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSECLICKLOCKTIME"></a><a id="spi_getmouseclicklocktime"></a><dl>
     * <dt><b>SPI_GETMOUSECLICKLOCKTIME</b></dt>
     * <dt>0x2008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time delay before the primary mouse button is locked. The <i>pvParam</i> parameter must point to <b>DWORD</b> that receives the time delay, in milliseconds. This is only enabled if <b>SPI_SETMOUSECLICKLOCK</b> is set to <b>TRUE</b>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEKEYS"></a><a id="spi_getmousekeys"></a><dl>
     * <dt><b>SPI_GETMOUSEKEYS</b></dt>
     * <dt>0x0036</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the MouseKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mousekeys">MOUSEKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MOUSEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSESONAR"></a><a id="spi_getmousesonar"></a><dl>
     * <dt><b>SPI_GETMOUSESONAR</b></dt>
     * <dt>0x101C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the state of the Mouse Sonar feature. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> otherwise. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEVANISH"></a><a id="spi_getmousevanish"></a><dl>
     * <dt><b>SPI_GETMOUSEVANISH</b></dt>
     * <dt>0x1020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the state of the Mouse Vanish feature. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> otherwise. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENREADER"></a><a id="spi_getscreenreader"></a><dl>
     * <dt><b>SPI_GETSCREENREADER</b></dt>
     * <dt>0x0046</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a screen reviewer utility is running. A screen reviewer utility directs textual information to an output device, such as a speech synthesizer or Braille display. When this flag is set, an application should provide textual information in situations where it would otherwise present the information  graphically.
     * 
     * The <i>pvParam</i> parameter is a pointer to a <b>BOOL</b> variable that receives <b>TRUE</b> if a screen reviewer utility is running, or <b>FALSE</b> otherwise.
     * 
     * <div class="alert"><b>Note</b>Narrator, the screen reader that is included with Windows, does not set the <b>SPI_SETSCREENREADER</b> or <b>SPI_GETSCREENREADER</b> flags.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSERIALKEYS"></a><a id="spi_getserialkeys"></a><dl>
     * <dt><b>SPI_GETSERIALKEYS</b></dt>
     * <dt>0x003E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>The user should control this setting through the Control Panel.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSHOWSOUNDS"></a><a id="spi_getshowsounds"></a><dl>
     * <dt><b>SPI_GETSHOWSOUNDS</b></dt>
     * <dt>0x0038</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the Show Sounds accessibility flag is on or off. If it is on, the user requires an application to present information visually in situations where it would otherwise present the information only in audible form. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the feature is on, or <b>FALSE</b> if it is off.
     * 
     * Using this value is equivalent to calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with <b>SM_SHOWSOUNDS</b>. That is the recommended call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSOUNDSENTRY"></a><a id="spi_getsoundsentry"></a><dl>
     * <dt><b>SPI_GETSOUNDSENTRY</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the SoundSentry accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-soundsentrya">SOUNDSENTRY</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(SOUNDSENTRY)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSTICKYKEYS"></a><a id="spi_getstickykeys"></a><dl>
     * <dt><b>SPI_GETSTICKYKEYS</b></dt>
     * <dt>0x003A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the StickyKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-stickykeys">STICKYKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(STICKYKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTOGGLEKEYS"></a><a id="spi_gettogglekeys"></a><dl>
     * <dt><b>SPI_GETTOGGLEKEYS</b></dt>
     * <dt>0x0034</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves information about the ToggleKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-togglekeys">TOGGLEKEYS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(TOGGLEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACCESSTIMEOUT"></a><a id="spi_setaccesstimeout"></a><dl>
     * <dt><b>SPI_SETACCESSTIMEOUT</b></dt>
     * <dt>0x003D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the time-out period associated with the accessibility features. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-accesstimeout">ACCESSTIMEOUT</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ACCESSTIMEOUT)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETAUDIODESCRIPTION"></a><a id="spi_setaudiodescription"></a><dl>
     * <dt><b>SPI_SETAUDIODESCRIPTION</b></dt>
     * <dt>0x0075</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the audio descriptions feature on or off. The <i>pvParam</i> parameter is a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-audiodescription">AUDIODESCRIPTION</a> structure.
     * 
     * While it is possible for users who are visually impaired to hear the audio in video content, there is a lot of action in video that does not have corresponding audio. Specific audio description of what is happening in a video helps these users understand the content better. This flag enables you to enable or disable audio descriptions in the languages they are provided in.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCLIENTAREAANIMATION"></a><a id="spi_setclientareaanimation"></a><dl>
     * <dt><b>SPI_SETCLIENTAREAANIMATION</b></dt>
     * <dt>0x1043</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns client area animations on or off. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable animations and other transient effects in the client area, or <b>FALSE</b> to disable them.
     * 
     * Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive epilepsy. This flag enables you to enable or disable all such animations.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDISABLEOVERLAPPEDCONTENT"></a><a id="spi_setdisableoverlappedcontent"></a><dl>
     * <dt><b>SPI_SETDISABLEOVERLAPPEDCONTENT</b></dt>
     * <dt>0x1041</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns overlapped content (such as background images and watermarks) on or off. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to disable overlapped content, or <b>FALSE</b> to enable overlapped content.
     * 
     * Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency can reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on the screen. This flag enables you to enable or disable all such overlapped content.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFILTERKEYS"></a><a id="spi_setfilterkeys"></a><dl>
     * <dt><b>SPI_SETFILTERKEYS</b></dt>
     * <dt>0x0033</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the FilterKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-filterkeys">FILTERKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(FILTERKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOCUSBORDERHEIGHT"></a><a id="spi_setfocusborderheight"></a><dl>
     * <dt><b>SPI_SETFOCUSBORDERHEIGHT</b></dt>
     * <dt>0x2011</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height of the top and bottom edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a> to the value of the <i>pvParam</i> parameter.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOCUSBORDERWIDTH"></a><a id="spi_setfocusborderwidth"></a><dl>
     * <dt><b>SPI_SETFOCUSBORDERWIDTH</b></dt>
     * <dt>0x200F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height of the left and right edges of the focus rectangle drawn with <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-drawfocusrect">DrawFocusRect</a> to the value of the <i>pvParam</i> parameter.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETHIGHCONTRAST"></a><a id="spi_sethighcontrast"></a><dl>
     * <dt><b>SPI_SETHIGHCONTRAST</b></dt>
     * <dt>0x0043</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the HighContrast accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-highcontrasta">HIGHCONTRAST</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(HIGHCONTRAST)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLOGICALDPIOVERRIDE"></a><a id="spi_setlogicaldpioverride"></a><dl>
     * <dt><b>SPI_SETLOGICALDPIOVERRIDE</b></dt>
     * <dt>0x009F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMESSAGEDURATION"></a><a id="spi_setmessageduration"></a><dl>
     * <dt><b>SPI_SETMESSAGEDURATION</b></dt>
     * <dt>0x2017</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the time that notification pop-ups should be displayed, in seconds. The <i>pvParam</i> parameter specifies the message duration.
     * 
     * Users with visual impairments or cognitive conditions such as ADHD and dyslexia might need a longer time to read the text in notification messages. This flag enables you to set the message duration.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSECLICKLOCK"></a><a id="spi_setmouseclicklock"></a><dl>
     * <dt><b>SPI_SETMOUSECLICKLOCK</b></dt>
     * <dt>0x101F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the Mouse ClickLock accessibility feature on or off. This feature temporarily locks down the primary mouse button when that button is clicked and held down for the time specified by <b>SPI_SETMOUSECLICKLOCKTIME</b>. The <i>pvParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off. The default is off. For more information, see Remarks and <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">AboutMouse Input</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSECLICKLOCKTIME"></a><a id="spi_setmouseclicklocktime"></a><dl>
     * <dt><b>SPI_SETMOUSECLICKLOCKTIME</b></dt>
     * <dt>0x2009</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Adjusts the time delay before the primary mouse button is locked. The <i>uiParam</i> parameter should be set to 0. The <i>pvParam</i> parameter points to a <b>DWORD</b> that specifies the time delay in milliseconds. For example, specify 1000 for a 1 second delay. The default is 1200. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEKEYS"></a><a id="spi_setmousekeys"></a><dl>
     * <dt><b>SPI_SETMOUSEKEYS</b></dt>
     * <dt>0x0037</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the MouseKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-mousekeys">MOUSEKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MOUSEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSESONAR"></a><a id="spi_setmousesonar"></a><dl>
     * <dt><b>SPI_SETMOUSESONAR</b></dt>
     * <dt>0x101D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the Sonar accessibility feature on or off. This feature briefly shows several concentric circles around the mouse pointer when the user presses and releases the CTRL key. The <i>pvParam</i> parameter specifies <b>TRUE</b> for on and <b>FALSE</b> for off. The default is off. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEVANISH"></a><a id="spi_setmousevanish"></a><dl>
     * <dt><b>SPI_SETMOUSEVANISH</b></dt>
     * <dt>0x1021</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the Vanish feature on or off. This feature hides the mouse pointer when the user types; the pointer reappears when the user moves the mouse. The <i>pvParam</i> parameter specifies <b>TRUE</b> for on and <b>FALSE</b> for off. The default is off. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-mouse-input">Mouse Input Overview</a>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENREADER"></a><a id="spi_setscreenreader"></a><dl>
     * <dt><b>SPI_SETSCREENREADER</b></dt>
     * <dt>0x0047</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a screen review utility is running. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * <div class="alert"><b>Note</b>Narrator, the screen reader that is included with Windows, does not set the <b>SPI_SETSCREENREADER</b> or <b>SPI_GETSCREENREADER</b> flags.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSERIALKEYS"></a><a id="spi_setserialkeys"></a><dl>
     * <dt><b>SPI_SETSERIALKEYS</b></dt>
     * <dt>0x003F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>The user should control this setting through the Control Panel.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSHOWSOUNDS"></a><a id="spi_setshowsounds"></a><dl>
     * <dt><b>SPI_SETSHOWSOUNDS</b></dt>
     * <dt>0x0039</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the ShowSounds accessibility feature on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSOUNDSENTRY"></a><a id="spi_setsoundsentry"></a><dl>
     * <dt><b>SPI_SETSOUNDSENTRY</b></dt>
     * <dt>0x0041</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the <b>SoundSentry</b> accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-soundsentrya">SOUNDSENTRY</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(SOUNDSENTRY)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSTICKYKEYS"></a><a id="spi_setstickykeys"></a><dl>
     * <dt><b>SPI_SETSTICKYKEYS</b></dt>
     * <dt>0x003B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the StickyKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-stickykeys">STICKYKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(STICKYKEYS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTOGGLEKEYS"></a><a id="spi_settogglekeys"></a><dl>
     * <dt><b>SPI_SETTOGGLEKEYS</b></dt>
     * <dt>0x0035</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the parameters of the ToggleKeys accessibility feature. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-togglekeys">TOGGLEKEYS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(TOGGLEKEYS)</c>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the desktop parameters.
     * 
     * <table>
     * <tr>
     * <th>Desktop parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCLEARTYPE"></a><a id="spi_getcleartype"></a><dl>
     * <dt><b>SPI_GETCLEARTYPE</b></dt>
     * <dt>0x1048</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether ClearType is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if ClearType is enabled, or <b>FALSE</b> otherwise.
     * 
     * ClearType is a software technology that improves the readability of text on liquid crystal display (LCD) monitors.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDESKWALLPAPER"></a><a id="spi_getdeskwallpaper"></a><dl>
     * <dt><b>SPI_GETDESKWALLPAPER</b></dt>
     * <dt>0x0073</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the full path of the bitmap file for the desktop wallpaper. The <i>pvParam</i> parameter must point to a buffer to receive the null-terminated path string. Set the <i>uiParam</i> parameter to the size, in characters, of the <i>pvParam</i> buffer. The returned string will not exceed <b>MAX_PATH</b> characters. If there is no desktop wallpaper, the returned string is empty.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDROPSHADOW"></a><a id="spi_getdropshadow"></a><dl>
     * <dt><b>SPI_GETDROPSHADOW</b></dt>
     * <dt>0x1024</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the drop shadow effect is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that returns <b>TRUE</b> if enabled or <b>FALSE</b> if disabled.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFLATMENU"></a><a id="spi_getflatmenu"></a><dl>
     * <dt><b>SPI_GETFLATMENU</b></dt>
     * <dt>0x1022</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether native User menus have flat menu appearance. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that returns <b>TRUE</b> if the flat menu appearance is set, or <b>FALSE</b> otherwise.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHING"></a><a id="spi_getfontsmoothing"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHING</b></dt>
     * <dt>0x004A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the font smoothing feature is enabled. This feature uses font antialiasing to make font curves appear smoother by painting pixels at different gray levels.
     * 
     * The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the feature is enabled, or <b>FALSE</b> if  it is not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHINGCONTRAST"></a><a id="spi_getfontsmoothingcontrast"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHINGCONTRAST</b></dt>
     * <dt>0x200C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves a contrast value that is used in <a href="https://www.microsoft.com/typography/WhatIsClearType.mspx">ClearType</a> smoothing. The <i>pvParam</i> parameter must point to a <b>UINT</b> that receives the information. Valid contrast values are from 1000 to 2200. The default value is 1400.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHINGORIENTATION"></a><a id="spi_getfontsmoothingorientation"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHINGORIENTATION</b></dt>
     * <dt>0x2012</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the font smoothing orientation. The <i>pvParam</i> parameter must point to a <b>UINT</b> that receives the information. The possible values are <b>FE_FONTSMOOTHINGORIENTATIONBGR</b> (blue-green-red) and <b>FE_FONTSMOOTHINGORIENTATIONRGB</b> (red-green-blue).
     * 
     * <b>WindowsXP/2000:</b>This parameter is not supported until WindowsXP with SP2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFONTSMOOTHINGTYPE"></a><a id="spi_getfontsmoothingtype"></a><dl>
     * <dt><b>SPI_GETFONTSMOOTHINGTYPE</b></dt>
     * <dt>0x200A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type of font smoothing. The <i>pvParam</i> parameter must point to a <b>UINT</b> that receives the information. The possible values are <b>FE_FONTSMOOTHINGSTANDARD</b> and <b>FE_FONTSMOOTHINGCLEARTYPE</b>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWORKAREA"></a><a id="spi_getworkarea"></a><dl>
     * <dt><b>SPI_GETWORKAREA</b></dt>
     * <dt>0x0030</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the size of the work area on the primary display monitor. The work area is the portion of the screen not obscured by the system taskbar or by application desktop toolbars. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that receives the coordinates of the work area, expressed in physical pixel size. Any DPI virtualization mode of the caller has no effect on this output.
     * 
     * To get the work area of a monitor other than the primary display monitor, call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getmonitorinfoa">GetMonitorInfo</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCLEARTYPE"></a><a id="spi_setcleartype"></a><dl>
     * <dt><b>SPI_SETCLEARTYPE</b></dt>
     * <dt>0x1049</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns ClearType on or off. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable ClearType, or <b>FALSE</b> to disable it.
     * 
     * ClearType is a software technology that improves the readability of text on LCD monitors.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCURSORS"></a><a id="spi_setcursors"></a><dl>
     * <dt><b>SPI_SETCURSORS</b></dt>
     * <dt>0x0057</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reloads the system cursors. Set the <i>uiParam</i> parameter to zero and the <i>pvParam</i> parameter to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDESKPATTERN"></a><a id="spi_setdeskpattern"></a><dl>
     * <dt><b>SPI_SETDESKPATTERN</b></dt>
     * <dt>0x0015</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current desktop pattern by causing Windows to read the <b>Pattern=</b> setting from the WIN.INI file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDESKWALLPAPER"></a><a id="spi_setdeskwallpaper"></a><dl>
     * <dt><b>SPI_SETDESKWALLPAPER</b></dt>
     * <dt>0x0014</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <div class="alert"><b>Note</b>When the <b>SPI_SETDESKWALLPAPER</b> flag is used, <b>SystemParametersInfo</b> returns <b>TRUE</b> unless there is an error (like when the specified file doesn't exist).</div>
     * <div></div>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDROPSHADOW"></a><a id="spi_setdropshadow"></a><dl>
     * <dt><b>SPI_SETDROPSHADOW</b></dt>
     * <dt>0x1025</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the drop shadow effect. Set <i>pvParam</i> to <b>TRUE</b> to enable the drop shadow effect or <b>FALSE</b> to disable it. You must also have <b>CS_DROPSHADOW</b> in the window class style.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFLATMENU"></a><a id="spi_setflatmenu"></a><dl>
     * <dt><b>SPI_SETFLATMENU</b></dt>
     * <dt>0x1023</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables flat menu appearance for native User menus. Set <i>pvParam</i> to <b>TRUE</b> to enable flat menu appearance or <b>FALSE</b> to disable it.
     * 
     * When enabled, the menu bar uses <b>COLOR_MENUBAR</b> for the menubar background, <b>COLOR_MENU</b> for the menu-popup background, <b>COLOR_MENUHILIGHT</b> for the fill of the current menu selection, and <b>COLOR_HILIGHT</b> for the outline of the current menu selection. If disabled, menus are drawn using the same metrics and colors as in Windows2000.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHING"></a><a id="spi_setfontsmoothing"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHING</b></dt>
     * <dt>0x004B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the font smoothing feature, which uses font antialiasing to make font curves appear smoother by painting pixels at different gray levels.
     * 
     * To enable the feature, set the <i>uiParam</i> parameter to <b>TRUE</b>. To disable the feature, set <i>uiParam</i> to <b>FALSE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHINGCONTRAST"></a><a id="spi_setfontsmoothingcontrast"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHINGCONTRAST</b></dt>
     * <dt>0x200D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the contrast value used in <a href="https://www.microsoft.com/typography/WhatIsClearType.mspx">ClearType</a> smoothing. The <i>pvParam</i> parameter is the contrast value. Valid contrast values are from 1000 to 2200. The default value is 1400.
     * 
     * <b>SPI_SETFONTSMOOTHINGTYPE</b> must also be set to <b>FE_FONTSMOOTHINGCLEARTYPE</b>.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHINGORIENTATION"></a><a id="spi_setfontsmoothingorientation"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHINGORIENTATION</b></dt>
     * <dt>0x2013</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the font smoothing orientation. The <i>pvParam</i> parameter is either <b>FE_FONTSMOOTHINGORIENTATIONBGR</b> (blue-green-red) or <b>FE_FONTSMOOTHINGORIENTATIONRGB</b> (red-green-blue).
     * 
     * <b>WindowsXP/2000:</b>This parameter is not supported until WindowsXP with SP2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFONTSMOOTHINGTYPE"></a><a id="spi_setfontsmoothingtype"></a><dl>
     * <dt><b>SPI_SETFONTSMOOTHINGTYPE</b></dt>
     * <dt>0x200B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the font smoothing type. The <i>pvParam</i> parameter is either <b>FE_FONTSMOOTHINGSTANDARD</b>, if standard anti-aliasing is used, or <b>FE_FONTSMOOTHINGCLEARTYPE</b>, if <a href="https://www.microsoft.com/typography/WhatIsClearType.mspx">ClearType</a> is used. The default is <b>FE_FONTSMOOTHINGSTANDARD</b>.
     * 
     * <b>SPI_SETFONTSMOOTHING</b> must also be set.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWORKAREA"></a><a id="spi_setworkarea"></a><dl>
     * <dt><b>SPI_SETWORKAREA</b></dt>
     * <dt>0x002F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the size of the work area. The work area is the portion of the screen not obscured by the system taskbar or by application desktop toolbars. The <i>pvParam</i> parameter is a pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rect">RECT</a> structure that specifies the new work area rectangle, expressed in virtual screen coordinates. In a system with multiple display monitors, the function sets the work area of the monitor that contains the specified rectangle.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the icon parameters.
     * 
     * <table>
     * <tr>
     * <th>Icon parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETICONMETRICS"></a><a id="spi_geticonmetrics"></a><dl>
     * <dt><b>SPI_GETICONMETRICS</b></dt>
     * <dt>0x002D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the metrics associated with icons. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconmetricsa">ICONMETRICS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ICONMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETICONTITLELOGFONT"></a><a id="spi_geticontitlelogfont"></a><dl>
     * <dt><b>SPI_GETICONTITLELOGFONT</b></dt>
     * <dt>0x001F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the logical font information for the current icon-title font. The <i>uiParam</i> parameter specifies the size of a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure, and the <i>pvParam</i> parameter must point to the <b>LOGFONT</b> structure to fill in.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETICONTITLEWRAP"></a><a id="spi_geticontitlewrap"></a><dl>
     * <dt><b>SPI_GETICONTITLEWRAP</b></dt>
     * <dt>0x0019</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether icon-title wrapping is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_ICONHORIZONTALSPACING"></a><a id="spi_iconhorizontalspacing"></a><dl>
     * <dt><b>SPI_ICONHORIZONTALSPACING</b></dt>
     * <dt>0x000D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets or retrieves the width, in pixels, of an icon cell. The system uses this rectangle to arrange icons in large icon view.
     * 
     * To set this value, set <i>uiParam</i> to the new value and set <i>pvParam</i> to <b>NULL</b>. You cannot set this value to less than <b>SM_CXICON</b>.
     * 
     * To retrieve this value, <i>pvParam</i> must point to an integer that receives the  current value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_ICONVERTICALSPACING"></a><a id="spi_iconverticalspacing"></a><dl>
     * <dt><b>SPI_ICONVERTICALSPACING</b></dt>
     * <dt>0x0018</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets or retrieves the height, in pixels, of an icon cell.
     * 
     * To set this value, set <i>uiParam</i> to the new value and set <i>pvParam</i> to <b>NULL</b>. You cannot set this value to less than <b>SM_CYICON</b>.
     * 
     * To retrieve this value, <i>pvParam</i> must point to an integer that receives the  current value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONMETRICS"></a><a id="spi_seticonmetrics"></a><dl>
     * <dt><b>SPI_SETICONMETRICS</b></dt>
     * <dt>0x002E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the metrics associated with icons. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-iconmetricsa">ICONMETRICS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ICONMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONS"></a><a id="spi_seticons"></a><dl>
     * <dt><b>SPI_SETICONS</b></dt>
     * <dt>0x0058</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reloads the system icons. Set the <i>uiParam</i> parameter to zero and the <i>pvParam</i> parameter to <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONTITLELOGFONT"></a><a id="spi_seticontitlelogfont"></a><dl>
     * <dt><b>SPI_SETICONTITLELOGFONT</b></dt>
     * <dt>0x0022</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the font that is used for icon titles. The <i>uiParam</i> parameter specifies the size of a <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure, and the <i>pvParam</i> parameter must point to a <b>LOGFONT</b> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETICONTITLEWRAP"></a><a id="spi_seticontitlewrap"></a><dl>
     * <dt><b>SPI_SETICONTITLEWRAP</b></dt>
     * <dt>0x001A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns icon-title wrapping on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the input parameters. They include parameters related to the keyboard, mouse, pen, input language, and the warning beeper.
     * 
     * <table>
     * <tr>
     * <th>Input parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETBEEP"></a><a id="spi_getbeep"></a><dl>
     * <dt><b>SPI_GETBEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the warning beeper is on.
     * 
     * The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the beeper is on, or <b>FALSE</b> if it is off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETBLOCKSENDINPUTRESETS"></a><a id="spi_getblocksendinputresets"></a><dl>
     * <dt><b>SPI_GETBLOCKSENDINPUTRESETS</b></dt>
     * <dt>0x1026</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves a <b>BOOL</b> indicating whether an application can reset the screensaver's timer by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendinput">SendInput</a> function to simulate keyboard or mouse input. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the simulated input will be blocked, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCONTACTVISUALIZATION"></a><a id="spi_getcontactvisualization"></a><dl>
     * <dt><b>SPI_GETCONTACTVISUALIZATION</b></dt>
     * <dt>0x2018</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current contact visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that receives the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/contact-visualization">Contact Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDEFAULTINPUTLANG"></a><a id="spi_getdefaultinputlang"></a><dl>
     * <dt><b>SPI_GETDEFAULTINPUTLANG</b></dt>
     * <dt>0x0059</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the input locale identifier for the system default input language. The <i>pvParam</i> parameter must point to an <b>HKL</b> variable that receives this value. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-keyboard-input">Languages, Locales, and Keyboard Layouts</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETGESTUREVISUALIZATION"></a><a id="spi_getgesturevisualization"></a><dl>
     * <dt><b>SPI_GETGESTUREVISUALIZATION</b></dt>
     * <dt>0x201A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that receives the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/gesture-visualization">Gesture Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDCUES"></a><a id="spi_getkeyboardcues"></a><dl>
     * <dt><b>SPI_GETKEYBOARDCUES</b></dt>
     * <dt>0x100A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether menu access keys are always underlined. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if menu access keys are always underlined, and <b>FALSE</b> if they are underlined only when the menu is activated by the keyboard.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDDELAY"></a><a id="spi_getkeyboarddelay"></a><dl>
     * <dt><b>SPI_GETKEYBOARDDELAY</b></dt>
     * <dt>0x0016</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the keyboard repeat-delay setting, which is a value in the range from 0 (approximately 250 ms delay) through 3 (approximately 1 second delay). The actual delay associated with each value may vary depending on the hardware. The <i>pvParam</i> parameter must point to an integer variable that receives the setting.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDPREF"></a><a id="spi_getkeyboardpref"></a><dl>
     * <dt><b>SPI_GETKEYBOARDPREF</b></dt>
     * <dt>0x0044</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the user relies on the keyboard instead of the mouse, and wants applications to display keyboard interfaces that would otherwise be hidden. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the user relies on the keyboard; or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETKEYBOARDSPEED"></a><a id="spi_getkeyboardspeed"></a><dl>
     * <dt><b>SPI_GETKEYBOARDSPEED</b></dt>
     * <dt>0x000A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the keyboard repeat-speed setting, which is a value in the range from 0 (approximately 2.5 repetitions per second) through 31 (approximately 30 repetitions per second). The actual repeat rates are hardware-dependent and may vary from a linear scale by as much as 20%. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the setting.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSE"></a><a id="spi_getmouse"></a><dl>
     * <dt><b>SPI_GETMOUSE</b></dt>
     * <dt>0x0003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the two mouse threshold values and the mouse acceleration. The <i>pvParam</i> parameter must point to an array of three integers that receives these values. See <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-mouse_event">mouse_event</a> for further information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEHOVERHEIGHT"></a><a id="spi_getmousehoverheight"></a><dl>
     * <dt><b>SPI_GETMOUSEHOVERHEIGHT</b></dt>
     * <dt>0x0064</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the height, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the height.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEHOVERTIME"></a><a id="spi_getmousehovertime"></a><dl>
     * <dt><b>SPI_GETMOUSEHOVERTIME</b></dt>
     * <dt>0x0066</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEHOVERWIDTH"></a><a id="spi_getmousehoverwidth"></a><dl>
     * <dt><b>SPI_GETMOUSEHOVERWIDTH</b></dt>
     * <dt>0x0062</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the width, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the width.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSESPEED"></a><a id="spi_getmousespeed"></a><dl>
     * <dt><b>SPI_GETMOUSESPEED</b></dt>
     * <dt>0x0070</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current mouse speed. The mouse speed determines how far the pointer will move based on the distance the mouse moves. The <i>pvParam</i> parameter must point to an integer that receives a value which ranges between 1 (slowest) and 20 (fastest). A value of 10 is the default. The value can be set by an end-user using the mouse control panel application or by an application using <b>SPI_SETMOUSESPEED</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSETRAILS"></a><a id="spi_getmousetrails"></a><dl>
     * <dt><b>SPI_GETMOUSETRAILS</b></dt>
     * <dt>0x005E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the Mouse Trails feature is enabled. This feature improves the visibility of mouse cursor movements by briefly showing a trail of cursors and quickly erasing them.
     * 
     * The <i>pvParam</i> parameter must point to an integer variable that receives a value. if  the value is zero or 1, the feature is disabled. If the value is greater than 1, the feature is enabled and the value indicates the number of cursors drawn in the trail. The <i>uiParam</i> parameter is not used.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEWHEELROUTING"></a><a id="spi_getmousewheelrouting"></a><dl>
     * <dt><b>SPI_GETMOUSEWHEELROUTING</b></dt>
     * <dt>0x201C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the routing setting for wheel button input. The routing setting determines whether wheel button input is sent to the app with focus (foreground) or the app under the mouse cursor.
     * 
     * The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the routing option. 
     * If  the value is zero or MOUSEWHEEL_ROUTING_FOCUS, mouse wheel input is delivered to the app with focus. If the value is 1 or MOUSEWHEEL_ROUTING_HYBRID (default), mouse wheel input is delivered to the app with focus (desktop apps) or the app under the mouse cursor (Windows Store apps).
     * The <i>uiParam</i> parameter is not used.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENVISUALIZATION"></a><a id="spi_getpenvisualization"></a><dl>
     * <dt><b>SPI_GETPENVISUALIZATION</b></dt>
     * <dt>0x201E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the current pen gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that receives the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/pen-visualization">Pen Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSNAPTODEFBUTTON"></a><a id="spi_getsnaptodefbutton"></a><dl>
     * <dt><b>SPI_GETSNAPTODEFBUTTON</b></dt>
     * <dt>0x005F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the snap-to-default-button feature is enabled. If enabled, the mouse cursor automatically moves to the default button, such as <b>OK</b> or <b>Apply</b>, of a dialog box. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the feature is on, or <b>FALSE</b> if it is off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSYSTEMLANGUAGEBAR"></a><a id="spi_getsystemlanguagebar"></a><dl>
     * <dt><b>SPI_GETSYSTEMLANGUAGEBAR</b></dt>
     * <dt>0x1050</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Determines whether the system language bar is enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the language bar is enabled, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTHREADLOCALINPUTSETTINGS"></a><a id="spi_getthreadlocalinputsettings"></a><dl>
     * <dt><b>SPI_GETTHREADLOCALINPUTSETTINGS</b></dt>
     * <dt>0x104E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Determines whether the active input settings have Local (per-thread, <b>TRUE</b>) or Global (session, <b>FALSE</b>) scope. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWHEELSCROLLCHARS"></a><a id="spi_getwheelscrollchars"></a><dl>
     * <dt><b>SPI_GETWHEELSCROLLCHARS</b></dt>
     * <dt>0x006C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of characters to scroll when the horizontal mouse wheel is moved. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the number of lines. The default value is 3.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWHEELSCROLLLINES"></a><a id="spi_getwheelscrolllines"></a><dl>
     * <dt><b>SPI_GETWHEELSCROLLLINES</b></dt>
     * <dt>0x0068</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of lines to scroll when the vertical mouse wheel is moved. The <i>pvParam</i> parameter must point to a <b>UINT</b> variable that receives the number of lines. The default value is 3.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETBEEP"></a><a id="spi_setbeep"></a><dl>
     * <dt><b>SPI_SETBEEP</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Turns the warning beeper on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETBLOCKSENDINPUTRESETS"></a><a id="spi_setblocksendinputresets"></a><dl>
     * <dt><b>SPI_SETBLOCKSENDINPUTRESETS</b></dt>
     * <dt>0x1027</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether an application can reset the screensaver's timer by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-sendinput">SendInput</a> function to simulate keyboard or mouse input. The <i>uiParam</i> parameter specifies <b>TRUE</b> if the screensaver will not be deactivated by simulated input, or <b>FALSE</b> if the screensaver will be deactivated by simulated input.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCONTACTVISUALIZATION"></a><a id="spi_setcontactvisualization"></a><dl>
     * <dt><b>SPI_SETCONTACTVISUALIZATION</b></dt>
     * <dt>0x2019</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current contact visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that identifies the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/contact-visualization">Contact Visualization</a>.
     * 
     * <div class="alert"><b>Note</b>If contact visualizations are disabled, gesture visualizations cannot be enabled.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDEFAULTINPUTLANG"></a><a id="spi_setdefaultinputlang"></a><dl>
     * <dt><b>SPI_SETDEFAULTINPUTLANG</b></dt>
     * <dt>0x005A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the default input language for the system shell and applications. The specified language must be displayable using the current system character set. The <i>pvParam</i> parameter must point to an <b>HKL</b> variable that contains the input locale identifier for the default language. For more information, see <a href="https://docs.microsoft.com/windows/desktop/inputdev/about-keyboard-input">Languages, Locales, and Keyboard Layouts</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOUBLECLICKTIME"></a><a id="spi_setdoubleclicktime"></a><dl>
     * <dt><b>SPI_SETDOUBLECLICKTIME</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the double-click time for the mouse to the value of the <i>uiParam</i> parameter. If the <i>uiParam</i> value is greater than 5000 milliseconds, the system sets the double-click time to 5000 milliseconds.
     * 
     * The double-click time is the maximum number of milliseconds that can occur between the first and second clicks of a double-click. You can also call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setdoubleclicktime">SetDoubleClickTime</a> function to set the double-click time. To get the current double-click time, call the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getdoubleclicktime">GetDoubleClickTime</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOUBLECLKHEIGHT"></a><a id="spi_setdoubleclkheight"></a><dl>
     * <dt><b>SPI_SETDOUBLECLKHEIGHT</b></dt>
     * <dt>0x001E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height of the double-click rectangle to the value of the <i>uiParam</i> parameter.
     * 
     * The double-click rectangle is the rectangle within which the second click of a double-click must fall for it to be registered as a double-click.
     * 
     * To retrieve the height of the double-click rectangle, call  <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CYDOUBLECLK</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOUBLECLKWIDTH"></a><a id="spi_setdoubleclkwidth"></a><dl>
     * <dt><b>SPI_SETDOUBLECLKWIDTH</b></dt>
     * <dt>0x001D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the width of the double-click rectangle to the value of the <i>uiParam</i> parameter.
     * 
     * The double-click rectangle is the rectangle within which the second click of a double-click must fall for it to be registered as a double-click.
     * 
     * To retrieve the width of the double-click rectangle, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CXDOUBLECLK</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETGESTUREVISUALIZATION"></a><a id="spi_setgesturevisualization"></a><dl>
     * <dt><b>SPI_SETGESTUREVISUALIZATION</b></dt>
     * <dt>0x201B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that identifies the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/gesture-visualization">Gesture Visualization</a>.
     * 
     * <div class="alert"><b>Note</b>If contact visualizations are disabled, gesture visualizations cannot be enabled.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDCUES"></a><a id="spi_setkeyboardcues"></a><dl>
     * <dt><b>SPI_SETKEYBOARDCUES</b></dt>
     * <dt>0x100B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the underlining of menu access key letters. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to always underline menu access keys, or <b>FALSE</b> to underline menu access keys only when the menu is activated from the keyboard.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDDELAY"></a><a id="spi_setkeyboarddelay"></a><dl>
     * <dt><b>SPI_SETKEYBOARDDELAY</b></dt>
     * <dt>0x0017</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the keyboard repeat-delay setting. The <i>uiParam</i> parameter must specify 0, 1, 2, or 3, where zero sets the shortest delay approximately 250 ms) and 3 sets the longest delay (approximately 1 second). The actual delay associated with each value may vary depending on the hardware.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDPREF"></a><a id="spi_setkeyboardpref"></a><dl>
     * <dt><b>SPI_SETKEYBOARDPREF</b></dt>
     * <dt>0x0045</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the keyboard preference. The <i>uiParam</i> parameter specifies <b>TRUE</b> if the user relies on the keyboard instead of the mouse, and wants applications to display keyboard interfaces that would otherwise be hidden; <i>uiParam</i> is <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETKEYBOARDSPEED"></a><a id="spi_setkeyboardspeed"></a><dl>
     * <dt><b>SPI_SETKEYBOARDSPEED</b></dt>
     * <dt>0x000B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the keyboard repeat-speed setting. The <i>uiParam</i> parameter must specify a value in the range from 0 (approximately 2.5 repetitions per second) through 31 (approximately 30 repetitions per second). The actual repeat rates are hardware-dependent and may vary from a linear scale by as much as 20%. If <i>uiParam</i> is greater than 31, the parameter is set to 31.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLANGTOGGLE"></a><a id="spi_setlangtoggle"></a><dl>
     * <dt><b>SPI_SETLANGTOGGLE</b></dt>
     * <dt>0x005B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the hot key set for switching between input languages. The <i>uiParam</i> and <i>pvParam</i> parameters are not used. The value sets the shortcut keys in the keyboard property sheets by reading the registry again. The registry must be set before this flag is used. the path in the registry is 
     *                                     <b>HKEY_CURRENT_USER</b>&#92;<b>Keyboard Layout</b>&#92;<b>Toggle</b></p>. Valid values are "1" = ALT+SHIFT, "2" = CTRL+SHIFT, and "3" = none.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSE"></a><a id="spi_setmouse"></a><dl>
     * <dt><b>SPI_SETMOUSE</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the two mouse threshold values and the mouse acceleration. The <i>pvParam</i> parameter must point to an array of three integers that specifies these values. See <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-mouse_event">mouse_event</a> for further information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEBUTTONSWAP"></a><a id="spi_setmousebuttonswap"></a><dl>
     * <dt><b>SPI_SETMOUSEBUTTONSWAP</b></dt>
     * <dt>0x0021</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Swaps or restores the meaning of the left and right mouse buttons. The <i>uiParam</i> parameter specifies <b>TRUE</b> to swap the meanings of the buttons, or <b>FALSE</b> to restore their original meanings.
     * 
     * To retrieve the current setting, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_SWAPBUTTON</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEHOVERHEIGHT"></a><a id="spi_setmousehoverheight"></a><dl>
     * <dt><b>SPI_SETMOUSEHOVERHEIGHT</b></dt>
     * <dt>0x0065</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. Set the <i>uiParam</i> parameter to the new height.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEHOVERTIME"></a><a id="spi_setmousehovertime"></a><dl>
     * <dt><b>SPI_SETMOUSEHOVERTIME</b></dt>
     * <dt>0x0067</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. This is used only if you pass <b>HOVER_DEFAULT</b> in the <i>dwHoverTime</i> parameter in the call to <b>TrackMouseEvent</b>. Set the <i>uiParam</i> parameter to the new time.
     * 
     * The time specified should be between <b>USER_TIMER_MAXIMUM</b> and <b>USER_TIMER_MINIMUM</b>. If <i>uiParam</i> is less than <b>USER_TIMER_MINIMUM</b>, the function will use <b>USER_TIMER_MINIMUM</b>. If <i>uiParam</i> is greater than <b>USER_TIMER_MAXIMUM</b>, the function will be <b>USER_TIMER_MAXIMUM</b>.               
     * 
     * <b>Windows Server2003 and WindowsXP:</b>The operating system does not enforce the use of <b>USER_TIMER_MAXIMUM</b> and <b>USER_TIMER_MINIMUM</b> until Windows Server2003 with SP1 and WindowsXP with SP2.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEHOVERWIDTH"></a><a id="spi_setmousehoverwidth"></a><dl>
     * <dt><b>SPI_SETMOUSEHOVERWIDTH</b></dt>
     * <dt>0x0063</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the width, in pixels, of the rectangle within which the mouse pointer has to stay for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-trackmouseevent">TrackMouseEvent</a> to generate a <a href="https://docs.microsoft.com/windows/desktop/inputdev/wm-mousehover">WM_MOUSEHOVER</a> message. Set the <i>uiParam</i> parameter to the new width.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSESPEED"></a><a id="spi_setmousespeed"></a><dl>
     * <dt><b>SPI_SETMOUSESPEED</b></dt>
     * <dt>0x0071</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current mouse speed. The <i>pvParam</i> parameter is an integer between 1 (slowest) and 20 (fastest). A value of 10 is the default. This value is typically set using the mouse control panel application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSETRAILS"></a><a id="spi_setmousetrails"></a><dl>
     * <dt><b>SPI_SETMOUSETRAILS</b></dt>
     * <dt>0x005D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the Mouse Trails feature, which improves the visibility of mouse cursor movements by briefly showing a trail of cursors and quickly erasing them.
     * 
     * To disable the feature, set the <i>uiParam</i> parameter to zero or 1. To enable the  feature, set <i>uiParam</i> to a value greater than 1 to indicate the number of cursors drawn in the trail.
     * 
     * <b>Windows2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEWHEELROUTING"></a><a id="spi_setmousewheelrouting"></a><dl>
     * <dt><b>SPI_SETMOUSEWHEELROUTING</b></dt>
     * <dt>0x201D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the routing setting for wheel button input. The routing setting determines whether wheel button input is sent to the app with focus (foreground) or the app under the mouse cursor.
     * 
     * The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the routing option. 
     * If  the value is zero or MOUSEWHEEL_ROUTING_FOCUS, mouse wheel input is delivered to the app with focus. If the value is 1 or MOUSEWHEEL_ROUTING_HYBRID (default), mouse wheel input is delivered to the app with focus (desktop apps) or the app under the mouse cursor (Windows Store apps).
     * Set the <i>uiParam</i> parameter to zero.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENVISUALIZATION"></a><a id="spi_setpenvisualization"></a><dl>
     * <dt><b>SPI_SETPENVISUALIZATION</b></dt>
     * <dt>0x201F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the current pen gesture visualization setting. The <i>pvParam</i> parameter must point to a <b>ULONG</b> variable that identifies the setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/winmsg/pen-visualization">Pen Visualization</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSNAPTODEFBUTTON"></a><a id="spi_setsnaptodefbutton"></a><dl>
     * <dt><b>SPI_SETSNAPTODEFBUTTON</b></dt>
     * <dt>0x0060</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the snap-to-default-button feature. If enabled, the mouse cursor automatically moves to the default button, such as <b>OK</b> or <b>Apply</b>, of a dialog box. Set the <i>uiParam</i> parameter to <b>TRUE</b> to enable the feature, or <b>FALSE</b> to disable it. Applications should use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a> function when displaying a dialog box so the dialog manager can position the mouse cursor.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSYSTEMLANGUAGEBAR"></a><a id="spi_setsystemlanguagebar"></a><dl>
     * <dt><b>SPI_SETSYSTEMLANGUAGEBAR</b></dt>
     * <dt>0x1051</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Turns the legacy language bar feature on or off. The <i>pvParam</i> parameter is a pointer to a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable the legacy language bar, or <b>FALSE</b> to disable it. The flag is supported on Windows8 where the legacy language bar is replaced by Input Switcher and therefore turned off by default. Turning the legacy language bar on is provided for compatibility reasons and has no effect on the Input Switcher.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTHREADLOCALINPUTSETTINGS"></a><a id="spi_setthreadlocalinputsettings"></a><dl>
     * <dt><b>SPI_SETTHREADLOCALINPUTSETTINGS</b></dt>
     * <dt>0x104F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Starting with Windows8:</b> Determines whether the active input settings have Local (per-thread, <b>TRUE</b>) or Global (session, <b>FALSE</b>) scope. The <i>pvParam</i> parameter must be a <b>BOOL</b> variable, casted by PVOID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWHEELSCROLLCHARS"></a><a id="spi_setwheelscrollchars"></a><dl>
     * <dt><b>SPI_SETWHEELSCROLLCHARS</b></dt>
     * <dt>0x006D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the number of characters to scroll when the horizontal mouse wheel is moved. The number of characters is set from the <i>uiParam</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWHEELSCROLLLINES"></a><a id="spi_setwheelscrolllines"></a><dl>
     * <dt><b>SPI_SETWHEELSCROLLLINES</b></dt>
     * <dt>0x0069</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the number of lines to scroll when the vertical mouse wheel is moved. The number of lines is set from the <i>uiParam</i> parameter.
     * 
     * The number of lines is the suggested number of lines to scroll when the mouse wheel is rolled without using modifier keys. If the number is 0, then no scrolling should occur. If the number of lines to scroll is  greater than the number of lines viewable, and in particular if it is <b>WHEEL_PAGESCROLL</b> (#defined as <b>UINT_MAX</b>), the scroll operation should be interpreted as clicking once in the page down or page up regions of the scroll bar.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the menu parameters.
     * 
     * <table>
     * <tr>
     * <th>Menu parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUDROPALIGNMENT"></a><a id="spi_getmenudropalignment"></a><dl>
     * <dt><b>SPI_GETMENUDROPALIGNMENT</b></dt>
     * <dt>0x001B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether pop-up menus are left-aligned or right-aligned, relative to the corresponding menu-bar item. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if right-aligned, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUFADE"></a><a id="spi_getmenufade"></a><dl>
     * <dt><b>SPI_GETMENUFADE</b></dt>
     * <dt>0x1012</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether menu fade animation is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> when fade animation is enabled and <b>FALSE</b> when it isdisabled. If fade animation is disabled, menus use slide animation. This flag is ignored unless menu animation is enabled, which you can do using the <b>SPI_SETMENUANIMATION</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUSHOWDELAY"></a><a id="spi_getmenushowdelay"></a><dl>
     * <dt><b>SPI_GETMENUSHOWDELAY</b></dt>
     * <dt>0x006A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse cursor is over a submenu item. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the time of the delay.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUDROPALIGNMENT"></a><a id="spi_setmenudropalignment"></a><dl>
     * <dt><b>SPI_SETMENUDROPALIGNMENT</b></dt>
     * <dt>0x001C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the alignment value of pop-up menus. The <i>uiParam</i> parameter specifies <b>TRUE</b> for right alignment, or <b>FALSE</b> for left alignment.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUFADE"></a><a id="spi_setmenufade"></a><dl>
     * <dt><b>SPI_SETMENUFADE</b></dt>
     * <dt>0x1013</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables menu fade animation. Set <i>pvParam</i> to <b>TRUE</b> to enable the menu fade effect or <b>FALSE</b> to disable it. If fade animation is disabled, menus use slide animation. he The menu fade effect is possible only if the system has a color depth of more than 256 colors. This flag is ignored unless <b>SPI_MENUANIMATION</b> is also set. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUSHOWDELAY"></a><a id="spi_setmenushowdelay"></a><dl>
     * <dt><b>SPI_SETMENUSHOWDELAY</b></dt>
     * <dt>0x006B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets <i>uiParam</i> to the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse cursor is over a submenu item.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the power parameters.
     * 
     * Beginning with Windows Server2008 and WindowsVista, these power parameters are not supported. Instead, to determine the current display power state, an application should register for <b>GUID_MONITOR_POWER_STATE</b> notifications. To determine the current display power down time-out, an application should register for notification of changes to the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Power/registering-for-power-events">Registering for Power Events</a>.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>To determine the current display power state, use the following power parameters.
     * 
     * <table>
     * <tr>
     * <th>Power parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLOWPOWERACTIVE"></a><a id="spi_getlowpoweractive"></a><dl>
     * <dt><b>SPI_GETLOWPOWERACTIVE</b></dt>
     * <dt>0x0053</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Determines whether the low-power phase of screen saving is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> if disabled. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLOWPOWERTIMEOUT"></a><a id="spi_getlowpowertimeout"></a><dl>
     * <dt><b>SPI_GETLOWPOWERTIMEOUT</b></dt>
     * <dt>0x004F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Retrieves the time-out value for the low-power phase of screen saving. The <i>pvParam</i> parameter must point to an integer variable that receives the value. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPOWEROFFACTIVE"></a><a id="spi_getpoweroffactive"></a><dl>
     * <dt><b>SPI_GETPOWEROFFACTIVE</b></dt>
     * <dt>0x0054</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. When the power-off phase of screen saving is enabled, the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting is greater than zero.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Determines whether the power-off phase of screen saving is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> if disabled. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPOWEROFFTIMEOUT"></a><a id="spi_getpowerofftimeout"></a><dl>
     * <dt><b>SPI_GETPOWEROFFTIMEOUT</b></dt>
     * <dt>0x0050</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. Instead, check the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Retrieves the time-out value for the power-off phase of screen saving. The <i>pvParam</i> parameter must point to an integer variable that receives the value. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLOWPOWERACTIVE"></a><a id="spi_setlowpoweractive"></a><dl>
     * <dt><b>SPI_SETLOWPOWERACTIVE</b></dt>
     * <dt>0x0055</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Activates or deactivates the low-power phase of screen saving. Set <i>uiParam</i> to 1 to activate, or zero to deactivate. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLOWPOWERTIMEOUT"></a><a id="spi_setlowpowertimeout"></a><dl>
     * <dt><b>SPI_SETLOWPOWERTIMEOUT</b></dt>
     * <dt>0x0051</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Sets the time-out value, in seconds, for the low-power phase of screen saving. The <i>uiParam</i> parameter specifies the new value. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPOWEROFFACTIVE"></a><a id="spi_setpoweroffactive"></a><dl>
     * <dt><b>SPI_SETPOWEROFFACTIVE</b></dt>
     * <dt>0x0056</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. Instead, set the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Activates or deactivates the power-off phase of screen saving. Set <i>uiParam</i> to 1 to activate, or zero to deactivate. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPOWEROFFTIMEOUT"></a><a id="spi_setpowerofftimeout"></a><dl>
     * <dt><b>SPI_SETPOWEROFFTIMEOUT</b></dt>
     * <dt>0x0052</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This parameter is not supported. Instead, set the <b>GUID_VIDEO_POWERDOWN_TIMEOUT</b> power setting to a time-out value.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>Sets the time-out value, in seconds, for the power-off phase of screen saving. The <i>uiParam</i> parameter specifies the new value. The <i>pvParam</i> parameter must be <b>NULL</b>. This flag is supported for 32-bit applications only.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the screen saver parameters.
     * 
     * <table>
     * <tr>
     * <th>Screen saver parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVEACTIVE"></a><a id="spi_getscreensaveactive"></a><dl>
     * <dt><b>SPI_GETSCREENSAVEACTIVE</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether screen saving is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if screen saving is enabled, or <b>FALSE</b> otherwise.
     * 
     * <b>Windows7, Windows Server2008R2 and Windows2000:</b>The function returns <b>TRUE</b> even when screen saving is not enabled. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVERRUNNING"></a><a id="spi_getscreensaverrunning"></a><dl>
     * <dt><b>SPI_GETSCREENSAVERRUNNING</b></dt>
     * <dt>0x0072</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a screen saver is currently running on the window station of the calling process. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if a screen saver is currently running, or <b>FALSE</b> otherwise. Note that only the interactive window station, WinSta0, can have a screen saver running.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVESECURE"></a><a id="spi_getscreensavesecure"></a><dl>
     * <dt><b>SPI_GETSCREENSAVESECURE</b></dt>
     * <dt>0x0076</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the screen saver  requires a password to display the Windows desktop. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the screen saver requires a password, or <b>FALSE</b> otherwise. The <i>uiParam</i> parameter is ignored.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSCREENSAVETIMEOUT"></a><a id="spi_getscreensavetimeout"></a><dl>
     * <dt><b>SPI_GETSCREENSAVETIMEOUT</b></dt>
     * <dt>0x000E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the screen saver time-out value, in seconds. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENSAVEACTIVE"></a><a id="spi_setscreensaveactive"></a><dl>
     * <dt><b>SPI_SETSCREENSAVEACTIVE</b></dt>
     * <dt>0x0011</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the state of the screen saver. The <i>uiParam</i> parameter specifies <b>TRUE</b> to activate screen saving, or <b>FALSE</b> to deactivate it.
     * 
     * If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENSAVESECURE"></a><a id="spi_setscreensavesecure"></a><dl>
     * <dt><b>SPI_SETSCREENSAVESECURE</b></dt>
     * <dt>0x0077</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether the screen saver requires the user to enter a password to display the Windows desktop. The <i>uiParam</i> parameter is a <b>BOOL</b> variable. The <i>pvParam</i> parameter is ignored. Set <i>uiParam</i> to <b>TRUE</b> to require a password, or <b>FALSE</b> to not require a password.
     * 
     * If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.
     * 
     * <b>Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSCREENSAVETIMEOUT"></a><a id="spi_setscreensavetimeout"></a><dl>
     * <dt><b>SPI_SETSCREENSAVETIMEOUT</b></dt>
     * <dt>0x000F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the screen saver time-out value to the value of the <i>uiParam</i> parameter. This value is the amount of time, in seconds, that the system must be idle before the screen saver activates.
     * 
     * If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the time-out parameters for applications and services.
     * 
     * <table>
     * <tr>
     * <th>Time-out parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETHUNGAPPTIMEOUT"></a><a id="spi_gethungapptimeout"></a><dl>
     * <dt><b>SPI_GETHUNGAPPTIMEOUT</b></dt>
     * <dt>0x0078</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of milliseconds that a thread can go without dispatching a message before the system considers it unresponsive. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWAITTOKILLTIMEOUT"></a><a id="spi_getwaittokilltimeout"></a><dl>
     * <dt><b>SPI_GETWAITTOKILLTIMEOUT</b></dt>
     * <dt>0x007A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of milliseconds that the system waits before terminating an application that does not respond to a shutdown request. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWAITTOKILLSERVICETIMEOUT"></a><a id="spi_getwaittokillservicetimeout"></a><dl>
     * <dt><b>SPI_GETWAITTOKILLSERVICETIMEOUT</b></dt>
     * <dt>0x007C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of milliseconds that the service control manager waits before terminating a service that does not respond to a shutdown request. The <i>pvParam</i> parameter must point to an integer variable that receives the value.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETHUNGAPPTIMEOUT"></a><a id="spi_sethungapptimeout"></a><dl>
     * <dt><b>SPI_SETHUNGAPPTIMEOUT</b></dt>
     * <dt>0x0079</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the hung application time-out to the value of the <i>uiParam</i> parameter. This value is the number of milliseconds that a thread can go without dispatching a message before the system considers it unresponsive.
     *                     
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWAITTOKILLTIMEOUT"></a><a id="spi_setwaittokilltimeout"></a><dl>
     * <dt><b>SPI_SETWAITTOKILLTIMEOUT</b></dt>
     * <dt>0x007B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the application shutdown request time-out to the value of the <i>uiParam</i> parameter. This value is the number of milliseconds that the system waits before terminating an application that does not respond to a shutdown request.
     * 
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWAITTOKILLSERVICETIMEOUT"></a><a id="spi_setwaittokillservicetimeout"></a><dl>
     * <dt><b>SPI_SETWAITTOKILLSERVICETIMEOUT</b></dt>
     * <dt>0x007D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the service shutdown request time-out to the value of the <i>uiParam</i> parameter. This value is the number of milliseconds that the system waits before terminating a service that does not respond to a shutdown request.
     *                                 
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the UI effects. The <b>SPI_SETUIEFFECTS</b> value is used to enable or disable all UI effects at once. This table contains the complete list of UI effect values.
     * 
     * <table>
     * <tr>
     * <th>UI effects parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCOMBOBOXANIMATION"></a><a id="spi_getcomboboxanimation"></a><dl>
     * <dt><b>SPI_GETCOMBOBOXANIMATION</b></dt>
     * <dt>0x1004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the slide-open effect for combo boxes is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCURSORSHADOW"></a><a id="spi_getcursorshadow"></a><dl>
     * <dt><b>SPI_GETCURSORSHADOW</b></dt>
     * <dt>0x101A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the cursor has a shadow around it. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the shadow is enabled, <b>FALSE</b> if it is disabled. This effect appears only if the system has a color depth of more than 256 colors.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETGRADIENTCAPTIONS"></a><a id="spi_getgradientcaptions"></a><dl>
     * <dt><b>SPI_GETGRADIENTCAPTIONS</b></dt>
     * <dt>0x1008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the gradient effect for window title bars is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled. For more information about the gradient effect, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETHOTTRACKING"></a><a id="spi_gethottracking"></a><dl>
     * <dt><b>SPI_GETHOTTRACKING</b></dt>
     * <dt>0x100E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether hot tracking of user-interface elements, such as menu names on menu bars, is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled.
     * 
     * Hot tracking means that when the cursor moves over an item, it is highlighted but not selected. You can query this value to decide whether to use hot tracking in the user interface of your application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETLISTBOXSMOOTHSCROLLING"></a><a id="spi_getlistboxsmoothscrolling"></a><dl>
     * <dt><b>SPI_GETLISTBOXSMOOTHSCROLLING</b></dt>
     * <dt>0x1006</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the smooth-scrolling effect for list boxes is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for enabled, or <b>FALSE</b> for disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUANIMATION"></a><a id="spi_getmenuanimation"></a><dl>
     * <dt><b>SPI_GETMENUANIMATION</b></dt>
     * <dt>0x1002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the menu animation feature is enabled. This master switch must be on to enable menu animation effects. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if animation is enabled and <b>FALSE</b> if it is disabled.
     * 
     * If animation is enabled, <b>SPI_GETMENUFADE</b> indicates whether menus use fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMENUUNDERLINES"></a><a id="spi_getmenuunderlines"></a><dl>
     * <dt><b>SPI_GETMENUUNDERLINES</b></dt>
     * <dt>0x100A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>SPI_GETKEYBOARDCUES</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSELECTIONFADE"></a><a id="spi_getselectionfade"></a><dl>
     * <dt><b>SPI_GETSELECTIONFADE</b></dt>
     * <dt>0x1014</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the selection fade effect is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> if disabled.
     * 
     * The selection fade effect causes the menu item selected by the user to remain on the screen briefly while fading out after the menu is dismissed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTOOLTIPANIMATION"></a><a id="spi_gettooltipanimation"></a><dl>
     * <dt><b>SPI_GETTOOLTIPANIMATION</b></dt>
     * <dt>0x1016</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether ToolTip animation is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled or <b>FALSE</b> if disabled. If ToolTip animation is enabled, <b>SPI_GETTOOLTIPFADE</b> indicates whether ToolTips use fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETTOOLTIPFADE"></a><a id="spi_gettooltipfade"></a><dl>
     * <dt><b>SPI_GETTOOLTIPFADE</b></dt>
     * <dt>0x1018</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If <b>SPI_SETTOOLTIPANIMATION</b> is enabled, <b>SPI_GETTOOLTIPFADE</b> indicates whether ToolTip animation uses a fade effect or a slide effect. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for fade animation or <b>FALSE</b> for slide animation. For more information on slide and fade effects, see <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETUIEFFECTS"></a><a id="spi_getuieffects"></a><dl>
     * <dt><b>SPI_GETUIEFFECTS</b></dt>
     * <dt>0x103E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether UI effects are enabled or disabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if all UI effects are enabled, or <b>FALSE</b> if they are disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCOMBOBOXANIMATION"></a><a id="spi_setcomboboxanimation"></a><dl>
     * <dt><b>SPI_SETCOMBOBOXANIMATION</b></dt>
     * <dt>0x1005</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the slide-open effect for combo boxes. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable the gradient effect, or <b>FALSE</b> to disable it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCURSORSHADOW"></a><a id="spi_setcursorshadow"></a><dl>
     * <dt><b>SPI_SETCURSORSHADOW</b></dt>
     * <dt>0x101B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables a shadow around the cursor. The <i>pvParam</i> parameter is a <b>BOOL</b> variable. Set <i>pvParam</i> to <b>TRUE</b> to enable the shadow or <b>FALSE</b> to disable the shadow. This effect appears only if the system has a color depth of more than 256 colors.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETGRADIENTCAPTIONS"></a><a id="spi_setgradientcaptions"></a><dl>
     * <dt><b>SPI_SETGRADIENTCAPTIONS</b></dt>
     * <dt>0x1009</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the gradient effect for window title bars. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable it, or <b>FALSE</b> to disable it. The gradient effect is possible only if the system has a color depth of more than 256 colors. For more information about the gradient effect, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsyscolor">GetSysColor</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETHOTTRACKING"></a><a id="spi_sethottracking"></a><dl>
     * <dt><b>SPI_SETHOTTRACKING</b></dt>
     * <dt>0x100F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables hot tracking of user-interface elements such as menu names on menu bars. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable it, or <b>FALSE</b> to disable it.
     * 
     * Hot-tracking means that when the cursor moves over an item, it is highlighted but not selected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETLISTBOXSMOOTHSCROLLING"></a><a id="spi_setlistboxsmoothscrolling"></a><dl>
     * <dt><b>SPI_SETLISTBOXSMOOTHSCROLLING</b></dt>
     * <dt>0x1007</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables the smooth-scrolling effect for list boxes. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable the smooth-scrolling effect, or <b>FALSE</b> to disable it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUANIMATION"></a><a id="spi_setmenuanimation"></a><dl>
     * <dt><b>SPI_SETMENUANIMATION</b></dt>
     * <dt>0x1003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables menu animation. This master switch must be on for any menu animation to occur. The <i>pvParam</i> parameter is a <b>BOOL</b> variable; set <i>pvParam</i> to <b>TRUE</b> to enable animation and <b>FALSE</b> to disable animation.
     * 
     * If animation is enabled, <b>SPI_GETMENUFADE</b> indicates whether menus use fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMENUUNDERLINES"></a><a id="spi_setmenuunderlines"></a><dl>
     * <dt><b>SPI_SETMENUUNDERLINES</b></dt>
     * <dt>0x100B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Same as <b>SPI_SETKEYBOARDCUES</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSELECTIONFADE"></a><a id="spi_setselectionfade"></a><dl>
     * <dt><b>SPI_SETSELECTIONFADE</b></dt>
     * <dt>0x1015</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set <i>pvParam</i> to <b>TRUE</b> to enable the selection fade effect or <b>FALSE</b> to disable it.
     * 
     * The selection fade effect causes the menu item selected by the user to remain on the screen briefly while fading out after the menu is dismissed. The selection fade effect is possible only if the system has a color depth of more than 256 colors.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTOOLTIPANIMATION"></a><a id="spi_settooltipanimation"></a><dl>
     * <dt><b>SPI_SETTOOLTIPANIMATION</b></dt>
     * <dt>0x1017</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Set <i>pvParam</i> to <b>TRUE</b> to enable ToolTip animation or <b>FALSE</b> to disable it. If enabled, you can use <b>SPI_SETTOOLTIPFADE</b> to specify fade or slide animation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETTOOLTIPFADE"></a><a id="spi_settooltipfade"></a><dl>
     * <dt><b>SPI_SETTOOLTIPFADE</b></dt>
     * <dt>0x1019</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <b>SPI_SETTOOLTIPANIMATION</b> flag is enabled, use <b>SPI_SETTOOLTIPFADE</b> to indicate whether ToolTip animation uses a fade effect or a slide effect. Set <i>pvParam</i> to <b>TRUE</b> for fade animation or <b>FALSE</b> for slide animation. The tooltip fade effect is possible only if the system has a color depth of more than 256 colors. For more information on the slide and fade effects, see the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-animatewindow">AnimateWindow</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETUIEFFECTS"></a><a id="spi_setuieffects"></a><dl>
     * <dt><b>SPI_SETUIEFFECTS</b></dt>
     * <dt>0x103F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enables or disables UI effects. Set the <i>pvParam</i> parameter to <b>TRUE</b> to enable all UI effects or <b>FALSE</b> to disable all UI effects.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following are the window parameters.
     * 
     * <table>
     * <tr>
     * <th>Window parameter</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACTIVEWINDOWTRACKING"></a><a id="spi_getactivewindowtracking"></a><dl>
     * <dt><b>SPI_GETACTIVEWINDOWTRACKING</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether active window tracking (activating the window the mouse is on) is on or off. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACTIVEWNDTRKZORDER"></a><a id="spi_getactivewndtrkzorder"></a><dl>
     * <dt><b>SPI_GETACTIVEWNDTRKZORDER</b></dt>
     * <dt>0x100C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether windows activated through active window tracking will be brought to the top. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETACTIVEWNDTRKTIMEOUT"></a><a id="spi_getactivewndtrktimeout"></a><dl>
     * <dt><b>SPI_GETACTIVEWNDTRKTIMEOUT</b></dt>
     * <dt>0x2002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the active window tracking delay, in milliseconds. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETANIMATION"></a><a id="spi_getanimation"></a><dl>
     * <dt><b>SPI_GETANIMATION</b></dt>
     * <dt>0x0048</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the animation effects associated with user actions. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-animationinfo">ANIMATIONINFO</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ANIMATIONINFO)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETBORDER"></a><a id="spi_getborder"></a><dl>
     * <dt><b>SPI_GETBORDER</b></dt>
     * <dt>0x0005</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the border multiplier factor that determines the width of a window's sizing border. The <i>pvParam</i> parameter must point to an integer variable that receives this value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETCARETWIDTH"></a><a id="spi_getcaretwidth"></a><dl>
     * <dt><b>SPI_GETCARETWIDTH</b></dt>
     * <dt>0x2006</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the caret width in edit controls, in pixels. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives this value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDOCKMOVING"></a><a id="spi_getdockmoving"></a><dl>
     * <dt><b>SPI_GETDOCKMOVING</b></dt>
     * <dt>0x0090</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a window is docked when it is moved to the top, left, or right edges of a monitor or monitor array. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDRAGFROMMAXIMIZE"></a><a id="spi_getdragfrommaximize"></a><dl>
     * <dt><b>SPI_GETDRAGFROMMAXIMIZE</b></dt>
     * <dt>0x008C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a maximized window is restored when its caption bar is dragged. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETDRAGFULLWINDOWS"></a><a id="spi_getdragfullwindows"></a><dl>
     * <dt><b>SPI_GETDRAGFULLWINDOWS</b></dt>
     * <dt>0x0026</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether dragging of full windows is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOREGROUNDFLASHCOUNT"></a><a id="spi_getforegroundflashcount"></a><dl>
     * <dt><b>SPI_GETFOREGROUNDFLASHCOUNT</b></dt>
     * <dt>0x2004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the number of times <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> will flash the taskbar button when rejecting a foreground switch request. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETFOREGROUNDLOCKTIMEOUT"></a><a id="spi_getforegroundlocktimeout"></a><dl>
     * <dt><b>SPI_GETFOREGROUNDLOCKTIMEOUT</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the amount of time following user input, in milliseconds, during which the system will not allow applications to force themselves into the foreground. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMINIMIZEDMETRICS"></a><a id="spi_getminimizedmetrics"></a><dl>
     * <dt><b>SPI_GETMINIMIZEDMETRICS</b></dt>
     * <dt>0x002B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the metrics associated with minimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-minimizedmetrics">MINIMIZEDMETRICS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MINIMIZEDMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEDOCKTHRESHOLD"></a><a id="spi_getmousedockthreshold"></a><dl>
     * <dt><b>SPI_GETMOUSEDOCKTHRESHOLD</b></dt>
     * <dt>0x007E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a monitor or monitor array. The default threshold is 1. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that receives the value.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSEDRAGOUTTHRESHOLD"></a><a id="spi_getmousedragoutthreshold"></a><dl>
     * <dt><b>SPI_GETMOUSEDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0084</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a monitor or a monitor array toward the center. The default threshold is 20.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETMOUSESIDEMOVETHRESHOLD"></a><a id="spi_getmousesidemovethreshold"></a><dl>
     * <dt><b>SPI_GETMOUSESIDEMOVETHRESHOLD</b></dt>
     * <dt>0x0088</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels from the top of a monitor or a monitor array where a vertically maximized window  is restored when dragged with the mouse. The default threshold is 50.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETNONCLIENTMETRICS"></a><a id="spi_getnonclientmetrics"></a><dl>
     * <dt><b>SPI_GETNONCLIENTMETRICS</b></dt>
     * <dt>0x0029</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the metrics associated with the nonclient area of nonminimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa">NONCLIENTMETRICS</a> structure that receives the information. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(NONCLIENTMETRICS)</c>.
     * 
     * <b>Windows Server 2003 and Windows XP/2000:  </b>See Remarks for <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa#remarks">NONCLIENTMETRICS</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENDOCKTHRESHOLD"></a><a id="spi_getpendockthreshold"></a><dl>
     * <dt><b>SPI_GETPENDOCKTHRESHOLD</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>Retrieves the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a monitor or monitor array. The default is 30.</b>
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENDRAGOUTTHRESHOLD"></a><a id="spi_getpendragoutthreshold"></a><dl>
     * <dt><b>SPI_GETPENDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0086</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a monitor or monitor array toward its center. The default threshold is 30.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETPENSIDEMOVETHRESHOLD"></a><a id="spi_getpensidemovethreshold"></a><dl>
     * <dt><b>SPI_GETPENSIDEMOVETHRESHOLD</b></dt>
     * <dt>0x008A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the threshold in pixels from the top of a monitor or monitor array where a vertically maximized window  is restored when dragged with the mouse. The default threshold is 50.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSHOWIMEUI"></a><a id="spi_getshowimeui"></a><dl>
     * <dt><b>SPI_GETSHOWIMEUI</b></dt>
     * <dt>0x006E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether the IME status window is visible (on a per-user basis). The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if the status window is visible, or <b>FALSE</b> if it is not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETSNAPSIZING"></a><a id="spi_getsnapsizing"></a><dl>
     * <dt><b>SPI_GETSNAPSIZING</b></dt>
     * <dt>0x008E</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether a window is vertically maximized when it is sized to the top or bottom of a monitor or monitor array. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Use <b>SPI_GETWINARRANGING</b> to determine whether this behavior is enabled.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_GETWINARRANGING"></a><a id="spi_getwinarranging"></a><dl>
     * <dt><b>SPI_GETWINARRANGING</b></dt>
     * <dt>0x0082</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether window arrangement is enabled. The <i>pvParam</i> parameter must point to a <b>BOOL</b> variable that receives <b>TRUE</b> if enabled, or <b>FALSE</b> otherwise.
     * 
     * Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by simplifying the default behavior of a window when it is dragged or sized.
     * 
     * The following parameters retrieve individual window arrangement settings:
     * 
     * <dl>
     * <dd><b>SPI_GETDOCKMOVING</b></dd>
     * <dd><b>SPI_GETMOUSEDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_GETMOUSEDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_GETMOUSESIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_GETPENDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_GETPENDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_GETPENSIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_GETSNAPSIZING</b></dd>
     * </dl>
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACTIVEWINDOWTRACKING"></a><a id="spi_setactivewindowtracking"></a><dl>
     * <dt><b>SPI_SETACTIVEWINDOWTRACKING</b></dt>
     * <dt>0x1001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets active window tracking (activating the window the mouse is on) either on or off. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACTIVEWNDTRKZORDER"></a><a id="spi_setactivewndtrkzorder"></a><dl>
     * <dt><b>SPI_SETACTIVEWNDTRKZORDER</b></dt>
     * <dt>0x100D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Determines whether or not windows activated through active window tracking should be brought to the top. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETACTIVEWNDTRKTIMEOUT"></a><a id="spi_setactivewndtrktimeout"></a><dl>
     * <dt><b>SPI_SETACTIVEWNDTRKTIMEOUT</b></dt>
     * <dt>0x2003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the active window tracking delay. Set <i>pvParam</i> to the number of milliseconds to delay before activating the window under the mouse pointer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETANIMATION"></a><a id="spi_setanimation"></a><dl>
     * <dt><b>SPI_SETANIMATION</b></dt>
     * <dt>0x0049</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the animation effects associated with user actions. The <i>pvParam</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-animationinfo">ANIMATIONINFO</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(ANIMATIONINFO)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETBORDER"></a><a id="spi_setborder"></a><dl>
     * <dt><b>SPI_SETBORDER</b></dt>
     * <dt>0x0006</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the border multiplier factor that determines the width of a window's sizing border. The <i>uiParam</i> parameter specifies the new value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETCARETWIDTH"></a><a id="spi_setcaretwidth"></a><dl>
     * <dt><b>SPI_SETCARETWIDTH</b></dt>
     * <dt>0x2007</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the caret width in edit controls. Set <i>pvParam</i> to the desired width, in pixels. The default and minimum value is 1.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDOCKMOVING"></a><a id="spi_setdockmoving"></a><dl>
     * <dt><b>SPI_SETDOCKMOVING</b></dt>
     * <dt>0x0091</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether a window is docked when it is moved to the top, left, or right docking targets on a monitor or monitor array. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGFROMMAXIMIZE"></a><a id="spi_setdragfrommaximize"></a><dl>
     * <dt><b>SPI_SETDRAGFROMMAXIMIZE</b></dt>
     * <dt>0x008D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether a maximized window is restored when its caption bar is dragged. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGFULLWINDOWS"></a><a id="spi_setdragfullwindows"></a><dl>
     * <dt><b>SPI_SETDRAGFULLWINDOWS</b></dt>
     * <dt>0x0025</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets dragging of full windows either on or off. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on, or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGHEIGHT"></a><a id="spi_setdragheight"></a><dl>
     * <dt><b>SPI_SETDRAGHEIGHT</b></dt>
     * <dt>0x004D</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the height, in pixels, of the rectangle used to detect the start of a drag operation. Set <i>uiParam</i> to the new value. To retrieve the drag height, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CYDRAG</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETDRAGWIDTH"></a><a id="spi_setdragwidth"></a><dl>
     * <dt><b>SPI_SETDRAGWIDTH</b></dt>
     * <dt>0x004C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the width, in pixels, of the rectangle used to detect the start of a drag operation. Set <i>uiParam</i> to the new value. To retrieve the drag width, call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getsystemmetrics">GetSystemMetrics</a> with the <b>SM_CXDRAG</b> flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOREGROUNDFLASHCOUNT"></a><a id="spi_setforegroundflashcount"></a><dl>
     * <dt><b>SPI_SETFOREGROUNDFLASHCOUNT</b></dt>
     * <dt>0x2005</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the number of times <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> will flash the taskbar button when rejecting a foreground switch request. Set <i>pvParam</i> to the number of times to flash.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETFOREGROUNDLOCKTIMEOUT"></a><a id="spi_setforegroundlocktimeout"></a><dl>
     * <dt><b>SPI_SETFOREGROUNDLOCKTIMEOUT</b></dt>
     * <dt>0x2001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the amount of time following user input, in milliseconds, during which the system does not allow applications to force themselves into the foreground. Set <i>pvParam</i> to the new time-out value.
     * 
     * The calling thread must be able to change the foreground window, otherwise the call fails.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMINIMIZEDMETRICS"></a><a id="spi_setminimizedmetrics"></a><dl>
     * <dt><b>SPI_SETMINIMIZEDMETRICS</b></dt>
     * <dt>0x002C</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the metrics associated with minimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-minimizedmetrics">MINIMIZEDMETRICS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(MINIMIZEDMETRICS)</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEDOCKTHRESHOLD"></a><a id="spi_setmousedockthreshold"></a><dl>
     * <dt><b>SPI_SETMOUSEDOCKTHRESHOLD</b></dt>
     * <dt>0x007F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a monitor or monitor array. The default threshold is 1. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSEDRAGOUTTHRESHOLD"></a><a id="spi_setmousedragoutthreshold"></a><dl>
     * <dt><b>SPI_SETMOUSEDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0085</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a monitor or monitor array to its center. The default threshold is 20. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETMOUSESIDEMOVETHRESHOLD"></a><a id="spi_setmousesidemovethreshold"></a><dl>
     * <dt><b>SPI_SETMOUSESIDEMOVETHRESHOLD</b></dt>
     * <dt>0x0089</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with the mouse. The default threshold is 50. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETNONCLIENTMETRICS"></a><a id="spi_setnonclientmetrics"></a><dl>
     * <dt><b>SPI_SETNONCLIENTMETRICS</b></dt>
     * <dt>0x002A</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the metrics associated with the nonclient area of nonminimized windows. The <i>pvParam</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-nonclientmetricsa">NONCLIENTMETRICS</a> structure that contains the new parameters. Set the <b>cbSize</b> member of this structure and the <i>uiParam</i> parameter to <c>sizeof(NONCLIENTMETRICS)</c>. Also, the <b>lfHeight</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/ns-wingdi-logfonta">LOGFONT</a> structure must be a negative value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENDOCKTHRESHOLD"></a><a id="spi_setpendockthreshold"></a><dl>
     * <dt><b>SPI_SETPENDOCKTHRESHOLD</b></dt>
     * <dt>0x0081</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a monitor or monitor array. The default threshold is 30. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENDRAGOUTTHRESHOLD"></a><a id="spi_setpendragoutthreshold"></a><dl>
     * <dt><b>SPI_SETPENDRAGOUTTHRESHOLD</b></dt>
     * <dt>0x0087</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a monitor or monitor array to its center. The default threshold is 30. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETPENSIDEMOVETHRESHOLD"></a><a id="spi_setpensidemovethreshold"></a><dl>
     * <dt><b>SPI_SETPENSIDEMOVETHRESHOLD</b></dt>
     * <dt>0x008B</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with a pen. The default threshold is 50. The <i>pvParam</i> parameter must point to a <b>DWORD</b> variable that contains the new value.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSHOWIMEUI"></a><a id="spi_setshowimeui"></a><dl>
     * <dt><b>SPI_SETSHOWIMEUI</b></dt>
     * <dt>0x006F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether the IME status window is visible or not on a per-user basis. The <i>uiParam</i> parameter specifies <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETSNAPSIZING"></a><a id="spi_setsnapsizing"></a><dl>
     * <dt><b>SPI_SETSNAPSIZING</b></dt>
     * <dt>0x008F</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether a window is vertically maximized when it is sized to the top or bottom of the monitor. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * <b>SPI_GETWINARRANGING</b> must be <b>TRUE</b> to enable this behavior.
     * 
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SPI_SETWINARRANGING"></a><a id="spi_setwinarranging"></a><dl>
     * <dt><b>SPI_SETWINARRANGING</b></dt>
     * <dt>0x0083</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sets whether window arrangement is enabled. Set <i>pvParam</i> to <b>TRUE</b> for on or <b>FALSE</b> for off.
     * 
     * Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by simplifying the default behavior of a window when it is dragged or sized.
     * 
     * The following parameters set individual window arrangement settings:
     * 
     * <dl>
     * <dd><b>SPI_SETDOCKMOVING</b></dd>
     * <dd><b>SPI_SETMOUSEDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_SETMOUSEDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_SETMOUSESIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_SETPENDOCKTHRESHOLD</b></dd>
     * <dd><b>SPI_SETPENDRAGOUTTHRESHOLD</b></dd>
     * <dd><b>SPI_SETPENSIDEMOVETHRESHOLD</b></dd>
     * <dd><b>SPI_SETSNAPSIZING</b></dd>
     * </dl>
     * <b>Windows Server2008, WindowsVista, Windows Server2003 and WindowsXP/2000:</b>This parameter is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} uiParam Type: <b>UINT</b>
     * 
     * A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify zero for this parameter.
     * @param {Pointer<Void>} pvParam Type: <b>PVOID</b>
     * 
     * A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see the <i>uiAction</i> parameter. If not otherwise indicated, you must specify <b>NULL</b> for this parameter. For information on the <b>PVOID</b> datatype, see <a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">Windows Data Types</a>.
     * @param {Integer} fWinIni Type: <b>UINT</b>
     * 
     * If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the <a href="https://docs.microsoft.com/windows/desktop/winmsg/wm-settingchange">WM_SETTINGCHANGE</a> message is to be broadcast to all top-level windows to notify them of the change.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-systemparametersinfow
     * @since windows5.0
     */
    static SystemParametersInfoW(uiAction, uiParam, pvParam, fWinIni) {
        A_LastError := 0

        result := DllCall("USER32.dll\SystemParametersInfoW", "uint", uiAction, "uint", uiParam, "ptr", pvParam, "uint", fWinIni, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Triggers a visual signal to indicate that a sound is playing.
     * @remarks
     * Set the notification behavior by calling <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-systemparametersinfoa">SystemParametersInfo</a> with the <b>SPI_SETSOUNDSENTRY</b> value.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * This function returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>TRUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The visual signal was or will be displayed correctly.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error prevented the signal from being displayed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-soundsentry
     * @since windows6.0.6000
     */
    static SoundSentry() {
        result := DllCall("USER32.dll\SoundSentry", "int")
        return result
    }

    /**
     * 
     * @param {Integer} dwLevel 
     * @returns {Pointer} 
     */
    static SetDebugErrorLevel(dwLevel) {
        result := DllCall("USER32.dll\SetDebugErrorLevel", "uint", dwLevel)
        return result
    }

    /**
     * Copies the text of the specified window's title bar (if it has one) into a buffer.
     * @remarks
     * This function was not included in the SDK headers and libraries until WindowsXP with Service Pack1 (SP1) and Windows Server2003. If you do not have a header file and import library for this function, you can call the function using <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a>.
     * @param {Pointer<Void>} hWnd Type: <b>HWND</b>
     * 
     * A handle to the window or control containing the text.
     * @param {Pointer<Char>} pString Type: <b>LPWSTR</b>
     * 
     * The buffer that is to receive the text.
     * 				
     * If the string is as long or longer than the buffer, the string is truncated and terminated with a null character.
     * @param {Integer} cchMaxCount Type: <b>int</b>
     * 
     * The maximum number of characters to be copied to the buffer, including the null character. If the text exceeds this limit, it is truncated.
     * @returns {Pointer} Type: <b>int</b>
     * 
     * If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character.
     * 
     * If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-internalgetwindowtext
     * @since windows5.0
     */
    static InternalGetWindowText(hWnd, pString, cchMaxCount) {
        pString := pString is String? StrPtr(pString) : pString

        A_LastError := 0

        result := DllCall("USER32.dll\InternalGetWindowText", "ptr", hWnd, "ptr", pString, "int", cchMaxCount)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static CancelShutdown() {
        result := DllCall("USER32.dll\CancelShutdown", "int")
        return result
    }

    /**
     * Retrieves information about the active window or a specified GUI thread.
     * @remarks
     * This function succeeds even if the active window is not owned by the calling process. If the specified thread does not exist or have an input queue, the function will fail. 
     * 
     * This function is useful for retrieving out-of-context information about a thread. The information retrieved is the same as if an application retrieved the information about itself. 
     * 
     * For an edit control, the returned <b>rcCaret</b> rectangle contains the caret plus information on text direction and padding. Thus, it may not give the correct position of the cursor. The Sans Serif font uses four characters for the cursor: 
     * 				
     * 
     * <table class="clsStd">
     * <tr>
     * <th>Cursor character</th>
     * <th>Unicode code point</th>
     * </tr>
     * <tr>
     * <td><b>CURSOR_LTR</b></td>
     * <td>0xf00c</td>
     * </tr>
     * <tr>
     * <td><b>CURSOR_RTL</b></td>
     * <td>0xf00d</td>
     * </tr>
     * <tr>
     * <td><b>CURSOR_THAI</b></td>
     * <td>0xf00e</td>
     * </tr>
     * <tr>
     * <td><b>CURSOR_USA</b></td>
     * <td>0xfff (this is a marker value with no associated glyph)</td>
     * </tr>
     * </table>
     * 
     * 
     *  To get the actual insertion point in the <b>rcCaret</b> rectangle, perform the following steps.
     * 				<ol>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getkeyboardlayout">GetKeyboardLayout</a> to retrieve the current input language. </li>
     * <li>Determine the character used for the cursor, based on the current input language.</li>
     * <li>Call <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-createfonta">CreateFont</a> using Sans Serif for the font, the height given by <b>rcCaret</b>, and a width of <c>zero</code>. For <i>fnWeight</i>, call <code>SystemParametersInfo(SPI_GETCARETWIDTH, 0, pvParam, 0)</c>. If <i>pvParam</i> is greater than 1, set <i>fnWeight</i> to 700, otherwise set <i>fnWeight</i> to 400.</li>
     * <li>Select the font into a device context (DC) and use <a href="https://docs.microsoft.com/windows/desktop/api/wingdi/nf-wingdi-getcharabcwidthsa">GetCharABCWidths</a> to get the <c>B</c> width of the appropriate cursor character.</li>
     * <li>Add the <c>B</c> width to <b>rcCaret</b>.<b>left</b> to obtain the actual insertion point.</li>
     * </ol>
     * 
     * 
     * The function may not return valid window handles in the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-guithreadinfo">GUITHREADINFO</a> structure when called to retrieve information for the foreground thread, such as when a window is losing activation.
     * 
     * 
     * 
     * 
     * 
     * <h3><a id="DPI_Virtualization"></a><a id="dpi_virtualization"></a><a id="DPI_VIRTUALIZATION"></a>DPI Virtualization</h3>
     * The coordinates returned in the <b>rcCaret</b> rect of the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-guithreadinfo">GUITHREADINFO</a> struct are logical coordinates in terms of the window associated with the caret. They are not virtualized into the mode of the calling thread.
     * @param {Integer} idThread Type: <b>DWORD</b>
     * 
     * The identifier for the thread for which information is to be retrieved. To retrieve this value, use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-getwindowthreadprocessid">GetWindowThreadProcessId</a> function. If this parameter is <b>NULL</b>, the function returns information for the foreground thread.
     * @param {Pointer<GUITHREADINFO>} pgui Type: <b>LPGUITHREADINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-guithreadinfo">GUITHREADINFO</a> structure that receives information describing the thread. Note that you must set the <b>cbSize</b> member to <c>sizeof(GUITHREADINFO)</c> before calling this function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getguithreadinfo
     * @since windows5.0
     */
    static GetGUIThreadInfo(idThread, pgui) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetGUIThreadInfo", "uint", idThread, "ptr", pgui, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * SetProcessDPIAware may be altered or unavailable. Instead, use SetProcessDPIAwareness.
     * @remarks
     * For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/mt846517(v=vs.85)">Setting the default DPI awareness for a process</a>.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. Otherwise, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setprocessdpiaware
     * @since windows6.0.6000
     */
    static SetProcessDPIAware() {
        result := DllCall("USER32.dll\SetProcessDPIAware", "int")
        return result
    }

    /**
     * IsProcessDPIAware may be altered or unavailable. Instead, use GetProcessDPIAwareness.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if the process is dpi aware; otherwise, <b>FALSE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-isprocessdpiaware
     * @since windows6.0.6000
     */
    static IsProcessDPIAware() {
        result := DllCall("USER32.dll\IsProcessDPIAware", "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} hwnd 
     * @param {Pointer<Void>} hwndInherit 
     * @returns {Integer} 
     */
    static InheritWindowMonitor(hwnd, hwndInherit) {
        result := DllCall("USER32.dll\InheritWindowMonitor", "ptr", hwnd, "ptr", hwndInherit, "int")
        return result
    }

    /**
     * Retrieves the full path and file name of the module associated with the specified window handle. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetWindowModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window whose module file name is to be retrieved.
     * @param {Pointer<Byte>} pszFileName Type: <b>LPTSTR</b>
     * 
     * The path and file name.
     * @param {Integer} cchFileNameMax Type: <b>UINT</b>
     * 
     * The maximum number of characters that can be copied into the <i>lpszFileName</i> buffer.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * The return value is the total number of characters copied into the buffer.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowmodulefilenamea
     * @since windows5.0
     */
    static GetWindowModuleFileNameA(hwnd, pszFileName, cchFileNameMax) {
        pszFileName := pszFileName is String? StrPtr(pszFileName) : pszFileName

        result := DllCall("USER32.dll\GetWindowModuleFileNameA", "ptr", hwnd, "ptr", pszFileName, "uint", cchFileNameMax)
        return result
    }

    /**
     * Retrieves the full path and file name of the module associated with the specified window handle. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winuser.h header defines GetWindowModuleFileName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window whose module file name is to be retrieved.
     * @param {Pointer<Char>} pszFileName Type: <b>LPTSTR</b>
     * 
     * The path and file name.
     * @param {Integer} cchFileNameMax Type: <b>UINT</b>
     * 
     * The maximum number of characters that can be copied into the <i>lpszFileName</i> buffer.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * The return value is the total number of characters copied into the buffer.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowmodulefilenamew
     * @since windows5.0
     */
    static GetWindowModuleFileNameW(hwnd, pszFileName, cchFileNameMax) {
        pszFileName := pszFileName is String? StrPtr(pszFileName) : pszFileName

        result := DllCall("USER32.dll\GetWindowModuleFileNameW", "ptr", hwnd, "ptr", pszFileName, "uint", cchFileNameMax)
        return result
    }

    /**
     * Retrieves information about the global cursor.
     * @param {Pointer<CURSORINFO>} pci Type: <b>PCURSORINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winuser/ns-winuser-cursorinfo">CURSORINFO</a> structure that receives the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(CURSORINFO)</c> before calling this function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getcursorinfo
     * @since windows5.0
     */
    static GetCursorInfo(pci) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetCursorInfo", "ptr", pci, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified window. (GetWindowInfo)
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window whose information is to be retrieved.
     * @param {Pointer<WINDOWINFO>} pwi Type: <b>PWINDOWINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-windowinfo">WINDOWINFO</a> structure to receive the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(WINDOWINFO)</c> before calling this function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. 
     * 
     * To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowinfo
     * @since windows5.0
     */
    static GetWindowInfo(hwnd, pwi) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetWindowInfo", "ptr", hwnd, "ptr", pwi, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified title bar.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the title bar whose information is to be retrieved.
     * @param {Pointer<TITLEBARINFO>} pti Type: <b>PTITLEBARINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-titlebarinfo">TITLEBARINFO</a> structure to receive the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(TITLEBARINFO)</c> before calling this function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-gettitlebarinfo
     * @since windows5.0
     */
    static GetTitleBarInfo(hwnd, pti) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetTitleBarInfo", "ptr", hwnd, "ptr", pti, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified menu bar.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window (menu bar) whose information is to be retrieved.
     * @param {Integer} idObject Type: <b>LONG</b>
     * @param {Integer} idItem Type: <b>LONG</b>
     * 
     * The item for which to retrieve information. If this parameter is zero, the function retrieves information about the menu itself. If this parameter is 1, the function retrieves information about the first item on the menu, and so on.
     * @param {Pointer<MENUBARINFO>} pmbi Type: <b>PMENUBARINFO</b>
     * 
     * A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-menubarinfo">MENUBARINFO</a> structure that receives the information. Note that you must set the <b>cbSize</b> member to <c>sizeof(MENUBARINFO)</c> before calling this function.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getmenubarinfo
     * @since windows5.0
     */
    static GetMenuBarInfo(hwnd, idObject, idItem, pmbi) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetMenuBarInfo", "ptr", hwnd, "int", idObject, "int", idItem, "ptr", pmbi, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetScrollBarInfo function retrieves information about the specified scroll bar.
     * @remarks
     * If <i>idObject</i> is OBJID_CLIENT and the window specified by <i>hwnd</i> is not a system scroll bar control, the system sends the <a href="https://docs.microsoft.com/windows/desktop/Controls/sbm-getscrollbarinfo">SBM_GETSCROLLBARINFO</a> message to the window to obtain scroll bar information.  This allows <b>GetScrollBarInfo</b> to operate on a custom control that mimics a scroll bar.  If the window does not handle the <b>SBM_GETSCROLLBARINFO</b> message, the <b>GetScrollBarInfo</b> function fails.
     * @param {Pointer<Void>} hwnd Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">HWND</a></b>
     * 
     * Handle to a window associated with the scroll bar whose information is to be retrieved. If the 
     * 					<i>idObject</i> parameter is OBJID_CLIENT, 
     * 					<i>hwnd</i> is a handle to a scroll bar control. Otherwise, 
     * 					<i>hwnd</i> is a handle to a window created with <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">WS_VSCROLL</a> and/or <a href="https://docs.microsoft.com/windows/desktop/winmsg/window-styles">WS_HSCROLL</a> style.
     * @param {Integer} idObject Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">LONG</a></b>
     * @param {Pointer<SCROLLBARINFO>} psbi Type: <b>PSCROLLBARINFO</b>
     * 
     * Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-scrollbarinfo">SCROLLBARINFO</a> structure to receive the information. Before calling <b>GetScrollBarInfo</b>, set the 
     * 					<b>cbSize</b> member to 
     * 					<b>sizeof</b>(<b>SCROLLBARINFO</b>).
     * @returns {Integer} Type: <b><a href="https://docs.microsoft.com/windows/desktop/WinProg/windows-data-types">BOOL</a></b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getscrollbarinfo
     * @since windows6.0.6000
     */
    static GetScrollBarInfo(hwnd, idObject, psbi) {
        A_LastError := 0

        result := DllCall("USER32.dll\GetScrollBarInfo", "ptr", hwnd, "int", idObject, "ptr", psbi, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the handle to the ancestor of the specified window.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns <b>NULL</b>.
     * @param {Integer} gaFlags Type: <b>UINT</b>
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is the handle to the ancestor window.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getancestor
     * @since windows5.0
     */
    static GetAncestor(hwnd, gaFlags) {
        result := DllCall("USER32.dll\GetAncestor", "ptr", hwnd, "uint", gaFlags)
        return result
    }

    /**
     * Retrieves a handle to the child window at the specified point. The search is restricted to immediate child windows; grandchildren and deeper descendant windows are not searched.
     * @remarks
     * <b>RealChildWindowFromPoint</b> treats <b>HTTRANSPARENT</b> areas of a standard control differently from other areas of the control; it returns the child window behind a transparent part of a control. In contrast, <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-childwindowfrompoint">ChildWindowFromPoint</a> treats <b>HTTRANSPARENT</b> areas of a control the same as other areas. For example, if the point is in a transparent area of a groupbox, <b>RealChildWindowFromPoint</b> returns the child window behind a groupbox, whereas <b>ChildWindowFromPoint</b> returns the groupbox. However, both APIs return a static field, even though it, too, returns <b>HTTRANSPARENT</b>.
     * @param {Pointer<Void>} hwndParent Type: <b>HWND</b>
     * 
     * A handle to the window whose child is to be retrieved.
     * @param {Pointer} ptParentClientCoords Type: <b><a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a></b>
     * 
     * A <a href="https://docs.microsoft.com/windows/win32/api/windef/ns-windef-point">POINT</a> structure that defines the client coordinates of the point to be checked.
     * @returns {Pointer<Void>} Type: <b>HWND</b>
     * 
     * The return value is a handle to the child window that contains the specified point.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-realchildwindowfrompoint
     * @since windows5.0
     */
    static RealChildWindowFromPoint(hwndParent, ptParentClientCoords) {
        result := DllCall("USER32.dll\RealChildWindowFromPoint", "ptr", hwndParent, "ptr", ptParentClientCoords)
        return result
    }

    /**
     * Retrieves a string that specifies the window type. (ANSI)
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window whose type will be retrieved.
     * @param {Pointer<Byte>} ptszClassName Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the window type.
     * @param {Integer} cchClassNameMax Type: <b>UINT</b>
     * 
     * The length, in characters, of the buffer pointed to by the <i>pszType</i> parameter.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the return value is the number of characters copied to the specified buffer. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-realgetwindowclassa
     */
    static RealGetWindowClassA(hwnd, ptszClassName, cchClassNameMax) {
        ptszClassName := ptszClassName is String? StrPtr(ptszClassName) : ptszClassName

        result := DllCall("USER32.dll\RealGetWindowClassA", "ptr", hwnd, "ptr", ptszClassName, "uint", cchClassNameMax)
        return result
    }

    /**
     * Retrieves a string that specifies the window type. (Unicode)
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window whose type will be retrieved.
     * @param {Pointer<Char>} ptszClassName Type: <b>LPTSTR</b>
     * 
     * A pointer to a string that receives the window type.
     * @param {Integer} cchClassNameMax Type: <b>UINT</b>
     * 
     * The length, in characters, of the buffer pointed to by the <i>pszType</i> parameter.
     * @returns {Pointer} Type: <b>UINT</b>
     * 
     * If the function succeeds, the return value is the number of characters copied to the specified buffer. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-realgetwindowclassw
     * @since windows5.0
     */
    static RealGetWindowClassW(hwnd, ptszClassName, cchClassNameMax) {
        ptszClassName := ptszClassName is String? StrPtr(ptszClassName) : ptszClassName

        A_LastError := 0

        result := DllCall("USER32.dll\RealGetWindowClassW", "ptr", hwnd, "ptr", ptszClassName, "uint", cchClassNameMax)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves status information for the specified window if it is the application-switching (ALT+TAB) window. (ANSI)
     * @remarks
     * The application-switching window enables you to switch to the most recently used application window. To display the application-switching window, press ALT+TAB. To select an application from the list, continue to hold ALT down and press TAB to move through the list. Add SHIFT to reverse direction through the list.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetAltTabInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window for which status information will be retrieved. This window must be the application-switching window.
     * @param {Integer} iItem Type: <b>int</b>
     * 
     * The index of the icon in the application-switching window. If the <i>pszItemText</i> parameter is not <b>NULL</b>, the name of the item is copied to the <i>pszItemText</i> string. If this parameter is 1, the name of the item is not copied.
     * @param {Pointer<ALTTABINFO>} pati Type: <b>PALTTABINFO</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-alttabinfo">ALTTABINFO</a> structure to receive the status information. Note that you must set the <b>csSize</b> member to <c>sizeof(ALTTABINFO)</c> before calling this function.
     * @param {Pointer<Byte>} pszItemText Type: <b>LPTSTR</b>
     * 
     * The name of the item. If this parameter is <b>NULL</b>, the name of the item is not copied.
     * @param {Integer} cchItemText Type: <b>UINT</b>
     * 
     * The size, in characters, of the <i>pszItemText</i> buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getalttabinfoa
     * @since windows5.0
     */
    static GetAltTabInfoA(hwnd, iItem, pati, pszItemText, cchItemText) {
        pszItemText := pszItemText is String? StrPtr(pszItemText) : pszItemText

        A_LastError := 0

        result := DllCall("USER32.dll\GetAltTabInfoA", "ptr", hwnd, "int", iItem, "ptr", pati, "ptr", pszItemText, "uint", cchItemText, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves status information for the specified window if it is the application-switching (ALT+TAB) window. (Unicode)
     * @remarks
     * The application-switching window enables you to switch to the most recently used application window. To display the application-switching window, press ALT+TAB. To select an application from the list, continue to hold ALT down and press TAB to move through the list. Add SHIFT to reverse direction through the list.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winuser.h header defines GetAltTabInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window for which status information will be retrieved. This window must be the application-switching window.
     * @param {Integer} iItem Type: <b>int</b>
     * 
     * The index of the icon in the application-switching window. If the <i>pszItemText</i> parameter is not <b>NULL</b>, the name of the item is copied to the <i>pszItemText</i> string. If this parameter is 1, the name of the item is not copied.
     * @param {Pointer<ALTTABINFO>} pati Type: <b>PALTTABINFO</b>
     * 
     * A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-alttabinfo">ALTTABINFO</a> structure to receive the status information. Note that you must set the <b>csSize</b> member to <c>sizeof(ALTTABINFO)</c> before calling this function.
     * @param {Pointer<Char>} pszItemText Type: <b>LPTSTR</b>
     * 
     * The name of the item. If this parameter is <b>NULL</b>, the name of the item is not copied.
     * @param {Integer} cchItemText Type: <b>UINT</b>
     * 
     * The size, in characters, of the <i>pszItemText</i> buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero. 
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getalttabinfow
     * @since windows5.0
     */
    static GetAltTabInfoW(hwnd, iItem, pati, pszItemText, cchItemText) {
        pszItemText := pszItemText is String? StrPtr(pszItemText) : pszItemText

        A_LastError := 0

        result := DllCall("USER32.dll\GetAltTabInfoW", "ptr", hwnd, "int", iItem, "ptr", pati, "ptr", pszItemText, "uint", cchItemText, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds or removes a message from the User Interface Privilege Isolation (UIPI) message filter.
     * @remarks
     * UIPI is a security feature that prevents messages from being received from a lower integrity level sender. All such messages with a value above <b>WM_USER</b> are blocked by default. The filter, somewhat contrary to intuition, is a list of messages that are allowed through. Therefore, adding a message to the filter allows that message to be received from a lower integrity sender, while removing a message blocks that message from being received.
     * 
     * Certain messages with a value less than <b>WM_USER</b> are required to pass through the filter regardless of the filter setting. You can call this function to remove one of those messages from the filter and it will return <b>TRUE</b>. However, the message will still be received by the calling process.
     * 
     * Processes at or below <b>SECURITY_MANDATORY_LOW_RID</b> are not allowed to change the filter. If those processes call this function, it will fail.
     * 
     * For more information on integrity levels, see <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/">Understanding and Working in Protected Mode Internet Explorer</a>.
     * @param {Integer} message Type: <b>UINT</b>
     * 
     * The message to add to or remove from the filter.
     * @param {Integer} dwFlag Type: <b>DWORD</b>
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * <b>TRUE</b> if successful; otherwise, <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *                     
     * 
     * <div class="alert"><b>Note</b>A message can be successfully removed from the filter, but that is not a guarantee that the message will be blocked. See the Remarks section for more details.</div>
     * <div></div>
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-changewindowmessagefilter
     * @since windows6.0.6000
     */
    static ChangeWindowMessageFilter(message, dwFlag) {
        A_LastError := 0

        result := DllCall("USER32.dll\ChangeWindowMessageFilter", "uint", message, "uint", dwFlag, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Modifies the User Interface Privilege Isolation (UIPI) message filter for a specified window.
     * @remarks
     * UIPI is a security feature that prevents messages from being received from a lower-integrity-level sender.
     * 		You can use this function to allow specific messages to be delivered to a window even 
     * 		if the message originates from a process at a lower integrity level. Unlike the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-changewindowmessagefilter">ChangeWindowMessageFilter</a> function, 
     * 		which controls the process message filter, the <b>ChangeWindowMessageFilterEx</b> function controls the window message filter. 
     * 		
     * 
     * An application may use the <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-changewindowmessagefilter">ChangeWindowMessageFilter</a> function to 
     * 		allow or block a message in a process-wide manner. 
     * 		If the message is allowed by either the process message filter 
     * 		or the window message filter, it will be delivered to the window.
     * 		
     * 
     * Note that processes at or below <b>SECURITY_MANDATORY_LOW_RID</b> are not allowed to change the message filter. 
     * 		If those processes call this function, it will fail and generate the extended error code, <b>ERROR_ACCESS_DENIED</b>.
     * 		
     * 
     * Certain messages whose value is smaller than <b>WM_USER</b> are required to be passed through the filter, 
     * 		regardless of the filter setting. There will be no effect when you attempt to use this function to 
     * 		allow or block such messages.
     * @param {Pointer<Void>} hwnd Type: <b>HWND</b>
     * 
     * A handle to the window whose UIPI message filter is to be modified.
     * @param {Integer} message Type: <b>UINT</b>
     * 
     * The message that the message filter allows through or blocks.
     * @param {Integer} action Type: <b>DWORD</b>
     * @param {Pointer<CHANGEFILTERSTRUCT>} pChangeFilterStruct Type: <b>PCHANGEFILTERSTRUCT</b>
     * 
     * Optional pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winuser/ns-winuser-changefilterstruct">CHANGEFILTERSTRUCT</a> structure.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, it returns <b>TRUE</b>; otherwise, it returns <b>FALSE</b>. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-changewindowmessagefilterex
     * @since windows6.1
     */
    static ChangeWindowMessageFilterEx(hwnd, message, action, pChangeFilterStruct) {
        A_LastError := 0

        result := DllCall("USER32.dll\ChangeWindowMessageFilterEx", "ptr", hwnd, "uint", message, "uint", action, "ptr", pChangeFilterStruct, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * SetAdditionalForegroundBoostProcesses is a performance assist API to help applications with a multi-process application model where multiple processes contribute to a foreground experience, either as data or rendering.
     * @remarks
     * This function takes a group of process handles that all get foreground boosted or de-boosted when the passed-in top level HWND moves to the foreground or background respectively. Whenever the passed-in top level HWND becomes the foreground window, a foreground boost will also be applied to the processes passed in the handle array. A similar de-boost happens when the top level HWND moves to the background.
     * 
     * The top level HWND passed to this function must be owned by the calling process. The calling process should have the **PROCESS_SET_INFORMATION** access right on the process handles in the **processHandleArray** - in other words, you must have full control of every window in your process. If some external component injects a window that takes foreground, or if a dialog box appears, then you lose your boost.
     * 
     * If you have two top level windows, you need to call this function for each one.
     * 
     * If the passed-in top level HWND is already in the foreground when **SetAdditionalForegroundBoostProcesses** is called, all of the processes in the **processHandleArray** are immediately boosted.
     * 
     * A process whose handle is in the **processHandleArray** will get a foreground boost only when the top level HWND becomes the foreground window.
     * 
     * Additional foreground boost is applied only when:
     * 
     * 1. The foreground window changes, or 
     * 2. If this function is called while the window is in the foreground and the new list has the process handle, or the list does not include the process handle while it was previously included.
     * 
     * When the process owning the top level HWND exits or terminates, the additional boosting relationship is torn down and secondary processes do not receive any additional foreground boosting.
     * 
     * The primary process's top level HWND will continue to hold references to secondary processes until either the primary process's top level HWND clears its grouped boost state, or the HWND is destroyed.
     * @param {Pointer<Void>} topLevelWindow A handle to the top level window (HWND) of the application.
     * @param {Integer} processHandleCount The number of process handles in **processHandleArray**. This function can be called at a single time with a maximum of 32 handles. Set this parameter to **0** along with setting **processHandleArray** to **NULL** to clear a prior boost configuration.
     * @param {Pointer<Void>} processHandleArray A group of process handles to be foreground boosted or de-boosted. Set this parameter to **NULL** along with setting **processHandleCount** to **0** to clear a prior boost configuration.
     * @returns {Integer} Returns **TRUE** if the call succeeds in boosting the application, **FALSE** otherwise. **SetAdditionalForegroundBoostProcesses** sets the last error code, so the application can call [GetLastError()](../errhandlingapi/nf-errhandlingapi-getlasterror.md) to obtain extended information if the call failed (for example, ERROR_INVALID_PARAMETER, ERROR_NOT_ENOUGH_MEMORY, or ERROR_ACCESS_DENIED).
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-setadditionalforegroundboostprocesses
     */
    static SetAdditionalForegroundBoostProcesses(topLevelWindow, processHandleCount, processHandleArray) {
        result := DllCall("USER32.dll\SetAdditionalForegroundBoostProcesses", "ptr", topLevelWindow, "uint", processHandleCount, "ptr", processHandleArray, "int")
        return result
    }

    /**
     * Lets apps or UI frameworks register and unregister windows to receive notification to dismiss their tooltip windows.
     * @remarks
     * This function makes tooltips more accessible by letting apps and frameworks that support tooltips register and unregister to be notified by a **WM_TOOLTIPDISMISS** message when the system requires all showing tooltips to be dismissed.
     * 
     * Apps should register for this notification each time they show a tooltip and hide their tooltips in response to a **WM_TOOLTIPDISMISS** message. When a tooltip is hidden for some other reason, like a mouse action, the app should unregister.
     * 
     * System-defined triggers for tooltip dismissal include a solitary Ctrl key up or Ctrl+Shift+F10. (The set of triggers may change over time.)
     * 
     * The function takes either the **HWND** of a tooltip window or the **HWND** of an app window that has child tooltips.  
     * 
     * - If a tooltip **HWND** itself is registered, the tooltip window is expected to register upon showing and to dismiss upon receiving a **WM_TOOLTIPDISMISS** message.  
     * - If an app **HWND** registers on behalf of its tooltips, the app's window is expected to register upon showing tooltips and dismiss all of its tooltips upon receiving a **WM_TOOLTIPDISMISS** message.  
     * 
     * Tooltip or app windows are expected to call the function to register each time tooltips are shown. Registered windows are automatically unregistered upon posting **WM_TOOLTIPDISMISS**.
     * 
     * The **TDF_UNREGISTER** flag is used to explicitly unregister a window when a tooltip window is dismissed by application or framework prerogative (such as moving the cursor out of the "safe zone"). If an app or framework calls `RegisterForTooltipDismissNotification` with **TDF_UNREGISTER** after the window has been automatically unregistered, the function returns **FALSE**. There is no impact on future registrations.
     * @param {Pointer<Void>} hWnd Type: **HWND**
     * 
     * The handle of the window to receive the **WM_TOOLTIPDISMISS** message.
     * @param {Integer} tdFlags Type: **[TOOLTIP_DISMISS_FLAGS](ne-winuser-tooltip_dismiss_flags.md)**
     * 
     * A value of the enumeration that specifies whether the function registers or unregisters the window. **TDF_REGISTER** to register; **TDF_UNREGISTER** to unregister.
     * @returns {Integer} **TRUE** if the window was successfully registered or unregistered; otherwise, **FALSE**. (See Remarks.)
     * @see https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-registerfortooltipdismissnotification
     */
    static RegisterForTooltipDismissNotification(hWnd, tdFlags) {
        result := DllCall("USER32.dll\RegisterForTooltipDismissNotification", "ptr", hWnd, "int", tdFlags, "int")
        return result
    }

    /**
     * Creates a new resource indexer for the specified paths of the root of the project files and the extension DLL.
     * @param {Pointer<Char>} projectRoot The path of the root folder to use for the project for the files to be produced, in string form. This path is used to determine file paths relative to the package that contains them. This path must be an absolute path with the drive letter specified. Long file paths are not supported.
     * @param {Pointer<Char>} extensionDllPath The full path to an extension dynamic-link library (DLL) that is Microsoft-signed and implements the ext-ms-win-mrmcorer-environment-l1 API set. This path determines the file path from where the extension DLL for the modern resource technology (MRT) environment is loaded. This path must be an absolute path with the drive letter specified. Long file paths are not supported.
     * @param {Pointer<Void>} ppResourceIndexer The newly created resource indexer.
     * @returns {Integer} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/resourceindexer/nf-resourceindexer-createresourceindexer
     * @since windows10.0.10240
     */
    static CreateResourceIndexer(projectRoot, extensionDllPath, ppResourceIndexer) {
        projectRoot := projectRoot is String? StrPtr(projectRoot) : projectRoot
        extensionDllPath := extensionDllPath is String? StrPtr(extensionDllPath) : extensionDllPath

        result := DllCall("MrmSupport.dll\CreateResourceIndexer", "ptr", projectRoot, "ptr", extensionDllPath, "ptr", ppResourceIndexer, "int")
        return result
    }

    /**
     * Frees the computational resources associated with the specified resource indexer.
     * @param {Pointer<Void>} resourceIndexer The resource indexer for which you want to free the computational resources.
     * @returns {Pointer} 
     * @see https://learn.microsoft.com/windows/win32/api/resourceindexer/nf-resourceindexer-destroyresourceindexer
     * @since windows10.0.10240
     */
    static DestroyResourceIndexer(resourceIndexer) {
        result := DllCall("MrmSupport.dll\DestroyResourceIndexer", "ptr", resourceIndexer)
        return result
    }

    /**
     * Indexes a file path for file and folder naming conventions.
     * @param {Pointer<Void>} resourceIndexer The resource indexer object that you created by calling the <a href="https://docs.microsoft.com/windows/desktop/api/resourceindexer/nf-resourceindexer-createresourceindexer">CreateResourceIndexer</a> function.
     * @param {Pointer<Char>} filePath The path for the folder that you want to index. The path must be an absolute path with the drive letter specified. Long file paths are not supported.
     * @param {Pointer<Char>} ppResourceUri A uniform resource indicator (URI) that uses the ms-resource URI scheme and represents the named resource for the candidate, where the authority of the URI or the resource map is empty. For example, ms-resource:///Resources/String1 or ms-resource:///Files/images/logo.png.
     * @param {Pointer<UInt32>} pQualifierCount The number of indexed resource qualifiers that the list in the <i>ppQualifiers</i> parameter contains.
     * @param {Pointer<IndexedResourceQualifier>} ppQualifiers A list of indexed resource qualifiers that declare the context under which the resources are appropriate.
     * @returns {Integer} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/resourceindexer/nf-resourceindexer-indexfilepath
     * @since windows10.0.10240
     */
    static IndexFilePath(resourceIndexer, filePath, ppResourceUri, pQualifierCount, ppQualifiers) {
        filePath := filePath is String? StrPtr(filePath) : filePath

        result := DllCall("MrmSupport.dll\IndexFilePath", "ptr", resourceIndexer, "ptr", filePath, "ptr", ppResourceUri, "uint*", pQualifierCount, "ptr", ppQualifiers, "int")
        return result
    }

    /**
     * Frees the parameters that the IndexFilePath method returned.
     * @param {Pointer<Char>} resourceUri A uniform resource indicator (URI) that uses the ms-resource URI scheme and represents the named resource for the candidate, where the authority of the URI or the resource map is empty. For example, ms-resource:///Resources/String1 or ms-resource:///Files/images/logo.png.
     * @param {Integer} qualifierCount The number of indexed resource qualifiers that the list in the <i>ppQualifiers</i> parameter contains.
     * @param {Pointer<IndexedResourceQualifier>} qualifiers A list of indexed resource qualifiers that declare the context under which the resources are appropriate.
     * @returns {Pointer} 
     * @see https://learn.microsoft.com/windows/win32/api/resourceindexer/nf-resourceindexer-destroyindexedresults
     * @since windows10.0.10240
     */
    static DestroyIndexedResults(resourceUri, qualifierCount, qualifiers) {
        resourceUri := resourceUri is String? StrPtr(resourceUri) : resourceUri

        result := DllCall("MrmSupport.dll\DestroyIndexedResults", "ptr", resourceUri, "uint", qualifierCount, "ptr", qualifiers)
        return result
    }

    /**
     * Creates a resource indexer, used to generate package resource index (PRI) files for a UWP app. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @param {Pointer<Char>} packageFamilyName Type: **PCWSTR**
     * 
     * The package family name of the UWP app for which you will be generating PRI files. This value will be used as the resource map name when you later generate a PRI file from this resource indexer.
     * @param {Pointer<Char>} projectRoot Type: **PCWSTR**
     * 
     * The project root of the UWP app for which you will be generating PRI files. In other words, the path to that app's resource files. You specify this so that you can then specify paths relative to that root in subsequent API calls to the same resource indexer.
     * @param {Integer} platformVersion Type: **[**MrmPlatformVersion**](mrmplatformversion.md)**
     * 
     * The target platform version for the resource indexer.
     * @param {Pointer<Char>} defaultQualifiers Type: **PCWSTR**
     * 
     * A list of default resource qualifiers. For example, L"language-en-US\_scale-100\_contrast-standard"
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)\***
     * 
     * A pointer to a resource indexer handle.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateresourceindexer
     */
    static MrmCreateResourceIndexer(packageFamilyName, projectRoot, platformVersion, defaultQualifiers, indexer) {
        packageFamilyName := packageFamilyName is String? StrPtr(packageFamilyName) : packageFamilyName
        projectRoot := projectRoot is String? StrPtr(projectRoot) : projectRoot
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers

        result := DllCall("MrmSupport.dll\MrmCreateResourceIndexer", "ptr", packageFamilyName, "ptr", projectRoot, "int", platformVersion, "ptr", defaultQualifiers, "ptr", indexer, "int")
        return result
    }

    /**
     * Creates a resource indexer from a schema file created with a previous call to MrmDumpPriFile. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @param {Pointer<Char>} projectRoot Type: **PCWSTR**
     * 
     * The project root of the UWP app for which you will be generating PRI files. In other words, the path to that app's resource files. You specify this so that you can then specify paths relative to that root in subsequent API calls to the same resource indexer.
     * @param {Integer} platformVersion Type: **[**MrmPlatformVersion**](mrmplatformversion.md)**
     * 
     * The target platform version for the resource indexer.
     * @param {Pointer<Char>} defaultQualifiers Type: **PCWSTR**
     * 
     * A list of default resource qualifiers. For example, L"language-en-US\_scale-100\_contrast-standard"
     * @param {Pointer<Char>} schemaFile Type: **PCWSTR**
     * 
     * A full file path to a schema file created by a previous call to [**MrmDumpPriFile**](mrmdumpprifile.md).
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)\***
     * 
     * A pointer to a resource indexer handle.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateresourceindexerfrompreviousschemafile
     */
    static MrmCreateResourceIndexerFromPreviousSchemaFile(projectRoot, platformVersion, defaultQualifiers, schemaFile, indexer) {
        projectRoot := projectRoot is String? StrPtr(projectRoot) : projectRoot
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers
        schemaFile := schemaFile is String? StrPtr(schemaFile) : schemaFile

        result := DllCall("MrmSupport.dll\MrmCreateResourceIndexerFromPreviousSchemaFile", "ptr", projectRoot, "int", platformVersion, "ptr", defaultQualifiers, "ptr", schemaFile, "ptr", indexer, "int")
        return result
    }

    /**
     * Creates a resource indexer from a PRI file created with a previous call to MrmCreateResourceFile. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @param {Pointer<Char>} projectRoot Type: **PCWSTR**
     * 
     * The project root of the UWP app for which you will be generating PRI files. In other words, the path to that app's resource files. You specify this so that you can then specify paths relative to that root in subsequent API calls to the same resource indexer.
     * @param {Integer} platformVersion Type: **[**MrmPlatformVersion**](mrmplatformversion.md)**
     * 
     * The target platform version for the resource indexer.
     * @param {Pointer<Char>} defaultQualifiers Type: **PCWSTR**
     * 
     * A list of default resource qualifiers. For example, L"language-en-US\_scale-100\_contrast-standard"
     * @param {Pointer<Char>} priFile Type: **PCWSTR**
     * 
     * A full file path to a PRI file.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)\***
     * 
     * A pointer to a resource indexer handle.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateresourceindexerfrompreviousprifile
     */
    static MrmCreateResourceIndexerFromPreviousPriFile(projectRoot, platformVersion, defaultQualifiers, priFile, indexer) {
        projectRoot := projectRoot is String? StrPtr(projectRoot) : projectRoot
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers
        priFile := priFile is String? StrPtr(priFile) : priFile

        result := DllCall("MrmSupport.dll\MrmCreateResourceIndexerFromPreviousPriFile", "ptr", projectRoot, "int", platformVersion, "ptr", defaultQualifiers, "ptr", priFile, "ptr", indexer, "int")
        return result
    }

    /**
     * Creates a resource indexer from in-memory schema data created with a previous call to either MrmDumpPriFileInMemory or MrmDumpPriDataInMemory.
     * @remarks
     * Don't free *schemaXmlData* until after you've finished using the resource indexer created by this function.
     * @param {Pointer<Char>} projectRoot Type: **PCWSTR**
     * 
     * The project root of the UWP app for which you will be generating PRI files. In other words, the path to that app's resource files. You specify this so that you can then specify paths relative to that root in subsequent API calls to the same resource indexer.
     * @param {Integer} platformVersion Type: **[**MrmPlatformVersion**](mrmplatformversion.md)**
     * 
     * The target platform version for the resource indexer.
     * @param {Pointer<Char>} defaultQualifiers Type: **PCWSTR**
     * 
     * A list of default resource qualifiers. For example, L"language-en-US\_scale-100\_contrast-standard"
     * @param {Pointer} schemaXmlData Type: **BYTE\***
     * 
     * A pointer to schema data created by a previous call to either [**MrmDumpPriFileInMemory**](mrmdumpprifileinmemory.md) or [**MrmDumpPriDataInMemory**](mrmdumppridatainmemory.md). Don't free *schemaXmlData* until after you've finished using the resource indexer created by this function.
     * @param {Integer} schemaXmlSize Type: **ULONG**
     * 
     * The size of the data pointed to by *schemaXmlData*.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)\***
     * 
     * A pointer to a resource indexer handle.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateresourceindexerfrompreviousschemadata
     */
    static MrmCreateResourceIndexerFromPreviousSchemaData(projectRoot, platformVersion, defaultQualifiers, schemaXmlData, schemaXmlSize, indexer) {
        projectRoot := projectRoot is String? StrPtr(projectRoot) : projectRoot
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers

        result := DllCall("MrmSupport.dll\MrmCreateResourceIndexerFromPreviousSchemaData", "ptr", projectRoot, "int", platformVersion, "ptr", defaultQualifiers, "ptr", schemaXmlData, "uint", schemaXmlSize, "ptr", indexer, "int")
        return result
    }

    /**
     * Creates a resource indexer from PRI data created by a previous call to MrmCreateResourceFileInMemory. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @remarks
     * Don't free *priData* until after you've finished using the resource indexer created by this function.
     * @param {Pointer<Char>} projectRoot Type: **PCWSTR**
     * 
     * The project root of the UWP app for which you will be generating PRI files. In other words, the path to that app's resource files. You specify this so that you can then specify paths relative to that root in subsequent API calls to the same resource indexer.
     * @param {Integer} platformVersion Type: **[**MrmPlatformVersion**](mrmplatformversion.md)**
     * 
     * The target platform version for the resource indexer.
     * @param {Pointer<Char>} defaultQualifiers Type: **PCWSTR**
     * 
     * A list of default resource qualifiers. For example, L"language-en-US\_scale-100\_contrast-standard"
     * @param {Pointer} priData Type: **BYTE\***
     * 
     * A pointer to PRI data created by a previous call to [**MrmCreateResourceFileInMemory**](mrmcreateresourcefileinmemory.md). Don't free *priData* until after you've finished using the resource indexer created by this function.
     * @param {Integer} priSize Type: **ULONG**
     * 
     * The size of the data pointed to by *priData*.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)\***
     * 
     * A pointer to a resource indexer handle.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateresourceindexerfrompreviouspridata-
     */
    static MrmCreateResourceIndexerFromPreviousPriData(projectRoot, platformVersion, defaultQualifiers, priData, priSize, indexer) {
        projectRoot := projectRoot is String? StrPtr(projectRoot) : projectRoot
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers

        result := DllCall("MrmSupport.dll\MrmCreateResourceIndexerFromPreviousPriData", "ptr", projectRoot, "int", platformVersion, "ptr", defaultQualifiers, "ptr", priData, "uint", priSize, "ptr", indexer, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} packageFamilyName 
     * @param {Pointer<Char>} projectRoot 
     * @param {Integer} platformVersion 
     * @param {Pointer<Char>} defaultQualifiers 
     * @param {Integer} flags 
     * @param {Pointer<Void>} indexer 
     * @returns {Integer} 
     */
    static MrmCreateResourceIndexerWithFlags(packageFamilyName, projectRoot, platformVersion, defaultQualifiers, flags, indexer) {
        packageFamilyName := packageFamilyName is String? StrPtr(packageFamilyName) : packageFamilyName
        projectRoot := projectRoot is String? StrPtr(projectRoot) : projectRoot
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers

        result := DllCall("MrmSupport.dll\MrmCreateResourceIndexerWithFlags", "ptr", packageFamilyName, "ptr", projectRoot, "int", platformVersion, "ptr", defaultQualifiers, "int", flags, "ptr", indexer, "int")
        return result
    }

    /**
     * Indexes a single string resource belonging to a UWP app.
     * @remarks
     * If you want to specify any resource qualifiers, then pass them in the *qualifiers* parameter. Resource qualifiers are *not* inferred from *resourceUri*.
     * 
     * The file name segment of *resourceUri* is used as the resource name.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer that will index the string resources.
     * @param {Pointer<Char>} resourceUri Type: **PCWSTR**
     * 
     * The resource URI to assign to the resource. The path will be used as the resource map subtree name for this resource when you later generate a PRI file from this resource indexer.
     * @param {Pointer<Char>} resourceString Type: **PCWSTR**
     * 
     * The value of the string resource.
     * @param {Pointer<Char>} qualifiers Type: **PCWSTR**
     * 
     * An optional list of resource qualifiers, for example L"language-en-US\_scale-100\_contrast-standard". An empty string or **nullptr** indicates a neutral resource. Resource qualifiers are *not* inferred from *resourceUri*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmindexstring
     */
    static MrmIndexString(indexer, resourceUri, resourceString, qualifiers) {
        resourceUri := resourceUri is String? StrPtr(resourceUri) : resourceUri
        resourceString := resourceString is String? StrPtr(resourceString) : resourceString
        qualifiers := qualifiers is String? StrPtr(qualifiers) : qualifiers

        result := DllCall("MrmSupport.dll\MrmIndexString", "ptr", indexer, "ptr", resourceUri, "ptr", resourceString, "ptr", qualifiers, "int")
        return result
    }

    /**
     * Indexes a single embeddeddata resource belonging to a UWP app.
     * @remarks
     * If you want to specify any resource qualifiers, then pass them in the *qualifiers* parameter. Resource qualifiers are *not* inferred from *resourceUri*.
     * 
     * The file name segment of *resourceUri* is used as the resource name.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer that will index the resource file.
     * @param {Pointer<Char>} resourceUri Type: **PCWSTR**
     * 
     * The resource URI to assign to the resource. The path will be used as the resource map subtree name for this resource when you later generate a PRI file from this resource indexer.
     * @param {Pointer} embeddedData Type: **const BYTE\***
     * 
     * A pointer to the data of the resource that you want to index.
     * @param {Integer} embeddedDataSize Type: **ULONG**
     * 
     * The size of the data pointed to by *embeddedData*.
     * @param {Pointer<Char>} qualifiers Type: **PCWSTR**
     * 
     * An optional list of resource qualifiers, for example L"language-en-US\_scale-100\_contrast-standard". An empty string or **nullptr** indicates a neutral resource. Resource qualifiers are *not* inferred from *resourceUri*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmindexembeddeddata
     */
    static MrmIndexEmbeddedData(indexer, resourceUri, embeddedData, embeddedDataSize, qualifiers) {
        resourceUri := resourceUri is String? StrPtr(resourceUri) : resourceUri
        qualifiers := qualifiers is String? StrPtr(qualifiers) : qualifiers

        result := DllCall("MrmSupport.dll\MrmIndexEmbeddedData", "ptr", indexer, "ptr", resourceUri, "ptr", embeddedData, "uint", embeddedDataSize, "ptr", qualifiers, "int")
        return result
    }

    /**
     * Indexes a resource file belonging to a UWP app. Takes an explicit (but optional) list of resource qualifiers. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @remarks
     * If you want to specify any resource qualifiers, then pass them in the *qualifiers* parameter. Resource qualifiers are *not* inferred from *resourceUri* nor from *filePath*.
     * 
     * The file name segment of *resourceUri* (not *filePath*) is used as the resource name.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer that will index the resource file.
     * @param {Pointer<Char>} resourceUri Type: **PCWSTR**
     * 
     * The resource URI to assign to the resource. The path will be used as the resource map subtree name for this resource when you later generate a PRI file from this resource indexer.
     * @param {Pointer<Char>} filePath Type: **PCWSTR**
     * 
     * A relative path to a file containing a resource that you want to index. This path is relative to the project root of the UWP app for which you are generating PRI files. That project root is the value of *projectRoot* that you passed to [**MrmCreateResourceIndexer**](mrmcreateresourceindexer.md).
     * @param {Pointer<Char>} qualifiers Type: **PCWSTR**
     * 
     * An optional list of resource qualifiers, for example L"language-en-US\_scale-100\_contrast-standard". An empty string or **nullptr** indicates a neutral resource. Resource qualifiers are *not* inferred from *resourceUri* nor from *containerPath*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmindexfile
     */
    static MrmIndexFile(indexer, resourceUri, filePath, qualifiers) {
        resourceUri := resourceUri is String? StrPtr(resourceUri) : resourceUri
        filePath := filePath is String? StrPtr(filePath) : filePath
        qualifiers := qualifiers is String? StrPtr(qualifiers) : qualifiers

        result := DllCall("MrmSupport.dll\MrmIndexFile", "ptr", indexer, "ptr", resourceUri, "ptr", filePath, "ptr", qualifiers, "int")
        return result
    }

    /**
     * Indexes a resource file belonging to a UWP app. Infers a list of resource qualifiers from the filePath parameter. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @remarks
     * The file name segment of *filePath* is used as the resource name; and resource qualifiers are derived from its path. For example, if you pass L"Images\\de-DE\\scale-100\\background.png" to *filePath* then the resource indexer adds a resource named "background.png" with resource qualifiers "language-de-DE" and "scale-100".
     * 
     * L"Files" will be used as the resource map subtree name for this resource when you later generate a PRI file from this resource indexer.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer that will index the resource file.
     * @param {Pointer<Char>} filePath Type: **PCWSTR**
     * 
     * A relative path to a file containing a resource that you want to index. This path is relative to the project root of the UWP app for which you are generating PRI files. That project root is the value of *projectRoot* that you passed to [**MrmCreateResourceIndexer**](mrmcreateresourceindexer.md).
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmindexfileautoqualifiers
     */
    static MrmIndexFileAutoQualifiers(indexer, filePath) {
        filePath := filePath is String? StrPtr(filePath) : filePath

        result := DllCall("MrmSupport.dll\MrmIndexFileAutoQualifiers", "ptr", indexer, "ptr", filePath, "int")
        return result
    }

    /**
     * Indexes the string resources contained inside a Resources File (.resw/.resjson), or a .priinfo or .prifile, belonging to a UWP app.
     * @remarks
     * Resource qualifiers are inferred from *containerPath*. For example, a value of L"en-US\\\\resources.resw" adds string resources with the qualifier "language-en-US".
     * 
     * The name of the Resources File will be used as the resource map subtree name for these resources when you later generate a PRI file from this resource indexer.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer that will index the string resources.
     * @param {Pointer<Char>} containerPath Type: **PCWSTR**
     * 
     * A relative path to a .resw, .resjson, .priinfo, or .prifile containing string resources that you want to index. This path is relative to the project root of the UWP app for which you are generating PRI files. That project root is the value of *projectRoot* that you passed to [**MrmCreateResourceIndexer**](mrmcreateresourceindexer.md).
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmindexresourcecontainerautoqualifiers
     */
    static MrmIndexResourceContainerAutoQualifiers(indexer, containerPath) {
        containerPath := containerPath is String? StrPtr(containerPath) : containerPath

        result := DllCall("MrmSupport.dll\MrmIndexResourceContainerAutoQualifiers", "ptr", indexer, "ptr", containerPath, "int")
        return result
    }

    /**
     * Creates a PRI file (named \ 0034;resources.pri \ 0034;), or files, on disk in the specified folder. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer from which to create the PRI file.
     * @param {Integer} packagingMode Type: **[**MrmPackagingMode**](mrmpackagingmode.md)**
     * 
     * Specifies whether the PRI file should be standalone, be automatically split by resource qualifier, or be a resource pack.
     * @param {Integer} packagingOptions Type: **[**MrmPackagingOptions**](mrmpackagingoptions.md)**
     * 
     * Specifies additional options about the PRI file.
     * @param {Pointer<Char>} outputDirectory Type: **PCWSTR**
     * 
     * A path to a folder in which to save the PRI file.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateresourcefile
     */
    static MrmCreateResourceFile(indexer, packagingMode, packagingOptions, outputDirectory) {
        outputDirectory := outputDirectory is String? StrPtr(outputDirectory) : outputDirectory

        result := DllCall("MrmSupport.dll\MrmCreateResourceFile", "ptr", indexer, "int", packagingMode, "int", packagingOptions, "ptr", outputDirectory, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} indexer 
     * @param {Integer} packagingMode 
     * @param {Integer} packagingOptions 
     * @param {Integer} checksum 
     * @param {Pointer<Char>} outputDirectory 
     * @returns {Integer} 
     */
    static MrmCreateResourceFileWithChecksum(indexer, packagingMode, packagingOptions, checksum, outputDirectory) {
        outputDirectory := outputDirectory is String? StrPtr(outputDirectory) : outputDirectory

        result := DllCall("MrmSupport.dll\MrmCreateResourceFileWithChecksum", "ptr", indexer, "int", packagingMode, "int", packagingOptions, "uint", checksum, "ptr", outputDirectory, "int")
        return result
    }

    /**
     * Creates PRI info as a blob in memory, not as a file on disk.
     * @remarks
     * If you pass *outputPriData* to [**MrmCreateResourceIndexerFromPreviousPriData**](mrmcreateresourceindexerfrompreviouspridata-.md), then don't free the memory until after you've finished using the resource indexer.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer from which to create the PRI info.
     * @param {Integer} packagingMode Type: **[**MrmPackagingMode**](mrmpackagingmode.md)**
     * 
     * Specifies whether the PRI info should be standalone, or be a resource pack. **MrmPackagingModeAutoSplit** is not supported.
     * @param {Integer} packagingOptions Type: **[**MrmPackagingOptions**](mrmpackagingoptions.md)**
     * 
     * Specifies additional options about the PRI info.
     * @param {Pointer<Byte>} outputPriData Type: **BYTE\*\***
     * 
     * The address of a pointer to BYTE. The function allocates memory and returns a pointer to that memory in *outputPriData*. Call [**MrmFreeMemory**](mrmfreememory.md) with your pointer to BYTE to free that memory.
     * @param {Pointer<UInt32>} outputPriSize Type: **ULONG\***
     * 
     * The address of a ULONG. In *outputPriSize*, the function returns the size of the allocated memory pointed to by *outputPriData*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateresourcefileinmemory
     */
    static MrmCreateResourceFileInMemory(indexer, packagingMode, packagingOptions, outputPriData, outputPriSize) {
        result := DllCall("MrmSupport.dll\MrmCreateResourceFileInMemory", "ptr", indexer, "int", packagingMode, "int", packagingOptions, "ptr", outputPriData, "uint*", outputPriSize, "int")
        return result
    }

    /**
     * View any messages generated by a resource indexer. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @remarks
     * Your app doesn't own the memory allocated and returned in *messages*, so don't free it.
     * @param {Pointer<Void>} handle 
     * @param {Pointer<MrmResourceIndexerMessage>} messages Type: **[**MrmResourceIndexerMessage**](mrmresourceindexermessage.md)\*\***
     * 
     * A pointer to a pointer to an [**MrmResourceIndexerMessage**](mrmresourceindexermessage.md). The function allocates an array of **MrmResourceIndexerMessage** and returns a pointer to that memory in *messages*. Do not free the pointer whose address you pass to *messages*.
     * @param {Pointer<UInt32>} numMsgs Type: **ULONG\***
     * 
     * The number of messages returned in *messages*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmpeekresourceindexermessages
     */
    static MrmPeekResourceIndexerMessages(handle, messages, numMsgs) {
        result := DllCall("MrmSupport.dll\MrmPeekResourceIndexerMessages", "ptr", handle, "ptr", messages, "uint*", numMsgs, "int")
        return result
    }

    /**
     * Releases machine resources associated with a resource indexer.
     * @param {Pointer<Void>} indexer Type: **[**MrmResourceIndexerHandle**](mrmresourceindexerhandle.md)**
     * 
     * A handle identifying the resource indexer to destroy.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmdestroyindexerandmessages
     */
    static MrmDestroyIndexerAndMessages(indexer) {
        result := DllCall("MrmSupport.dll\MrmDestroyIndexerAndMessages", "ptr", indexer, "int")
        return result
    }

    /**
     * Frees memory allocated by MrmCreateConfigInMemory, MrmCreateResourceFileInMemory, MrmDumpPriFileInMemory, and MrmDumpPriDataInMemory.
     * @param {Pointer<Byte>} data Type: **BYTE\***
     * 
     * A pointer to memory allocated and returned by [**MrmCreateConfigInMemory**](mrmcreateconfiginmemory.md), [**MrmCreateResourceFileInMemory**](mrmcreateresourcefileinmemory.md), [**MrmDumpPriFileInMemory**](mrmdumpprifileinmemory.md), or [**MrmDumpPriDataInMemory**](mrmdumppridatainmemory.md).
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmfreememory
     */
    static MrmFreeMemory(data) {
        result := DllCall("MrmSupport.dll\MrmFreeMemory", "char*", data, "int")
        return result
    }

    /**
     * Dumps a PRI file (which is binary) to its XML equivalent (as a file on disk), in order to make it more easily readable.
     * @remarks
     * A schema-free resource pack is one that was created with the [**MrmPackagingOptionsOmitSchemaFromResourcePacks**](mrmpackagingoptions.md) argument passed to [**MrmCreateResourceFile**](mrmcreateresourcefile.md) or [**MrmCreateResourceFileInMemory**](mrmcreateresourcefileinmemory.md) (or with the *omitSchemaFromResourcePacks* switch in the PRI config file). To dump a schema-free resource pack, pass the path to your main package PRI data as the argument for the *schemaPriFile* parameter.
     * @param {Pointer<Char>} indexFileName Type: **PCWSTR**
     * 
     * A full file path to a PRI file. This is the PRI file that will be dumped to XML.
     * @param {Pointer<Char>} schemaPriFile Type: **PCWSTR**
     * 
     * An optional full file path to a schema file (or to a PRI file representing a schema; see Remarks).
     * @param {Integer} dumpType Type: **[**MrmDumpType**](mrmdumptype.md)**
     * 
     * Specifies how detailed the XML dump should be, or whether a schema should be dumped.
     * @param {Pointer<Char>} outputXmlFile Type: **PCWSTR**
     * 
     * The path of an XML file to create.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmdumpprifile
     */
    static MrmDumpPriFile(indexFileName, schemaPriFile, dumpType, outputXmlFile) {
        indexFileName := indexFileName is String? StrPtr(indexFileName) : indexFileName
        schemaPriFile := schemaPriFile is String? StrPtr(schemaPriFile) : schemaPriFile
        outputXmlFile := outputXmlFile is String? StrPtr(outputXmlFile) : outputXmlFile

        result := DllCall("MrmSupport.dll\MrmDumpPriFile", "ptr", indexFileName, "ptr", schemaPriFile, "int", dumpType, "ptr", outputXmlFile, "int")
        return result
    }

    /**
     * Dumps a PRI file (which is binary) to its XML equivalent (as in-memory data), in order to make it more easily readable.
     * @remarks
     * A schema-free resource pack is one that was created with the [**MrmPackagingOptionsOmitSchemaFromResourcePacks**](mrmpackagingoptions.md) argument passed to [**MrmCreateResourceFile**](mrmcreateresourcefile.md) or [**MrmCreateResourceFileInMemory**](mrmcreateresourcefileinmemory.md) (or with the *omitSchemaFromResourcePacks* switch in the PRI config file). To dump a schema-free resource pack, pass the path to your main package PRI data as the argument for the *schemaPriFile* parameter.
     * @param {Pointer<Char>} indexFileName Type: **PCWSTR**
     * 
     * A full file path to a PRI file. This is the PRI file that will be dumped to XML.
     * @param {Pointer<Char>} schemaPriFile Type: **PCWSTR**
     * 
     * An optional full file path to a schema file (or to a PRI file representing a schema; see Remarks).
     * @param {Integer} dumpType Type: **[**MrmDumpType**](mrmdumptype.md)**
     * 
     * Specifies how detailed the XML dump should be, or whether a schema should be dumped.
     * @param {Pointer<Byte>} outputXmlData Type: **BYTE\*\***
     * 
     * The address of a pointer to BYTE. The function allocates memory and returns a pointer to that memory in *outputXmlData*. Call [**MrmFreeMemory**](mrmfreememory.md) with your pointer to BYTE to free that memory.
     * @param {Pointer<UInt32>} outputXmlSize Type: **ULONG\***
     * 
     * The address of a ULONG. In *outputXmlSize*, the function returns the size of the allocated memory pointed to by *outputXmlData*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmdumpprifileinmemory
     */
    static MrmDumpPriFileInMemory(indexFileName, schemaPriFile, dumpType, outputXmlData, outputXmlSize) {
        indexFileName := indexFileName is String? StrPtr(indexFileName) : indexFileName
        schemaPriFile := schemaPriFile is String? StrPtr(schemaPriFile) : schemaPriFile

        result := DllCall("MrmSupport.dll\MrmDumpPriFileInMemory", "ptr", indexFileName, "ptr", schemaPriFile, "int", dumpType, "ptr", outputXmlData, "uint*", outputXmlSize, "int")
        return result
    }

    /**
     * Dumps PRI info (as a blob in memory, created by a previous call to MrmCreateResourceFileInMemory) to its XML equivalent (as in-memory data), in order to make it more easily readable.
     * @remarks
     * A schema-free resource pack is one that was created with the [**MrmPackagingOptionsOmitSchemaFromResourcePacks**](mrmpackagingoptions.md) argument passed to [**MrmCreateResourceFile**](mrmcreateresourcefile.md) or [**MrmCreateResourceFileInMemory**](mrmcreateresourcefileinmemory.md) (or with the *omitSchemaFromResourcePacks* switch in the PRI config file). To dump a schema-free resource pack, pass the path to your main package PRI data as the argument for the *schemaPriData* parameter.
     * @param {Pointer} inputPriData Type: **BYTE\***
     * 
     * A pointer to PRI data created by a previous call to [**MrmCreateResourceFileInMemory**](mrmcreateresourcefileinmemory.md).
     * @param {Integer} inputPriSize Type: **ULONG**
     * 
     * The size of the data pointed to by *inputPriData*.
     * @param {Pointer} schemaPriData Type: **BYTE\***
     * 
     * An optional pointer to PRI info (as a blob in memory) representing schema data created by a previous call to [**MrmCreateResourceFileInMemory**](mrmcreateresourcefileinmemory.md). Don't free *schemaPriData* until after you've finished using the resource indexer. Also see Remarks.
     * @param {Integer} schemaPriSize Type: **ULONG**
     * 
     * The size of the data pointed to by *schemaPriData*.
     * @param {Integer} dumpType Type: **[**MrmDumpType**](mrmdumptype.md)**
     * 
     * Specifies how detailed the XML dump should be, or whether a schema should be dumped.
     * @param {Pointer<Byte>} outputXmlData Type: **BYTE\*\***
     * 
     * The address of a pointer to BYTE. The function allocates memory and returns a pointer to that memory in *outputXmlData*. Call [**MrmFreeMemory**](mrmfreememory.md) with your pointer to BYTE to free that memory.
     * @param {Pointer<UInt32>} outputXmlSize Type: **ULONG\***
     * 
     * The address of a ULONG. In *outputXmlSize*, the function returns the size of the allocated memory pointed to by *outputXmlData*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmdumppridatainmemory
     */
    static MrmDumpPriDataInMemory(inputPriData, inputPriSize, schemaPriData, schemaPriSize, dumpType, outputXmlData, outputXmlSize) {
        result := DllCall("MrmSupport.dll\MrmDumpPriDataInMemory", "ptr", inputPriData, "uint", inputPriSize, "ptr", schemaPriData, "uint", schemaPriSize, "int", dumpType, "ptr", outputXmlData, "uint*", outputXmlSize, "int")
        return result
    }

    /**
     * Creates a new, initialized PRI config file defining the qualifier defaults that you specify. For more info, and scenario-based walkthroughs of how to use these APIs, see Package resource indexing (PRI) APIs and custom build systems.
     * @param {Integer} platformVersion Type: **[**MrmPlatformVersion**](mrmplatformversion.md)**
     * 
     * The platform version (*targetOsVersion*) to use for the generated configuration file.
     * @param {Pointer<Char>} defaultQualifiers Type: **PCWSTR**
     * 
     * A list of default resource qualifiers. For example, L"language-en-US\_scale-100\_contrast-standard"
     * @param {Pointer<Char>} outputXmlFile Type: **PCWSTR**
     * 
     * The path of the configuration file to create.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateconfig
     */
    static MrmCreateConfig(platformVersion, defaultQualifiers, outputXmlFile) {
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers
        outputXmlFile := outputXmlFile is String? StrPtr(outputXmlFile) : outputXmlFile

        result := DllCall("MrmSupport.dll\MrmCreateConfig", "int", platformVersion, "ptr", defaultQualifiers, "ptr", outputXmlFile, "int")
        return result
    }

    /**
     * Creates new, initialized PRI configuration info (as in-memory data, not as a file) defining the qualifier defaults that you specify.
     * @param {Integer} platformVersion Type: **[**MrmPlatformVersion**](mrmplatformversion.md)**
     * 
     * The platform version (*targetOsVersion*) to use for the generated configuration info.
     * @param {Pointer<Char>} defaultQualifiers Type: **PCWSTR**
     * 
     * A list of default resource qualifiers. For example, L"language-en-US\_scale-100\_contrast-standard"
     * @param {Pointer<Byte>} outputXmlData Type: **BYTE\*\***
     * 
     * The address of a pointer to BYTE. The function allocates memory and returns a pointer to that memory in *outputXmlData*. Call [**MrmFreeMemory**](mrmfreememory.md) with your pointer to BYTE to free that memory.
     * @param {Pointer<UInt32>} outputXmlSize Type: **ULONG\***
     * 
     * The address of a ULONG. In *outputXmlSize*, the function returns the size of the allocated memory pointed to by *outputXmlData*.
     * @returns {Integer} Type: **HRESULT**
     * 
     * S\_OK if the function succeeded, otherwise some other value. Use the SUCCEEDED() or FAILED() macros (defined in winerror.h) to determine success or failure.
     * @see https://learn.microsoft.com/windows/win32/menurc/mrmcreateconfiginmemory
     */
    static MrmCreateConfigInMemory(platformVersion, defaultQualifiers, outputXmlData, outputXmlSize) {
        defaultQualifiers := defaultQualifiers is String? StrPtr(defaultQualifiers) : defaultQualifiers

        result := DllCall("MrmSupport.dll\MrmCreateConfigInMemory", "int", platformVersion, "ptr", defaultQualifiers, "ptr", outputXmlData, "uint*", outputXmlSize, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} priFile 
     * @param {Pointer<UInt32>} checksum 
     * @returns {Integer} 
     */
    static MrmGetPriFileContentChecksum(priFile, checksum) {
        priFile := priFile is String? StrPtr(priFile) : priFile

        result := DllCall("MrmSupport.dll\MrmGetPriFileContentChecksum", "ptr", priFile, "uint*", checksum, "int")
        return result
    }

    /**
     * Determines whether the specified window is arranged (that is, whether it's snapped).
     * @remarks
     * At this time, this function does not have an associated header file or library file. Your application can call [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) with the DLL name (`User32.dll`) to obtain a module handle. It can then call [**GetProcAddress**](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) with the module handle and the name of this function to get the function address.
     * 
     * A snapped window (see [Snap your windows](https://support.microsoft.com/windows/snap-your-windows-885a9b1e-a983-a3b1-16cd-c531795e6241)) is considered to be arranged. You should treat arrange as a window state similar to maximize. Arranged, maximize, and minimize are mutually exclusive states. An arranged window can be restored to its original size and position. Restoring a window from minimize can make a window arranged if the window was arranged before it was minimized. When calling [GetWindowPlacement](/windows/win32/api/winuser/nf-winuser-getwindowplacement), keep in mind that the *showCmd* member on the returned [WINDOWPLACEMENT](/windows/win32/api/winuser/ns-winuser-windowplacement) can have a value of **SW_SHOWNORMAL** even if the window is arranged.
     * @param {Pointer<Void>} hwnd Type: **HWND**
     * 
     * A handle to the window to be tested.
     * @returns {Integer} Type: **BOOL**
     * 
     * A nonzero value if the window is arranged; otherwise, zero.
     * @see https://learn.microsoft.com/windows/win32/winmsg/winuser/nf-winuser-iswindowarranged
     */
    static IsWindowArranged(hwnd) {
        result := DllCall("USER32.dll\IsWindowArranged", "ptr", hwnd, "int")
        return result
    }

;@endregion Methods
}
