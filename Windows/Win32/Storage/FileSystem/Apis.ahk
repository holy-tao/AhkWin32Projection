#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\..\Win32Handle.ahk
#Include ..\..\Foundation\HANDLE.ahk

/**
 * @namespace Windows.Win32.Storage.FileSystem
 * @version v4.0.30319
 */
class FileSystem {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static MAXIMUM_REPARSE_DATA_BUFFER_SIZE => 16384

    /**
     * @type {String}
     */
    static EA_CONTAINER_NAME => "ContainerName"

    /**
     * @type {String}
     */
    static EA_CONTAINER_SIZE => "ContainerSize"

    /**
     * @type {String}
     */
    static CLFS_BASELOG_EXTENSION => ".blf"

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_REENTRANT_FILE_SYSTEM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_NON_REENTRANT_FILTER => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_REENTRANT_FILTER => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_IGNORE_SHARE_ACCESS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_READ_IN_PROGRESS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_MINIFILTER_LEVEL => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_HIDDEN_SYSTEM_LOG => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MARSHALLING_FLAG_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MARSHALLING_FLAG_DISABLE_BUFF_INIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_FILTER_TOP_LEVEL => 32

    /**
     * @type {String}
     */
    static CLFS_CONTAINER_STREAM_PREFIX => "%BLF%:"

    /**
     * @type {String}
     */
    static CLFS_CONTAINER_RELATIVE_PREFIX => "%BLF%\"

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_VOLATILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_LOWEST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_MAXIMUM_OPTION => 63

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_DO_NOT_PROMOTE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MAXIMUM_OPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RESOURCE_MANAGER_VOLATILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RESOURCE_MANAGER_COMMUNICATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RESOURCE_MANAGER_MAXIMUM_OPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRM_PROTOCOL_MAXIMUM_OPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ENLISTMENT_SUPERIOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ENLISTMENT_MAXIMUM_OPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_MASK => 1073741823

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPREPARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPARE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ROLLBACK => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPREPARE_COMPLETE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPARE_COMPLETE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT_COMPLETE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ROLLBACK_COMPLETE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_RECOVER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_DELEGATE_COMMIT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_RECOVER_QUERY => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ENLIST_PREPREPARE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_LAST_RECOVER => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_INDOUBT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROPAGATE_PULL => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROPAGATE_PUSH => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_MARSHAL => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ENLIST_MASK => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_RM_DISCONNECTED => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_TM_ONLINE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT_REQUEST => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROMOTE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROMOTE_NEW => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_REQUEST_OUTCOME => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT_FINALIZE => 1073741824

    /**
     * @type {String}
     */
    static TRANSACTIONMANAGER_OBJECT_PATH => "\TransactionManager\"

    /**
     * @type {String}
     */
    static TRANSACTION_OBJECT_PATH => "\Transaction\"

    /**
     * @type {String}
     */
    static ENLISTMENT_OBJECT_PATH => "\Enlistment\"

    /**
     * @type {String}
     */
    static RESOURCE_MANAGER_OBJECT_PATH => "\ResourceManager\"

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KTM_MARSHAL_BLOB_VERSION_MAJOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KTM_MARSHAL_BLOB_VERSION_MINOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_TRANSACTION_DESCRIPTION_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_BASE => 86

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS => 5636096

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_ONLINE => 5685256

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_OFFLINE => 5685260

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_CLUSTERED => 5636144

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_GPT_ATTRIBUTES => 5636152

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE => 5636100

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_OFFLINE => 5636112

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_IO_CAPABLE => 5636116

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_FAILOVER_SET => 5636120

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_VOLUME_NUMBER => 5636124

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_LOGICAL_TO_PHYSICAL => 5636128

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_PHYSICAL_TO_LOGICAL => 5636132

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_PARTITION => 5636136

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_READ_PLEX => 5652526

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_SET_GPT_ATTRIBUTES => 5636148

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_BC_PROPERTIES => 5652540

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_ALLOCATE_BC_STREAM => 5685312

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_FREE_BC_STREAM => 5685316

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_BC_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_DYNAMIC => 5636168

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_PREPARE_FOR_CRITICAL_IO => 5685324

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_ALLOCATION_HINT => 5652562

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_UPDATE_PROPERTIES => 5636180

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_MINIMUM_SHRINK_SIZE => 5652568

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_PREPARE_FOR_SHRINK => 5685340

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_CSV => 5636192

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_POST_ONLINE => 5685348

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_CSVBLOCKCACHE_CALLBACK => 5685352

    /**
     * @type {Integer (UInt32)}
     */
    static CSV_BLOCK_CACHE_CALLBACK_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CSV_BLOCK_AND_FILE_CACHE_CALLBACK_VERSION => 2

    /**
     * @type {String}
     */
    static PARTITION_BASIC_DATA_GUID => "{ebd0a0a2-b9e5-4433-87c0-68b6b72699c7}"

    /**
     * @type {String}
     */
    static PARTITION_BSP_GUID => "{57434f53-4df9-45b9-8e9e-2370f006457c}"

    /**
     * @type {String}
     */
    static PARTITION_CLUSTER_GUID => "{db97dba9-0840-4bae-97f0-ffb9a327c7e1}"

    /**
     * @type {String}
     */
    static PARTITION_DPP_GUID => "{57434f53-94cb-43f0-a533-d73c10cfa57d}"

    /**
     * @type {String}
     */
    static PARTITION_ENTRY_UNUSED_GUID => "{00000000-0000-0000-0000-000000000000}"

    /**
     * @type {String}
     */
    static PARTITION_LDM_DATA_GUID => "{af9b60a0-1431-4f62-bc68-3311714a69ad}"

    /**
     * @type {String}
     */
    static PARTITION_LDM_METADATA_GUID => "{5808c8aa-7e8f-42e0-85d2-e1e90434cfb3}"

    /**
     * @type {String}
     */
    static PARTITION_MAIN_OS_GUID => "{57434f53-8f45-405e-8a23-186d8a4330d3}"

    /**
     * @type {String}
     */
    static PARTITION_MSFT_RECOVERY_GUID => "{de94bba4-06d1-4d40-a16a-bfd50179d6ac}"

    /**
     * @type {String}
     */
    static PARTITION_MSFT_RESERVED_GUID => "{e3c9e316-0b5c-4db8-817d-f92df00215ae}"

    /**
     * @type {String}
     */
    static PARTITION_MSFT_SNAPSHOT_GUID => "{caddebf1-4400-4de8-b103-12117dcf3ccf}"

    /**
     * @type {String}
     */
    static PARTITION_OS_DATA_GUID => "{57434f53-23f2-44d5-a830-67bbdaa609f9}"

    /**
     * @type {String}
     */
    static PARTITION_PATCH_GUID => "{8967a686-96aa-6aa8-9589-a84256541090}"

    /**
     * @type {String}
     */
    static PARTITION_PRE_INSTALLED_GUID => "{57434f53-7fe0-4196-9b42-427b51643484}"

    /**
     * @type {String}
     */
    static PARTITION_SBL_CACHE_SSD_GUID => "{eeff8352-dd2a-44db-ae83-bee1cf7481dc}"

    /**
     * @type {String}
     */
    static PARTITION_SBL_CACHE_SSD_RESERVED_GUID => "{dcc0c7c1-55ad-4f17-9d43-4bc776e0117e}"

    /**
     * @type {String}
     */
    static PARTITION_SBL_CACHE_HDD_GUID => "{03aaa829-ebfc-4e7e-aac9-c4d76c63b24b}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_FILES_GUID => "{57434f53-432e-4014-ae4c-8deaa9c0006a}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_METADATA_GUID => "{57434f53-c691-4a05-bb4e-703dafd229ce}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_RESERVE_GUID => "{57434f53-4b81-460b-a319-ffb6fe136d14}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_STAGING_ROOT_GUID => "{57434f53-e84d-4e84-aaf3-ecbbbd04b9df}"

    /**
     * @type {String}
     */
    static PARTITION_SPACES_GUID => "{e75caf8f-f680-4cee-afa3-b001e56efc2d}"

    /**
     * @type {String}
     */
    static PARTITION_SPACES_DATA_GUID => "{e7addcb4-dc34-4539-9a76-ebbd07be6f7e}"

    /**
     * @type {String}
     */
    static PARTITION_SYSTEM_GUID => "{c12a7328-f81f-11d2-ba4b-00a0c93ec93b}"

    /**
     * @type {String}
     */
    static PARTITION_WINDOWS_SYSTEM_GUID => "{57434f53-e3e3-4631-a5c5-26d2243873aa}"

    /**
     * @type {Integer (UInt32)}
     */
    static _FT_TYPES_DEFINITION_ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MGMT_POLICY_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOG_POLICY_OVERWRITE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOG_POLICY_PERSIST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MGMT_CLIENT_REGISTRATION_VERSION => 1

    /**
     * @type {String}
     */
    static CLSID_DiskQuotaControl => "{7988b571-ec89-11cf-9c00-00aa00a14f56}"

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_DISABLED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_TRACK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_ENFORCE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_MASK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_FILESTATE_INCOMPLETE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_FILESTATE_REBUILDING => 512

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_FILESTATE_MASK => 768

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_LOGFLAG_USER_THRESHOLD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_LOGFLAG_USER_LIMIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_RESOLVED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_UNAVAILABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_DELETED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_INVALID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_UNKNOWN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_UNRESOLVED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static INVALID_FILE_SIZE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static INVALID_SET_FILE_POINTER => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static INVALID_FILE_ATTRIBUTES => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_NETNAME_PARMNUM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_TYPE_PARMNUM => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_REMARK_PARMNUM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_PERMISSIONS_PARMNUM => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_MAX_USES_PARMNUM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_CURRENT_USES_PARMNUM => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_PATH_PARMNUM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_PASSWD_PARMNUM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_FILE_SD_PARMNUM => 501

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_SERVER_PARMNUM => 503

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_QOS_POLICY_PARMNUM => 504

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1_NUM_ELEMENTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHI2_NUM_ELEMENTS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED1 => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED2 => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED3 => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED4 => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED5 => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED_ALL => 1073741568

    /**
     * @type {Integer (UInt32)}
     */
    static SHI_USES_UNLIMITED => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DFS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DFS_ROOT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_MASK_EXT => 8240

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_MASK => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_MANUAL_REINT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_AUTO_REINT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_VDO => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_NONE => 48

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_FORCE_SHARED_DELETE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_FORCE_LEVELII_OPLOCK => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ENABLE_HASH => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ENABLE_CA => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ENCRYPT_DATA => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_RESERVED => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DISABLE_CLIENT_BUFFERING => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_IDENTITY_REMOTING => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_CLUSTER_MANAGED => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_COMPRESS_DATA => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ISOLATED_TRANSPORT => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DISABLE_DIRECTORY_HANDLE_LEASING => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static SESI1_NUM_ELEMENTS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SESI2_NUM_ELEMENTS => 9

    /**
     * @type {Integer (UInt32)}
     */
    static STATSOPT_CLR => 1

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_BADINHANDLE => -1

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_BADOUTHANDLE => -2

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_READ => -3

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_WRITE => -4

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_GLOBALLOC => -5

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_GLOBLOCK => -6

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_BADVALUE => -7

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_UNKNOWNALG => -8

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OBJECTNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_DESCRIPTION_LENGTH => 127

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_DEVICENAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_SERIALNUMBER_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_REVISION_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_BARCODE_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_SEQUENCE_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_VENDORNAME_LENGTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_PRODUCTNAME_LENGTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_USERNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_APPLICATIONNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_COMPUTERNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_I1_MESSAGE_LENGTH => 127

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_MESSAGE_LENGTH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_POOLHIERARCHY_LENGTH => 512

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OMIDLABELID_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OMIDLABELTYPE_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OMIDLABELINFO_LENGTH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_MAXATTR_LENGTH => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_MAXATTR_NAMELEN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMSMLI_MAXTYPE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMSMLI_MAXIDSIZE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NTMSMLI_MAXAPPDESCR => 256

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_COMMIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_ABORT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_PREPARE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_DATA => 8

    /**
     * @type {Integer (UInt32)}
     */
    static VS_VERSION_INFO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static VS_USER_DEFINED => 100

    /**
     * @type {Integer (Int32)}
     */
    static VS_FFI_SIGNATURE => -17890115

    /**
     * @type {Integer (Int32)}
     */
    static VS_FFI_STRUCVERSION => 65536

    /**
     * @type {Integer (Int32)}
     */
    static VS_FFI_FILEFLAGSMASK => 63

    /**
     * @type {Integer (UInt32)}
     */
    static WINEFS_SETUSERKEY_SET_CAPABILITIES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_COMPATIBILITY_VERSION_NCRYPT_PROTECTOR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_COMPATIBILITY_VERSION_PFILE_PROTECTOR => 6

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_SUBVER_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_EFS_SUBVER_EFS_CERT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_PFILE_SUBVER_RMS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_PFILE_SUBVER_APPX => 3

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SID_SIZE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_ADD_USER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_REMOVE_USER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_REPLACE_USER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_GENERAL_OP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static WOF_PROVIDER_WIM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WOF_PROVIDER_FILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_PROVIDER_HASH_SIZE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_BOOT_OS_WIM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_BOOT_NOT_OS_WIM => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_ENTRY_FLAG_NOT_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_ENTRY_FLAG_SUSPENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_EXTERNAL_FILE_INFO_FLAG_NOT_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_EXTERNAL_FILE_INFO_FLAG_SUSPENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_XPRESS4K => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_LZX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_XPRESS8K => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_XPRESS16K => 3

    /**
     * @type {Integer (Int32)}
     */
    static COPYFILE2_MESSAGE_COPY_OFFLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFILE2_IO_CYCLE_SIZE_MIN => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFILE2_IO_CYCLE_SIZE_MAX => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFILE2_IO_RATE_MIN => 512

    /**
     * @type {Integer (Byte)}
     */
    static ClfsNullRecord => 0x00

    /**
     * @type {Integer (Byte)}
     */
    static ClfsDataRecord => 0x01

    /**
     * @type {Integer (Byte)}
     */
    static ClfsRestartRecord => 0x02

    /**
     * @type {Integer (Byte)}
     */
    static ClfsClientRecord => 0x03

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerInitializing => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerInactive => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerActive => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerActivePendingDelete => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerPendingArchive => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerPendingArchiveAndDelete => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerInitializing => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerInactive => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerActive => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerActivePendingDelete => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerPendingArchive => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerPendingArchiveAndDelete => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MAX_CONTAINER_INFO => 256

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_INIT => 0x01

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_FORWARD => 0x02

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_BACKWARD => 0x04

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_CLOSE => 0x08

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_INITIALIZED => 0x10

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_BUFFERED => 0x20
;@endregion Constants

;@region Methods
    /**
     * Searches for a specified file in a specified path.
     * @param {PWSTR} lpPath The path to be searched for the file.
     * 
     * If this parameter is <b>NULL</b>, the 
     *        function searches for a matching file using a registry-dependent system  search path. For more information, see 
     *        the Remarks section.
     * @param {PWSTR} lpFileName The name of the file for which to search.
     * @param {PWSTR} lpExtension The extension to be added to the file name when searching for the file. The first character of the file name 
     *        extension must be a period (.). The extension is added only if the specified file name does not end with an 
     *        extension.
     * 
     * If a file name extension is not required or if the file name contains an extension, this parameter can be 
     *        <b>NULL</b>.
     * @param {Integer} nBufferLength The size of the buffer that receives the valid path and file name (including the terminating null 
     *       character), in <b>TCHARs</b>.
     * @param {PWSTR} lpBuffer A pointer to the buffer to receive the path and file name of the file found. The  string is a 
     *       null-terminated string.
     * @param {Pointer<PWSTR>} lpFilePart A pointer to the variable to receive the address (within <i>lpBuffer</i>) of the last 
     *       component of the valid path and file name, which is the address of the character immediately following the final 
     *       backslash (\\) in the path.
     * @returns {Integer} If the function succeeds, the value returned is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to the buffer, not including the terminating null character. If the return value is 
     *        greater than <i>nBufferLength</i>, the value returned is the size of the buffer that is 
     *        required to hold the path, including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpathw
     * @since windows5.1.2600
     */
    static SearchPathW(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart) {
        lpPath := lpPath is String ? StrPtr(lpPath) : lpPath
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpExtension := lpExtension is String ? StrPtr(lpExtension) : lpExtension
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SearchPathW", "ptr", lpPath, "ptr", lpFileName, "ptr", lpExtension, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches for a specified file in a specified path.
     * @param {PSTR} lpPath The path to be searched for the file.
     * 
     * If this parameter is <b>NULL</b>, the 
     *        function searches for a matching file using a registry-dependent system  search path. For more information, see 
     *        the Remarks section.
     * @param {PSTR} lpFileName The name of the file for which to search.
     * @param {PSTR} lpExtension The extension to be added to the file name when searching for the file. The first character of the file name 
     *        extension must be a period (.). The extension is added only if the specified file name does not end with an 
     *        extension.
     * 
     * If a file name extension is not required or if the file name contains an extension, this parameter can be 
     *        <b>NULL</b>.
     * @param {Integer} nBufferLength The size of the buffer that receives the valid path and file name (including the terminating null 
     *       character), in <b>TCHARs</b>.
     * @param {PSTR} lpBuffer A pointer to the buffer to receive the path and file name of the file found. The  string is a 
     *       null-terminated string.
     * @param {Pointer<PSTR>} lpFilePart A pointer to the variable to receive the address (within <i>lpBuffer</i>) of the last 
     *       component of the valid path and file name, which is the address of the character immediately following the final 
     *       backslash (\\) in the path.
     * @returns {Integer} If the function succeeds, the value returned is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to the buffer, not including the terminating null character. If the return value is 
     *        greater than <i>nBufferLength</i>, the value returned is the size of the buffer that is 
     *        required to hold the path, including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//processenv/nf-processenv-searchpatha
     * @since windows5.1.2600
     */
    static SearchPathA(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart) {
        lpPath := lpPath is String ? StrPtr(lpPath) : lpPath
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpExtension := lpExtension is String ? StrPtr(lpExtension) : lpExtension
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SearchPathA", "ptr", lpPath, "ptr", lpFileName, "ptr", lpExtension, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two file times.
     * @param {Pointer<FILETIME>} lpFileTime1 A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the 
     *      first file time.
     * @param {Pointer<FILETIME>} lpFileTime2 A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the 
     *      second file time.
     * @returns {Integer} The return value is one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>-1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * First file time is earlier than second file time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * First file time is equal to second file time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * First file time is later than second file time.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-comparefiletime
     * @since windows5.1.2600
     */
    static CompareFileTime(lpFileTime1, lpFileTime2) {
        result := DllCall("KERNEL32.dll\CompareFileTime", "ptr", lpFileTime1, "ptr", lpFileTime2, "int")
        return result
    }

    /**
     * Creates a new directory.
     * @param {PSTR} lpPathName The path of the directory to be created.
     * 
     * For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory. If <i>lpSecurityAttributes</i> is 
     *        <b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default 
     *        security descriptor for a  directory are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        (This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.)
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist; this function will only create the final directory in 
     *         the path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createdirectorya
     * @since windows5.1.2600
     */
    static CreateDirectoryA(lpPathName, lpSecurityAttributes) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryA", "ptr", lpPathName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory.
     * @param {PWSTR} lpPathName The path of the directory to be created.
     * 
     * For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory. If <i>lpSecurityAttributes</i> is 
     *        <b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default 
     *        security descriptor for a  directory are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        (This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.)
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist; this function will only create the final directory in 
     *         the path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createdirectoryw
     * @since windows5.1.2600
     */
    static CreateDirectoryW(lpPathName, lpSecurityAttributes) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryW", "ptr", lpPathName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:\_file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe.
     * @param {PSTR} lpFileName The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * For information on special device names, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are <b>GENERIC_READ</b>, 
     *        <b>GENERIC_WRITE</b>, or both 
     *        (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device 
     *        attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would 
     *        have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the 
     *        <i>dwShareMode</i> parameter in an open request that already has an open handle.
     * 
     * For more information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or 
     *        none (refer to the following table). Access requests to attributes or extended attributes are not affected by 
     *        this flag.
     * 
     * If this parameter is zero and <b>CreateFile</b> succeeds, the 
     *        file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. 
     *        For more information, see the Remarks section.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an existing 
     *        request that has an open handle. <b>CreateFile</b> would fail and 
     *        the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return 
     *        <b>ERROR_SHARING_VIOLATION</b>.
     * 
     * To enable a process to share a file or device while another process has the file or device open, use a
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains two separate but related data members: an optional security descriptor, and a Boolean 
     *        value that determines whether the returned handle can be inherited by child processes.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If this parameter is <b>NULL</b>, the handle returned by 
     *        <b>CreateFile</b> cannot be inherited by any child processes the 
     *        application may create and the file or device associated with the returned handle gets a default security 
     *        descriptor.
     * 
     * The <b>lpSecurityDescriptor</b> member of the structure specifies a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If 
     *        this member is <b>NULL</b>, the file or device associated with the returned handle is 
     *        assigned a default security descriptor.
     * 
     * <b>CreateFile</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues 
     *        to use the <b>bInheritHandle</b> member.
     * 
     * The <b>bInheritHandle</b>member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     * 
     * For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwFlagsAndAttributes The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most 
     *        common default value for files.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of 
     *        file or device caching behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally 
     *        combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied 
     *        as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div>
     * <div> </div>
     * Some of the following file attributes and flags may only apply to files and not necessarily all other types 
     *        of devices that <b>CreateFile</b> can open. For additional 
     *        information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * For more advanced access to file attributes, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list 
     *        of all file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the calling 
     *          process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and 
     *          <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after all of its handles are closed, which includes the specified 
     *          handle and any other open or duplicated handles.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with no system caching for data reads and writes. This flag does not 
     *          affect hard disk caching or memory mapped files.
     * 
     * There are strict requirements for successfully working with files opened with 
     *          <b>CreateFile</b> using the 
     *          <b>FILE_FLAG_NO_BUFFERING</b> flag, for details see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not 
     *          occur; <b>CreateFile</b> will attempt to open the reparse 
     *          point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse 
     *          point is operational.
     * 
     * This flag cannot be used with the <b>CREATE_ALWAYS</b> flag.
     * 
     * If the file is not a reparse point, then this flag is ignored.
     * 
     * For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened or created for asynchronous I/O.
     * 
     * When subsequent I/O operations are completed on this handle, the event specified in the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the 
     *          signaled state.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * For information about considerations when using a file handle created with this flag, see the 
     *          <a href="https://docs.microsoft.com/">Synchronous and Asynchronous I/O Handles</a> 
     *          section of this topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access will occur according to POSIX rules. This includes allowing multiple files with names, differing 
     *          only in case, for file systems that support that naming. Use care when using this option, because files 
     *          created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be random. The system can use this as a hint to optimize file caching.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize 
     *          file caching.
     * 
     * This flag should not be used if read-behind (that is, reverse scans) will be used.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * For additional information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i>parameter can also specify SQOS information. For more 
     *        information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the 
     *        calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {HANDLE} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * When opening an existing file, <b>CreateFile</b> ignores this 
     *        parameter.
     * 
     * When opening a new encrypted file, the file inherits the discretionary access control list from its parent 
     *        directory. For additional information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilea
     * @since windows5.1.2600
     */
    static CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTemplateFile := hTemplateFile is Win32Handle ? NumGet(hTemplateFile, "ptr") : hTemplateFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileA", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:\_file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe.
     * @param {PWSTR} lpFileName The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     * To extend this limit to 32,767 wide characters, use this Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * For information on special device names, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are <b>GENERIC_READ</b>, 
     *        <b>GENERIC_WRITE</b>, or both 
     *        (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device 
     *        attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would 
     *        have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the 
     *        <i>dwShareMode</i> parameter in an open request that already has an open handle.
     * 
     * For more information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or 
     *        none (refer to the following table). Access requests to attributes or extended attributes are not affected by 
     *        this flag.
     * 
     * If this parameter is zero and <b>CreateFile</b> succeeds, the 
     *        file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. 
     *        For more information, see the Remarks section.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an existing 
     *        request that has an open handle. <b>CreateFile</b> would fail and 
     *        the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return 
     *        <b>ERROR_SHARING_VIOLATION</b>.
     * 
     * To enable a process to share a file or device while another process has the file or device open, use a
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains two separate but related data members: an optional security descriptor, and a Boolean 
     *        value that determines whether the returned handle can be inherited by child processes.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If this parameter is <b>NULL</b>, the handle returned by 
     *        <b>CreateFile</b> cannot be inherited by any child processes the 
     *        application may create and the file or device associated with the returned handle gets a default security 
     *        descriptor.
     * 
     * The <b>lpSecurityDescriptor</b> member of the structure specifies a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If 
     *        this member is <b>NULL</b>, the file or device associated with the returned handle is 
     *        assigned a default security descriptor.
     * 
     * <b>CreateFile</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues 
     *        to use the <b>bInheritHandle</b> member.
     * 
     * The <b>bInheritHandle</b>member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     * 
     * For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwFlagsAndAttributes The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most 
     *        common default value for files.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of 
     *        file or device caching behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally 
     *        combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied 
     *        as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div>
     * <div> </div>
     * Some of the following file attributes and flags may only apply to files and not necessarily all other types 
     *        of devices that <b>CreateFile</b> can open. For additional 
     *        information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * For more advanced access to file attributes, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list 
     *        of all file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the calling 
     *          process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and 
     *          <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after all of its handles are closed, which includes the specified 
     *          handle and any other open or duplicated handles.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with no system caching for data reads and writes. This flag does not 
     *          affect hard disk caching or memory mapped files.
     * 
     * There are strict requirements for successfully working with files opened with 
     *          <b>CreateFile</b> using the 
     *          <b>FILE_FLAG_NO_BUFFERING</b> flag, for details see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not 
     *          occur; <b>CreateFile</b> will attempt to open the reparse 
     *          point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse 
     *          point is operational.
     * 
     * This flag cannot be used with the <b>CREATE_ALWAYS</b> flag.
     * 
     * If the file is not a reparse point, then this flag is ignored.
     * 
     * For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened or created for asynchronous I/O.
     * 
     * When subsequent I/O operations are completed on this handle, the event specified in the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the 
     *          signaled state.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * For information about considerations when using a file handle created with this flag, see the 
     *          <a href="https://docs.microsoft.com/">Synchronous and Asynchronous I/O Handles</a> 
     *          section of this topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access will occur according to POSIX rules. This includes allowing multiple files with names, differing 
     *          only in case, for file systems that support that naming. Use care when using this option, because files 
     *          created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be random. The system can use this as a hint to optimize file caching.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize 
     *          file caching.
     * 
     * This flag should not be used if read-behind (that is, reverse scans) will be used.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * For additional information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i> parameter can also specify SQOS information. For more 
     *        information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the 
     *        calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {HANDLE} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * When opening an existing file, <b>CreateFile</b> ignores this 
     *        parameter.
     * 
     * When opening a new encrypted file, the file inherits the discretionary access control list from its parent 
     *        directory. For additional information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfilew
     * @since windows5.1.2600
     */
    static CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTemplateFile := hTemplateFile is Win32Handle ? NumGet(hTemplateFile, "ptr") : hTemplateFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Defines, redefines, or deletes MS-DOS device names.
     * @param {Integer} dwFlags The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
     * @param {PWSTR} lpDeviceName A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or 
     *       deleting. The device name string must not have a colon as the last character, unless a drive letter is being 
     *       defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a 
     *       trailing backslash ("\") allowed.
     * @param {PWSTR} lpTargetPath A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the 
     *       <b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path 
     *       string.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-definedosdevicew
     * @since windows5.1.2600
     */
    static DefineDosDeviceW(dwFlags, lpDeviceName, lpTargetPath) {
        lpDeviceName := lpDeviceName is String ? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String ? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DefineDosDeviceW", "uint", dwFlags, "ptr", lpDeviceName, "ptr", lpTargetPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file.
     * @param {PSTR} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-deletefilea
     * @since windows5.1.2600
     */
    static DeleteFileA(lpFileName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileA", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file.
     * @param {PWSTR} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-deletefilew
     * @since windows5.1.2600
     */
    static DeleteFileW(lpFileName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileW", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes a drive letter or mounted folder.
     * @param {PWSTR} lpszVolumeMountPoint The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, 
     *       "X:\" or "Y:\MountX\".
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-deletevolumemountpointw
     * @since windows5.1.2600
     */
    static DeleteVolumeMountPointW(lpszVolumeMountPoint) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteVolumeMountPointW", "ptr", lpszVolumeMountPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a file time to a local file time.
     * @param {Pointer<FILETIME>} lpFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the UTC-based file time to be converted into a local file time.
     * @param {Pointer<FILETIME>} lpLocalFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the converted local file time. This parameter cannot be the same as the <i>lpFileTime</i> parameter.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-filetimetolocalfiletime
     * @since windows5.1.2600
     */
    static FileTimeToLocalFileTime(lpFileTime, lpLocalFileTime) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FileTimeToLocalFileTime", "ptr", lpFileTime, "ptr", lpLocalFileTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW, FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
     * @param {HANDLE} hFindFile The file search handle.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findclose
     * @since windows5.1.2600
     */
    static FindClose(hFindFile) {
        hFindFile := hFindFile is Win32Handle ? NumGet(hFindFile, "ptr") : hFindFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindClose", "ptr", hFindFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Stops change notification handle monitoring.
     * @param {HANDLE} hChangeHandle A handle to a change notification handle created by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findclosechangenotification
     * @since windows5.1.2600
     */
    static FindCloseChangeNotification(hChangeHandle) {
        hChangeHandle := hChangeHandle is Win32Handle ? NumGet(hChangeHandle, "ptr") : hChangeHandle

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindCloseChangeNotification", "ptr", hChangeHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a change notification handle and sets up initial change notification filter conditions.
     * @param {PSTR} lpPathName The full path of the directory to be watched. 
     * 
     * 
     * This cannot be a relative path or an empty string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {BOOL} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.
     * @param {Integer} dwNotifyFilter 
     * @returns {HANDLE} If the function succeeds, the return value is a handle to a find change notification object.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstchangenotificationa
     * @since windows5.1.2600
     */
    static FindFirstChangeNotificationA(lpPathName, bWatchSubtree, dwNotifyFilter) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstChangeNotificationA", "ptr", lpPathName, "int", bWatchSubtree, "uint", dwNotifyFilter, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Creates a change notification handle and sets up initial change notification filter conditions.
     * @param {PWSTR} lpPathName The full path of the directory to be watched. 
     * 
     * 
     * This cannot be a relative path or an empty string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {BOOL} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.
     * @param {Integer} dwNotifyFilter 
     * @returns {HANDLE} If the function succeeds, the return value is a handle to a find change notification object.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstchangenotificationw
     * @since windows5.1.2600
     */
    static FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstChangeNotificationW", "ptr", lpPathName, "int", bWatchSubtree, "uint", dwNotifyFilter, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).
     * @param {PSTR} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to 
     *        the root and all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<WIN32_FIND_DATAA>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *       receives information about a found file or directory.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no matching files can be found, the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilea
     * @since windows5.1.2600
     */
    static FindFirstFileA(lpFileName, lpFindFileData) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileA", "ptr", lpFileName, "ptr", lpFindFileData, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).
     * @param {PWSTR} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to 
     *        the root and all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<WIN32_FIND_DATAW>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *       receives information about a found file or directory.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilew">FindNextFile</a> or 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no matching files can be found, the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilew
     * @since windows5.1.2600
     */
    static FindFirstFileW(lpFileName, lpFindFileData) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileW", "ptr", lpFileName, "ptr", lpFindFileData, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Searches a directory for a file or subdirectory with a name and attributes that match those specified.
     * @param {PSTR} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all 
     *        subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and 
     *        prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the buffer that receives the file data.
     *       
     * 
     * The pointer type is determined by the level of information that is specified in the 
     *        <i>fInfoLevelId</i> parameter.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_LARGE_FETCH"></a><a id="find_first_ex_large_fetch"></a><dl>
     * <dt><b>FIND_FIRST_EX_LARGE_FETCH</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses a larger buffer for directory queries, which can increase performance of the find operation.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY"></a><a id="find_first_ex_on_disk_entries_only"></a><dl>
     * <dt><b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexa
     * @since windows5.1.2600
     */
    static FindFirstFileExA(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileExA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Searches a directory for a file or subdirectory with a name and attributes that match those specified.
     * @param {PWSTR} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all 
     *        subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and 
     *        prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the buffer that receives the file data.
     *       
     * 
     * The pointer type is determined by the level of information that is specified in the 
     *        <i>fInfoLevelId</i> parameter.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_LARGE_FETCH"></a><a id="find_first_ex_large_fetch"></a><dl>
     * <dt><b>FIND_FIRST_EX_LARGE_FETCH</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses a larger buffer for directory queries, which can increase performance of the find operation.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY"></a><a id="find_first_ex_on_disk_entries_only"></a><dl>
     * <dt><b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfileexw
     * @since windows5.1.2600
     */
    static FindFirstFileExW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileExW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Retrieves the name of a volume on a computer.
     * @param {PWSTR} lpszVolumeName A pointer to a buffer that receives a null-terminated string that specifies a volume 
     *       <b>GUID</b> path for the first volume that is found.
     * @param {Integer} cchBufferLength The length of the buffer to receive the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> and 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> functions.
     * 
     * If the function fails to find any volumes, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstvolumew
     * @since windows5.1.2600
     */
    static FindFirstVolumeW(lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeW", "ptr", lpszVolumeName, "uint", cchBufferLength, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Requests that the operating system signal a change notification handle the next time it detects an appropriate change.
     * @param {HANDLE} hChangeHandle A handle to a change notification handle created by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextchangenotification
     * @since windows5.1.2600
     */
    static FindNextChangeNotification(hChangeHandle) {
        hChangeHandle := hChangeHandle is Win32Handle ? NumGet(hChangeHandle, "ptr") : hChangeHandle

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextChangeNotification", "ptr", hChangeHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted functions.
     * @param {HANDLE} hFindFile The search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a> function.
     * @param {Pointer<WIN32_FIND_DATAA>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure 
     *       that receives information about the found file or subdirectory.
     * @returns {BOOL} If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i> 
     *        parameter contains information about the next file or directory found.
     * 
     * If the function fails, the return value is zero and the contents of <i>lpFindFileData</i> 
     *        are indeterminate. To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no more matching files can be found, the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_NO_MORE_FILES</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilea
     * @since windows5.1.2600
     */
    static FindNextFileA(hFindFile, lpFindFileData) {
        hFindFile := hFindFile is Win32Handle ? NumGet(hFindFile, "ptr") : hFindFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextFileA", "ptr", hFindFile, "ptr", lpFindFileData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted functions.
     * @param {HANDLE} hFindFile The search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a> function.
     * @param {Pointer<WIN32_FIND_DATAW>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure 
     *       that receives information about the found file or subdirectory.
     * @returns {BOOL} If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i> 
     *        parameter contains information about the next file or directory found.
     * 
     * If the function fails, the return value is zero and the contents of <i>lpFindFileData</i> 
     *        are indeterminate. To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no more matching files can be found, the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_NO_MORE_FILES</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilew
     * @since windows5.1.2600
     */
    static FindNextFileW(hFindFile, lpFindFileData) {
        hFindFile := hFindFile is Win32Handle ? NumGet(hFindFile, "ptr") : hFindFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextFileW", "ptr", hFindFile, "ptr", lpFindFileData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a volume search started by a call to the FindFirstVolume function.
     * @param {HANDLE} hFindVolume The volume search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.
     * @param {PWSTR} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no matching files can be found, the 
     *        <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextvolumew
     * @since windows5.1.2600
     */
    static FindNextVolumeW(hFindVolume, lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName
        hFindVolume := hFindVolume is Win32Handle ? NumGet(hFindVolume, "ptr") : hFindVolume

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeW", "ptr", hFindVolume, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes the specified volume search handle.
     * @param {HANDLE} hFindVolume The volume search handle to be closed. This handle must have been previously opened by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findvolumeclose
     * @since windows5.1.2600
     */
    static FindVolumeClose(hFindVolume) {
        hFindVolume := hFindVolume is Win32Handle ? NumGet(hFindVolume, "ptr") : hFindVolume

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindVolumeClose", "ptr", hFindVolume, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Flushes the buffers of a specified file and causes all buffered data to be written to a file.
     * @param {HANDLE} hFile A handle to the open file. 
     * 
     * The file handle must have the <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * If <i>hFile</i> is a handle to a communications device, the function only flushes the transmit buffer.
     * 
     * If <i>hFile</i> is a handle to the server end of a named pipe, the function does not return until the client has read all buffered data from the pipe.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The function fails if <i>hFile</i> is a handle to the console output. That is because the console output is not buffered. The function returns <b>FALSE</b>, and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_HANDLE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-flushfilebuffers
     * @since windows5.1.2600
     */
    static FlushFileBuffers(hFile) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FlushFileBuffers", "ptr", hFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified disk, including the amount of free space on the disk.
     * @param {PSTR} lpRootPathName The root directory of the disk for which information is to be returned. If this parameter is 
     *       <b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, 
     *       it must include a trailing backslash (for example, "\\\\MyServer\\MyShare\\"). Furthermore, a drive 
     *       specification must have a trailing backslash (for example, "C:\\"). The calling application must 
     *       have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.
     * @param {Pointer<UInt32>} lpSectorsPerCluster A pointer to a variable that receives the number of sectors per cluster.
     * @param {Pointer<UInt32>} lpBytesPerSector A pointer to a variable that receives the number of bytes per sector.
     * @param {Pointer<UInt32>} lpNumberOfFreeClusters A pointer to a variable that receives the total number of free clusters on the disk that are available to the 
     *        user who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of free clusters on the 
     *        disk.
     * @param {Pointer<UInt32>} lpTotalNumberOfClusters A pointer to a variable that receives the total number of clusters on the disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespacea
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceA(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceA", "ptr", lpRootPathName, "uint*", lpSectorsPerCluster, "uint*", lpBytesPerSector, "uint*", lpNumberOfFreeClusters, "uint*", lpTotalNumberOfClusters, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified disk, including the amount of free space on the disk.
     * @param {PWSTR} lpRootPathName The root directory of the disk for which information is to be returned. If this parameter is 
     *       <b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, 
     *       it must include a trailing backslash (for example, "\\\\MyServer\\MyShare\\"). Furthermore, a drive 
     *       specification must have a trailing backslash (for example, "C:\\"). The calling application must 
     *       have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.
     * @param {Pointer<UInt32>} lpSectorsPerCluster A pointer to a variable that receives the number of sectors per cluster.
     * @param {Pointer<UInt32>} lpBytesPerSector A pointer to a variable that receives the number of bytes per sector.
     * @param {Pointer<UInt32>} lpNumberOfFreeClusters A pointer to a variable that receives the total number of free clusters on the disk that are available to the 
     *        user who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of free clusters on the 
     *        disk.
     * @param {Pointer<UInt32>} lpTotalNumberOfClusters A pointer to a variable that receives the total number of clusters on the disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespacew
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceW(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceW", "ptr", lpRootPathName, "uint*", lpSectorsPerCluster, "uint*", lpBytesPerSector, "uint*", lpNumberOfFreeClusters, "uint*", lpTotalNumberOfClusters, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.
     * @param {PSTR} lpDirectoryName A directory on the disk.
     * 
     * If this parameter is <b>NULL</b>, the function uses the root of the current disk.
     * 
     * If this parameter is a UNC name, it must include a trailing backslash, for example, 
     *        "\\\\MyServer\\MyShare\\".
     * 
     * This parameter does not have to specify the root directory on a disk. The function accepts any directory on a 
     *        disk.
     * 
     * The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this  
     *        directory.
     * @param {Pointer<UInt64>} lpFreeBytesAvailableToCaller A pointer to a variable that receives the total number of free bytes on a disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.
     * @param {Pointer<UInt64>} lpTotalNumberOfBytes A pointer to a variable that receives the total number of bytes on a disk that are available to the user who 
     *        is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of bytes on a disk.
     * 
     * To determine the total number of bytes on a disk or volume, use 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.
     * @param {Pointer<UInt64>} lpTotalNumberOfFreeBytes A pointer to a variable that receives the total number of free bytes on a disk.
     * 
     * This parameter can be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespaceexa
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceExA(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes) {
        lpDirectoryName := lpDirectoryName is String ? StrPtr(lpDirectoryName) : lpDirectoryName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceExA", "ptr", lpDirectoryName, "uint*", lpFreeBytesAvailableToCaller, "uint*", lpTotalNumberOfBytes, "uint*", lpTotalNumberOfFreeBytes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread.
     * @param {PWSTR} lpDirectoryName A directory on the disk.
     * 
     * If this parameter is <b>NULL</b>, the function uses the root of the current disk.
     * 
     * If this parameter is a UNC name, it must include a trailing backslash, for example, 
     *        "\\\\MyServer\\MyShare\\".
     * 
     * This parameter does not have to specify the root directory on a disk. The function accepts any directory on a 
     *        disk.
     * 
     * The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this  
     *        directory.
     * @param {Pointer<UInt64>} lpFreeBytesAvailableToCaller A pointer to a variable that receives the total number of free bytes on a disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.
     * @param {Pointer<UInt64>} lpTotalNumberOfBytes A pointer to a variable that receives the total number of bytes on a disk that are available to the user who 
     *        is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of bytes on a disk.
     * 
     * To determine the total number of bytes on a disk or volume, use 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.
     * @param {Pointer<UInt64>} lpTotalNumberOfFreeBytes A pointer to a variable that receives the total number of free bytes on a disk.
     * 
     * This parameter can be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdiskfreespaceexw
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceExW(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes) {
        lpDirectoryName := lpDirectoryName is String ? StrPtr(lpDirectoryName) : lpDirectoryName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceExW", "ptr", lpDirectoryName, "uint*", lpFreeBytesAvailableToCaller, "uint*", lpTotalNumberOfBytes, "uint*", lpTotalNumberOfFreeBytes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {PSTR} rootPath 
     * @param {Pointer<DISK_SPACE_INFORMATION>} diskSpaceInfo 
     * @returns {HRESULT} 
     */
    static GetDiskSpaceInformationA(rootPath, diskSpaceInfo) {
        rootPath := rootPath is String ? StrPtr(rootPath) : rootPath

        result := DllCall("KERNEL32.dll\GetDiskSpaceInformationA", "ptr", rootPath, "ptr", diskSpaceInfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {PWSTR} rootPath 
     * @param {Pointer<DISK_SPACE_INFORMATION>} diskSpaceInfo 
     * @returns {HRESULT} 
     */
    static GetDiskSpaceInformationW(rootPath, diskSpaceInfo) {
        rootPath := rootPath is String ? StrPtr(rootPath) : rootPath

        result := DllCall("KERNEL32.dll\GetDiskSpaceInformationW", "ptr", rootPath, "ptr", diskSpaceInfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.
     * @param {PSTR} lpRootPathName The root directory for the drive.
     *       
     * 
     * A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the 
     *        root of the current directory.
     * @returns {Integer} The return value specifies the type of drive, which can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid; for example, there is no volume mounted at the specified path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has fixed media; for example, a hard disk drive or flash drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdrivetypea
     * @since windows5.1.2600
     */
    static GetDriveTypeA(lpRootPathName) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName

        result := DllCall("KERNEL32.dll\GetDriveTypeA", "ptr", lpRootPathName, "uint")
        return result
    }

    /**
     * Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.
     * @param {PWSTR} lpRootPathName The root directory for the drive.
     *       
     * 
     * A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the 
     *        root of the current directory.
     * @returns {Integer} The return value specifies the type of drive, which can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid; for example, there is no volume mounted at the specified path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has fixed media; for example, a hard disk drive or flash drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getdrivetypew
     * @since windows5.1.2600
     */
    static GetDriveTypeW(lpRootPathName) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName

        result := DllCall("KERNEL32.dll\GetDriveTypeW", "ptr", lpRootPathName, "uint")
        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory.
     * @param {PSTR} lpFileName The name of the file or directory. 
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value contains the attributes of the specified file or directory. For a 
     *        list of attribute values and their descriptions, see 
     *        <a href="/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesa
     * @since windows5.1.2600
     */
    static GetFileAttributesA(lpFileName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesA", "ptr", lpFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory.
     * @param {PWSTR} lpFileName The name of the file or directory. 
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value contains the attributes of the specified file or directory. For a 
     *        list of attribute values and their descriptions, see 
     *        <a href="/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesw
     * @since windows5.1.2600
     */
    static GetFileAttributesW(lpFileName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesW", "ptr", lpFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves attributes for a specified file or directory.
     * @param {PSTR} lpFileName The name of the file or directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId A class of attribute information to retrieve.
     * 
     * This parameter can be the following value from the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesexa
     * @since windows5.1.2600
     */
    static GetFileAttributesExA(lpFileName, fInfoLevelId, lpFileInformation) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesExA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves attributes for a specified file or directory.
     * @param {PWSTR} lpFileName The name of the file or directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId A class of attribute information to retrieve.
     * 
     * This parameter can be the following value from the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>.
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileattributesexw
     * @since windows5.1.2600
     */
    static GetFileAttributesExW(lpFileName, fInfoLevelId, lpFileInformation) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesExW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file information for the specified file.
     * @param {HANDLE} hFile A handle to the file that contains the information to be retrieved.
     * 
     * This handle should not be a pipe handle.
     * @param {Pointer<BY_HANDLE_FILE_INFORMATION>} lpFileInformation A pointer to a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-by_handle_file_information">BY_HANDLE_FILE_INFORMATION</a> structure that 
     *       receives the file information.
     * @returns {BOOL} If the function succeeds, the return value is nonzero and file information data is contained in the buffer 
     *        pointed to by the <i>lpFileInformation</i> parameter.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfileinformationbyhandle
     * @since windows5.1.2600
     */
    static GetFileInformationByHandle(hFile, lpFileInformation) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileInformationByHandle", "ptr", hFile, "ptr", lpFileInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the size of the specified file, in bytes.
     * @param {HANDLE} hFile A handle to the file.
     * @param {Pointer<UInt32>} lpFileSizeHigh A pointer to the variable where the high-order doubleword of the file size is returned. This parameter can 
     *       be <b>NULL</b> if the application does not require the high-order doubleword.
     * @returns {Integer} If the function succeeds, the return value is the low-order doubleword of the file size, and, if 
     *        <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the 
     *        high-order doubleword of the file size into the variable pointed to by that parameter.
     * 
     * If the function fails and <i>lpFileSizeHigh</i> is <b>NULL</b>, the 
     *        return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. When 
     *        <i>lpFileSizeHigh</i> is <b>NULL</b>, the results returned for large 
     *        files are ambiguous, and you will not be able to determine the actual size of the file. It is recommended that 
     *        you use <a href="/windows/desktop/api/fileapi/nf-fileapi-getfilesizeex">GetFileSizeEx</a> instead.
     * 
     * If the function fails and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the 
     *        return value is <b>INVALID_FILE_SIZE</b> and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return a value other than 
     *        <b>NO_ERROR</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfilesize
     * @since windows5.1.2600
     */
    static GetFileSize(hFile, lpFileSizeHigh) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileSize", "ptr", hFile, "uint*", lpFileSizeHigh, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the size of the specified file.
     * @param {HANDLE} hFile A handle to the file. The handle must have been created with the 
     *       <b>FILE_READ_ATTRIBUTES</b> access right or equivalent, or the caller must have sufficient permission on the directory that contains the file. 
     *       For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<Int64>} lpFileSize A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure that 
     *       receives the file size, in bytes.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfilesizeex
     * @since windows5.1.2600
     */
    static GetFileSizeEx(hFile, lpFileSize) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileSizeEx", "ptr", hFile, "int64*", lpFileSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the file type of the specified file.
     * @param {HANDLE} hFile A handle to the file.
     * @returns {Integer} The function returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_CHAR</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file is a character file, typically an LPT device or a console.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_DISK</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file is a disk file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_PIPE</b></dt>
     * <dt>0x0003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file is a socket, a named pipe, or an anonymous pipe.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_REMOTE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unused.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_UNKNOWN</b></dt>
     * <dt>0x0000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the type of the specified file is unknown, or the function failed.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * You can distinguish between a "valid" return of <b>FILE_TYPE_UNKNOWN</b> and its return due to a calling error (for example, passing an invalid handle to 
     * <b>GetFileType</b>) by calling 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the function worked properly and <b>FILE_TYPE_UNKNOWN</b> was returned, a call to <b>GetLastError</b> will return <b>NO_ERROR</b>.
     * 
     * If the function returned <b>FILE_TYPE_UNKNOWN</b> due to an error in calling 
     * <b>GetFileType</b>, 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return the error code.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletype
     * @since windows5.1.2600
     */
    static GetFileType(hFile) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileType", "ptr", hFile, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the final path for the specified file.
     * @param {HANDLE} hFile A handle to a file or directory.
     * @param {PSTR} lpszFilePath A pointer to a buffer that receives the path of <i>hFile</i>.
     * @param {Integer} cchFilePath The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is the length of the string received by 
     *        <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the 
     *        size of the terminating null character.
     * 
     * <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function, 
     *         <b>GetFinalPathNameByHandleA</b>, the return value 
     *         includes the size of the terminating null character.
     * 
     * If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the 
     *        terminating null character, the return value is the required buffer size, in 
     *        <b>TCHAR</b>s. This value includes the size of the terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle 
     *          was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive 
     *          letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to 
     *          identify it.
     * 
     * This return value can also be returned if you are searching for a volume <b>GUID</b> 
     *          path on a network share. Volume <b>GUID</b> paths are not created for network 
     *          shares.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid flags were specified for <i>dwFlags</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfinalpathnamebyhandlea
     * @since windows6.0.6000
     */
    static GetFinalPathNameByHandleA(hFile, lpszFilePath, cchFilePath, dwFlags) {
        lpszFilePath := lpszFilePath is String ? StrPtr(lpszFilePath) : lpszFilePath
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFinalPathNameByHandleA", "ptr", hFile, "ptr", lpszFilePath, "uint", cchFilePath, "uint", dwFlags, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the final path for the specified file.
     * @param {HANDLE} hFile A handle to a file or directory.
     * @param {PWSTR} lpszFilePath A pointer to a buffer that receives the path of <i>hFile</i>.
     * @param {Integer} cchFilePath The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is the length of the string received by 
     *        <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the 
     *        size of the terminating null character.
     * 
     * <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function, 
     *         <b>GetFinalPathNameByHandleA</b>, the return value 
     *         includes the size of the terminating null character.
     * 
     * If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the 
     *        terminating null character, the return value is the required buffer size, in 
     *        <b>TCHAR</b>s. This value includes the size of the terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle 
     *          was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive 
     *          letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to 
     *          identify it.
     * 
     * This return value can also be returned if you are searching for a volume <b>GUID</b> 
     *          path on a network share. Volume <b>GUID</b> paths are not created for network 
     *          shares.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid flags were specified for <i>dwFlags</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfinalpathnamebyhandlew
     * @since windows6.0.6000
     */
    static GetFinalPathNameByHandleW(hFile, lpszFilePath, cchFilePath, dwFlags) {
        lpszFilePath := lpszFilePath is String ? StrPtr(lpszFilePath) : lpszFilePath
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFinalPathNameByHandleW", "ptr", hFile, "ptr", lpszFilePath, "uint", cchFilePath, "uint", dwFlags, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the date and time that a file or directory was created, last accessed, and last modified.
     * @param {HANDLE} hFile A handle to the file or directory for which dates and times are to be retrieved. The handle must have been 
     *       created using the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the 
     *       <b>GENERIC_READ</b> access right. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<FILETIME>} lpCreationTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the 
     *       date and time the file or directory was created. This parameter can be <b>NULL</b> if the 
     *       application does not require this information.
     * @param {Pointer<FILETIME>} lpLastAccessTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to 
     *       receive the date and time the file or directory was last accessed. The last access time includes the last time 
     *       the file or directory was written to, read from, or, in the case of executable files, run. This parameter can be 
     *       <b>NULL</b> if the application does not require this information.
     * @param {Pointer<FILETIME>} lpLastWriteTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to 
     *       receive the date and time the file or directory was last written to, truncated, or overwritten (for example, 
     *       with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a>). This date and time is not updated when 
     *       file attributes or security descriptors are changed. This parameter can be <b>NULL</b> if the 
     *       application does not require this information.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfiletime
     * @since windows5.1.2600
     */
    static GetFileTime(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileTime", "ptr", hFile, "ptr", lpCreationTime, "ptr", lpLastAccessTime, "ptr", lpLastWriteTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file.
     * @param {PWSTR} lpFileName The name of the  file.
     * 
     * This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume 
     *        name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string for the drive and path, in 
     *       <b>TCHARs</b>.
     * @param {PWSTR} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<PWSTR>} lpFilePart A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final 
     *       file name component in the path. 
     * 
     * This parameter can be  <b>NULL</b>.
     * 
     * If <i>lpBuffer</i> 
     *       refers to a directory and not a file, <i>lpFilePart</i> receives zero.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfullpathnamew
     * @since windows5.1.2600
     */
    static GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameW", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file.
     * @param {PSTR} lpFileName The name of the  file.
     * 
     * This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume 
     *        name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFullPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string for the drive and path, in 
     *       <b>TCHARs</b>.
     * @param {PSTR} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<PSTR>} lpFilePart A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final 
     *       file name component in the path. 
     * 
     * This parameter can be  <b>NULL</b>.
     * 
     * If <i>lpBuffer</i> 
     *       refers to a directory and not a file, <i>lpFilePart</i> receives zero.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getfullpathnamea
     * @since windows5.1.2600
     */
    static GetFullPathNameA(lpFileName, nBufferLength, lpBuffer, lpFilePart) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameA", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a bitmask representing the currently available disk drives.
     * @returns {Integer} If the function succeeds, the return value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlogicaldrives
     * @since windows5.1.2600
     */
    static GetLogicalDrives() {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLogicalDrives", "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Fills a buffer with strings that specify valid drives in the system.
     * @param {Integer} nBufferLength The maximum size of the buffer pointed to by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>. This size does not include the terminating null character. If this 
     *       parameter is zero, <i>lpBuffer</i> is not used.
     * @param {PWSTR} lpBuffer A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the 
     *       system, plus with an additional null character. Each string is a device name.
     * @returns {Integer} If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, 
     *        not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a 
     *        Unicode (UTF-16) null character uses two bytes.
     * 
     * If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. 
     *        It is the size of the buffer required to hold the drive strings.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlogicaldrivestringsw
     * @since windows5.1.2600
     */
    static GetLogicalDriveStringsW(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLogicalDriveStringsW", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form.
     * @param {PSTR} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, 
     *        <b>GetLongPathNameA</b>, the name is limited to 
     *        <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the 
     *        Unicode version of the function, <b>GetLongPathNameW</b>, 
     *        and prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PSTR} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not 
     *        exist, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlongpathnamea
     * @since windows5.1.2600
     */
    static GetLongPathNameA(lpszShortPath, lpszLongPath, cchBuffer) {
        lpszShortPath := lpszShortPath is String ? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String ? StrPtr(lpszLongPath) : lpszLongPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameA", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form.
     * @param {PWSTR} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, 
     *        <b>GetLongPathNameA</b>, the name is limited to 
     *        <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the 
     *        Unicode version of the function, <b>GetLongPathNameW</b>, 
     *        and prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PWSTR} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not 
     *        exist, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getlongpathnamew
     * @since windows5.1.2600
     */
    static GetLongPathNameW(lpszShortPath, lpszLongPath, cchBuffer) {
        lpszShortPath := lpszShortPath is String ? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String ? StrPtr(lpszLongPath) : lpszLongPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameW", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HANDLE} Handle 
     * @param {Pointer<BOOL>} Enabled 
     * @returns {BOOL} 
     */
    static AreShortNamesEnabled(Handle, Enabled) {
        Handle := Handle is Win32Handle ? NumGet(Handle, "ptr") : Handle

        result := DllCall("KERNEL32.dll\AreShortNamesEnabled", "ptr", Handle, "ptr", Enabled, "int")
        return result
    }

    /**
     * Retrieves the short path form of the specified path.
     * @param {PWSTR} lpszLongPath The path string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * @param {PWSTR} lpszShortPath A pointer to a buffer to receive the null-terminated short form of the path that 
     *        <i>lpszLongPath</i> specifies.
     * 
     * Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i> 
     *        will always return the required buffer size for a specified <i>lpszLongPath</i>.
     * @param {Integer} cchBuffer The size of the buffer  that <i>lpszShortPath</i> points to, in 
     *        <b>TCHARs</b>.
     * 
     * Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to <i>lpszShortPath</i>, not including the terminating null 
     *        character.
     * 
     * If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is 
     *        the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getshortpathnamew
     * @since windows5.1.2600
     */
    static GetShortPathNameW(lpszLongPath, lpszShortPath, cchBuffer) {
        lpszLongPath := lpszLongPath is String ? StrPtr(lpszLongPath) : lpszLongPath
        lpszShortPath := lpszShortPath is String ? StrPtr(lpszShortPath) : lpszShortPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetShortPathNameW", "ptr", lpszLongPath, "ptr", lpszShortPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.
     * @param {PWSTR} lpPathName The directory path for the file name. Applications typically specify a period (.) for the current directory 
     *        or the result of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-gettemppatha">GetTempPath</a> function. The string 
     *        cannot be longer than <b>MAX_PATH</b>–14 characters or
     *        <b>GetTempFileName</b> will fail. If this parameter is 
     *        <b>NULL</b>, the function fails.
     * @param {PWSTR} lpPrefixString The null-terminated prefix string. The function uses up to the first three characters of this string as the 
     *        prefix of the file name. This string must consist of characters in the OEM-defined character set.
     * @param {Integer} uUnique An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.
     * 
     * If <i>uUnique</i> is zero, the function attempts to form a unique file name using the 
     *        current system time. If the file already exists, the number is increased by one and the functions tests if this 
     *        file already exists. This continues until a unique filename is found; the function creates a file by that name 
     *        and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when 
     *        <i>uUnique</i> is nonzero.
     * @param {PWSTR} lpTempFileName A pointer to the buffer that receives the temporary file name. This buffer should be 
     *        <b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.
     * @returns {Integer} If the function succeeds, the return value specifies the unique numeric value used in the temporary file 
     *        name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same 
     *        number.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * The following is a possible return value.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUFFER_OVERFLOW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The length of the string pointed to by the <i>lpPathName</i> parameter is more than 
     *          <b>MAX_PATH</b>–14 characters.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettempfilenamew
     * @since windows5.1.2600
     */
    static GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName
        lpPrefixString := lpPrefixString is String ? StrPtr(lpPrefixString) : lpPrefixString
        lpTempFileName := lpTempFileName is String ? StrPtr(lpTempFileName) : lpTempFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempFileNameW", "ptr", lpPathName, "ptr", lpPrefixString, "uint", uUnique, "ptr", lpTempFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the file system and volume associated with the specified file.
     * @param {HANDLE} hFile A handle to the file.
     * @param {PWSTR} lpVolumeNameBuffer A pointer to a buffer that receives the name of a specified volume. The maximum buffer size is 
     *       <c>MAX_PATH+1</c>.
     * @param {Integer} nVolumeNameSize The length of a volume name buffer, in <b>WCHAR</b>s. The maximum buffer size is 
     *        <c>MAX_PATH+1</c>.
     * 
     * This parameter is ignored if the volume name buffer is not supplied.
     * @param {Pointer<UInt32>} lpVolumeSerialNumber A pointer to a variable that receives the volume serial number.
     * 
     * This parameter can be <b>NULL</b> if the serial number is not required.
     * 
     * This function returns the volume serial number that the operating system assigns when a hard disk is 
     *        formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the 
     *        Windows Management Instrumentation (WMI) 
     *        <a href="https://docs.microsoft.com/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> property 
     *        <b>SerialNumber</b>.
     * @param {Pointer<UInt32>} lpMaximumComponentLength A pointer to a variable that receives the maximum length, in <b>WCHAR</b>s, of a file 
     *        name component  that a specified file system supports.
     * 
     * A file name component is the portion of a file name between backslashes.
     * 
     * The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to 
     *        is used to indicate that a specified file system supports long names. For example, for a FAT file system that 
     *        supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can 
     *        also be supported on systems that use the NTFS file system.
     * @param {Pointer<UInt32>} lpFileSystemFlags A pointer to a variable that receives flags associated with the specified file system.
     * 
     * This parameter can be one or more of the following flags. However, 
     *        <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually 
     *        exclusive.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a><dl>
     * <dt><b>FILE_CASE_PRESERVED_NAMES</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports preserved case of file names when it places a name on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a><dl>
     * <dt><b>FILE_CASE_SENSITIVE_SEARCH</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports case-sensitive file names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a><dl>
     * <dt><b>FILE_FILE_COMPRESSION</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports file-based compression.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a><dl>
     * <dt><b>FILE_NAMED_STREAMS</b></dt>
     * <dt>0x00040000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports named streams.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a id="file_persistent_acls"></a><dl>
     * <dt><b>FILE_PERSISTENT_ACLS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system 
     *         preserves and enforces ACLs, and the FAT file system does not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a><dl>
     * <dt><b>FILE_READ_ONLY_VOLUME</b></dt>
     * <dt>0x00080000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a><dl>
     * <dt><b>FILE_SEQUENTIAL_WRITE_ONCE</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports a single sequential write.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a id="file_supports_encryption"></a><dl>
     * <dt><b>FILE_SUPPORTS_ENCRYPTION</b></dt>
     * <dt>0x00020000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports the Encrypted File System (EFS). For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a id="file_supports_extended_attributes"></a><dl>
     * <dt><b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports extended attributes. An extended attribute is a piece of 
     *         application-specific metadata that an application can associate with a file and is not part of the file's data.
     * 
     * <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a><dl>
     * <dt><b>FILE_SUPPORTS_HARD_LINKS</b></dt>
     * <dt>0x00400000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports hard links. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a><dl>
     * <dt><b>FILE_SUPPORTS_OBJECT_IDS</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports object identifiers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a id="file_supports_open_by_file_id"></a><dl>
     * <dt><b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system supports open by FileID. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.
     * 
     * <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a><dl>
     * <dt><b>FILE_SUPPORTS_REPARSE_POINTS</b></dt>
     * <dt>0x00000080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports re-parse points.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a><dl>
     * <dt><b>FILE_SUPPORTS_SPARSE_FILES</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sparse files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a id="file_supports_transactions"></a><dl>
     * <dt><b>FILE_SUPPORTS_TRANSACTIONS</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports transactions. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/Ktm/about-ktm">About KTM</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a><dl>
     * <dt><b>FILE_SUPPORTS_USN_JOURNAL</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports update sequence number (USN) journals. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.
     * 
     * <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a id="file_unicode_on_disk"></a><dl>
     * <dt><b>FILE_UNICODE_ON_DISK</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports Unicode in file names as they appear on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a><dl>
     * <dt><b>FILE_VOLUME_IS_COMPRESSED</b></dt>
     * <dt>0x00008000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is a compressed volume.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a><dl>
     * <dt><b>FILE_VOLUME_QUOTAS</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports disk quotas.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a><dl>
     * <dt><b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpFileSystemNameBuffer A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the 
     *       NTFS file system. The buffer size is specified by the <i>nFileSystemNameSize</i> 
     *       parameter.
     * @param {Integer} nFileSystemNameSize The length of the file system name buffer, in <b>WCHAR</b>s. The maximum buffer size 
     *        is <c>MAX_PATH+1</c>.
     * 
     * This parameter is ignored if the file system name buffer is not supplied.
     * @returns {BOOL} If all the requested information is retrieved, the return value is nonzero.
     * 
     * If not all the requested information is retrieved, the return value is zero. To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationbyhandlew
     * @since windows6.0.6000
     */
    static GetVolumeInformationByHandleW(hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize) {
        lpVolumeNameBuffer := lpVolumeNameBuffer is String ? StrPtr(lpVolumeNameBuffer) : lpVolumeNameBuffer
        lpFileSystemNameBuffer := lpFileSystemNameBuffer is String ? StrPtr(lpFileSystemNameBuffer) : lpFileSystemNameBuffer
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeInformationByHandleW", "ptr", hFile, "ptr", lpVolumeNameBuffer, "uint", nVolumeNameSize, "uint*", lpVolumeSerialNumber, "uint*", lpMaximumComponentLength, "uint*", lpFileSystemFlags, "ptr", lpFileSystemNameBuffer, "uint", nFileSystemNameSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the file system and volume associated with the specified root directory.
     * @param {PWSTR} lpRootPathName A pointer to a string that contains the root directory of the volume to be described.
     * 
     * If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing 
     *        backslash is required. For example, you  specify \\MyServer\MyShare as 
     *        "\\MyServer\MyShare\", or the C drive as 
     *        "C:\".
     * @param {PWSTR} lpVolumeNameBuffer A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the 
     *        <i>nVolumeNameSize</i> parameter.
     * @param {Integer} nVolumeNameSize The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is 
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the volume name buffer is not supplied.
     * @param {Pointer<UInt32>} lpVolumeSerialNumber A pointer to a variable that receives the volume serial number.
     * 
     * This parameter can be <b>NULL</b> if the serial number is not required.
     * 
     * This function returns the volume serial number that the operating system assigns when a hard disk is 
     *        formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the 
     *        Windows Management Instrumentation (WMI) 
     *        <a href="https://docs.microsoft.com/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property 
     *        <b>SerialNumber</b>.
     * @param {Pointer<UInt32>} lpMaximumComponentLength A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file 
     *        name component  that a specified file system supports.
     * 
     * A file name component is the portion of a file name between backslashes.
     * 
     * The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to 
     *        is used to indicate that a specified file system supports long names. For example, for a FAT file system that 
     *        supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can 
     *        also be supported on systems that use the NTFS file system.
     * @param {Pointer<UInt32>} lpFileSystemFlags A pointer to a variable that receives flags associated with the specified file system.
     * 
     * This parameter can be one or more of the following flags. However, 
     *        <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually 
     *        exclusive.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a><dl>
     * <dt><b>FILE_CASE_PRESERVED_NAMES</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports preserved case of file names when it places a name on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a><dl>
     * <dt><b>FILE_CASE_SENSITIVE_SEARCH</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports case-sensitive file names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_DAX_VOLUME________"></a><a id="file_dax_volume________"></a><dl>
     * <dt><b>FILE_DAX_VOLUME        </b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is a direct access (DAX) volume.
     * 
     * <div class="alert"><b>Note</b>  This flag was introduced in Windows 10, version 1607.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a><dl>
     * <dt><b>FILE_FILE_COMPRESSION</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports file-based compression.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a><dl>
     * <dt><b>FILE_NAMED_STREAMS</b></dt>
     * <dt>0x00040000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports named streams.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a id="file_persistent_acls"></a><dl>
     * <dt><b>FILE_PERSISTENT_ACLS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system 
     *         preserves and enforces ACLs, and the FAT file system does not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a><dl>
     * <dt><b>FILE_READ_ONLY_VOLUME</b></dt>
     * <dt>0x00080000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a><dl>
     * <dt><b>FILE_SEQUENTIAL_WRITE_ONCE</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports a single sequential write.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a id="file_supports_encryption"></a><dl>
     * <dt><b>FILE_SUPPORTS_ENCRYPTION</b></dt>
     * <dt>0x00020000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports the Encrypted File System (EFS). For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a id="file_supports_extended_attributes"></a><dl>
     * <dt><b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports extended attributes. An extended attribute is a piece of 
     *         application-specific metadata that an application can associate with a file and is not part of the file's data.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a><dl>
     * <dt><b>FILE_SUPPORTS_HARD_LINKS</b></dt>
     * <dt>0x00400000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports hard links. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a><dl>
     * <dt><b>FILE_SUPPORTS_OBJECT_IDS</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports object identifiers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a id="file_supports_open_by_file_id"></a><dl>
     * <dt><b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system supports open by FileID. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a><dl>
     * <dt><b>FILE_SUPPORTS_REPARSE_POINTS</b></dt>
     * <dt>0x00000080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports reparse points.
     * 
     * <b>ReFS:  </b>ReFS supports reparse points but does not index them so 
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> and 
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> will not 
     *           function as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a><dl>
     * <dt><b>FILE_SUPPORTS_SPARSE_FILES</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sparse files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a id="file_supports_transactions"></a><dl>
     * <dt><b>FILE_SUPPORTS_TRANSACTIONS</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports transactions. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/Ktm/about-ktm">About KTM</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a><dl>
     * <dt><b>FILE_SUPPORTS_USN_JOURNAL</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports update sequence number (USN) journals. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a id="file_unicode_on_disk"></a><dl>
     * <dt><b>FILE_UNICODE_ON_DISK</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports Unicode in file names as they appear on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a><dl>
     * <dt><b>FILE_VOLUME_IS_COMPRESSED</b></dt>
     * <dt>0x00008000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is a compressed volume, for example, a DoubleSpace volume.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a><dl>
     * <dt><b>FILE_VOLUME_QUOTAS</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports disk quotas.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a><dl>
     * <dt><b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpFileSystemNameBuffer A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS 
     *        file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.
     * @param {Integer} nFileSystemNameSize The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is 
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the file system name buffer is not supplied.
     * @returns {BOOL} If all the requested information is retrieved, the return value is nonzero.
     * 
     * If not all the requested information is retrieved, the return value is zero. To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationw
     * @since windows5.1.2600
     */
    static GetVolumeInformationW(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeNameBuffer := lpVolumeNameBuffer is String ? StrPtr(lpVolumeNameBuffer) : lpVolumeNameBuffer
        lpFileSystemNameBuffer := lpFileSystemNameBuffer is String ? StrPtr(lpFileSystemNameBuffer) : lpFileSystemNameBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeInformationW", "ptr", lpRootPathName, "ptr", lpVolumeNameBuffer, "uint", nVolumeNameSize, "uint*", lpVolumeSerialNumber, "uint*", lpMaximumComponentLength, "uint*", lpFileSystemFlags, "ptr", lpFileSystemNameBuffer, "uint", nFileSystemNameSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the volume mount point where the specified path is mounted.
     * @param {PWSTR} lpszFileName A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.
     * 
     * If you specify a relative directory or file name without a volume qualifier, **GetVolumePathName** returns the drive letter of the boot volume.
     * 
     * If this parameter is an empty string, "", the function fails but the last error is set to **ERROR_SUCCESS**.
     * @param {PWSTR} lpszVolumePathName A pointer to a string that receives the volume mount point for the input path.
     * @param {Integer} cchBufferLength The length of the output buffer, in **TCHARs**.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamew
     * @since windows5.1.2600
     */
    static GetVolumePathNameW(lpszFileName, lpszVolumePathName, cchBufferLength) {
        lpszFileName := lpszFileName is String ? StrPtr(lpszFileName) : lpszFileName
        lpszVolumePathName := lpszVolumePathName is String ? StrPtr(lpszVolumePathName) : lpszVolumePathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNameW", "ptr", lpszFileName, "ptr", lpszVolumePathName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a local file time to a file time based on the Coordinated Universal Time (UTC).
     * @param {Pointer<FILETIME>} lpLocalFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the 
     *       local file time to be converted into a UTC-based file time.
     * @param {Pointer<FILETIME>} lpFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the 
     *       converted UTC-based file time. This parameter cannot be the same as the 
     *       <i>lpLocalFileTime</i> parameter.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-localfiletimetofiletime
     * @since windows5.1.2600
     */
    static LocalFileTimeToFileTime(lpLocalFileTime, lpFileTime) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\LocalFileTimeToFileTime", "ptr", lpLocalFileTime, "ptr", lpFileTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Locks the specified file for exclusive access by the calling process.
     * @param {HANDLE} hFile A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} dwFileOffsetLow The low-order 32 bits of the starting byte offset in the file where the lock should begin.
     * @param {Integer} dwFileOffsetHigh The high-order 32 bits of the starting byte offset in the file where the lock should begin.
     * @param {Integer} nNumberOfBytesToLockLow The low-order 32 bits of the length of the byte range to be locked.
     * @param {Integer} nNumberOfBytesToLockHigh The high-order 32 bits of the length of the byte range to be locked.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-lockfile
     * @since windows5.1.2600
     */
    static LockFile(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LockFile", "ptr", hFile, "uint", dwFileOffsetLow, "uint", dwFileOffsetHigh, "uint", nNumberOfBytesToLockLow, "uint", nNumberOfBytesToLockHigh, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Locks the specified file for exclusive access by the calling process. This function can operate either synchronously or asynchronously and can request either an exclusive or a shared lock.
     * @param {HANDLE} hFile A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} dwFlags 
     * @param {Integer} nNumberOfBytesToLockLow The low-order 32 bits of the length of the byte range to lock.
     * @param {Integer} nNumberOfBytesToLockHigh The high-order 32 bits of the length of the byte range to lock.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that the function uses with the locking request. This structure, which is required, contains the file offset of the beginning of the lock range. You must initialize the <b>hEvent</b> member to a valid handle or zero.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-lockfileex
     * @since windows5.1.2600
     */
    static LockFileEx(hFile, dwFlags, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LockFileEx", "ptr", hFile, "uint", dwFlags, "uint", dwReserved, "uint", nNumberOfBytesToLockLow, "uint", nNumberOfBytesToLockHigh, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about MS-DOS device names.
     * @param {PWSTR} lpDeviceName An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing 
     *        backslash; for example, use "C:", not "C:\\".
     * 
     * This parameter can be <b>NULL</b>. In that case, the 
     *        <b>QueryDosDevice</b> function will store a list of all 
     *        existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.
     * @param {PWSTR} lpTargetPath A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or 
     *        more null-terminated strings. The final null-terminated string is followed by an additional 
     *        <b>NULL</b>.
     * 
     * If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves 
     *        information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first 
     *        null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated 
     *        strings represent undeleted prior mappings for the device.
     * 
     * If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of 
     *        all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing 
     *        MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.
     * @param {Integer} ucchMax The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by 
     *       <i>lpTargetPath</i>.
     * @returns {Integer} If the function succeeds, the return value is the number of <b>TCHARs</b> stored into 
     *        the buffer pointed to by <i>lpTargetPath</i>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the buffer is too small, the function fails and the last error code is 
     *        <b>ERROR_INSUFFICIENT_BUFFER</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-querydosdevicew
     * @since windows5.1.2600
     */
    static QueryDosDeviceW(lpDeviceName, lpTargetPath, ucchMax) {
        lpDeviceName := lpDeviceName is String ? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String ? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\QueryDosDeviceW", "ptr", lpDeviceName, "ptr", lpTargetPath, "uint", ucchMax, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
     * @param {HANDLE} hFile A handle to the device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive, 
     *        socket, communications resource, mailslot, or  pipe).
     * 
     * The <i>hFile</i> parameter must have been created with read access. For more information, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * For asynchronous read operations, <i>hFile</i> can be any handle that is opened with the 
     *        <b>FILE_FLAG_OVERLAPPED</b> flag by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.
     * @param {Pointer} lpBuffer A pointer to the buffer that receives the data read from a file or device.
     * 
     * This buffer must remain valid for the duration of the read operation. The caller must not use this buffer 
     *        until the read operation is completed.
     * @param {Integer} nNumberOfBytesToRead The maximum number of bytes to be read.
     * @param {Pointer<UInt32>} lpNumberOfBytesRead A pointer to the variable that receives the number of bytes read when using a synchronous 
     *        <i>hFile</i> parameter. <b>ReadFile</b> sets 
     *        this value to zero  before doing any work or error checking. Use <b>NULL</b> for this 
     *        parameter if this is an asynchronous operation to avoid potentially erroneous results.
     * 
     * This parameter can be <b>NULL</b> only when the <i>lpOverlapped</i> 
     *        parameter is not <b>NULL</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is 
     *        required if the <i>hFile</i> parameter was opened with 
     *        <b>FILE_FLAG_OVERLAPPED</b>, otherwise it can be <b>NULL</b>.
     * 
     * If <i>hFile</i> is opened with <b>FILE_FLAG_OVERLAPPED</b>, the 
     *        <i>lpOverlapped</i> parameter must point to a 
     *        valid and unique <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, otherwise the 
     *        function can incorrectly report that the read operation is complete.
     * 
     * For an <i>hFile</i> that supports byte offsets, if you use this parameter you must specify 
     *        a byte offset at which to start reading from the file or device. This offset is specified by setting the 
     *        <b>Offset</b> and <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For an 
     *        <i>hFile</i> that does not support byte offsets, <b>Offset</b> and 
     *        <b>OffsetHigh</b> are ignored.
     * 
     * For more information about different combinations of <i>lpOverlapped</i> and 
     *        <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the 
     *        <a href="https://docs.microsoft.com/">Synchronization and File Position</a> section.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, or is completing asynchronously, the return value is zero 
     *        (<b>FALSE</b>). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     *        <div class="alert"><b>Note</b>  The <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> code 
     *         <b>ERROR_IO_PENDING</b> is not a failure; it designates the read operation is pending 
     *         completion asynchronously. For more information, see Remarks.</div>
     * <div> </div>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfile
     * @since windows5.1.2600
     */
    static ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadFile", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToRead, "uint*", lpNumberOfBytesRead, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads data from the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when reading is completed or canceled and the calling thread is in an alertable wait state.
     * @param {HANDLE} hFile A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, 
     *        tape drive, socket, communications resource, mailslot, or pipe).
     * 
     * This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.
     * 
     * This handle also must have the <b>GENERIC_READ</b> access right. For more information on 
     *        access rights, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer} lpBuffer A pointer to a buffer that receives the data read from the file or device.
     * 
     * This buffer must remain valid for the duration of the read operation. The application should not use this 
     *        buffer until the read operation is completed.
     * @param {Integer} nNumberOfBytesToRead The number of bytes to be read.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure that 
     *        supplies data to be used during the asynchronous (overlapped) file read operation.
     * 
     * For files that support byte offsets, you must specify a byte offset at which to start reading from the file. 
     *        You specify this offset by setting the <b>Offset</b> and 
     *        <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For files or devices that do not 
     *        support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are 
     *        ignored.
     * 
     * The <b>ReadFileEx</b> function ignores the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's 
     *        <b>hEvent</b> member. An application is free to use that member for its own purposes in the 
     *        context of a <b>ReadFileEx</b> call. 
     *        <b>ReadFileEx</b> signals completion of its read operation by 
     *        calling, or queuing a call to, the completion routine pointed to by 
     *        <i>lpCompletionRoutine</i>, so it does not need an event handle.
     * 
     * The <b>ReadFileEx</b> function does use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's 
     *        <b>Internal</b> and <b>InternalHigh</b> members. An application should 
     *        not set these members.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure must remain valid for 
     *        the duration of the read operation. It should not be a variable that can go out of scope while the read 
     *        operation is pending completion.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to the completion routine to be called when the read operation is complete and the calling thread 
     *       is in an alertable wait state. For more information about the completion routine, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped read 
     *        operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable 
     *        wait state, the system calls the function pointed to by <i>lpCompletionRoutine</i>, and the 
     *        wait state completes with a return code of <b>WAIT_IO_COMPLETION</b>.
     * 
     * If the function succeeds, and the file reading operation completes, but the calling thread is not in an 
     *        alertable wait state, the system queues the completion routine call, holding the call until the calling thread 
     *        enters an alertable wait state. For information about alertable waits and overlapped input/output operations, 
     *        see <a href="/windows/desktop/Sync/about-synchronization">About Synchronization</a>.
     * 
     * If <b>ReadFileEx</b> attempts to read past the 
     *        end-of-file (EOF), the call to 
     *        <a href="/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for that operation returns 
     *        <b>FALSE</b> and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        returns <b>ERROR_HANDLE_EOF</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfileex
     * @since windows5.1.2600
     */
    static ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadFileEx", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToRead, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads data from a file and stores it in an array of buffers.
     * @param {HANDLE} hFile A handle to the file to be read.
     * 
     * The file handle must be created with the <b>GENERIC_READ</b> right, and the 
     *        <b>FILE_FLAG_OVERLAPPED</b> and <b>FILE_FLAG_NO_BUFFERING</b> flags. For 
     *        more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<FILE_SEGMENT_ELEMENT>} aSegmentArray A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_file_segment_element">FILE_SEGMENT_ELEMENT</a> 
     *        buffers that receives the data. For a description of this union, see Remarks.
     * 
     * Each element can receive one page of data.
     * 
     * <div class="alert"><b>Note</b>  To determine the size of a system page, use 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a>.</div>
     * <div> </div>
     * The array must contain enough elements to store <i>nNumberOfBytesToRead</i> bytes of data, 
     *        plus one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be 
     *        read and the page size is 4 KB, the array must have 11 elements that includes 10 for the data and one for 
     *        the <b>NULL</b>.
     * 
     * Each buffer must be at least the size of a system memory page and must be aligned on a system memory page 
     *        size boundary. The system reads one system memory page of data into each buffer.
     * 
     * The function stores the data in the buffers in sequential order. For example, it stores data into the first 
     *        buffer, then into the second buffer, and so on until each buffer is filled and all the data is stored, or there 
     *        are no more buffers.
     * @param {Integer} nNumberOfBytesToRead The total number of bytes to be read from the file. Each element of <i>aSegmentArray</i> 
     *       contains a one-page chunk of this total. Because the file must be opened with 
     *       <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of 
     *       the file system where the file is located.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data 
     *        structure.
     * 
     * The <b>ReadFileScatter</b> function requires a valid 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. The 
     *        <i>lpOverlapped</i> parameter 
     *        cannot be <b>NULL</b>.
     * 
     * The <b>ReadFileScatter</b> function starts reading data 
     *        from the file at a position that is specified by the <b>Offset</b> and 
     *        <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * The <b>ReadFileScatter</b> function may return before the 
     *        read operation is complete. In that scenario, the 
     *        <b>ReadFileScatter</b> function returns the value 0 
     *        (zero), and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the 
     *        value <b>ERROR_IO_PENDING</b>. This asynchronous operation of 
     *        <b>ReadFileScatter</b> lets the calling process continue 
     *        while the read operation completes. You can call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-hasoverlappediocompleted">HasOverlappedIoCompleted</a>, or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> functions to 
     *        obtain information about the completion of the read operation. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If <b>ReadFileScatter</b> attempts to read past the 
     *        end-of-file (EOF), the call to 
     *        <a href="/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for that operation returns 
     *        <b>FALSE</b> and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        returns <b>ERROR_HANDLE_EOF</b>.
     * 
     * If the function returns before the read operation is complete, the function returns zero (0), and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *        <b>ERROR_IO_PENDING</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-readfilescatter
     * @since windows5.1.2600
     */
    static ReadFileScatter(hFile, aSegmentArray, nNumberOfBytesToRead, lpOverlapped) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadFileScatter", "ptr", hFile, "ptr", aSegmentArray, "uint", nNumberOfBytesToRead, "uint*", lpReserved, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory.
     * @param {PSTR} lpPathName The path of the directory to be removed. This path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-removedirectorya
     * @since windows5.1.2600
     */
    static RemoveDirectoryA(lpPathName) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryA", "ptr", lpPathName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory.
     * @param {PWSTR} lpPathName The path of the directory to be removed. This path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-removedirectoryw
     * @since windows5.1.2600
     */
    static RemoveDirectoryW(lpPathName) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryW", "ptr", lpPathName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the physical file size for the specified file to the current position of the file pointer.
     * @param {HANDLE} hFile A handle to the file to be extended or truncated.
     * 
     *  The file handle must be created with the <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setendoffile
     * @since windows5.1.2600
     */
    static SetEndOfFile(hFile) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetEndOfFile", "ptr", hFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the attributes for a file or directory.
     * @param {PSTR} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values 
     *        override <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that is an archive file or directory. Applications typically use this attribute to 
     *         mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is hidden. It is not included in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that does not have other attributes set. This attribute is valid only when used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></a><a id="file_attribute_not_content_indexed"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b></dt>
     * <dt>8192 (0x2000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is not to be indexed by the content indexing service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not available immediately. This attribute indicates that the file data is 
     *         physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical 
     *         storage management software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is read-only. Applications can read the file, but cannot write to it or delete it. This 
     *         attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or 
     *         the System attributes of folders in Windows Server 2003, in Windows XP, or in 
     *         Windows Vista.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that the operating system uses a part of, or uses exclusively.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is being used for temporary storage. File systems avoid writing data back to mass storage if 
     *         sufficient cache memory is available, because typically, an application deletes a temporary file after the 
     *         handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is 
     *         written after the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileattributesa
     * @since windows5.1.2600
     */
    static SetFileAttributesA(lpFileName, dwFileAttributes) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesA", "ptr", lpFileName, "uint", dwFileAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the attributes for a file or directory.
     * @param {PWSTR} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values 
     *        override <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that is an archive file or directory. Applications typically use this attribute to 
     *         mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is hidden. It is not included in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that does not have other attributes set. This attribute is valid only when used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></a><a id="file_attribute_not_content_indexed"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b></dt>
     * <dt>8192 (0x2000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is not to be indexed by the content indexing service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not available immediately. This attribute indicates that the file data is 
     *         physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical 
     *         storage management software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is read-only. Applications can read the file, but cannot write to it or delete it. This 
     *         attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or 
     *         the System attributes of folders in Windows Server 2003, in Windows XP, or in 
     *         Windows Vista.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that the operating system uses a part of, or uses exclusively.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is being used for temporary storage. File systems avoid writing data back to mass storage if 
     *         sufficient cache memory is available, because typically, an application deletes a temporary file after the 
     *         handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is 
     *         written after the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileattributesw
     * @since windows5.1.2600
     */
    static SetFileAttributesW(lpFileName, dwFileAttributes) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesW", "ptr", lpFileName, "uint", dwFileAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the file information for the specified file.
     * @param {HANDLE} hFile A handle to the file for which to change information.
     * 
     * This handle must be opened with the appropriate permissions for the requested change. For more information, 
     *        see the Remarks and Example Code sections.
     * 
     * This handle should not be a pipe handle.
     * @param {Integer} FileInformationClass A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-file_info_by_handle_class">FILE_INFO_BY_HANDLE_CLASS</a> enumeration 
     *        value that specifies the type of information to be changed.
     * 
     * For a table of valid values, see the Remarks section.
     * @param {Pointer} lpFileInformation A pointer to the buffer that contains the information to change  for the specified file information class. 
     *        The structure that this parameter points to corresponds to the class that is specified by 
     *        <i>FileInformationClass</i>.
     * 
     * For a table of valid structure types, see the Remarks section.
     * @param {Integer} dwBufferSize The size of <i>lpFileInformation</i>, in bytes.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileinformationbyhandle
     * @since windows6.0.6000
     */
    static SetFileInformationByHandle(hFile, FileInformationClass, lpFileInformation, dwBufferSize) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileInformationByHandle", "ptr", hFile, "int", FileInformationClass, "ptr", lpFileInformation, "uint", dwBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves the file pointer of the specified file.
     * @param {HANDLE} hFile A handle to the file.
     *       
     * 
     * The file handle must be created with the <b>GENERIC_READ</b> or 
     *        <b>GENERIC_WRITE</b> access right. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} lDistanceToMove The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.
     *       
     * 
     * If <i>lpDistanceToMoveHigh</i> is not <b>NULL</b>, 
     *        <i>lpDistanceToMoveHigh</i> and <i>lDistanceToMove</i> form a single 
     *        64-bit signed value that specifies the distance to move.
     * 
     * If <i>lpDistanceToMoveHigh</i> is <b>NULL</b>, 
     *        <i>lDistanceToMove</i> is a 32-bit signed value. A positive value for 
     *        <i>lDistanceToMove</i> moves the file pointer forward in the file, and a negative value 
     *        moves the file pointer back.
     * @param {Pointer<Int32>} lpDistanceToMoveHigh A pointer to the high order 32-bits of the signed 64-bit distance to move.
     *       
     * 
     * If you do not need the high order 32-bits, this pointer must be set to <b>NULL</b>.
     * 
     * When  not <b>NULL</b>, this parameter also receives the high order 
     *        <b>DWORD</b> of the new value of the file pointer. For more information, see the Remarks 
     *        section in this topic.
     * @param {Integer} dwMoveMethod The starting point for the file pointer move.
     * @returns {Integer} If the function succeeds and <i>lpDistanceToMoveHigh</i> is 
     *        <b>NULL</b>, the return value is the low-order <b>DWORD</b> of the new 
     *        file pointer.
     *        <b>Note</b>  If the function returns a value other than <b>INVALID_SET_FILE_POINTER</b>, the call 
     *          to <b>SetFilePointer</b> has succeeded. You do not need to 
     *          call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * If function succeeds and <i>lpDistanceToMoveHigh</i> is not 
     *        <b>NULL</b>, the return value is the low-order <b>DWORD</b> of the new 
     *        file pointer and <i>lpDistanceToMoveHigh</i> contains the high order 
     *        <b>DWORD</b> of the new file pointer.
     * 
     * If the function fails, the return value is <b>INVALID_SET_FILE_POINTER</b>. To get 
     *        extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If a new file pointer is a negative value, the function fails, the file pointer is not moved, and the code 
     *        returned by <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is 
     *        <b>ERROR_NEGATIVE_SEEK</b>.
     * 
     * If <i>lpDistanceToMoveHigh</i> is <b>NULL</b> and the new file position 
     *        does not fit in a 32-bit value, the function fails and returns 
     *        <b>INVALID_SET_FILE_POINTER</b>.
     * 
     * <div class="alert"><b>Note</b>  Because <b>INVALID_SET_FILE_POINTER</b> is a valid value for the 
     *        low-order <b>DWORD</b> of the new file pointer, you must check both the return value of 
     *        the function and the error code returned by 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether or not an error has 
     *        occurred. If an error has occurred, the return value of 
     *        <b>SetFilePointer</b> is 
     *        <b>INVALID_SET_FILE_POINTER</b> and 
     *        <b>GetLastError</b> returns a value other than 
     *        <b>NO_ERROR</b>. For a code example that demonstrates how to check for failure, see the 
     *        Remarks section in this topic.</div>
     * <div> </div>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointer
     * @since windows5.1.2600
     */
    static SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFilePointer", "ptr", hFile, "int", lDistanceToMove, "int*", lpDistanceToMoveHigh, "uint", dwMoveMethod, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves the file pointer of the specified file.
     * @param {HANDLE} hFile A handle to the file. The file handle must have been created with the 
     *       <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} liDistanceToMove The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a 
     *       negative value moves the file pointer backward.
     * @param {Pointer<Int64>} lpNewFilePointer A pointer to a variable to receive the new file pointer. If this parameter is 
     *       <b>NULL</b>, the new file pointer is not returned.
     * @param {Integer} dwMoveMethod 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilepointerex
     * @since windows5.1.2600
     */
    static SetFilePointerEx(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFilePointerEx", "ptr", hFile, "int64", liDistanceToMove, "int64*", lpNewFilePointer, "uint", dwMoveMethod, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the date and time that the specified file or directory was created, last accessed, or last modified.
     * @param {HANDLE} hFile A handle to the file or directory. The handle must have been created using the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function  with the 
     *       <b>FILE_WRITE_ATTRIBUTES</b> access right. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<FILETIME>} lpCreationTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that contains the 
     *       new creation date and time for the file or directory. If 
     *       the application does not need to change this information, set this parameter either to <b>NULL</b> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.
     * @param {Pointer<FILETIME>} lpLastAccessTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that 
     *        contains the new last access date and time for the file or directory. The last access time includes the last 
     *        time the file or directory was written to, read from, or (in the case of executable files) run. If 
     *       the application does not need to change this information, set this parameter 
     *        either to <b>NULL</b> or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.
     * 
     * To prevent file operations using the given handle from modifying the last access time, call 
     *        <b>SetFileTime</b> immediately  after opening the file handle 
     *        and pass a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that has both the 
     *        <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 
     *        0xFFFFFFFF.
     * @param {Pointer<FILETIME>} lpLastWriteTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that 
     *        contains the new last modified date and time for the file or directory.  If the application does not need to change this information, set this parameter either  to <b>NULL</b>  or to a pointer to a <b>FILETIME</b> structure that has both the <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 0.
     * 
     * To prevent file operations using the given handle from modifying the last access time, call 
     *        <b>SetFileTime</b> immediately after opening the file handle 
     *        and pass a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that has both the 
     *        <b>dwLowDateTime</b> and <b>dwHighDateTime</b> members set to 
     *        0xFFFFFFFF.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfiletime
     * @since windows5.1.2600
     */
    static SetFileTime(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileTime", "ptr", hFile, "ptr", lpCreationTime, "ptr", lpLastAccessTime, "ptr", lpLastWriteTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the valid data length of the specified file. This function is useful in very limited scenarios. For more information, see the Remarks section.
     * @param {HANDLE} hFile A handle to the file. The file must have been opened with the <b>GENERIC_WRITE</b> access right, and the <b>SE_MANAGE_VOLUME_NAME</b> privilege enabled. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * <div class="alert"><b>Note</b>  The file cannot be a network file, or be compressed, sparse, or transacted.</div>
     * <div> </div>
     * @param {Integer} ValidDataLength The new valid data length. 
     * 
     * This parameter must be a positive value that is greater than the current valid data length, but less than the current file size.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfilevaliddata
     * @since windows5.1.2600
     */
    static SetFileValidData(hFile, ValidDataLength) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileValidData", "ptr", hFile, "int64", ValidDataLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Unlocks a region in an open file.
     * @param {HANDLE} hFile A handle to the file that contains a region locked with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-lockfile">LockFile</a>. The file handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} dwFileOffsetLow The low-order word of the starting byte offset in the file where the locked region begins.
     * @param {Integer} dwFileOffsetHigh The high-order word of the starting byte offset in the file where the locked region begins.
     * @param {Integer} nNumberOfBytesToUnlockLow The low-order word of the length of the byte range to be unlocked.
     * @param {Integer} nNumberOfBytesToUnlockHigh The high-order word of the length of the byte range to be unlocked.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-unlockfile
     * @since windows5.1.2600
     */
    static UnlockFile(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\UnlockFile", "ptr", hFile, "uint", dwFileOffsetLow, "uint", dwFileOffsetHigh, "uint", nNumberOfBytesToUnlockLow, "uint", nNumberOfBytesToUnlockHigh, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Unlocks a region in the specified file. This function can operate either synchronously or asynchronously.
     * @param {HANDLE} hFile A handle to the file. The handle must have been created with either the 
     *       <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} nNumberOfBytesToUnlockLow The low-order part of the length of the byte range to unlock.
     * @param {Integer} nNumberOfBytesToUnlockHigh The high-order part of the length of the byte range to unlock.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that the 
     *       function uses with the unlocking request. This structure contains the file offset of the beginning of the unlock 
     *       range. You must initialize the <b>hEvent</b> member to a valid handle or zero. For more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero or <b>NULL</b>. To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-unlockfileex
     * @since windows5.1.2600
     */
    static UnlockFileEx(hFile, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\UnlockFileEx", "ptr", hFile, "uint", dwReserved, "uint", nNumberOfBytesToUnlockLow, "uint", nNumberOfBytesToUnlockHigh, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes data to the specified file or input/output (I/O) device.
     * @param {HANDLE} hFile A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, 
     *        tape drive, socket, communications resource, mailslot, or  pipe).
     * 
     * The <i>hFile</i> parameter must have been created with the write access. For more 
     *        information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * For asynchronous write operations, <i>hFile</i> can be any handle opened with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function using the 
     *        <b>FILE_FLAG_OVERLAPPED</b> flag or a socket handle returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.
     * @param {Pointer} lpBuffer A pointer to the buffer containing the data to be written to the file or device.
     * 
     * This buffer must remain valid for the duration of the write operation. The caller must not use this buffer 
     *         until the write operation is completed.
     * @param {Integer} nNumberOfBytesToWrite The number of bytes to be written to the file or device.
     * 
     * A value of zero specifies a null write operation. The behavior of a null write operation depends on the 
     *         underlying file system or communications technology.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>Pipe write operations across a network are limited in size per write. The amount varies per platform. 
     *          For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more 
     *          information regarding pipes, see the Remarks section.
     * @param {Pointer<UInt32>} lpNumberOfBytesWritten A pointer to the variable that receives the number of bytes written when using a synchronous 
     *         <i>hFile</i> parameter. <b>WriteFile</b> sets 
     *         this value to zero before doing any work or error checking. Use <b>NULL</b> for this 
     *         parameter if this is an asynchronous operation to avoid potentially erroneous results.
     * 
     * This parameter can be <b>NULL</b> only when the <i>lpOverlapped</i> 
     *         parameter is not <b>NULL</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is 
     *        required if the <i>hFile</i> parameter was opened with 
     *        <b>FILE_FLAG_OVERLAPPED</b>, otherwise this parameter can be 
     *        <b>NULL</b>.
     * 
     * For an <i>hFile</i> that supports byte offsets, if you use this parameter you must specify 
     *        a byte offset at which to start writing to the file or device. This offset is specified by setting the 
     *        <b>Offset</b> and <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For an 
     *        <i>hFile</i> that does not support byte offsets, <b>Offset</b> and 
     *        <b>OffsetHigh</b> are ignored.
     * 
     * To write to the end of file, specify both the <b>Offset</b> and 
     *        <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure as 0xFFFFFFFF. This is 
     *        functionally equivalent to previously calling the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to open 
     *        <i>hFile</i> using <b>FILE_APPEND_DATA</b> access.
     * 
     * For more information about different combinations of <i>lpOverlapped</i> and 
     *        <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the 
     *        <a href="https://docs.microsoft.com/">Synchronization and File Position</a> section.
     * @returns {BOOL} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, or is completing asynchronously, the return value is zero 
     *        (<b>FALSE</b>). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <div class="alert"><b>Note</b>  The <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> code 
     *        <b>ERROR_IO_PENDING</b> is not a failure; it designates the write operation is pending 
     *        completion asynchronously. For more information, see Remarks.</div>
     * <div> </div>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefile
     * @since windows5.1.2600
     */
    static WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\WriteFile", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToWrite, "uint*", lpNumberOfBytesWritten, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes data to the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when writing is completed or canceled and the calling thread is in an alertable wait state.
     * @param {HANDLE} hFile A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive, 
     *     socket, communications resource, mailslot, or  pipe). 
     *        
     * 
     * This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function. 
     * 
     * Do not associate an I/O completion port with this handle. For more information, see the Remarks section.
     * 
     * This handle also must have the <b>GENERIC_WRITE</b> access 
     *       right. For more information on access rights, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer} lpBuffer A pointer to the buffer containing the data to be written to the file or device.
     *      
     * 
     * This buffer must remain valid for the duration of the write operation. The caller must not use this buffer 
     *       until the write operation is completed.
     * @param {Integer} nNumberOfBytesToWrite The number of bytes to be written to the file or device.
     *       
     * 
     * A value of zero specifies a null write operation. The behavior of a null write operation depends on the 
     *        underlying file system.
     * 
     * Pipe write operations across a network are limited to 65,535 bytes per write. For more information regarding  pipes, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure that 
     *       supplies data to be used during the overlapped (asynchronous) write operation.
     *       
     * 
     * For files that support byte offsets, you must specify a byte offset at which to start writing to the file. 
     *        You specify this offset by setting the <b>Offset</b> and 
     *        <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For files or devices that do not support 
     *        byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are ignored.
     * 
     * To write to the end of file, specify both the <b>Offset</b> and <b>OffsetHigh</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to open <i>hFile</i> using <b>FILE_APPEND_DATA</b> access.
     * 
     * The <b>WriteFileEx</b> function ignores the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's 
     *        <b>hEvent</b> member. An application is free to use that member for its own purposes in the 
     *        context of a <b>WriteFileEx</b> call. 
     *        <b>WriteFileEx</b> signals completion of its writing operation 
     *        by calling, or queuing a call to, the completion routine pointed to by 
     *        <i>lpCompletionRoutine</i>, so it does not need an event handle.
     * 
     * The <b>WriteFileEx</b> function does use the 
     *        <b>Internal</b> and <b>InternalHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. You should not change the value 
     *        of these members.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure must remain valid for 
     *        the duration of the write operation. It should not be a variable that can go out of scope while the write 
     *        operation is pending completion.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to a completion routine to be called when the write operation has been completed and the calling 
     *       thread is in an alertable wait state. For more information about this completion routine, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the <b>WriteFileEx</b> function succeeds, the calling 
     *        thread has an asynchronous I/O operation pending: the overlapped write operation to the file. 
     *        When this I/O operation finishes, and the calling thread is blocked in an alertable wait state, the 
     *        operating system calls the function pointed to by <i>lpCompletionRoutine</i>, and the wait 
     *        completes with a return code of <b>WAIT_IO_COMPLETION</b>.
     * 
     * If the function succeeds and the file-writing operation finishes, but the calling thread is not in an 
     *        alertable wait state, the system queues the call to *<i>lpCompletionRoutine</i>, holding the 
     *        call until the calling thread enters an alertable wait state. For more information about 
     *        alertable wait states and overlapped input/output operations, see <a href="/windows/desktop/Sync/about-synchronization">About Synchronization</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefileex
     * @since windows5.1.2600
     */
    static WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\WriteFileEx", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToWrite, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves data from an array of buffers and writes the data to a file.
     * @param {HANDLE} hFile A handle to the file. The file handle must be created with the <b>GENERIC_WRITE</b> 
     *       access right, and the <b>FILE_FLAG_OVERLAPPED</b> and 
     *       <b>FILE_FLAG_NO_BUFFERING</b> flags. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<FILE_SEGMENT_ELEMENT>} aSegmentArray A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-_file_segment_element">FILE_SEGMENT_ELEMENT</a> 
     *        buffers that contain the data. For a description of this union, see Remarks.
     * 
     * Each element contains the address of one page of data. 
     *        <div class="alert"><b>Note</b>  To determine the size of a system page, use the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function.</div>
     * <div> </div>The array must contain enough elements to store <i>nNumberOfBytesToWrite</i> bytes of data, 
     *        and one element for the terminating <b>NULL</b>. For example, if there are 40 KB to be read 
     *        and the page size is 4 KB, the array must have 11 elements that includes 10 elements for the data and one 
     *        element for the <b>NULL</b>.
     * 
     * Each buffer must be at least the size of a system memory page and must be aligned on a system memory page 
     *        size boundary. The system writes one system memory page of data from each buffer.
     * 
     * The function gathers the data from the buffers in a sequential order. For example, it writes data to the file 
     *        from the first buffer, then the second buffer, and so on until there is no more data.
     * 
     * Due to the asynchronous operation of this function, precautions must be taken to ensure that this parameter 
     *        always references valid memory for the lifetime of the asynchronous writes. For instance, a common programming 
     *        error is to use local stack storage and then allow execution to run out of scope.
     * @param {Integer} nNumberOfBytesToWrite The total number of bytes to be written. Each element of <i>aSegmentArray</i> contains a 
     *        one-page chunk of this total. Because the file must be opened with 
     *        <b>FILE_FLAG_NO_BUFFERING</b>, the number of bytes must be a multiple of the sector size of 
     *        the file system where the file is located.
     * 
     * If <i>nNumberOfBytesToWrite</i> is zero (0), the function performs a null write operation. 
     *        The behavior of a null write operation depends on the underlying file system. If 
     *        <i>nNumberOfBytesToWrite</i> is not zero (0) and the offset and length of the write place 
     *        data beyond the current end of the file, 
     *        the <b>WriteFileGather</b> function extends the file.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data 
     *        structure.
     * 
     * The <b>WriteFileGather</b> function requires a valid 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. The 
     *        <i>lpOverlapped</i> parameter cannot be <b>NULL</b>.
     * 
     * The <b>WriteFileGather</b> function starts writing data to 
     *        the file at a position that is specified by the <b>Offset</b> and 
     *        <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * The <b>WriteFileGather</b> function may return before the 
     *        write operation is complete. In that scenario, the 
     *        <b>WriteFileGather</b> function returns the value zero (0), 
     *        and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the 
     *        value <b>ERROR_IO_PENDING</b>. This asynchronous operation of the 
     *        <b>WriteFileGather</b> function lets the calling process 
     *        continue while the write operation completes. You can call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-hasoverlappediocompleted">HasOverlappedIoCompleted</a>, or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function to 
     *        obtain information about the completion of the write operation. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function returns before the write operation is complete, the function returns zero (0), and 
     *        the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_IO_PENDING</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-writefilegather
     * @since windows5.1.2600
     */
    static WriteFileGather(hFile, aSegmentArray, nNumberOfBytesToWrite, lpOverlapped) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\WriteFileGather", "ptr", hFile, "ptr", aSegmentArray, "uint", nNumberOfBytesToWrite, "uint*", lpReserved, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path of the directory designated for temporary files.
     * @param {Integer} nBufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {PWSTR} lpBuffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettemppathw
     * @since windows5.1.2600
     */
    static GetTempPathW(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempPathW", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a volume GUID path for the volume that is associated with the specified volume mount point ( drive letter, volume GUID path, or mounted folder).
     * @param {PWSTR} lpszVolumeMountPoint A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\\") or a drive letter (for example, "X:\\"). The string must end with a trailing backslash ('\\').
     * @param {PWSTR} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\\\?\Volume{<i>GUID</i>}\\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.
     * @param {Integer} cchBufferLength The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumenameforvolumemountpointw
     * @since windows5.1.2600
     */
    static GetVolumeNameForVolumeMountPointW(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeNameForVolumeMountPointW", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a list of drive letters and mounted folder paths for the specified volume.
     * @param {PWSTR} lpszVolumeName A volume <b>GUID</b> path for the volume. A volume <b>GUID</b> 
     *       path is of the form 
     *       "\\\\?\\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\\".
     * @param {PWSTR} lpszVolumePathNames A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an 
     *       array of null-terminated strings terminated by an additional <b>NULL</b> character. If the 
     *       buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.
     * @param {Integer} cchBufferLength The length of the <i>lpszVolumePathNames</i> buffer, in 
     *       <b>TCHARs</b>, including all <b>NULL</b> characters.
     * @param {Pointer<UInt32>} lpcchReturnLength If the call is successful, this parameter is the number of <b>TCHARs</b> copied to 
     *       the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer 
     *       required to hold the complete list, in <b>TCHARs</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the buffer is not large enough to 
     *        hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the 
     *        <i>lpcchReturnLength</i> parameter receives the required buffer size.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumepathnamesforvolumenamew
     * @since windows5.1.2600
     */
    static GetVolumePathNamesForVolumeNameW(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength) {
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName
        lpszVolumePathNames := lpszVolumePathNames is String ? StrPtr(lpszVolumePathNames) : lpszVolumePathNames

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNamesForVolumeNameW", "ptr", lpszVolumeName, "ptr", lpszVolumePathNames, "uint", cchBufferLength, "uint*", lpcchReturnLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file or I/O device.
     * @param {PWSTR} lpFileName The name of the file or device to be created or opened.
     * 
     * For information on special device names, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are <b>GENERIC_READ</b>, 
     *        <b>GENERIC_WRITE</b>, or both 
     *        (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device 
     *        attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would 
     *        have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the 
     *        <i>dwShareMode</i> parameter in an open request that already has an open handle.
     * 
     * For more information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or 
     *        none (refer to the following table). Access requests to attributes or extended attributes are not affected by 
     *        this flag.
     * 
     * If this parameter is zero and <b>CreateFile2</b> succeeds, the 
     *        file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. 
     *        For more information, see the Remarks section.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an existing 
     *        request that has an open handle. <b>CreateFile2</b> would fail 
     *        and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return 
     *        <b>ERROR_SHARING_VIOLATION</b>.
     * 
     * To enable a process to share a file or device while another process has the file or device open, use a
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     * 
     * For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Pointer<CREATEFILE2_EXTENDED_PARAMETERS>} pCreateExParams Pointer to an optional 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-createfile2_extended_parameters">CREATEFILE2_EXTENDED_PARAMETERS</a> 
     *       structure.
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-createfile2
     * @since windows8.0
     */
    static CreateFile2(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFile2", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "uint", dwCreationDisposition, "ptr", pCreateExParams, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Associates a virtual address range with the specified file handle.
     * @param {HANDLE} FileHandle A handle to the file.
     * 
     * This file handle must be opened with <b>FILE_READ_ATTRIBUTES</b> access rights.
     * @param {Pointer<Byte>} OverlappedRangeStart The starting address for the range.
     * @param {Integer} Length The length of the range, in bytes.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileiooverlappedrange
     * @since windows6.0.6000
     */
    static SetFileIoOverlappedRange(FileHandle, OverlappedRangeStart, Length) {
        FileHandle := FileHandle is Win32Handle ? NumGet(FileHandle, "ptr") : FileHandle

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileIoOverlappedRange", "ptr", FileHandle, "char*", OverlappedRangeStart, "uint", Length, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file.
     * @param {PSTR} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<UInt32>} lpFileSizeHigh The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getcompressedfilesizea
     * @since windows5.1.2600
     */
    static GetCompressedFileSizeA(lpFileName, lpFileSizeHigh) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeA", "ptr", lpFileName, "uint*", lpFileSizeHigh, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file.
     * @param {PWSTR} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<UInt32>} lpFileSizeHigh The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getcompressedfilesizew
     * @since windows5.1.2600
     */
    static GetCompressedFileSizeW(lpFileName, lpFileSizeHigh) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeW", "ptr", lpFileName, "uint*", lpFileSizeHigh, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the first stream with a ::$DATA stream type in the specified file or directory.
     * @param {PWSTR} lpFileName The fully qualified file name.
     * @param {Integer} InfoLevel The information level of the returned data. This parameter is one of the values in the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ne-fileapi-stream_info_levels">STREAM_INFO_LEVELS</a> enumeration type.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FindStreamInfoStandard"></a><a id="findstreaminfostandard"></a><a id="FINDSTREAMINFOSTANDARD"></a><dl>
     * <dt><b>FindStreamInfoStandard</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data is returned in a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_find_stream_data">WIN32_FIND_STREAM_DATA</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFindStreamData A pointer to a buffer that receives the file stream data. The format of this data depends on the value of 
     *       the <i>InfoLevel</i> parameter.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle that can be used in subsequent calls to the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a> function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If no  streams can be found, the function fails and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *        <b>ERROR_HANDLE_EOF</b> (38).
     *        
     * If the filesystem does not support streams, the function fails and
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *        <b>ERROR_INVALID_PARAMETER</b> (87).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirststreamw
     * @since windows6.0.6000
     */
    static FindFirstStreamW(lpFileName, InfoLevel, lpFindStreamData) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstStreamW", "ptr", lpFileName, "int", InfoLevel, "ptr", lpFindStreamData, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Continues a stream search started by a previous call to the FindFirstStreamW function.
     * @param {HANDLE} hFindStream The search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirststreamw">FindFirstStreamW</a> function.
     * @param {Pointer<Void>} lpFindStreamData A pointer to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_find_stream_data">WIN32_FIND_STREAM_DATA</a> structure that 
     *       receives information about the stream.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no  more streams can be found, 
     *        <b>GetLastError</b> returns 
     *        <b>ERROR_HANDLE_EOF</b> (38).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextstreamw
     * @since windows6.0.6000
     */
    static FindNextStreamW(hFindStream, lpFindStreamData) {
        hFindStream := hFindStream is Win32Handle ? NumGet(hFindStream, "ptr") : hFindStream

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextStreamW", "ptr", hFindStream, "ptr", lpFindStreamData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the file I/O functions are using the ANSI or OEM character set code page.
     * @returns {BOOL} If the set of file I/O functions is using the ANSI code page, the return value is nonzero.
     * 
     * If the set of file I/O functions is using the OEM code page, the return value is zero.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-arefileapisansi
     * @since windows5.1.2600
     */
    static AreFileApisANSI() {
        result := DllCall("KERNEL32.dll\AreFileApisANSI", "int")
        return result
    }

    /**
     * Retrieves the path of the directory designated for temporary files.
     * @param {Integer} nBufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {PSTR} lpBuffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettemppatha
     * @since windows5.1.2600
     */
    static GetTempPathA(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempPathA", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an enumeration of all the hard links to the specified file. The FindFirstFileNameW function returns a handle to the enumeration that can be used on subsequent calls to the FindNextFileNameW function.
     * @param {PWSTR} lpFileName The name of the file.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags Reserved; specify zero (0).
     * @param {Pointer<UInt32>} StringLength The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If 
     *       this call fails and the error returned from the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function is 
     *       <b>ERROR_MORE_DATA</b> (234), the value that is returned by this parameter is the size that 
     *       the buffer pointed to by <i>LinkName</i>  must be to contain all the data.
     * @param {PWSTR} LinkName A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle that can be used with the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilenamew">FindNextFileNameW</a> function or closed with the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To 
     *        get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        function.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findfirstfilenamew
     * @since windows6.0.6000
     */
    static FindFirstFileNameW(lpFileName, dwFlags, StringLength, LinkName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        LinkName := LinkName is String ? StrPtr(LinkName) : LinkName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileNameW", "ptr", lpFileName, "uint", dwFlags, "uint*", StringLength, "ptr", LinkName, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Continues enumerating the hard links to a file using the handle returned by a successful call to the FindFirstFileNameW function.
     * @param {HANDLE} hFindStream A handle to the enumeration that is returned by a successful call to 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilenamew">FindFirstFileNameW</a>.
     * @param {Pointer<UInt32>} StringLength The size of the <i>LinkName</i> parameter, in characters. If this call fails and the 
     *       error is <b>ERROR_MORE_DATA</b>, the value that is returned by this parameter is the size 
     *       that <i>LinkName</i>  must be to contain all the data.
     * @param {PWSTR} LinkName A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If no matching files can be found, the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        function returns <b>ERROR_HANDLE_EOF</b>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-findnextfilenamew
     * @since windows6.0.6000
     */
    static FindNextFileNameW(hFindStream, StringLength, LinkName) {
        LinkName := LinkName is String ? StrPtr(LinkName) : LinkName
        hFindStream := hFindStream is Win32Handle ? NumGet(hFindStream, "ptr") : hFindStream

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextFileNameW", "ptr", hFindStream, "uint*", StringLength, "ptr", LinkName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the file system and volume associated with the specified root directory.
     * @param {PSTR} lpRootPathName A pointer to a string that contains the root directory of the volume to be described.
     * 
     * If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing 
     *        backslash is required. For example, you  specify \\\\MyServer\\MyShare as 
     *        "\\\\MyServer\\MyShare\\", or the C drive as 
     *        "C:\\".
     * @param {PSTR} lpVolumeNameBuffer A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the 
     *        <i>nVolumeNameSize</i> parameter.
     * @param {Integer} nVolumeNameSize The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is 
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the volume name buffer is not supplied.
     * @param {Pointer<UInt32>} lpVolumeSerialNumber A pointer to a variable that receives the volume serial number.
     * 
     * This parameter can be <b>NULL</b> if the serial number is not required.
     * 
     * This function returns the volume serial number that the operating system assigns when a hard disk is 
     *        formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the 
     *        Windows Management Instrumentation (WMI) 
     *        <a href="https://docs.microsoft.com/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property 
     *        <b>SerialNumber</b>.
     * @param {Pointer<UInt32>} lpMaximumComponentLength A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file 
     *        name component  that a specified file system supports.
     * 
     * A file name component is the portion of a file name between backslashes.
     * 
     * The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to 
     *        is used to indicate that a specified file system supports long names. For example, for a FAT file system that 
     *        supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can 
     *        also be supported on systems that use the NTFS file system.
     * @param {Pointer<UInt32>} lpFileSystemFlags A pointer to a variable that receives flags associated with the specified file system.
     * 
     * This parameter can be one or more of the following flags. However, 
     *        <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually 
     *        exclusive.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a><dl>
     * <dt><b>FILE_CASE_PRESERVED_NAMES</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports preserved case of file names when it places a name on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a><dl>
     * <dt><b>FILE_CASE_SENSITIVE_SEARCH</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports case-sensitive file names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_DAX_VOLUME________"></a><a id="file_dax_volume________"></a><dl>
     * <dt><b>FILE_DAX_VOLUME        </b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is a direct access (DAX) volume.
     * 
     * <div class="alert"><b>Note</b>  This flag was introduced in Windows 10, version 1607.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a><dl>
     * <dt><b>FILE_FILE_COMPRESSION</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports file-based compression.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a><dl>
     * <dt><b>FILE_NAMED_STREAMS</b></dt>
     * <dt>0x00040000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports named streams.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a id="file_persistent_acls"></a><dl>
     * <dt><b>FILE_PERSISTENT_ACLS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system 
     *         preserves and enforces ACLs, and the FAT file system does not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a><dl>
     * <dt><b>FILE_READ_ONLY_VOLUME</b></dt>
     * <dt>0x00080000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a><dl>
     * <dt><b>FILE_SEQUENTIAL_WRITE_ONCE</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports a single sequential write.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a id="file_supports_encryption"></a><dl>
     * <dt><b>FILE_SUPPORTS_ENCRYPTION</b></dt>
     * <dt>0x00020000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports the Encrypted File System (EFS). For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a id="file_supports_extended_attributes"></a><dl>
     * <dt><b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports extended attributes. An extended attribute is a piece of 
     *         application-specific metadata that an application can associate with a file and is not part of the file's data.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a><dl>
     * <dt><b>FILE_SUPPORTS_HARD_LINKS</b></dt>
     * <dt>0x00400000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports hard links. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a><dl>
     * <dt><b>FILE_SUPPORTS_OBJECT_IDS</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports object identifiers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a id="file_supports_open_by_file_id"></a><dl>
     * <dt><b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system supports open by FileID. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a><dl>
     * <dt><b>FILE_SUPPORTS_REPARSE_POINTS</b></dt>
     * <dt>0x00000080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports reparse points.
     * 
     * <b>ReFS:  </b>ReFS supports reparse points but does not index them so 
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> and 
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> will not 
     *           function as expected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a><dl>
     * <dt><b>FILE_SUPPORTS_SPARSE_FILES</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sparse files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a id="file_supports_transactions"></a><dl>
     * <dt><b>FILE_SUPPORTS_TRANSACTIONS</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports transactions. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/Ktm/about-ktm">About KTM</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a><dl>
     * <dt><b>FILE_SUPPORTS_USN_JOURNAL</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports update sequence number (USN) journals. For more information, see 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a id="file_unicode_on_disk"></a><dl>
     * <dt><b>FILE_UNICODE_ON_DISK</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports Unicode in file names as they appear on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a><dl>
     * <dt><b>FILE_VOLUME_IS_COMPRESSED</b></dt>
     * <dt>0x00008000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is a compressed volume, for example, a DoubleSpace volume.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a><dl>
     * <dt><b>FILE_VOLUME_QUOTAS</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports disk quotas.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a><dl>
     * <dt><b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} lpFileSystemNameBuffer A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS 
     *        file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.
     * @param {Integer} nFileSystemNameSize The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is 
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the file system name buffer is not supplied.
     * @returns {BOOL} If all the requested information is retrieved, the return value is nonzero.
     * 
     * If not all the requested information is retrieved, the return value is zero. To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-getvolumeinformationa
     * @since windows5.1.2600
     */
    static GetVolumeInformationA(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeNameBuffer := lpVolumeNameBuffer is String ? StrPtr(lpVolumeNameBuffer) : lpVolumeNameBuffer
        lpFileSystemNameBuffer := lpFileSystemNameBuffer is String ? StrPtr(lpFileSystemNameBuffer) : lpFileSystemNameBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeInformationA", "ptr", lpRootPathName, "ptr", lpVolumeNameBuffer, "uint", nVolumeNameSize, "uint*", lpVolumeSerialNumber, "uint*", lpMaximumComponentLength, "uint*", lpFileSystemFlags, "ptr", lpFileSystemNameBuffer, "uint", nFileSystemNameSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated.
     * @param {PSTR} lpPathName The directory path for the file name. Applications typically specify a period (.) for the current directory 
     *        or the result of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-gettemppatha">GetTempPath</a> function. The string 
     *        cannot be longer than <b>MAX_PATH</b>–14 characters or
     *        <b>GetTempFileName</b> will fail. If this parameter is 
     *        <b>NULL</b>, the function fails.
     * @param {PSTR} lpPrefixString The null-terminated prefix string. The function uses up to the first three characters of this string as the 
     *        prefix of the file name. This string must consist of characters in the OEM-defined character set.
     * @param {Integer} uUnique An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.
     * 
     * If <i>uUnique</i> is zero, the function attempts to form a unique file name using the 
     *        current system time. If the file already exists, the number is increased by one and the functions tests if this 
     *        file already exists. This continues until a unique filename is found; the function creates a file by that name 
     *        and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when 
     *        <i>uUnique</i> is nonzero.
     * @param {PSTR} lpTempFileName A pointer to the buffer that receives the temporary file name. This buffer should be 
     *        <b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.
     * @returns {Integer} If the function succeeds, the return value specifies the unique numeric value used in the temporary file 
     *        name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same 
     *        number.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * The following is a possible return value.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUFFER_OVERFLOW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The length of the string pointed to by the <i>lpPathName</i> parameter is more than 
     *          <b>MAX_PATH</b>–14 characters.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettempfilenamea
     * @since windows5.1.2600
     */
    static GetTempFileNameA(lpPathName, lpPrefixString, uUnique, lpTempFileName) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName
        lpPrefixString := lpPrefixString is String ? StrPtr(lpPrefixString) : lpPrefixString
        lpTempFileName := lpTempFileName is String ? StrPtr(lpTempFileName) : lpTempFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempFileNameA", "ptr", lpPathName, "ptr", lpPrefixString, "uint", uUnique, "ptr", lpTempFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Causes the file I/O functions for the process to use the OEM character set code page.
     * @remarks
     * 
     * The file I/O functions whose code page is set by <b>SetFileApisToOEM</b> are those 
     *     functions exported by KERNEL32.DLL that accept or return a file name. 
     *     <b>SetFileApisToOEM</b> sets the code page per process, rather than per thread or per 
     *     computer.
     * 
     * The <b>SetFileApisToOEM</b> function is complemented by the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> function, which causes the same 
     *      set of file I/O functions to use the ANSI character set code page.
     * 
     * The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by 
     *     default. This means that strings returned by the console functions may not be processed correctly by other 
     *     functions, and vice versa. For example, if the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA</a> function returns a string that contains 
     *     certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the 
     *     <a href="https://docs.microsoft.com/windows/console/writeconsole">WriteConsoleA</a> function will not display the string 
     *     properly.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi">AreFileApisANSI</a> function to determine 
     *     which code page the set of file I/O functions is currently using. Use the 
     *     <a href="https://docs.microsoft.com/windows/console/setconsolecp">SetConsoleCP</a> and 
     *     <a href="https://docs.microsoft.com/windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page 
     *     for the 8-bit console functions.
     * 
     * To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console 
     *     applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that 
     *     solution, a console application can call the <b>SetFileApisToOEM</b> function to cause 
     *     the set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> function to set those functions 
     *     back to the ANSI code page.
     * 
     * When dealing with command lines, a console application should obtain the command line in Unicode form and then 
     *     convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the 
     *     <i>argv</i> parameter of the command-line <b>main</b> function 
     *     contains ANSI character set strings in this case.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileapistooem
     * @since windows5.1.2600
     */
    static SetFileApisToOEM() {
        DllCall("KERNEL32.dll\SetFileApisToOEM")
    }

    /**
     * Causes the file I/O functions to use the ANSI character set code page for the current process.
     * @remarks
     * 
     * The file I/O functions whose code page is set by <b>SetFileApisToANSI</b> are those 
     *     functions exported by KERNEL32.DLL that accept or return a file name. 
     *     <b>SetFileApisToANSI</b> sets the code page per process, rather than per thread or per 
     *     computer.
     * 
     * The <b>SetFileApisToANSI</b> function complements the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> function, which causes the same set 
     *     of file I/O functions to use the OEM character set code page.
     * 
     * The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by 
     *     default. This means that strings returned by the console functions may not be processed correctly by other 
     *     functions, and vice versa. For example, if the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA</a> function returns a string that contains 
     *     certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the 
     *     <a href="https://docs.microsoft.com/windows/console/writeconsole">WriteConsoleA</a> function does not display the string 
     *     properly.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi">AreFileApisANSI</a> function to determine 
     *     which code page the set of file I/O functions is currently using. Use the 
     *     <a href="https://docs.microsoft.com/windows/console/setconsolecp">SetConsoleCP</a> and 
     *     <a href="https://docs.microsoft.com/windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page 
     *     for the 8-bit console functions.
     * 
     * To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console 
     *     applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that 
     *     solution, a console application can call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> function to cause the 
     *     set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the 
     *     <b>SetFileApisToANSI</b> function to set those functions back to the ANSI code 
     *     page.
     * 
     * When dealing with command lines, a console application should obtain the command line in Unicode form and then 
     *     convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the 
     *     <i>argv</i> parameter of the command-line <b>main</b> function 
     *     contains ANSI character set strings in this case.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-setfileapistoansi
     * @since windows5.1.2600
     */
    static SetFileApisToANSI() {
        DllCall("KERNEL32.dll\SetFileApisToANSI")
    }

    /**
     * Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process.
     * @param {Integer} BufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {PWSTR} Buffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettemppath2w
     */
    static GetTempPath2W(BufferLength, Buffer) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("KERNEL32.dll\GetTempPath2W", "uint", BufferLength, "ptr", Buffer, "uint")
        return result
    }

    /**
     * Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process.
     * @param {Integer} BufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {PSTR} Buffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://docs.microsoft.com/windows/win32/api//fileapi/nf-fileapi-gettemppath2a
     */
    static GetTempPath2A(BufferLength, Buffer) {
        Buffer := Buffer is String ? StrPtr(Buffer) : Buffer

        result := DllCall("KERNEL32.dll\GetTempPath2A", "uint", BufferLength, "ptr", Buffer, "uint")
        return result
    }

    /**
     * Copies an existing file to a new file. The behavior of this function is identical to CopyFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpExistingFileName The name of an existing file.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * 
     * If *lpExistingFileName* does not exist, the function fails, and [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md) returns **ERROR\_FILE\_NOT\_FOUND**.
     * @param {PWSTR} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to **MAX\_PATH** characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see [Naming a File](/windows/win32/FileIO/naming-a-file).
     * 
     * For the unicode version of this function (**CopyFileFromAppW**), you can opt-in to remove the **MAX\_PATH** limitation without prepending "\\\\?\\". See the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/FileIO/naming-a-file) for details.
     * @param {BOOL} bFailIfExists If this parameter is **TRUE** and the new file specified by *lpNewFileName* already exists, the function fails. If this parameter is **FALSE** and the new file already exists, the function overwrites the existing file and succeeds.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-copyfilefromappw
     */
    static CopyFileFromAppW(lpExistingFileName, lpNewFileName, bFailIfExists) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CopyFileFromAppW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int", bFailIfExists, "int")
        return result
    }

    /**
     * Creates a new directory. The behavior of this function is identical to CreateDirector, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpPathName The path of the directory to be created.
     *      
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a [**SECURITY\_ATTRIBUTES**](../wtypesbase/ns-wtypesbase-security_attributes.md) structure. The **lpSecurityDescriptor** member of the structure specifies a security descriptor for the new directory. If *lpSecurityAttributes* is **NULL**, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.
     *     
     * The target file system must support security on files and directories for this parameter to have an effect.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md). Possible errors include the following.
     * 
     * <table>
     * <colgroup>
     * <col style="width: 50%" />
     * <col style="width: 50%" />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><strong>ERROR_ALREADY_EXISTS</strong></td>
     * <td><p>The specified directory already exists.</p></td>
     * </tr>
     * <tr class="even">
     * <td><strong>ERROR_PATH_NOT_FOUND</strong></td>
     * <td><p>One or more intermediate directories do not exist; this function will only create the final directory in the path.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-createdirectoryfromappw
     */
    static CreateDirectoryFromAppW(lpPathName, lpSecurityAttributes) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CreateDirectoryFromAppW", "ptr", lpPathName, "ptr", lpSecurityAttributes, "int")
        return result
    }

    /**
     * Creates or opens a file or I/O device. The behavior of this function is identical to CreateFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpFileName The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name.
     *     
     * In the ANSI version of this function, the name is limited to **MAX\_PATH** characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file).
     * 
     * For information on special device names, see [Defining an MS-DOS Device Name](/windows/win32/fileio/defining-an-ms-dos-device-name).
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see [File Streams](/windows/win32/fileio/file-streams).
     * 
     * For the unicode version of this function (**CreateFileFromAppW**), you can opt-in to remove the **MAX\_PATH** limitation without prepending "\\\\?\\". See the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are **GENERIC\_READ**, **GENERIC\_WRITE**, or both (`GENERIC_READ | GENERIC_WRITE`). For more information, see [Generic Access Rights](/windows/win32/secauthz/generic-access-rights), [File Security and Access Rights](/windows/win32/fileio/file-security-and-access-rights), [**File Access Rights Constants**](/windows/win32/fileio/file-access-rights-constants), and [**ACCESS\_MASK**](/windows/win32/secauthz/access-mask).
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if **GENERIC\_READ** access would have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the *dwShareMode* parameter in an open request that already has an open handle.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
     *     
     * <table>
     * <colgroup>
     * <col style="width: 50%" />
     * <col style="width: 50%" />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="0"></span>
     * <strong>0</strong>
     * 0x00000000</td>
     * <td><p>Prevents other processes from opening a file or device if they request delete, read, or write access.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_SHARE_DELETE"></span><span id="file_share_delete"></span>
     * <strong>FILE_SHARE_DELETE</strong>
     * 0x00000004</td>
     * <td><p>Enables subsequent open operations on a file or device to request delete access.</p>
     * <p>Otherwise, other processes cannot open the file or device if they request delete access.</p>
     * <p>If this flag is not specified, but the file or device has been opened for delete access, the function fails.</p>
     * <strong>Note</strong>  Delete access allows both delete and rename operations.
     * <div>
     *  
     * </div></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_SHARE_READ"></span><span id="file_share_read"></span>
     * <strong>FILE_SHARE_READ</strong>
     * 0x00000001</td>
     * <td><p>Enables subsequent open operations on a file or device to request read access.</p>
     * <p>Otherwise, other processes cannot open the file or device if they request read access.</p>
     * <p>If this flag is not specified, but the file or device has been opened for read access, the function fails.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_SHARE_WRITE"></span><span id="file_share_write"></span>
     * <strong>FILE_SHARE_WRITE</strong>
     * 0x00000002</td>
     * <td><p>Enables subsequent open operations on a file or device to request write access.</p>
     * <p>Otherwise, other processes cannot open the file or device if they request write access.</p>
     * <p>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a [**SECURITY\_ATTRIBUTES**](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
     *     
     * This parameter can be **NULL**.
     * 
     * If this parameter is **NULL**, the handle returned cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
     * 
     * The **lpSecurityDescriptor** member of the structure specifies a [**SECURITY\_DESCRIPTOR**](../winnt/ns-winnt-security_descriptor.md) for a file or device. If this member is **NULL**, the file or device associated with the returned handle is assigned a default security descriptor.
     * 
     * This function ignores the **lpSecurityDescriptor** member when opening an existing file or device, but continues to use the **bInheritHandle** member.
     * 
     * The **bInheritHandle** member of the structure specifies whether the returned handle can be inherited.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     *     
     * For devices other than files, this parameter is usually set to **OPEN\_EXISTING**.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwFlagsAndAttributes The file or device attributes and flags, **FILE\_ATTRIBUTE\_NORMAL** being the most common default value for files.
     *     
     * This parameter can include any combination of the available file attributes (**FILE\_ATTRIBUTE\_\***). All other file attributes override **FILE\_ATTRIBUTE\_NORMAL**.
     * 
     * This parameter can also contain combinations of flags (**FILE\_FLAG\_\***) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any **FILE\_ATTRIBUTE\_\*** values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the **SECURITY\_SQOS\_PRESENT** flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
     * 
     * <table>
     * <colgroup>
     * <col style="width: 50%" />
     * <col style="width: 50%" />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_ARCHIVE"></span><span id="file_attribute_archive"></span>
     * <strong>FILE_ATTRIBUTE_ARCHIVE</strong>
     * 32 (0x20)</td>
     * <td><p>The file should be archived. Applications use this attribute to mark files for backup or removal.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_ENCRYPTED"></span><span id="file_attribute_encrypted"></span>
     * <strong>FILE_ATTRIBUTE_ENCRYPTED</strong>
     * 16384 (0x4000)</td>
     * <td><p>The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories. For more information, see <a href="https://docs.microsoft.com/windows/win32/fileio/file-encryption"><strong>File Encryption</strong></a>.</p>
     * <p>This flag has no effect if <strong>FILE_ATTRIBUTE_SYSTEM</strong> is also specified.</p>
     * <p>This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_HIDDEN"></span><span id="file_attribute_hidden"></span>
     * <strong>FILE_ATTRIBUTE_HIDDEN</strong>
     * 2 (0x2)</td>
     * <td><p>The file is hidden. Do not include it in an ordinary directory listing.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_NORMAL"></span><span id="file_attribute_normal"></span>
     * <strong>FILE_ATTRIBUTE_NORMAL</strong>
     * 128 (0x80)</td>
     * <td><p>The file does not have other attributes set. This attribute is valid only if used alone.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_OFFLINE"></span><span id="file_attribute_offline"></span>
     * <strong>FILE_ATTRIBUTE_OFFLINE</strong>
     * 4096 (0x1000)</td>
     * <td><p>The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_READONLY"></span><span id="file_attribute_readonly"></span>
     * <strong>FILE_ATTRIBUTE_READONLY</strong>
     * 1 (0x1)</td>
     * <td><p>The file is read only. Applications can read the file, but cannot write to or delete it.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_SYSTEM"></span><span id="file_attribute_system"></span>
     * <strong>FILE_ATTRIBUTE_SYSTEM</strong>
     * 4 (0x4)</td>
     * <td><p>The file is part of or used exclusively by an operating system.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_TEMPORARY"></span><span id="file_attribute_temporary"></span>
     * <strong>FILE_ATTRIBUTE_TEMPORARY</strong>
     * 256 (0x100)</td>
     * <td><p>The file is being used for temporary storage.</p>
     * <p>For more information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * 
     *  
     * 
     * <table>
     * <colgroup>
     * <col style="width: 50%" />
     * <col style="width: 50%" />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_BACKUP_SEMANTICS"></span><span id="file_flag_backup_semantics"></span>
     * <strong>FILE_FLAG_BACKUP_SEMANTICS</strong>
     * 0x02000000</td>
     * <td><p>The file is being opened or created for a backup or restore operation. The system ensures that the calling process overrides file security checks when the process has <strong>SE_BACKUP_NAME</strong> and <strong>SE_RESTORE_NAME</strong> privileges. For more information, see <a href="https://docs.microsoft.com/windows/win32/secbp/changing-privileges-in-a-token">Changing Privileges in a Token</a>.</p>
     * <p>You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks section.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_DELETE_ON_CLOSE"></span><span id="file_flag_delete_on_close"></span>
     * <strong>FILE_FLAG_DELETE_ON_CLOSE</strong>
     * 0x04000000</td>
     * <td><p>The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles.</p>
     * <p>If there are existing open handles to a file, the call fails unless they were all opened with the <strong>FILE_SHARE_DELETE</strong> share mode.</p>
     * <p>Subsequent open requests for the file fail, unless the <strong>FILE_SHARE_DELETE</strong> share mode is specified.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_NO_BUFFERING"></span><span id="file_flag_no_buffering"></span>
     * <strong>FILE_FLAG_NO_BUFFERING</strong>
     * 0x20000000</td>
     * <td><p>The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard disk caching or memory mapped files.</p>
     * <p>There are strict requirements for successfully working with files opened with this function using the <strong>FILE_FLAG_NO_BUFFERING</strong> flag, for details see <a href="https://docs.microsoft.com/windows/win32/fileio/file-buffering">File Buffering</a>.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_OPEN_NO_RECALL"></span><span id="file_flag_open_no_recall"></span>
     * <strong>FILE_FLAG_OPEN_NO_RECALL</strong>
     * 0x00100000</td>
     * <td><p>The file data is requested, but it should continue to be located in remote storage. It should not be transported back to local storage. This flag is for use by remote storage systems.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_OPEN_REPARSE_POINT"></span><span id="file_flag_open_reparse_point"></span>
     * <strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>
     * 0x00200000</td>
     * <td><p>Normal <a href="https://docs.microsoft.com/windows/win32/fileio/reparse-points">reparse point</a> processing will not occur; this function will attempt to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.</p>
     * <p>This flag cannot be used with the <strong>CREATE_ALWAYS</strong> flag.</p>
     * <p>If the file is not a reparse point, then this flag is ignored.</p>
     * <p>For more information, see the Remarks section.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_OVERLAPPED"></span><span id="file_flag_overlapped"></span>
     * <strong>FILE_FLAG_OVERLAPPED</strong>
     * 0x40000000</td>
     * <td><p>The file or device is being opened or created for asynchronous I/O.</p>
     * <p>When subsequent I/O operations are completed on this handle, the event specified in the <a href="https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure will be set to the signaled state.</p>
     * <p>If this flag is specified, the file can be used for simultaneous read and write operations.</p>
     * <p>If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an <a href="https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure.</p>
     * <p>For information about considerations when using a file handle created with this flag, see the Synchronous and Asynchronous I/O Handles section of this topic.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_POSIX_SEMANTICS"></span><span id="file_flag_posix_semantics"></span>
     * <strong>FILE_FLAG_POSIX_SEMANTICS</strong>
     * 0x0100000</td>
     * <td><p>Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file systems that support that naming. Use care when using this option, because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_RANDOM_ACCESS"></span><span id="file_flag_random_access"></span>
     * <strong>FILE_FLAG_RANDOM_ACCESS</strong>
     * 0x10000000</td>
     * <td><p>Access is intended to be random. The system can use this as a hint to optimize file caching.</p>
     * <p>This flag has no effect if the file system does not support cached I/O and <strong>FILE_FLAG_NO_BUFFERING</strong>.</p>
     * <p>For more information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_SESSION_AWARE"></span><span id="file_flag_session_aware"></span>
     * <strong>FILE_FLAG_SESSION_AWARE</strong>
     * 0x00800000</td>
     * <td><p>The file or device is being opened with session awareness. If this flag is not specified, then per-session devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for callers not in session 0. This flag is supported only on server editions of Windows.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_SEQUENTIAL_SCAN"></span><span id="file_flag_sequential_scan"></span>
     * <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong>
     * 0x08000000</td>
     * <td><p>Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.</p>
     * <p>This flag should not be used if read-behind (that is, reverse scans) will be used.</p>
     * <p>This flag has no effect if the file system does not support cached I/O and <strong>FILE_FLAG_NO_BUFFERING</strong>.</p>
     * <p>For more information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_WRITE_THROUGH"></span><span id="file_flag_write_through"></span>
     * <strong>FILE_FLAG_WRITE_THROUGH</strong>
     * 0x80000000</td>
     * <td><p>Write operations will not go through any intermediate cache, they will go directly to disk.</p>
     * <p>For additional information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @param {HANDLE} hTemplateFile A valid handle to a template file with the **GENERIC\_READ** access right. The template file supplies file attributes and extended attributes for the file that is being created.
     *     
     * This parameter can be **NULL**.
     * 
     * When opening an existing file, this parameter is ignored.
     * 
     * When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For more information, see [File Encryption](/windows/win32/fileio/file-encryption).
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
     * 
     * If the function fails, the return value is **INVALID\_HANDLE\_VALUE**. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-createfilefromappw
     */
    static CreateFileFromAppW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTemplateFile := hTemplateFile is Win32Handle ? NumGet(hTemplateFile, "ptr") : hTemplateFile

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CreateFileFromAppW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile, "ptr")
        return HANDLE({Value: result}, True)
    }

    /**
     * Creates or opens a file or I/O device. The behavior of this function is identical to CreateFile2, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpFileName The name of the file or device to be created or opened.
     *     
     * For information on special device names, see [Defining an MS-DOS Device Name](/windows/win32/fileio/defining-an-ms-dos-device-name).
     *     
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see [File Streams](/windows/win32/fileio/file-streams).
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are **GENERIC\_READ**, **GENERIC\_WRITE**, or both (`GENERIC_READ | GENERIC_WRITE`). For more information, see [Generic Access Rights](/windows/win32/secauthz/generic-access-rights), [File Security and Access Rights](/windows/win32/fileio/file-security-and-access-rights), [**File Access Rights Constants**](/windows/win32/fileio/file-access-rights-constants), and [**ACCESS\_MASK**](/windows/win32/secauthz/access-mask).
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if **GENERIC\_READ** access would have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the *dwShareMode* parameter in an open request that already has an open handle.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
     *     
     * If this parameter is zero and the function succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
     * 
     * You can't request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. This function would fail and the [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md) function would return **ERROR\_SHARING\_VIOLATION**.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     *     
     * For devices other than files, this parameter is usually set to **OPEN\_EXISTING**.
     * @param {Pointer<CREATEFILE2_EXTENDED_PARAMETERS>} pCreateExParams Pointer to an optional [**CREATEFILE2\_EXTENDED\_PARAMETERS**](../fileapi/ns-fileapi-createfile2_extended_parameters.md) structure.
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
     * 
     * If the function fails, the return value is **INVALID\_HANDLE\_VALUE**. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-createfile2fromappw
     */
    static CreateFile2FromAppW(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CreateFile2FromAppW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "uint", dwCreationDisposition, "ptr", pCreateExParams, "ptr")
        return HANDLE({Value: result}, True)
    }

    /**
     * Deletes an existing file. The behavior of this function is identical to DeleteFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpFileName The name of the file to be deleted.
     *     
     * In the ANSI version of this function, the name is limited to **MAX\_PATH** characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file).
     * 
     * For the unicode version of this function (**DeleteFileFromAppW**), you can opt-in to remove the **MAX\_PATH** character limitation without prepending "\\\\?\\". See the "Maximum Path Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-deletefilefromappw
     */
    static DeleteFileFromAppW(lpFileName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\DeleteFileFromAppW", "ptr", lpFileName, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} lpFileName 
     * @param {Integer} fInfoLevelId 
     * @param {Pointer<Void>} lpFindFileData 
     * @param {Integer} fSearchOp 
     * @param {Integer} dwAdditionalFlags 
     * @returns {HANDLE} 
     */
    static FindFirstFileExFromAppW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\FindFirstFileExFromAppW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags, "ptr")
        return HANDLE({Value: result}, True)
    }

    /**
     * 
     * @param {PWSTR} lpFileName 
     * @param {Integer} fInfoLevelId 
     * @param {Pointer<Void>} lpFileInformation 
     * @returns {BOOL} 
     */
    static GetFileAttributesExFromAppW(lpFileName, fInfoLevelId, lpFileInformation) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\GetFileAttributesExFromAppW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "int")
        return result
    }

    /**
     * Moves an existing file or a directory, including its children. The behavior of this function is identical to MoveFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpExistingFileName The current name of the file or directory on the local computer.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {PWSTR} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-movefilefromappw
     */
    static MoveFileFromAppW(lpExistingFileName, lpNewFileName) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\MoveFileFromAppW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int")
        return result
    }

    /**
     * Deletes an existing empty directory. The behavior of this function is identical to RemoveDirectory, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpPathName The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @returns {BOOL} If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-removedirectoryfromappw
     */
    static RemoveDirectoryFromAppW(lpPathName) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\RemoveDirectoryFromAppW", "ptr", lpPathName, "int")
        return result
    }

    /**
     * Replaces one file with another file, with the option of creating a backup copy of the original file. The behavior of this function is identical to ReplaceFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpReplacedFileName For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     *     
     * This file is opened with the **GENERIC\_READ**, **DELETE**, and **SYNCHRONIZE** access rights. The sharing mode is **FILE\_SHARE\_READ** | **FILE\_SHARE\_WRITE** | **FILE\_SHARE\_DELETE**.
     *     
     * The caller must have write access to the file to be replaced. For more information, see [File Security and Access Rights](/windows/win32/fileio/file-security-and-access-rights).
     * @param {PWSTR} lpReplacementFileName The name of the file that will replace the *lpReplacedFileName* file.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * 
     *     
     * The function attempts to open this file with the **SYNCHRONIZE**, **GENERIC\_READ**, **GENERIC\_WRITE**, **DELETE**, and **WRITE\_DAC** access rights so that it can preserve all attributes and ACLs. If this fails, the function attempts to open the file with the **SYNCHRONIZE**, **GENERIC\_READ**, **DELETE**, and **WRITE\_DAC** access rights. No sharing mode is specified.
     * @param {PWSTR} lpBackupFileName The name of the file that will serve as a backup copy of the *lpReplacedFileName* file. If this parameter is **NULL**, no backup file is created. See the Remarks section for implementation details on the backup file.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwReplaceFlags 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md). The following are possible error codes for this function.
     * 
     * <table>
     * <colgroup>
     * <col style="width: 50%" />
     * <col style="width: 50%" />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><strong>ERROR_UNABLE_TO_MOVE_REPLACEMENT</strong>
     * 1176 (0x498)</td>
     * <td><p>The replacement file could not be renamed. If <em>lpBackupFileName</em> was specified, the replaced and replacement files retain their original file names. Otherwise, the replaced file no longer exists and the replacement file exists under its original name.</p></td>
     * </tr>
     * <tr class="even">
     * <td><strong>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</strong>
     * 1177 (0x499)</td>
     * <td><p>The replacement file could not be moved. The replacement file still exists under its original name; however, it has inherited the file streams and attributes from the file it is replacing. The file to be replaced still exists with a different name. If <em>lpBackupFileName</em> is specified, it will be the name of the replaced file.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><strong>ERROR_UNABLE_TO_REMOVE_REPLACED</strong>
     * 1175 (0x497)</td>
     * <td><p>The replaced file could not be deleted. The replaced and replacement files retain their original file names.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * 
     *  
     * 
     * If any other error is returned, such as **ERROR\_INVALID\_PARAMETER**, the replaced and replacement files will retain their original file names. In this scenario, a backup file does not exist and it is not guaranteed that the replacement file will have inherited all of the attributes and streams of the replaced file.
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-replacefilefromappw
     */
    static ReplaceFileFromAppW(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags) {
        static lpExclude := 0, lpReserved := 0 ;Reserved parameters must always be NULL

        lpReplacedFileName := lpReplacedFileName is String ? StrPtr(lpReplacedFileName) : lpReplacedFileName
        lpReplacementFileName := lpReplacementFileName is String ? StrPtr(lpReplacementFileName) : lpReplacementFileName
        lpBackupFileName := lpBackupFileName is String ? StrPtr(lpBackupFileName) : lpBackupFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\ReplaceFileFromAppW", "ptr", lpReplacedFileName, "ptr", lpReplacementFileName, "ptr", lpBackupFileName, "uint", dwReplaceFlags, "ptr", lpExclude, "ptr", lpReserved, "int")
        return result
    }

    /**
     * Sets the attributes for a file or directory. The behavior of this function is identical to SetFileAttributes, except that this function adheres to the Universal Windows Platform app security model.
     * @param {PWSTR} lpFileName The name of the file whose attributes are to be set.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     *     
     * This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override **FILE\_ATTRIBUTE\_NORMAL**.
     * 
     * Not all attributes are supported by this function.
     * 
     * The following is a list of supported attribute values.
     * 
     * <table>
     * <colgroup>
     * <col style="width: 50%" />
     * <col style="width: 50%" />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_ARCHIVE"></span><span id="file_attribute_archive"></span>
     * <strong>FILE_ATTRIBUTE_ARCHIVE</strong>
     * 32 (0x20)</td>
     * <td><p>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_HIDDEN"></span><span id="file_attribute_hidden"></span>
     * <strong>FILE_ATTRIBUTE_HIDDEN</strong>
     * 2 (0x2)</td>
     * <td><p>The file or directory is hidden. It is not included in an ordinary directory listing.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_NORMAL"></span><span id="file_attribute_normal"></span>
     * <strong>FILE_ATTRIBUTE_NORMAL</strong>
     * 128 (0x80)</td>
     * <td><p>A file that does not have other attributes set. This attribute is valid only when used alone.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></span><span id="file_attribute_not_content_indexed"></span>
     * <strong>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</strong>
     * 8192 (0x2000)</td>
     * <td><p>The file or directory is not to be indexed by the content indexing service.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_OFFLINE"></span><span id="file_attribute_offline"></span>
     * <strong>FILE_ATTRIBUTE_OFFLINE</strong>
     * 4096 (0x1000)</td>
     * <td><p>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_READONLY"></span><span id="file_attribute_readonly"></span>
     * <strong>FILE_ATTRIBUTE_READONLY</strong>
     * 1 (0x1)</td>
     * <td><p>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_SYSTEM"></span><span id="file_attribute_system"></span>
     * <strong>FILE_ATTRIBUTE_SYSTEM</strong>
     * 4 (0x4)</td>
     * <td><p>A file or directory that the operating system uses a part of, or uses exclusively.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_TEMPORARY"></span><span id="file_attribute_temporary"></span>
     * <strong>FILE_ATTRIBUTE_TEMPORARY</strong>
     * 256 (0x100)</td>
     * <td><p>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://docs.microsoft.com/windows/win32/api//fileapifromapp/nf-fileapifromapp-setfileattributesfromappw
     */
    static SetFileAttributesFromAppW(lpFileName, dwFileAttributes) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\SetFileAttributesFromAppW", "ptr", lpFileName, "uint", dwFileAttributes, "int")
        return result
    }

    /**
     * Determines where to install a file based on whether it locates another version of the file in the system. The values VerFindFile returns in the specified buffers are used in a subsequent call to the VerInstallFile function.
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * 
     * This parameter can be the following value. All other bits are reserved. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="VFFF_ISSHAREDFILE"></a><a id="vfff_issharedfile"></a><dl>
     * <dt><b>VFFF_ISSHAREDFILE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file can be shared by multiple applications. An application can use this information to determine where the file should be copied.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} szFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. Include only the file name and extension, not a path.
     * @param {PSTR} szWinDir Type: <b>LPCTSTR</b>
     * 
     * The directory in which Windows is running or will be run. This string is returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya">GetWindowsDirectory</a> function.
     * @param {PSTR} szAppDir Type: <b>LPCTSTR</b>
     * 
     * The directory where the installation program is installing a set of related files. If the installation program is installing an application, this is the directory where the application will reside. This parameter also points to the application's current directory unless otherwise specified.
     * @param {PSTR} szCurDir Type: <b>LPWSTR</b>
     * 
     * A buffer that receives the path to a current version of the file being installed. The path is a zero-terminated string. If a current version is not installed, the buffer will contain a zero-length string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puCurDirLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szCurDir</i>  buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuCurDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szCurDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuCurDirLen</i> will be the size of the buffer required to hold the path.
     * @param {PSTR} szDestDir Type: <b>LPTSTR</b>
     * 
     * A buffer that receives the path to the installation location recommended by <b>VerFindFile</b>. The path is a zero-terminated string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puDestDirLen Type: <b>PUINT</b>
     * 
     * A pointer to a variable that specifies the length of the 
     * 					<i>szDestDir</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuDestDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szDestDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuDestDirLen</i> will be the size of the buffer needed to hold the path.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates the status of the file. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_CURNEDEST</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The currently installed version of the file is not in the recommended destination.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_FILEINUSE</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is using the currently installed version of the file; therefore, the file cannot be overwritten or deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_BUFFTOOSMALL</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * At least one of the buffers was too small to contain the corresponding string. An application should check the output buffers to determine which buffer was too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verfindfilea
     * @since windows5.0
     */
    static VerFindFileA(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen) {
        szFileName := szFileName is String ? StrPtr(szFileName) : szFileName
        szWinDir := szWinDir is String ? StrPtr(szWinDir) : szWinDir
        szAppDir := szAppDir is String ? StrPtr(szAppDir) : szAppDir
        szCurDir := szCurDir is String ? StrPtr(szCurDir) : szCurDir
        szDestDir := szDestDir is String ? StrPtr(szDestDir) : szDestDir

        result := DllCall("VERSION.dll\VerFindFileA", "uint", uFlags, "ptr", szFileName, "ptr", szWinDir, "ptr", szAppDir, "ptr", szCurDir, "uint*", puCurDirLen, "ptr", szDestDir, "uint*", puDestDirLen, "uint")
        return result
    }

    /**
     * Determines where to install a file based on whether it locates another version of the file in the system. The values VerFindFile returns in the specified buffers are used in a subsequent call to the VerInstallFile function.
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * 
     * This parameter can be the following value. All other bits are reserved. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="VFFF_ISSHAREDFILE"></a><a id="vfff_issharedfile"></a><dl>
     * <dt><b>VFFF_ISSHAREDFILE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file can be shared by multiple applications. An application can use this information to determine where the file should be copied.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} szFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. Include only the file name and extension, not a path.
     * @param {PWSTR} szWinDir Type: <b>LPCTSTR</b>
     * 
     * The directory in which Windows is running or will be run. This string is returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya">GetWindowsDirectory</a> function.
     * @param {PWSTR} szAppDir Type: <b>LPCTSTR</b>
     * 
     * The directory where the installation program is installing a set of related files. If the installation program is installing an application, this is the directory where the application will reside. This parameter also points to the application's current directory unless otherwise specified.
     * @param {PWSTR} szCurDir Type: <b>LPWSTR</b>
     * 
     * A buffer that receives the path to a current version of the file being installed. The path is a zero-terminated string. If a current version is not installed, the buffer will contain a zero-length string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puCurDirLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szCurDir</i>  buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuCurDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szCurDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuCurDirLen</i> will be the size of the buffer required to hold the path.
     * @param {PWSTR} szDestDir Type: <b>LPTSTR</b>
     * 
     * A buffer that receives the path to the installation location recommended by <b>VerFindFile</b>. The path is a zero-terminated string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puDestDirLen Type: <b>PUINT</b>
     * 
     * A pointer to a variable that specifies the length of the 
     * 					<i>szDestDir</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuDestDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szDestDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuDestDirLen</i> will be the size of the buffer needed to hold the path.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates the status of the file. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_CURNEDEST</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The currently installed version of the file is not in the recommended destination.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_FILEINUSE</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is using the currently installed version of the file; therefore, the file cannot be overwritten or deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_BUFFTOOSMALL</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * At least one of the buffers was too small to contain the corresponding string. An application should check the output buffers to determine which buffer was too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verfindfilew
     * @since windows5.0
     */
    static VerFindFileW(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen) {
        szFileName := szFileName is String ? StrPtr(szFileName) : szFileName
        szWinDir := szWinDir is String ? StrPtr(szWinDir) : szWinDir
        szAppDir := szAppDir is String ? StrPtr(szAppDir) : szAppDir
        szCurDir := szCurDir is String ? StrPtr(szCurDir) : szCurDir
        szDestDir := szDestDir is String ? StrPtr(szDestDir) : szDestDir

        result := DllCall("VERSION.dll\VerFindFileW", "uint", uFlags, "ptr", szFileName, "ptr", szWinDir, "ptr", szAppDir, "ptr", szCurDir, "uint*", puCurDirLen, "ptr", szDestDir, "uint*", puDestDirLen, "uint")
        return result
    }

    /**
     * Installs the specified file based on information returned from the VerFindFile function. VerInstallFile decompresses the file, if necessary, assigns a unique filename, and checks for errors, such as outdated files.
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * @param {PSTR} szSrcFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. This is the filename in the directory pointed to by the 
     * 					<i>szSrcDir</i> parameter; the filename can include only the filename and extension, not a path.
     * @param {PSTR} szDestFileName Type: <b>LPCTSTR</b>
     * 
     * The name <b>VerInstallFile</b> will give the new file upon installation. This file name may be different from the filename in the 
     * 					<i>szSrcFileName</i> directory. The new name should include only the file name and extension, not a path.
     * @param {PSTR} szSrcDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file can be found.
     * @param {PSTR} szDestDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file should be installed. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szDestDir</i> parameter.
     * @param {PSTR} szCurDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where a preexisting version of this file can be found. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szCurDir</i> parameter.
     * @param {PSTR} szTmpFile Type: <b>LPTSTR</b>
     * 
     * The name of a temporary copy of the source file. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required, and should be empty on input.
     * @param {Pointer<UInt32>} puTmpFileLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szTmpFile</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuTmpFileLen</i> receives the size, in characters, of the data returned in 
     * 					<i>szTmpFile</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuTmpFileLen</i> will be the size of the buffer required to hold the data.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates exceptions. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_ACCESSVIOLATION</b></dt>
     * <dt>0x00000200L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to an access violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_BUFFTOOSMALL</b></dt>
     * <dt>0x00040000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>szTmpFile</i> buffer was too small to contain the name of the temporary source file. When the function returns, <i>lpuTmpFileLen</i> contains the size of the buffer required to hold the filename.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTCREATE</b></dt>
     * <dt>0x00000800L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file. The specific error may be described by another flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETE</b></dt>
     * <dt>0x00001000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot delete the destination file, or cannot delete the existing version of the file located in another directory. If the <b>VIF_TEMPFILE</b> bit is set, the installation failed, and the destination file probably cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETECUR</b></dt>
     * <dt>0x00004000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The existing version of the file could not be deleted and <b>VIFF_DONTDELETEOLD</b> was not specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADCABINET</b></dt>
     * <dt>0x00100000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the cabinet file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADLZ32</b></dt>
     * <dt>0x00080000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADDST</b></dt>
     * <dt>0x00020000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the destination (existing) files. This prevents the function from examining the file's attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADSRC</b></dt>
     * <dt>0x00010000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the source file. This could mean that the path was not specified properly.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTRENAME</b></dt>
     * <dt>0x00002000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot rename the temporary file, but already deleted the destination file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFCODEPG</b></dt>
     * <dt>0x00000010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file requires a code page that cannot be displayed by the version of the system currently running. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFLANG</b></dt>
     * <dt>0x00000008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files have different language or code-page values. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFTYPE</b></dt>
     * <dt>0x00000020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file has a different type, subtype, or operating system from the preexisting file. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_FILEINUSE</b></dt>
     * <dt>0x00000080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is in use by the system and cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_MISMATCH</b></dt>
     * <dt>0x00000002L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files differ in one or more attributes. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFMEMORY</b></dt>
     * <dt>0x00008000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot complete the requested operation due to insufficient memory. Generally, this means the application ran out of memory attempting to expand a compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFSPACE</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file due to insufficient disk space on the destination drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SHARINGVIOLATION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to a sharing violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SRCOLD</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file to install is older than the preexisting file. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_TEMPFILE</b></dt>
     * <dt>0x00000001L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The temporary copy of the new file is in the destination directory. The cause of failure is reflected in other flags.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_WRITEPROT</b></dt>
     * <dt>0x00000040L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is write-protected. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verinstallfilea
     * @since windows5.0
     */
    static VerInstallFileA(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen) {
        szSrcFileName := szSrcFileName is String ? StrPtr(szSrcFileName) : szSrcFileName
        szDestFileName := szDestFileName is String ? StrPtr(szDestFileName) : szDestFileName
        szSrcDir := szSrcDir is String ? StrPtr(szSrcDir) : szSrcDir
        szDestDir := szDestDir is String ? StrPtr(szDestDir) : szDestDir
        szCurDir := szCurDir is String ? StrPtr(szCurDir) : szCurDir
        szTmpFile := szTmpFile is String ? StrPtr(szTmpFile) : szTmpFile

        result := DllCall("VERSION.dll\VerInstallFileA", "uint", uFlags, "ptr", szSrcFileName, "ptr", szDestFileName, "ptr", szSrcDir, "ptr", szDestDir, "ptr", szCurDir, "ptr", szTmpFile, "uint*", puTmpFileLen, "uint")
        return result
    }

    /**
     * Installs the specified file based on information returned from the VerFindFile function. VerInstallFile decompresses the file, if necessary, assigns a unique filename, and checks for errors, such as outdated files.
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * @param {PWSTR} szSrcFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. This is the filename in the directory pointed to by the 
     * 					<i>szSrcDir</i> parameter; the filename can include only the filename and extension, not a path.
     * @param {PWSTR} szDestFileName Type: <b>LPCTSTR</b>
     * 
     * The name <b>VerInstallFile</b> will give the new file upon installation. This file name may be different from the filename in the 
     * 					<i>szSrcFileName</i> directory. The new name should include only the file name and extension, not a path.
     * @param {PWSTR} szSrcDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file can be found.
     * @param {PWSTR} szDestDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file should be installed. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szDestDir</i> parameter.
     * @param {PWSTR} szCurDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where a preexisting version of this file can be found. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szCurDir</i> parameter.
     * @param {PWSTR} szTmpFile Type: <b>LPTSTR</b>
     * 
     * The name of a temporary copy of the source file. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required, and should be empty on input.
     * @param {Pointer<UInt32>} puTmpFileLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szTmpFile</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuTmpFileLen</i> receives the size, in characters, of the data returned in 
     * 					<i>szTmpFile</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuTmpFileLen</i> will be the size of the buffer required to hold the data.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates exceptions. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_ACCESSVIOLATION</b></dt>
     * <dt>0x00000200L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to an access violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_BUFFTOOSMALL</b></dt>
     * <dt>0x00040000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>szTmpFile</i> buffer was too small to contain the name of the temporary source file. When the function returns, <i>lpuTmpFileLen</i> contains the size of the buffer required to hold the filename.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTCREATE</b></dt>
     * <dt>0x00000800L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file. The specific error may be described by another flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETE</b></dt>
     * <dt>0x00001000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot delete the destination file, or cannot delete the existing version of the file located in another directory. If the <b>VIF_TEMPFILE</b> bit is set, the installation failed, and the destination file probably cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETECUR</b></dt>
     * <dt>0x00004000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The existing version of the file could not be deleted and <b>VIFF_DONTDELETEOLD</b> was not specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADCABINET</b></dt>
     * <dt>0x00100000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the cabinet file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADLZ32</b></dt>
     * <dt>0x00080000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADDST</b></dt>
     * <dt>0x00020000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the destination (existing) files. This prevents the function from examining the file's attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADSRC</b></dt>
     * <dt>0x00010000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the source file. This could mean that the path was not specified properly.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTRENAME</b></dt>
     * <dt>0x00002000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot rename the temporary file, but already deleted the destination file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFCODEPG</b></dt>
     * <dt>0x00000010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file requires a code page that cannot be displayed by the version of the system currently running. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFLANG</b></dt>
     * <dt>0x00000008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files have different language or code-page values. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFTYPE</b></dt>
     * <dt>0x00000020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file has a different type, subtype, or operating system from the preexisting file. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_FILEINUSE</b></dt>
     * <dt>0x00000080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is in use by the system and cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_MISMATCH</b></dt>
     * <dt>0x00000002L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files differ in one or more attributes. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFMEMORY</b></dt>
     * <dt>0x00008000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot complete the requested operation due to insufficient memory. Generally, this means the application ran out of memory attempting to expand a compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFSPACE</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file due to insufficient disk space on the destination drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SHARINGVIOLATION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to a sharing violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SRCOLD</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file to install is older than the preexisting file. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_TEMPFILE</b></dt>
     * <dt>0x00000001L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The temporary copy of the new file is in the destination directory. The cause of failure is reflected in other flags.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_WRITEPROT</b></dt>
     * <dt>0x00000040L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is write-protected. This error can be overridden by calling <a href="/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verinstallfilew
     * @since windows5.0
     */
    static VerInstallFileW(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen) {
        szSrcFileName := szSrcFileName is String ? StrPtr(szSrcFileName) : szSrcFileName
        szDestFileName := szDestFileName is String ? StrPtr(szDestFileName) : szDestFileName
        szSrcDir := szSrcDir is String ? StrPtr(szSrcDir) : szSrcDir
        szDestDir := szDestDir is String ? StrPtr(szDestDir) : szDestDir
        szCurDir := szCurDir is String ? StrPtr(szCurDir) : szCurDir
        szTmpFile := szTmpFile is String ? StrPtr(szTmpFile) : szTmpFile

        result := DllCall("VERSION.dll\VerInstallFileW", "uint", uFlags, "ptr", szSrcFileName, "ptr", szDestFileName, "ptr", szSrcDir, "ptr", szDestDir, "ptr", szCurDir, "ptr", szTmpFile, "uint*", puTmpFileLen, "uint")
        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSize returns the size, in bytes, of that information.
     * @param {PSTR} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * A pointer to a variable that the function sets to zero.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfosizea
     * @since windows5.0
     */
    static GetFileVersionInfoSizeA(lptstrFilename, lpdwHandle) {
        lptstrFilename := lptstrFilename is String ? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeA", "ptr", lptstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSize returns the size, in bytes, of that information.
     * @param {PWSTR} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * A pointer to a variable that the function sets to zero.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfosizew
     * @since windows5.0
     */
    static GetFileVersionInfoSizeW(lptstrFilename, lpdwHandle) {
        lptstrFilename := lptstrFilename is String ? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeW", "ptr", lptstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file.
     * @param {PSTR} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the 
     * 					<i>lpData</i> parameter. 
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizea">GetFileVersionInfoSize</a> function first to determine the size, in bytes, of a file's version information. The 
     * 						<i>dwLen</i> member should be equal to or greater than that value. 
     * 
     * If the buffer pointed to by 
     * 						<i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * Pointer to a buffer that receives the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfoa
     * @since windows5.0
     */
    static GetFileVersionInfoA(lptstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lptstrFilename := lptstrFilename is String ? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoA", "ptr", lptstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file.
     * @param {PWSTR} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the 
     * 					<i>lpData</i> parameter. 
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizea">GetFileVersionInfoSize</a> function first to determine the size, in bytes, of a file's version information. The 
     * 						<i>dwLen</i> member should be equal to or greater than that value. 
     * 
     * If the buffer pointed to by 
     * 						<i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * Pointer to a buffer that receives the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfow
     * @since windows5.0
     */
    static GetFileVersionInfoW(lptstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lptstrFilename := lptstrFilename is String ? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoW", "ptr", lptstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSizeEx returns the size, in bytes, of that information.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls which MUI DLLs (if any) from which the version resource is extracted. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * When this function returns, contains a pointer to a variable that is set to zero because this function sets it to zero. This parameter exists for historical reasons.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     *                     
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfosizeexa
     * @since windows6.0.6000
     */
    static GetFileVersionInfoSizeExA(dwFlags, lpwstrFilename, lpdwHandle) {
        lpwstrFilename := lpwstrFilename is String ? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeExA", "uint", dwFlags, "ptr", lpwstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSizeEx returns the size, in bytes, of that information.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls which MUI DLLs (if any) from which the version resource is extracted. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * When this function returns, contains a pointer to a variable that is set to zero because this function sets it to zero. This parameter exists for historical reasons.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     *                     
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfosizeexw
     * @since windows6.0.6000
     */
    static GetFileVersionInfoSizeExW(dwFlags, lpwstrFilename, lpdwHandle) {
        lpwstrFilename := lpwstrFilename is String ? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeExW", "uint", dwFlags, "ptr", lpwstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls the MUI DLLs (if any) from which the version resource is extracted. The value of this flag must match the flags passed to the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> call, which was used to determine the buffer size that is passed in the <i>dwLen</i> parameter. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_PREFETCHED"></a><a id="file_ver_get_prefetched"></a><dl>
     * <dt><b>FILE_VER_GET_PREFETCHED</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates a preference for version.dll to attempt to preload the image outside of the loader lock to avoid contention.  This flag does not change the behavior or semantics of the function.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PSTR} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the <i>lpData</i> parameter. 
     * 
     *                     
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> function first to determine the size, in bytes, of a file's version information. The <i>dwLen</i> parameter should be equal to or greater than that value.
     * 
     * If the buffer pointed to by <i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * When this function returns, contains a pointer to a buffer that contains the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfoexa
     * @since windows6.0.6000
     */
    static GetFileVersionInfoExA(dwFlags, lpwstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lpwstrFilename := lpwstrFilename is String ? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoExA", "uint", dwFlags, "ptr", lpwstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file.
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls the MUI DLLs (if any) from which the version resource is extracted. The value of this flag must match the flags passed to the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> call, which was used to determine the buffer size that is passed in the <i>dwLen</i> parameter. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_PREFETCHED"></a><a id="file_ver_get_prefetched"></a><dl>
     * <dt><b>FILE_VER_GET_PREFETCHED</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates a preference for version.dll to attempt to preload the image outside of the loader lock to avoid contention.  This flag does not change the behavior or semantics of the function.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the <i>lpData</i> parameter. 
     * 
     *                     
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> function first to determine the size, in bytes, of a file's version information. The <i>dwLen</i> parameter should be equal to or greater than that value.
     * 
     * If the buffer pointed to by <i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * When this function returns, contains a pointer to a buffer that contains the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-getfileversioninfoexw
     * @since windows6.0.6000
     */
    static GetFileVersionInfoExW(dwFlags, lpwstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lpwstrFilename := lpwstrFilename is String ? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoExW", "uint", dwFlags, "ptr", lpwstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a description string for the language associated with a specified binary Microsoft language identifier.
     * @param {Integer} wLang Type: <b>DWORD</b>
     * 
     * The binary language identifier. For a complete list of the language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language Identifiers</a>.
     * 
     * For example, the description string associated with the language identifier 0x040A is "Spanish (Traditional Sort)". If the identifier is unknown, the <i>szLang</i> parameter points to a default string ("Language Neutral").
     * @param {PSTR} szLang Type: <b>LPTSTR</b>
     * 
     * The language specified by the <i>wLang</i> parameter.
     * @param {Integer} cchLang Type: <b>DWORD</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>szLang</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the size, in characters, of the string returned in the buffer. This value does not include the terminating null character. If the description string is smaller than or equal to the buffer, the entire description string is in the buffer. If the description string is larger than the buffer, the description string is truncated to the length of the buffer.
     * 
     * If an error occurs, the return value is zero. Unknown language identifiers do not produce errors.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verlanguagenamea
     * @since windows5.0
     */
    static VerLanguageNameA(wLang, szLang, cchLang) {
        szLang := szLang is String ? StrPtr(szLang) : szLang

        result := DllCall("KERNEL32.dll\VerLanguageNameA", "uint", wLang, "ptr", szLang, "uint", cchLang, "uint")
        return result
    }

    /**
     * Retrieves a description string for the language associated with a specified binary Microsoft language identifier.
     * @param {Integer} wLang Type: <b>DWORD</b>
     * 
     * The binary language identifier. For a complete list of the language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language Identifiers</a>.
     * 
     * For example, the description string associated with the language identifier 0x040A is "Spanish (Traditional Sort)". If the identifier is unknown, the <i>szLang</i> parameter points to a default string ("Language Neutral").
     * @param {PWSTR} szLang Type: <b>LPTSTR</b>
     * 
     * The language specified by the <i>wLang</i> parameter.
     * @param {Integer} cchLang Type: <b>DWORD</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>szLang</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the size, in characters, of the string returned in the buffer. This value does not include the terminating null character. If the description string is smaller than or equal to the buffer, the entire description string is in the buffer. If the description string is larger than the buffer, the description string is truncated to the length of the buffer.
     * 
     * If an error occurs, the return value is zero. Unknown language identifiers do not produce errors.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verlanguagenamew
     * @since windows5.0
     */
    static VerLanguageNameW(wLang, szLang, cchLang) {
        szLang := szLang is String ? StrPtr(szLang) : szLang

        result := DllCall("KERNEL32.dll\VerLanguageNameW", "uint", wLang, "ptr", szLang, "uint", cchLang, "uint")
        return result
    }

    /**
     * Retrieves specified version information from the specified version-information resource.
     * @param {Pointer<Void>} pBlock Type: <b>LPCVOID</b>
     * 
     * The version-information resource returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoa">GetFileVersionInfo</a> function.
     * @param {PSTR} lpSubBlock Type: <b>LPCTSTR</b>
     * 
     * The version-information value to be retrieved. The string must consist of names separated by backslashes (\\) and it must have one of the following forms.
     * @param {Pointer<Void>} lplpBuffer Type: <b>LPVOID*</b>
     * 
     * When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by <i>pBlock</i>. The memory pointed to by <i>lplpBuffer</i> is freed when the associated <i>pBlock</i> memory is freed.
     * @param {Pointer<UInt32>} puLen Type: <b>PUINT</b>
     * 
     * When this method returns, contains a pointer to the size of the requested data pointed to by <i>lplpBuffer</i>: for version information values, the length in characters of the string stored at <i>lplpBuffer</i>; for translation array values, the size in bytes of the array stored at <i>lplpBuffer</i>; and for root block, the size in bytes of the structure.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the specified version-information structure exists, and version information is available, the return value is nonzero. If the address of the length buffer is zero, no value is available for the specified version-information name.
     * 
     * If the specified name does not exist or the specified resource is not valid, the return value is zero.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verqueryvaluea
     * @since windows5.0
     */
    static VerQueryValueA(pBlock, lpSubBlock, lplpBuffer, puLen) {
        lpSubBlock := lpSubBlock is String ? StrPtr(lpSubBlock) : lpSubBlock

        result := DllCall("VERSION.dll\VerQueryValueA", "ptr", pBlock, "ptr", lpSubBlock, "ptr", lplpBuffer, "uint*", puLen, "int")
        return result
    }

    /**
     * Retrieves specified version information from the specified version-information resource.
     * @param {Pointer<Void>} pBlock Type: <b>LPCVOID</b>
     * 
     * The version-information resource returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoa">GetFileVersionInfo</a> function.
     * @param {PWSTR} lpSubBlock Type: <b>LPCTSTR</b>
     * 
     * The version-information value to be retrieved. The string must consist of names separated by backslashes (\\) and it must have one of the following forms.
     * @param {Pointer<Void>} lplpBuffer Type: <b>LPVOID*</b>
     * 
     * When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by <i>pBlock</i>. The memory pointed to by <i>lplpBuffer</i> is freed when the associated <i>pBlock</i> memory is freed.
     * @param {Pointer<UInt32>} puLen Type: <b>PUINT</b>
     * 
     * When this method returns, contains a pointer to the size of the requested data pointed to by <i>lplpBuffer</i>: for version information values, the length in characters of the string stored at <i>lplpBuffer</i>; for translation array values, the size in bytes of the array stored at <i>lplpBuffer</i>; and for root block, the size in bytes of the structure.
     * @returns {BOOL} Type: <b>BOOL</b>
     * 
     * If the specified version-information structure exists, and version information is available, the return value is nonzero. If the address of the length buffer is zero, no value is available for the specified version-information name.
     * 
     * If the specified name does not exist or the specified resource is not valid, the return value is zero.
     * @see https://docs.microsoft.com/windows/win32/api//winver/nf-winver-verqueryvaluew
     * @since windows5.0
     */
    static VerQueryValueW(pBlock, lpSubBlock, lplpBuffer, puLen) {
        lpSubBlock := lpSubBlock is String ? StrPtr(lpSubBlock) : lpSubBlock

        result := DllCall("VERSION.dll\VerQueryValueW", "ptr", pBlock, "ptr", lpSubBlock, "ptr", lplpBuffer, "uint*", puLen, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<CLS_LSN>} plsn1 
     * @param {Pointer<CLS_LSN>} plsn2 
     * @returns {BOOLEAN} 
     */
    static LsnEqual(plsn1, plsn2) {
        result := DllCall("clfsw32.dll\LsnEqual", "ptr", plsn1, "ptr", plsn2, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<CLS_LSN>} plsn1 
     * @param {Pointer<CLS_LSN>} plsn2 
     * @returns {BOOLEAN} 
     */
    static LsnLess(plsn1, plsn2) {
        result := DllCall("clfsw32.dll\LsnLess", "ptr", plsn1, "ptr", plsn2, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<CLS_LSN>} plsn1 
     * @param {Pointer<CLS_LSN>} plsn2 
     * @returns {BOOLEAN} 
     */
    static LsnGreater(plsn1, plsn2) {
        result := DllCall("clfsw32.dll\LsnGreater", "ptr", plsn1, "ptr", plsn2, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<CLS_LSN>} plsn 
     * @returns {BOOLEAN} 
     */
    static LsnNull(plsn) {
        result := DllCall("clfsw32.dll\LsnNull", "ptr", plsn, "char")
        return result
    }

    /**
     * Retrieves the logical container ID that is contained in a specified LSN.
     * @param {Pointer<CLS_LSN>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure from which the container ID is to be retrieved.
     * @returns {Integer} This function returns the logical container ID that is contained in <i>plsn</i>. The logical container ID is not necessarily the same as the ID of the physical container on stable storage.
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-lsncontainer
     * @since windows6.0.6000
     */
    static LsnContainer(plsn) {
        result := DllCall("clfsw32.dll\LsnContainer", "ptr", plsn, "uint")
        return result
    }

    /**
     * Creates a log sequence number (LSN), given a container ID, a block offset, and a record sequence number.
     * @param {Integer} cidContainer The container ID. This value must be an integer between 0x0 and 0xFFFFFFFF.
     * @param {Integer} offBlock The block offset. This value must be a multiple of 512.
     * @param {Integer} cRecord The record sequence number. This value must be  an integer between  0 - 511.
     * @returns {CLS_LSN} Returns a <a href="/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that represents the container ID, block offset, and record sequence number that is supplied by the caller.
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-lsncreate
     * @since windows6.0.6000
     */
    static LsnCreate(cidContainer, offBlock, cRecord) {
        result := DllCall("clfsw32.dll\LsnCreate", "uint", cidContainer, "uint", offBlock, "uint", cRecord, "ptr")
        return result
    }

    /**
     * Returns the sector-aligned block offset that is contained in the specified LSN.
     * @param {Pointer<CLS_LSN>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure from which the block offset is to be retrieved.
     * @returns {Integer} <b>LsnBlockOffset</b> returns the block offset that is contained in <i>plsn</i>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-lsnblockoffset
     * @since windows6.0.6000
     */
    static LsnBlockOffset(plsn) {
        result := DllCall("clfsw32.dll\LsnBlockOffset", "ptr", plsn, "uint")
        return result
    }

    /**
     * Retrieves the record sequence number that is contained in a specified LSN.
     * @param {Pointer<CLS_LSN>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure from which the record sequence number is to be retrieved.
     * @returns {Integer} The record sequence number that is contained in <i>plsn</i>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-lsnrecordsequence
     * @since windows6.0.6000
     */
    static LsnRecordSequence(plsn) {
        result := DllCall("clfsw32.dll\LsnRecordSequence", "ptr", plsn, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<CLS_LSN>} plsn 
     * @returns {BOOLEAN} 
     */
    static LsnInvalid(plsn) {
        result := DllCall("clfsw32.dll\LsnInvalid", "ptr", plsn, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<CLS_LSN>} plsn 
     * @returns {CLS_LSN} 
     */
    static LsnIncrement(plsn) {
        result := DllCall("clfsw32.dll\LsnIncrement", "ptr", plsn, "ptr")
        return result
    }

    /**
     * Creates or opens a log.
     * @param {PWSTR} pszLogFileName The name of the log.
     * 
     * This  name is specified when creating the log  by using 
     *        <b>CreateLogFile</b>. The following example identifies the 
     *        format to use.
     * 
     * <b>log :&lt;</b><i>LogName</i><b>&gt;[::&lt;</b><i>LogStreamName</i><b>&gt;]</b>
     * 
     * For example: The path "LOG:c:\MyDirectory\MyLog" creates the file 
     *        "c:\MyDirectory\MyLog.blf". The path 
     *        "\??\LOG:\HarddiskVolume1\MyDirectory\MyLog" creates the file 
     *        "\\.\HarddiskVolume1\MyDirectory\MyLog.blf", as does the path 
     *        "\clfs\Device\HarddiskVolume1\MyDirectory\MyLog".
     * 
     * &lt;<i>LogName</i>&gt; corresponds to a valid file path in the file system, and 
     *        &lt;<i>LogStreamName</i>&gt; is the unique name of a log stream in the log. For more 
     *        information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/log-types">Log Types</a>.
     * @param {Integer} fDesiredAccess The type of access that the returned handle has to the log object.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GENERIC_READ"></a><a id="generic_read"></a><dl>
     * <dt><b>GENERIC_READ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies read access to the object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GENERIC_WRITE"></a><a id="generic_write"></a><dl>
     * <dt><b>GENERIC_WRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies write access to the object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="DELETE"></a><a id="delete"></a><dl>
     * <dt><b>DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specify log deletion access
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * A bitwise <b>OR</b> of two or more of these flags allows combinations of read, write, and delete access to the object.
     *        <div class="alert"><b>Note</b>  You must specify <b>DELETE</b> access to be able to delete the log.</div>
     * <div> </div>
     * <b>Windows Server 2003 R2:  </b>This parameter must be set to <b>GENERIC_WRITE</b>.
     * @param {Integer} dwShareMode The sharing mode of a file.
     * 
     * A client cannot request a sharing mode that conflicts with any mode that is specified in any previous open 
     *        request that has an open handle.
     * 
     * If this parameter is zero and the function succeeds, the object cannot be shared and cannot be opened 
     *        again until the handle is closed.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psaLogFile A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *       structure that  specifies the security attributes of a log.
     * 
     * It determines whether the returned handle can be 
     *       inherited by child processes. If this parameter is <b>NULL</b>, the handle cannot be 
     *       inherited.
     * 
     * The <b>lpSecurityDescriptor</b> member of 
     *       <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> specifies a 
     *       <a href="https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">security descriptor</a> for the new log 
     *       handle. If <i>psaLogFile</i> is <b>NULL</b>, the object gets a default 
     *       security descriptor. The access control lists (ACL) in the default security descriptor for a log come from the 
     *       primary or impersonation token of the creator.
     * @param {Integer} fCreateDisposition An action to be taken.
     * @param {Integer} fFlagsAndAttributes The file attributes and flags for the file.
     * 
     * This parameter can take the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This non-ephemeral log should be archived.
     * 
     * If this flag is not supplied, the log does not need to be archived, and an archival tail is not maintained 
     *         for recycling log containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <b>FILE_FLAG_OVERLAPPED</b> flag is set, all other flag values are ignored.
     * 
     * Specifying <b>FILE_FLAG_OVERLAPPED</b> means that a file is opened for overlapped I/O, 
     *         which enables more than one I/O operation to be performed on the log handle. If this flag is set when creating 
     *         a log, all asynchronous I/O calls to that log must specify an overlapped structure and synchronize with the deferred completion of the call.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the log.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *       error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-createlogfile
     * @since windows6.0.6000
     */
    static CreateLogFile(pszLogFileName, fDesiredAccess, dwShareMode, psaLogFile, fCreateDisposition, fFlagsAndAttributes) {
        pszLogFileName := pszLogFileName is String ? StrPtr(pszLogFileName) : pszLogFileName

        A_LastError := 0

        result := DllCall("clfsw32.dll\CreateLogFile", "ptr", pszLogFileName, "uint", fDesiredAccess, "uint", dwShareMode, "ptr", psaLogFile, "uint", fCreateDisposition, "uint", fFlagsAndAttributes, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Marks the specified log for deletion. The log is actually deleted when all handles, marshaling areas, and read contexts to the log are closed. If the log is a physical log, its underlying containers are deleted.
     * @param {HANDLE} hLog A handle to an open log that is obtained by a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. The log must have been created with DELETE access or you cannot delete the log.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-deletelogbyhandle
     * @since windows6.0.6000
     */
    static DeleteLogByHandle(hLog) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\DeleteLogByHandle", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Marks a log for deletion. The log is actually deleted when all handles, marshaling areas, and read contexts to the log are closed. If the log is a physical log, its underlying containers are deleted.
     * @param {PWSTR} pszLogFileName The name of the log. 
     * 
     * This  name is specified when creating the log  by using  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. The following example identifies the format  to use:
     * 
     * <b>log:&lt;</b><i>log name</i><b>&gt;[::&lt;</b><i>log stream name</i><b>&gt;]</b>
     * 
     * &lt;<i>log  name</i>&gt; corresponds to a valid file path in the  file system.
     * 
     * &lt;<i>log stream name</i>&gt; is the unique name of a log stream in the log.
     * 
     *   For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/log-types">Log Types</a>.
     * @param {Pointer<Void>} pvReserved This parameter is reserved and should be set to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-deletelogfile
     * @since windows6.0.6000
     */
    static DeleteLogFile(pszLogFileName, pvReserved) {
        pszLogFileName := pszLogFileName is String ? StrPtr(pszLogFileName) : pszLogFileName

        A_LastError := 0

        result := DllCall("clfsw32.dll\DeleteLogFile", "ptr", pszLogFileName, "ptr", pvReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a container to the physical log that is associated with the log handle�if the calling process has write access to the .blf file and the ability to create files in the target directory of the container.
     * @param {HANDLE} hLog The handle to an open log. 
     * 
     * The handle must  be   obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> with write access to the log. The client application must have  write access to the .blf file, and the ability to create files in the target directory of a container.
     * @param {Pointer<UInt64>} pcbContainer The optional parameter that specifies the size of the container, in bytes.  
     * 
     * The minimum size is  512 KB for normal logs and 1024 KB for multiplexed logs. The maximum size is approximately 4 gigabytes.
     * 
     * This parameter is required if the containers are being added to a newly created log.  If a container is already created, this parameter can  be <b>NULL</b>, or some value that is at least as large as the size of the first container. 
     * 
     * 
     * Log container sizes are multiples of the log region size  (512 KB).  When you add a container to a new file, the <b>AddLogContainer</b> function rounds the size of the container up to the next 512 KB boundary, and returns that size in the value pointed to by <i>pcbContainer</i>.  
     * 
     * Similarly,  if the log already has at least one container and the value of <i>*pcbContainer</i> is at least as large as the current container size, the function creates all containers with the current internal size and returns that size in <i>*pcbContainer</i>.
     * @param {PWSTR} pwszContainerPath A pointer to a null-terminated string that contains a valid path for the new container on a log volume.
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>pReserved</i> to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-addlogcontainer
     * @since windows6.0.6000
     */
    static AddLogContainer(hLog, pcbContainer, pwszContainerPath, pReserved) {
        pwszContainerPath := pwszContainerPath is String ? StrPtr(pwszContainerPath) : pwszContainerPath
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\AddLogContainer", "ptr", hLog, "uint*", pcbContainer, "ptr", pwszContainerPath, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds multiple log containers to the physical log that is associated with the log handle�if the calling process has access to the log handle.
     * @param {HANDLE} hLog The handle to an open log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> with permissions to add a log container. 
     * 
     * The file can be dedicated or multiplexed.
     * @param {Integer} cContainer The number of containers  in the <i>rgwszContainerPath</i> array.  
     * 
     * This value must be nonzero.  A log must have at least two containers before any I/O can be performed on it.
     * @param {Pointer<UInt64>} pcbContainer The size of the container, in bytes.  
     * 
     * The minimum size is  512 KB for normal logs and 1024 KB for multiplexed logs. The maximum size is approximately 4 gigabytes (GB).
     * 
     * This parameter is required if the containers are being added to a newly created log.  If a container is already created, this parameter can  be <b>NULL</b>, or some value that is at least as large as the size of the first container. 
     * 
     * 
     * Log container sizes are multiples of the log region size  (512 KB).  When you add a container to a new file, the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainer">AddLogContainer</a> function rounds the size of the container up to the next 512 KB boundary, and returns that size in the value pointed to by <i>pcbContainer</i>.  
     * 
     * Similarly,  if the log already has at least one container and the value of <i>*pcbContainer</i> is at least as large as the current container size, the function creates all containers with the current internal size and returns that size in <i>*pcbContainer</i>.
     * @param {Pointer<PWSTR>} rgwszContainerPath An array of   <i>cContainer</i> path names for containers.  
     * 
     * Each element in the array is a wide-character string that contains a valid path for the new container in the log volume.
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>Reserved</i> to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero, which indicates that all containers are added successfully to the log.
     * 
     * If the function fails, the return value is zero, which indicates that none of the containers are added.  To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-addlogcontainerset
     * @since windows6.0.6000
     */
    static AddLogContainerSet(hLog, cContainer, pcbContainer, rgwszContainerPath, pReserved) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\AddLogContainerSet", "ptr", hLog, "ushort", cContainer, "uint*", pcbContainer, "ptr", rgwszContainerPath, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes one container from a log that is associated with a dedicated or multiplexed log handle.
     * @param {HANDLE} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.
     * @param {PWSTR} pwszContainerPath A pointer to a wide character string that contains a  path for a  log container that is created by either  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainer">AddLogContainer</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainerset">AddLogContainerSet</a>.
     * @param {BOOL} fForce The deletion flag  that determines when and how a container is deleted.
     * 
     * If <i>fForce</i> is <b>TRUE</b>, and the container is part of the active log region, the container is not deleted and an error <b>ERROR_LOG_CANT_DELETE</b> is returned.
     * 
     * If <b>FALSE</b>, the container is deleted when the container is no longer a part of the active log region.
     * @param {Pointer<Void>} pReserved This parameter is reserved and should be  set to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-removelogcontainer
     * @since windows6.0.6000
     */
    static RemoveLogContainer(hLog, pwszContainerPath, fForce, pReserved) {
        pwszContainerPath := pwszContainerPath is String ? StrPtr(pwszContainerPath) : pwszContainerPath
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\RemoveLogContainer", "ptr", hLog, "ptr", pwszContainerPath, "int", fForce, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes multiple containers from a log that is associated with a dedicated or multiplexed log handle.
     * @param {HANDLE} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle must have administrative permission to add a log container, and can refer to either a dedicated or multiplexed log.
     * @param {Integer} cContainer The number of container path names in an array that is pointed to by <i>rgwszContainerPath</i>.  
     * 
     * This value must be nonzero.
     * @param {Pointer<PWSTR>} rgwszContainerPath An array of pointers to container path names that contain  <i>cContainers</i> pointers.  
     * 
     * Each path name is a wide character string that identifies  a container  created by either <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainer">AddLogContainer</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainerset">AddLogContainerSet</a>.
     * @param {BOOL} fForce The deletion flag  that determines when and how a container is deleted.
     * 
     * If <i>fForce</i> is <b>TRUE</b>, and the container is part of the active log region, the container is not deleted and an error <b>ERROR_LOG_CANT_DELETE</b> is returned.
     * 
     * If <b>FALSE</b>, the container is deleted when the container is no longer a part of the active log region.
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>pReserved</i> to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-removelogcontainerset
     * @since windows6.0.6000
     */
    static RemoveLogContainerSet(hLog, cContainer, rgwszContainerPath, fForce, pReserved) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\RemoveLogContainerSet", "ptr", hLog, "ushort", cContainer, "ptr", rgwszContainerPath, "int", fForce, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the last archived log sequence number (LSN) or archive tail of an archivable log.
     * @param {HANDLE} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle can refer to a dedicated or multiplexed log.
     * @param {Pointer<CLS_LSN>} plsnArchiveTail A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies a valid physical LSN in the log.
     * 
     * 
     * <div class="alert"><b>Note</b>  For handles to both a physical log or a log stream, <i>plsnArchiveTail</i> is a physical LSN, because it refers to a record address in the physical log.</div>
     * <div> </div>
     * @param {Pointer<Void>} pReserved This parameter is reserved and should be set to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following  list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-setlogarchivetail
     * @since windows6.0.6000
     */
    static SetLogArchiveTail(hLog, plsnArchiveTail, pReserved) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\SetLogArchiveTail", "ptr", hLog, "ptr", plsnArchiveTail, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * This function has been deprecated. Use TruncateLog instead.
     * @param {HANDLE} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle must refer to a dedicated log.
     * @param {Pointer<CLS_LSN>} plsnEnd A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the new end of a log.  
     * 
     * The LSN must be between the base log sequence number (LSN) of the log and the last LSN of the log.
     * @param {Pointer<OVERLAPPED>} lpOverlapped Reserved.  Set <i>lpOverlapped</i> to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-setendoflog
     * @since windows6.0.6000
     */
    static SetEndOfLog(hLog, plsnEnd, lpOverlapped) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\SetEndOfLog", "ptr", hLog, "ptr", plsnEnd, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Truncates the log. The function sets the end of the log to the specified value.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context that is allocated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<CLS_LSN>} plsnEnd A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the new end of a log.  
     * 
     * The LSN must be between the base log sequence number (LSN) of the log and the last LSN of the log.
     * @param {Pointer<OVERLAPPED>} lpOverlapped Reserved.  Set <i>Reserved</i> to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-truncatelog
     * @since windows6.0.6000
     */
    static TruncateLog(pvMarshal, plsnEnd, lpOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\TruncateLog", "ptr", pvMarshal, "ptr", plsnEnd, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a scan context to use with ScanLogContainers to enumerate all log containers that are associated with a log, and performs the first scan.
     * @param {HANDLE} hLog A  handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> with permissions  to scan the log containers.  
     * 
     * The file can be  a dedicated or multiplexed log.
     * @param {Integer} cFromContainer The container where  the scan is to be started.  
     * 
     * This parameter is an ordinal number relative to the number of containers in the log.
     * @param {Integer} cContainers The number of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_container_information">CLFS_CONTAINER_INFORMATION</a> structures for  <b>CreateLogContainerScanContext</b> to allocate. 
     * 
     * This number is the number of containers scanned with each scan call so the caller knows the scan is complete when the number of containers returned is less than this value.
     * 
     * On exit, a pointer to the system-allocated array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_container_information">CLFS_CONTAINER_INFORMATION</a> structures is placed in the <b>pinfoContainer</b> member of the client-allocated <a href="https://docs.microsoft.com/windows/win32/api/clfs/ns-clfs-cls_scan_context~r1">CLFS_SCAN_CONTEXT</a> structure. This member is   pointed to by the <i>pcxScan</i> parameter (that is, "pcxScan-&gt;pinfoContainer[]"), and the actual number of structures in the array is placed in "pcxScan-&gt;cContainersReturned".
     * 
     * The client must call <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-scanlogcontainers">ScanLogContainers</a> with the <i>eScanMode</i> parameter set to <b>CLFS_SCAN_CLOSE</b>  so that it can free this array; otherwise, memory leaks result.
     * @param {Integer} eScanMode The mode to scan containers.  
     * 
     * Containers can be scanned in any one of the following modes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_INIT__"></a><a id="clfs_scan_init__"></a><dl>
     * <dt><b>CLFS_SCAN_INIT  </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes or reinitializes a scan from the first container in the container list.  
     * 
     * This mode initializes the container context and returns the first set of container descriptors  that  <i>cContainers</i> specifies.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_FORWARD"></a><a id="clfs_scan_forward"></a><dl>
     * <dt><b>CLFS_SCAN_FORWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Returns the first set of containers  that  <i>cContainers</i> specifies.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_BACKWARD"></a><a id="clfs_scan_backward"></a><dl>
     * <dt><b>CLFS_SCAN_BACKWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Returns the last set of containers  that <i>cContainers</i> specifies.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CLS_SCAN_CONTEXT>} pcxScan A pointer to a client-allocated <a href="https://docs.microsoft.com/windows/win32/api/clfs/ns-clfs-cls_scan_context~r1">CLFS_SCAN_CONTEXT</a> structure that receives a scan context that can be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-scanlogcontainers">ScanLogContainers</a> function when a client scans the log containers of a dedicated log.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if an asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-createlogcontainerscancontext
     * @since windows6.0.6000
     */
    static CreateLogContainerScanContext(hLog, cFromContainer, cContainers, eScanMode, pcxScan, pOverlapped) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\CreateLogContainerScanContext", "ptr", hLog, "uint", cFromContainer, "uint", cContainers, "char", eScanMode, "ptr", pcxScan, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates log containers. Call this function repeatedly to iterate over all log containers.
     * @param {Pointer<CLS_SCAN_CONTEXT>} pcxScan A pointer to a client-allocated <a href="https://docs.microsoft.com/windows/win32/api/clfs/ns-clfs-cls_scan_context~r1">CLFS_SCAN_CONTEXT</a> structure  that  the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogcontainerscancontext">CreateLogContainerScanContext</a> function initializes.
     * @param {Integer} eScanMode The mode  for  containers  to  be scanned.  
     * 
     * Containers can be scanned in any  of the following <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/clfs-scan-mode-constants">CLFS_SCAN_MODE</a> modes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_INIT"></a><a id="clfs_scan_init"></a><dl>
     * <dt><b>CLFS_SCAN_INIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reinitializes the scan context, but does not allocate associated storage.  
     * 
     * The initialization is destructive, because all  data that is stored in the current scan context is lost.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_CLOSE"></a><a id="clfs_scan_close"></a><dl>
     * <dt><b>CLFS_SCAN_CLOSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uninitializes the scan context, and deallocates  system storage that is associated with a scan context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_FORWARD"></a><a id="clfs_scan_forward"></a><dl>
     * <dt><b>CLFS_SCAN_FORWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the next call to <b>ScanLogContainers</b> to proceed  in a forward direction. 
     * 
     * Cannot be used if <b>CLFS_SCAN_BACKWARD</b> is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_BACKWARD"></a><a id="clfs_scan_backward"></a><dl>
     * <dt><b>CLFS_SCAN_BACKWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the next call to <b>ScanLogContainers</b> to proceed  in a backward direction. 
     * 
     * Cannot be used if <b>CLFS_SCAN_FORWARD</b> is specified.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>pReserved</i> to <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  The following  list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-scanlogcontainers
     * @since windows6.0.6000
     */
    static ScanLogContainers(pcxScan, eScanMode, pReserved) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ScanLogContainers", "ptr", pcxScan, "char", eScanMode, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Calculates the sector-aligned reservation size for a set of reserved records.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context that is allocated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Integer} cReservedRecords The number of reserved records that are associated with the reservation adjustment.
     * @param {Pointer<Int64>} rgcbReservation An array of space allocations  to reserve in the log that is associated with the current marshaling context, in bytes.  
     * 
     * The number of allocations corresponds to the number of records  that  <i>cReservedRecords</i> specifies.  Each allocation must be greater than zero (0) or  the function fails with <b>ERROR_INVALID_PARAMETER</b>.
     * @param {Pointer<Int64>} pcbAlignReservation A pointer to a variable in which the function returns the number of   sector-aligned byte space to be reserved in the log—after being given the number of records  that  <i>cRecords</i> specifies and the size of reservations specified in the <i>rgcbReservation</i> array.
     * 
     *   The value returned in <i>*pcbAlignReservation</i> is used as input to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-allocreservedlog">AllocReservedLog</a>. If  <b>AllocReservedLog</b> succeeds, this value is always greater than zero (0).  If <b>AllocReservedLog</b> fails, the value is zero (0).
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-alignreservedlog
     * @since windows6.0.6000
     */
    static AlignReservedLog(pvMarshal, cReservedRecords, rgcbReservation, pcbAlignReservation) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\AlignReservedLog", "ptr", pvMarshal, "uint", cReservedRecords, "int64*", rgcbReservation, "int64*", pcbAlignReservation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Allocates sector-aligned space for a set of reserved records.
     * @param {Pointer<Void>} pvMarshal A pointer to the  marshaling context that is allocated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Integer} cReservedRecords The number of reserved records that are associated with the reservation adjustment.  
     * 
     * This value must be greater than zero (0).
     * @param {Pointer<Int64>} pcbAdjustment The size of the sector-aligned space reservation that is associated with the number of records specified in <i>cReservedRecords</i>, in bytes.  
     * 
     * This parameter must be the aligned reservation size  that  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-alignreservedlog">AlignReservedLog</a> returns in <i>*pcbAlignReservation</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible  error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-allocreservedlog
     * @since windows6.0.6000
     */
    static AllocReservedLog(pvMarshal, cReservedRecords, pcbAdjustment) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\AllocReservedLog", "ptr", pvMarshal, "uint", cReservedRecords, "int64*", pcbAdjustment, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reduces the number of reserved log records in a marshaling area made by calling ReserveAndAppendLog, ReserveAndAppendLogAligned, or AllocReservedLog.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Integer} cReservedRecords The number of reserved records to be freed.  
     * 
     * If the byte count of the adjustment in <i>pcbAdjustment</i> is positive,  <i>cReservedRecords</i> is the total  number of reserved records  that are remaining after the adjustment. Otherwise, this parameter specifies the number of records to be subtracted from the current number of reserved records, but can never exceed the reserved count.
     * @param {Pointer<Int64>} pcbAdjustment The number of bytes of reservation space affected by the adjustment.  
     * 
     * On input, if this number is positive,  it specifies the total remaining size of the reserved space after the adjustment. If this parameter  is negative,  its absolute value is  the number of bytes to be freed.
     * 
     * This value is usually an aggregate of the actual reserved space that is returned in a previous call to the following: 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-reserveandappendlog">ReserveAndAppendLog</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-reserveandappendlogaligned">ReserveAndAppendLogAligned</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-allocreservedlog">AllocReservedLog</a>
     * </li>
     * </ul>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-freereservedlog
     * @since windows6.0.6000
     */
    static FreeReservedLog(pvMarshal, cReservedRecords, pcbAdjustment) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\FreeReservedLog", "ptr", pvMarshal, "uint", cReservedRecords, "int64*", pcbAdjustment, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns a buffer that contains metadata about a specified log and its current state, which is defined by the CLFS_INFORMATION structure.
     * @param {HANDLE} hLog A handle to an open log that is obtained from a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle can refer to a dedicated or multiplexed log.
     * @param {Pointer<CLS_INFORMATION>} pinfoBuffer A pointer to a user-allocated <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_information">CLFS_INFORMATION</a> structure that receives the log metadata.
     * @param {Pointer<UInt32>} cbBuffer A pointer to a variable that on input specifies the size, in bytes, of the metadata buffer pointed to by <i>pinfoBuffer</i>.
     * 
     *  On output, it specifies the number of bytes that are actually copied into <i>pinfoBuffer</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-getlogfileinformation
     * @since windows6.0.6000
     */
    static GetLogFileInformation(hLog, pinfoBuffer, cbBuffer) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\GetLogFileInformation", "ptr", hLog, "ptr", pinfoBuffer, "uint*", cbBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enables or disables log archive support for a specified log.
     * @param {HANDLE} hLog A handle to the log that is obtained from 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.
     * @param {Integer} eMode 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-setlogarchivemode
     * @since windows6.0.6000
     */
    static SetLogArchiveMode(hLog, eMode) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\SetLogArchiveMode", "ptr", hLog, "int", eMode, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns the last restart area that is written successfully to the log associated with the marshaling area of WriteLogRestartArea.
     * @param {Pointer<Void>} pvMarshal A pointer to a   marshaling context that is  allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<Void>} ppvRestartBuffer A pointer to a variable that receives a pointer to the restart data in the log I/O block.
     * @param {Pointer<UInt32>} pcbRestartBuffer A pointer to a variable that receives the amount of restart data.
     * @param {Pointer<CLS_LSN>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the log sequence  number (LSN) of the restart area.
     * @param {Pointer<Void>} ppvContext A pointer to a variable that receives a pointer to a system-allocated read context  when a read is successful.  
     * 
     * If the function defers completion of an operation, it    returns a valid read-context pointer and an error status of <b>ERROR_IO_PENDING</b>.  On all other errors, the read-context pointer is <b>NULL</b>.  For more information about handling deferred completion of the function, see the Remarks section of this topic. 
     * 
     * After obtaining all requested log records, the client must pass  the read context to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatereadlog">TerminateReadLog</a> to free the associated memory. Failure to do so results in memory leakage.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time, or passed into more than one asynchronous read at a time.</div>
     * <div> </div>
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if an asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-readlogrestartarea
     * @since windows6.0.6000
     */
    static ReadLogRestartArea(pvMarshal, ppvRestartBuffer, pcbRestartBuffer, plsn, ppvContext, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogRestartArea", "ptr", pvMarshal, "ptr", ppvRestartBuffer, "uint*", pcbRestartBuffer, "ptr", plsn, "ptr", ppvContext, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads the previous log restart area that is relative to the current restart record specified in the read context, pvReadContext. This read context is the one previously created by a call to ReadLogRestartArea.
     * @param {Pointer<Void>} pvReadContext A pointer to a system-allocated read context that <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrestartarea">ReadLogRestartArea</a> returns.
     * 
     *   Even when those functions return <b>ERROR_IO_PENDING</b>, they still return a pointer to a valid read context. For information about  asynchronous completion, see the Remarks section of this topic.
     * @param {Pointer<Void>} ppvRestartBuffer A pointer to a variable that receives a pointer to the restart data.
     * @param {Pointer<UInt32>} pcbRestartBuffer A pointer to a variable that receives the size of the restart data at <i>*ppvRestartBuffer</i>, in bytes.
     * @param {Pointer<CLS_LSN>} plsnRestart A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the log sequence number (LSN) of the restart area  that   this function returns.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that  is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-readpreviouslogrestartarea
     * @since windows6.0.6000
     */
    static ReadPreviousLogRestartArea(pvReadContext, ppvRestartBuffer, pcbRestartBuffer, plsnRestart, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadPreviousLogRestartArea", "ptr", pvReadContext, "ptr", ppvRestartBuffer, "uint*", pcbRestartBuffer, "ptr", plsnRestart, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Appends a new client restart area to a log, and optionally advances the base log sequence number (LSN) of the log.
     * @param {Pointer<Void>} pvMarshal A pointer to the   marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<Void>} pvRestartBuffer A pointer to a  buffer that contains restart data.
     * @param {Integer} cbRestartBuffer The size of <i>pvRestartBuffer</i>, in bytes.
     * @param {Pointer<CLS_LSN>} plsnBase A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the new base LSN of the log after successfully writing the restart area.  
     * 
     * This value cannot be outside the range of the active log. It must be at least the value of the current base LSN, and not greater than the LSN that was returned in the <i>lastLSN</i> parameter from the latest call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-reserveandappendlog">ReserveAndAppendLog</a>.  If you omit this optional parameter, the base LSN  does not change.
     * @param {Integer} fFlags The flags that specify the behavior of this function.
     * @param {Pointer<UInt32>} pcbWritten A pointer to a variable that receives the number of bytes that are  written when an operation completes.
     * @param {Pointer<CLS_LSN>} plsnNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the restart area that is written.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. 
     * 
     * This parameter can be <b>NULL</b> if an asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following  list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-writelogrestartarea
     * @since windows6.0.6000
     */
    static WriteLogRestartArea(pvMarshal, pvRestartBuffer, cbRestartBuffer, plsnBase, fFlags, pcbWritten, plsnNext, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\WriteLogRestartArea", "ptr", pvMarshal, "ptr", pvRestartBuffer, "uint", cbRestartBuffer, "ptr", plsnBase, "uint", fFlags, "uint*", pcbWritten, "ptr", plsnNext, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} pvMarshal 
     * @param {Pointer<UInt32>} pcbRecordNumber 
     * @param {Pointer<Int64>} pcbUserReservation 
     * @param {Pointer<Int64>} pcbCommitReservation 
     * @returns {BOOL} 
     */
    static GetLogReservationInfo(pvMarshal, pcbRecordNumber, pcbUserReservation, pcbCommitReservation) {
        result := DllCall("clfsw32.dll\GetLogReservationInfo", "ptr", pvMarshal, "uint*", pcbRecordNumber, "int64*", pcbUserReservation, "int64*", pcbCommitReservation, "int")
        return result
    }

    /**
     * Advances the base log sequence number (LSN) of a log stream to the specified LSN.
     * @param {Pointer<Void>} pvMarshal A pointer to the marshaling context  that  a successful call to  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> returns.
     * @param {Pointer<CLS_LSN>} plsnBase The new base LSN for the log that is specified in <i>pvMarshal</i>.  
     * 
     * This LSN must be in the range between the current base LSN and the last LSN of the log, inclusively.
     * @param {Integer} fFlags This parameter is not implemented at this time, and must be zero.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * If asynchronous operation is not used, this parameter can be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-advancelogbase
     * @since windows6.0.6000
     */
    static AdvanceLogBase(pvMarshal, plsnBase, fFlags, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\AdvanceLogBase", "ptr", pvMarshal, "ptr", plsnBase, "uint", fFlags, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Resets the log file and then shuts the log.
     * @param {HANDLE} hLog A handle to a dedicated or multiplexed log. 
     * 
     * This handle is returned by a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  It is invalidated on successful completion of the call. No other operations that use this handle, or a derivative of this handle, can be called after this function has returned.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-closeandresetlogfile
     * @since windows6.0.6000
     */
    static CloseAndResetLogFile(hLog) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\CloseAndResetLogFile", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a marshaling area for a log, and when successful it returns a marshaling context. Before creating a marshaling area, the log must have at least one container.
     * @param {HANDLE} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle  can  refer to a dedicated or multiplexed log.
     * @param {Pointer<CLFS_BLOCK_ALLOCATION>} pfnAllocBuffer The callback function that allocates memory for log blocks.  
     * 
     * If this parameter is <b>NULL</b>, the Common Log File System (CLFS) provides a default block allocation function.  This parameter cannot be <b>NULL</b> if a block-freeing callback is specified by using the <i>pfnFreeBuffer</i>  parameter.
     * 
     * The following example identifies the  syntax of the block allocation callback function:
     * 
     * <c>typedef PVOID (* CLFS_BLOCK_ALLOCATION) (ULONG cbBufferSize, PVOID pvUserContext);</c>
     * @param {Pointer<CLFS_BLOCK_DEALLOCATION>} pfnFreeBuffer The callback function that   frees log blocks allocated by <i>pfnAllocBuffer</i>.  
     * 
     * If this parameter is <b>NULL</b>, CLFS provides a default block deallocation function.  This parameter cannot be <b>NULL</b> if a block allocation callback is specified by using the <i>pfnAllocBuffer</i> parameter.
     * 
     * The following example identifies the syntax of the  block-freeing callback function:
     * 
     * <c>typedef void (* CLFS_BLOCK_DEALLOCATION) (PVOID pvBuffer, PVOID pvUserContext);</c>
     * 
     * The <i>buffer</i> parameter of "ClfsBlockDeallocProc" must point to a block that is allocated by using the callback pointed to by <i>pfnAllocBuffer</i>.
     * @param {Pointer<Void>} pvBlockAllocContext A pointer to a  buffer that is passed back as a user context to the block allocation and deallocation routines, if a buffer is specified.  
     * 
     * If <i>pfnAllocBuffer</i> is <b>NULL</b>, this parameter is ignored.
     * @param {Integer} cbMarshallingBuffer The size, in bytes, of the individual log I/O blocks that will be used by the new marshaling area.  This must be a multiple of the sector size on the stable storage medium.   The sector size is the value returned in the <i>lpBytesPerSector</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * Records cannot be appended or read if they are longer than this value.
     * @param {Integer} cMaxWriteBuffers The maximum number of blocks that can be allocated at any time for   write operations.  
     * 
     * This value can affect the frequency of data flushes. If you do not need to specify a limit to control the frequency of the  data flush cycle, specify  INFINITE.
     * @param {Integer} cMaxReadBuffers The maximum number of blocks that can be allocated at any time for read operations.  
     * 
     * Read contexts use at least one read block.
     * @param {Pointer<Void>} ppvMarshal A pointer to the  marshaling context  that CLFS  allocates when <b>CreateLogMarshallingArea</b> completes successfully.  
     * 
     * This context must be used with all read, append, write, and flush operations to log marshaling areas.  All operations that access marshaling areas by using a marshaling context are thread-safe. This parameter is <b>NULL</b> if the operation is not successful.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following  list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-createlogmarshallingarea
     * @since windows6.0.6000
     */
    static CreateLogMarshallingArea(hLog, pfnAllocBuffer, pfnFreeBuffer, pvBlockAllocContext, cbMarshallingBuffer, cMaxWriteBuffers, cMaxReadBuffers, ppvMarshal) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\CreateLogMarshallingArea", "ptr", hLog, "ptr", pfnAllocBuffer, "ptr", pfnFreeBuffer, "ptr", pvBlockAllocContext, "uint", cbMarshallingBuffer, "uint", cMaxWriteBuffers, "uint", cMaxReadBuffers, "ptr", ppvMarshal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes a marshaling area that is created by a successful call to CreateLogMarshallingArea.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible  error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-deletelogmarshallingarea
     * @since windows6.0.6000
     */
    static DeleteLogMarshallingArea(pvMarshal) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\DeleteLogMarshallingArea", "ptr", pvMarshal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reserves space for log buffers, or appends a log record to the log, or does both. The function is atomic.
     * @param {Pointer<Void>} pvMarshal A pointer to a  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<CLS_WRITE_ENTRY>} rgWriteEntries A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_write_entry">CLFS_WRITE_ENTRY</a> buffers to be marshaled into  one  record.
     * 
     * This parameter is ignored if the <i>cWriteEntries</i> parameter is zero.
     * @param {Integer} cWriteEntries The number of write entries  in the <i>rgWriteEntries</i>  array. 
     * 
     * If this value is nonzero, you must specify a buffer in the <i>rgWriteEntries</i> parameter.
     * @param {Pointer<CLS_LSN>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the next record in the undo-chain.
     * @param {Pointer<CLS_LSN>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the previous record in the previous-chain.
     * @param {Integer} cReserveRecords The number of record sizes in the <i>rgcbReservation</i> array.
     * @param {Pointer<Int64>} rgcbReservation A pointer to an array of reservation sizes for each record  that  the <i>cReserveRecords</i> parameter specifies.  
     * 
     *  This parameter is ignored if the <i>cReserveRecords</i> parameter is zero.    If a reservation size is negative, a reservation of that size is released.
     * 
     * The actual space that is reserved for each record, including required overhead, is returned in the individual array elements on successful completion. These values can  be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-freereservedlog">FreeReservedLog</a>  function to adjust space that is reserved in the marshaling area.
     * @param {Integer} fFlags The flags that specify the behavior of this function.
     * @param {Pointer<CLS_LSN>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN  of the appended record.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-reserveandappendlog
     * @since windows6.0.6000
     */
    static ReserveAndAppendLog(pvMarshal, rgWriteEntries, cWriteEntries, plsnUndoNext, plsnPrevious, cReserveRecords, rgcbReservation, fFlags, plsn, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReserveAndAppendLog", "ptr", pvMarshal, "ptr", rgWriteEntries, "uint", cWriteEntries, "ptr", plsnUndoNext, "ptr", plsnPrevious, "uint", cReserveRecords, "int64*", rgcbReservation, "uint", fFlags, "ptr", plsn, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reserves space for log buffers, or appends a log record to the log, or both.
     * @param {Pointer<Void>} pvMarshal A pointer to a   marshaling context that  is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<CLS_WRITE_ENTRY>} rgWriteEntries A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_write_entry">CLFS_WRITE_ENTRY</a> buffers to be marshaled into  one  record.  
     * 
     * This parameter is ignored if the <i>cWriteEntries</i> parameter is zero.
     * @param {Integer} cWriteEntries The number of write entries  in the <i>rgWriteEntries</i>  array. 
     * 
     * If this value is nonzero, you must specify a buffer in the <i>rgWriteEntries</i> parameter.
     * @param {Integer} cbEntryAlignment The byte alignment for each write entry in the <i>rgWriteEntries</i> parameter.
     * 
     * Specify 1 (one) for a simple concatenation. The <i>cbWriteEntryAlignment</i> parameter must be nonzero.
     * @param {Pointer<CLS_LSN>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the next record in the undo-chain.
     * @param {Pointer<CLS_LSN>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the previous record in the previous-chain.
     * @param {Integer} cReserveRecords The number of record sizes in the <i>rgcbReservation</i> array.
     * @param {Pointer<Int64>} rgcbReservation A pointer to an array of reservation sizes for each record  that  the <i>cReserveRecords</i> parameter specifies.  
     * 
     *  This parameter is ignored if the <i>cReserveRecords</i> parameter is zero.    If a reservation size is negative, a reservation of that size is released.
     * 
     * The actual space that is reserved for each record, including required overhead, is returned in the individual array elements on successful completion. These values can  be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-freereservedlog">FreeReservedLog</a>  function to adjust space that is reserved in the marshaling area.
     * @param {Integer} fFlags The flags that specify the behavior of this function.
     * @param {Pointer<CLS_LSN>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN  of the appended record.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-reserveandappendlogaligned
     * @since windows6.0.6000
     */
    static ReserveAndAppendLogAligned(pvMarshal, rgWriteEntries, cWriteEntries, cbEntryAlignment, plsnUndoNext, plsnPrevious, cReserveRecords, rgcbReservation, fFlags, plsn, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReserveAndAppendLogAligned", "ptr", pvMarshal, "ptr", rgWriteEntries, "uint", cWriteEntries, "uint", cbEntryAlignment, "ptr", plsnUndoNext, "ptr", plsnPrevious, "uint", cReserveRecords, "int64*", rgcbReservation, "uint", fFlags, "ptr", plsn, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Forces all records appended to this marshaling area to be flushed to disk.
     * @param {Pointer<Void>} pvMarshal A pointer to the  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that  is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-flushlogbuffers
     * @since windows6.0.6000
     */
    static FlushLogBuffers(pvMarshal, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\FlushLogBuffers", "ptr", pvMarshal, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Forces all records appended to this marshaling area up to the record with the specified log sequence number (LSN) to be flushed to the disk. More records than specified may be flushed during this operation.
     * @param {Pointer<Void>} pvMarshalContext A pointer to the  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<CLS_LSN>} plsnFlush A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN that is used to determine which records to flush.   
     * 
     * Specify CLFS_LSN_NULL to flush all records in the marshaling area.
     * @param {Pointer<CLS_LSN>} plsnLastFlushed A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure. 
     * 
     * The LSN returned is greater than the LSN of any record flushed.  If the function  succeeds, the value of the LSN is never less than <i>plsnFlush</i>.  This value  is meaningful only  when  the function succeeds.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that  is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b>  except for an asynchronous operation.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the   possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-flushlogtolsn
     * @since windows6.0.6000
     */
    static FlushLogToLsn(pvMarshalContext, plsnFlush, plsnLastFlushed, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\FlushLogToLsn", "ptr", pvMarshalContext, "ptr", plsnFlush, "ptr", plsnLastFlushed, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Initiates a sequence of reads from a specified log sequence number (LSN) in one of three modes, and returns the first of the specified log records and a read context.
     * @param {Pointer<Void>} pvMarshal A pointer to a  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<CLS_LSN>} plsnFirst A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the record  where  the read operation should start.  
     * 
     * This value must be an LSN of a valid record in the active range of the log.
     * @param {Integer} eContextMode The mode for the read context that is returned in <i>*ppvReadContext</i>.  
     * 
     * The following table identifies the three  mutually exclusive  read modes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsContextPrevious"></a><a id="clfscontextprevious"></a><a id="CLFSCONTEXTPREVIOUS"></a><dl>
     * <dt><b>ClfsContextPrevious</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Reads the  record linked to by <i>plsnPrevious</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsContextUndoNext"></a><a id="clfscontextundonext"></a><a id="CLFSCONTEXTUNDONEXT"></a><dl>
     * <dt><b>ClfsContextUndoNext</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Reads the  record chain linked to by <i>plsnUndoNext</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsContextForward"></a><a id="clfscontextforward"></a><a id="CLFSCONTEXTFORWARD"></a><dl>
     * <dt><b>ClfsContextForward</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Reads the record  with the LSN that immediately follows the current LSN in the read context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ppvReadBuffer A pointer to a variable that receives a pointer to the target record in the log I/O block.
     * @param {Pointer<UInt32>} pcbReadBuffer A pointer to  a variable that receives the size of the data that is returned in <i>*ppvReadBuffer</i>, in bytes.
     * @param {Pointer<Byte>} peRecordType A pointer to a variable that receives the  type of record read. 
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/clfs-record-type-constants">CLFS_RECORD_TYPE Constants</a>.
     * @param {Pointer<CLS_LSN>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in the undo record chain.
     * @param {Pointer<CLS_LSN>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in the previous record chain.
     * @param {Pointer<Void>} ppvReadContext A pointer to a variable that receives a pointer to a system-allocated read context  when a read is successful.  
     * 
     * If the function defers completion of an operation, it    returns a valid read-context pointer and an error status of <b>ERROR_IO_PENDING</b>.  On all other errors, the read-context pointer is <b>NULL</b>.  For more information about handling deferred completion of the function, see the Remarks section of this topic.
     * 
     * After obtaining all requested log records, the client must pass  the read context to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatereadlog">TerminateReadLog</a> to free the associated memory. Failure to do so results in memory leakage.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time, or passed into more than one asynchronous read at a time.</div>
     * <div> </div>
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, which is required for asynchronous operation.
     * 
     *  This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following  list identifies the possible error codes.
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-readlogrecord
     * @since windows6.0.6000
     */
    static ReadLogRecord(pvMarshal, plsnFirst, eContextMode, ppvReadBuffer, pcbReadBuffer, peRecordType, plsnUndoNext, plsnPrevious, ppvReadContext, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogRecord", "ptr", pvMarshal, "ptr", plsnFirst, "int", eContextMode, "ptr", ppvReadBuffer, "uint*", pcbReadBuffer, "char*", peRecordType, "ptr", plsnUndoNext, "ptr", plsnPrevious, "ptr", ppvReadContext, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads the next record in a sequence that is initiated by a call to ReadLogRecord or ReadLogRestartArea.
     * @param {Pointer<Void>} pvReadContext A pointer to a  read context  that the system allocates and creates during a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrecord">ReadLogRecord</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrestartarea">ReadLogRestartArea</a>.  
     * 
     * If the function defers completion of an operation, it  returns a pointer to a valid read context and an error status of <b>ERROR_IO_PENDING</b>.  For information about handling asynchronous completion, see the Remarks section of this topic.
     * @param {Pointer<Void>} ppvBuffer A pointer to a variable that receives a pointer to the read data.
     * @param {Pointer<UInt32>} pcbBuffer A pointer to a variable that receives the size of the read data that is returned in <i>ppvReadBuffer</i>, in bytes.
     * @param {Pointer<Byte>} peRecordType A pointer that, on input, specifies   the record type filter of the next record read, and on output specifies the record type that is returned.    
     * 
     * Clients can specify any of the following record types.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsDataRecord"></a><a id="clfsdatarecord"></a><a id="CLFSDATARECORD"></a><dl>
     * <dt><b>ClfsDataRecord</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Only user-data records are read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsRestartRecord"></a><a id="clfsrestartrecord"></a><a id="CLFSRESTARTRECORD"></a><dl>
     * <dt><b>ClfsRestartRecord</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Only restart records are read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsClientRecord"></a><a id="clfsclientrecord"></a><a id="CLFSCLIENTRECORD"></a><dl>
     * <dt><b>ClfsClientRecord</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  All restart and data records are read.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CLS_LSN>} plsnUser A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies   the log client  to read this log sequence number (LSN) as the next LSN instead of  reading forward to the next record, reading the previous LSN, or reading the next undo LSN.  
     * 
     * This parameter gives log clients the ability to cursor through user-defined LSN chains in client buffers.  The relationship of this parameter to the current LSN held by the read context must be consistent with the context mode, <i>ecxMode</i>,  that is specified in the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrecord">ReadLogRecord</a>  entry points; otherwise, an error code of <b>ERROR_INVALID_PARAMETER</b> is returned.
     * @param {Pointer<CLS_LSN>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in an undo record chain.
     * @param {Pointer<CLS_LSN>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in the previous record chain.
     * @param {Pointer<CLS_LSN>} plsnRecord A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the current record read into the read context.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following  list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-readnextlogrecord
     * @since windows6.0.6000
     */
    static ReadNextLogRecord(pvReadContext, ppvBuffer, pcbBuffer, peRecordType, plsnUser, plsnUndoNext, plsnPrevious, plsnRecord, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadNextLogRecord", "ptr", pvReadContext, "ptr", ppvBuffer, "uint*", pcbBuffer, "char*", peRecordType, "ptr", plsnUser, "ptr", plsnUndoNext, "ptr", plsnPrevious, "ptr", plsnRecord, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Terminates a read context. This function frees system-allocated resources associated with the specified read context. Do not attempt to read log records after calling this function; you will receive indeterminate results.
     * @param {Pointer<Void>} pvCursorContext A pointer to a  read context that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrecord">ReadLogRecord</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrestartarea">ReadLogRestartArea</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-terminatereadlog
     * @since windows6.0.6000
     */
    static TerminateReadLog(pvCursorContext) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\TerminateReadLog", "ptr", pvCursorContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Prepares a physical log for archival.
     * @param {HANDLE} hLog A handle to the log that is  obtained by a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * This handle can be the handle to a dedicated or multiplexed log.
     * @param {PWSTR} pszBaseLogFileName A pointer to a  user-allocated buffer to receive the fully qualified path of the base log.  
     * 
     * If the buffer is not large enough, it contains a truncated file path on exit, and the function fails with an <i>ERROR_BUFFER_OVERFLOW</i> status code. 
     * 
     * The  length of the file path is returned in the variable pointed to by <i>pcActualLength</i>.  The client can re-attempt  a failed call with a  name buffer that is large enough.
     * @param {Integer} cLen The size of the <i>pszBaseLogFileName</i> buffer, in wide characters.
     * @param {Pointer<CLS_LSN>} plsnLow A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the low end of the range of the  active log where the log client needs log archival information. 
     * 
     * If this parameter is omitted, the low end of the range defaults to the LSN of the log archive tail.
     * @param {Pointer<CLS_LSN>} plsnHigh A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the high end of the range of the  active log where the log client needs log archival information. 
     * 
     * If this parameter is omitted, the high end of the range defaults to the next LSN to be written to the log.
     * @param {Pointer<UInt32>} pcActualLength A pointer to a variable that receives the actual length of the name of the base log path, in characters.  
     * 
     * If this value is greater than <i>cLen</i>, the function returns an ERROR_BUFFER_OVERFLOW status with a truncated path that is stored in the <i>pszBaseLogFileName</i> buffer and all other out parameters that are not set to meaningful values.
     * @param {Pointer<UInt64>} poffBaseLogFileData A pointer to a variable that receives the offset  where  the metadata begins in the base log.
     * 
     * The contiguous extent in the base log   <i>pszBaseLogFileName</i> represents the full contents of the log metadata—that is, from <i>poffBaseLogFileData</i> to <i>pcbBaseLogFileLength</i>.
     * @param {Pointer<UInt64>} pcbBaseLogFileLength A pointer to a variable  that specifies the exact length  of the base log, in bytes.
     * @param {Pointer<CLS_LSN>} plsnBase A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure to receive the base log sequence number (LSN) of the active log.
     * @param {Pointer<CLS_LSN>} plsnLast A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure to receive the highest valid LSN in the active log.
     * @param {Pointer<CLS_LSN>} plsnCurrentArchiveTail A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure to receive the current LSN of the archive tail of the log.
     * @param {Pointer<Void>} ppvArchiveContext A pointer to the variable that receives a pointer to an  archive context that the system allocates.  
     * 
     * The archive context maintains the cursor state of the archival iterator and the log handle context.  The archival client is responsible for releasing the context by calling <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-preparelogarchive
     * @since windows6.0.6000
     */
    static PrepareLogArchive(hLog, pszBaseLogFileName, cLen, plsnLow, plsnHigh, pcActualLength, poffBaseLogFileData, pcbBaseLogFileLength, plsnBase, plsnLast, plsnCurrentArchiveTail, ppvArchiveContext) {
        pszBaseLogFileName := pszBaseLogFileName is String ? StrPtr(pszBaseLogFileName) : pszBaseLogFileName
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\PrepareLogArchive", "ptr", hLog, "ptr", pszBaseLogFileName, "uint", cLen, "ptr", plsnLow, "ptr", plsnHigh, "uint*", pcActualLength, "uint*", poffBaseLogFileData, "uint*", pcbBaseLogFileLength, "ptr", plsnBase, "ptr", plsnLast, "ptr", plsnCurrentArchiveTail, "ptr", ppvArchiveContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies a range of the archive view of the metadata to the specified buffer.
     * @param {Pointer<Void>} pvArchiveContext A pointer to an  archive context that is obtained by a call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-preparelogarchive">PrepareLogArchive</a>.
     * 
     *   The context maintains  the cursor state, which allows iteration through the set of file extents in the archive.  The archive client is responsible for deallocating the context by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a> function.
     * @param {Integer} cbOffset The offset in the metadata where data copying starts.  
     * 
     * On the first call to this function, specify zero (0). On subsequent calls, specify the value that is returned in <i>pcbBytesRead</i>.
     * @param {Integer} cbBytesToRead The number of bytes of the metadata snapshot should be copied into <i>pbReadBuffer</i>.  
     * 
     * This parameter cannot be zero (0).
     * @param {Pointer<Byte>} pbReadBuffer A pointer to the buffer  where the metadata snapshot is copied.
     * @param {Pointer<UInt32>} pcbBytesRead A pointer to a variable that receives the number of bytes  that are  copied to <i>pbReadBuffer</i>.  
     * 
     * The number of bytes is always between zero (0) and <i>cbBytesToRead</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies  the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-readlogarchivemetadata
     * @since windows6.0.6000
     */
    static ReadLogArchiveMetadata(pvArchiveContext, cbOffset, cbBytesToRead, pbReadBuffer, pcbBytesRead) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogArchiveMetadata", "ptr", pvArchiveContext, "uint", cbOffset, "uint", cbBytesToRead, "char*", pbReadBuffer, "uint*", pcbBytesRead, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the next set of archive extents in a log archive context.
     * @param {Pointer<Void>} pvArchiveContext A pointer to an  archive context that is obtained by a call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-preparelogarchive">PrepareLogArchive</a>.
     * 
     *   The context maintains  the cursor state, which allows iteration through the set of file extents in the archive.  The archive client is responsible for deallocating the context by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a> function.
     * @param {Pointer<CLS_ARCHIVE_DESCRIPTOR>} rgadExtent A client-allocated array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_archive_descriptor">CLFS_ARCHIVE_DESCRIPTOR</a>  structures to be filled in by this function.
     * @param {Integer} cDescriptors The number of elements in  the <i>rgadExtent</i> array. 
     * 
     * This value is the maximum number of archive descriptors that can be retrieved by this function.
     * @param {Pointer<UInt32>} pcDescriptorsReturned The number of descriptors in the <i>rgadExtent</i> array that are  filled in by this function.  
     * 
     * If this value is less than <i>cDescriptors</i>,  the set of descriptors is exhausted and the archive client can terminate iteration through the ordered descriptor set.  Further calls to this function fail with ERROR_NO_MORE_ENTRIES.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-getnextlogarchiveextent
     * @since windows6.0.6000
     */
    static GetNextLogArchiveExtent(pvArchiveContext, rgadExtent, cDescriptors, pcDescriptorsReturned) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\GetNextLogArchiveExtent", "ptr", pvArchiveContext, "ptr", rgadExtent, "uint", cDescriptors, "uint*", pcDescriptorsReturned, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deallocates system resources that are allocated originally for a log archive context by PrepareLogArchive.
     * @param {Pointer<Void>} pvArchiveContext The archive context that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-preparelogarchive">PrepareLogArchive</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  error code is possible:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-terminatelogarchive
     * @since windows6.0.6000
     */
    static TerminateLogArchive(pvArchiveContext) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\TerminateLogArchive", "ptr", pvArchiveContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Validates the consistency of the log metadata and data before log archive and after log restore.
     * @param {PWSTR} pszLogFileName The name of the log. 
     * 
     * The  name is specified when creating the log  by using  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. The following example identifies the format  to use:
     * 
     * <i>Log</i><b>:&lt;</b><i>LogName</i><b>&gt;[::&lt;</b><i>LogStreamName</i><b>&gt;]</b>
     * 
     * <b>&lt;</b><i>LogName</i><b>&gt;</b> corresponds to a valid file path  in  the   file system.
     * 
     * <b>&lt;</b><i>LogStreamName</i><b>&gt;</b> is  the unique name of a log stream in the dedicated log.   
     * 
     * For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/log-types">Log Types</a>.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psaLogFile A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that  specifies the security attributes of a log. 
     * 
     * This parameter can be <b>NULL</b>.
     * @param {Pointer<CLS_INFORMATION>} pinfoBuffer A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_information">CLFS_INFORMATION</a> structure that receives log metadata.
     * @param {Pointer<UInt32>} pcbBuffer A pointer to a variable that, on input, specifies the size of the <i>pinfoBuffer</i> metadata buffer, in bytes.  
     * 
     * On output, it receives the amount of information that is copied to the buffer, in bytes.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-validatelog
     * @since windows6.0.6000
     */
    static ValidateLog(pszLogFileName, psaLogFile, pinfoBuffer, pcbBuffer) {
        pszLogFileName := pszLogFileName is String ? StrPtr(pszLogFileName) : pszLogFileName

        A_LastError := 0

        result := DllCall("clfsw32.dll\ValidateLog", "ptr", pszLogFileName, "ptr", psaLogFile, "ptr", pinfoBuffer, "uint*", pcbBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path name of the specified container.
     * @param {HANDLE} hLog A handle to the log that is obtained from a successful call to 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. 
     * 
     * The log handle could refer to a 
     *       log stream or a physical log.
     * @param {Integer} cidLogicalContainer The unique  identifier that is associated with a container.
     * @param {PWSTR} pwstrContainerName A pointer to a user-allocated buffer to receive the full path and name of the log container, in wide characters.
     * @param {Integer} cLenContainerName The size of the buffer pointed to by <i>pwstrContainerName</i>, in characters.
     * @param {Pointer<UInt32>} pcActualLenContainerName A pointer to a variable to receive the actual character count of the full container path name that is retrieved. 
     *       
     * 
     * If the function succeeds, the value of this parameter is less than or equal to 
     *       <i>cLenContainerName</i>. If the buffer is not large enough to store the whole container 
     *       path name, the function fails with <b>ERROR_MORE_DATA</b> and sets this parameter to the 
     *       size that is required for the full path name. For other failures the value is not defined.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-getlogcontainername
     * @since windows6.0.6000
     */
    static GetLogContainerName(hLog, cidLogicalContainer, pwstrContainerName, cLenContainerName, pcActualLenContainerName) {
        pwstrContainerName := pwstrContainerName is String ? StrPtr(pwstrContainerName) : pwstrContainerName
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\GetLogContainerName", "ptr", hLog, "uint", cidLogicalContainer, "ptr", pwstrContainerName, "uint", cLenContainerName, "uint*", pcActualLenContainerName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves log I/O statistics for a dedicated or multiplexed log that is associated with the specified handle.
     * @param {HANDLE} hLog A handle to an open log file that <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> gets.  The log handle can refer to either a dedicated or multiplexed log file.
     * @param {Pointer<Void>} pvStatsBuffer A pointer to a buffer to receive the I/O statistics.  
     * 
     * This buffer must be at least as large as an I/O statistics packet header. For more information, see  <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_io_statistics_header">CLFS_IO_STATISTICS_HEADER</a>.
     * @param {Integer} cbStatsBuffer The size of the I/O statistics buffer <i>pvStatsBuffer</i>, in bytes.   
     * 
     * If the buffer is not large enough for the statistics packet, the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} eStatsClass This parameter is not implemented at this time; it is reserved for future use.
     * @param {Pointer<UInt32>} pcbStatsWritten A pointer to a variable to receive the size of the I/O statistics packet that is written to  <i>pvStatsBuffer</i>.   
     * 
     * This value is less than or equal to <i>cbStatsBuffer</i>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//clfsw32/nf-clfsw32-getlogiostatistics
     * @since windows6.0.6000
     */
    static GetLogIoStatistics(hLog, pvStatsBuffer, cbStatsBuffer, eStatsClass, pcbStatsWritten) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\GetLogIoStatistics", "ptr", hLog, "ptr", pvStatsBuffer, "uint", cbStatsBuffer, "int", eStatsClass, "uint*", pcbStatsWritten, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers a client with the log manager. A client can specify whether to receive notifications by using callbacks, or have the notifications queued for retrieval by using ReadLogNotification.
     * @param {HANDLE} hLog The handle to the log to register. Only one registration per unique opening of the log is allowed.
     * @param {Pointer<LOG_MANAGEMENT_CALLBACKS>} pCallbacks Specifies the callbacks that the client is registering for.  Valid callbacks are enumerated by <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmtw32/ns-clfsmgmtw32-log_management_callbacks">LOG_MANAGEMENT_CALLBACKS</a>. Specify zero to queue notifications instead.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-registermanageablelogclient
     * @since windows6.0.6000
     */
    static RegisterManageableLogClient(hLog, pCallbacks) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\RegisterManageableLogClient", "ptr", hLog, "ptr", pCallbacks, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deregisters a client with the log manager.
     * @param {HANDLE} hLog The handle to deregister.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. For extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-deregistermanageablelogclient
     * @since windows6.0.6000
     */
    static DeregisterManageableLogClient(hLog) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\DeregisterManageableLogClient", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves notifications from the log manager. It retrieves a queued notification from the log manager immediately if a notification is available; otherwise the request remains pending until a notification is generated.
     * @param {HANDLE} hLog The handle to the log.
     * @param {Pointer<CLFS_MGMT_NOTIFICATION>} pNotification Receives the notification type, and if the type has parameters associated with it, the parameters.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. If asynchronous operation is not used, this parameter can be <b>NULL</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following is a possible error code:
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-readlognotification
     * @since windows6.0.6000
     */
    static ReadLogNotification(hLog, pNotification, lpOverlapped) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogNotification", "ptr", hLog, "ptr", pNotification, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Installs (sets) a policy for a log.
     * @param {HANDLE} hLog A handle to a log.
     * @param {Pointer<CLFS_MGMT_POLICY>} pPolicy A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmt/ns-clfsmgmt-clfs_mgmt_policy">CLFS_MGMT_POLICY</a> structure that represents the desired policy to install.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-installlogpolicy
     * @since windows6.0.6000
     */
    static InstallLogPolicy(hLog, pPolicy) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\InstallLogPolicy", "ptr", hLog, "ptr", pPolicy, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Resets the specified policy to its default behavior.
     * @param {HANDLE} hLog Handle to the log to reset the policy for.
     * @param {Integer} ePolicyType Specifies the policy to reset. Policy types are enumerated in <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmt/ne-clfsmgmt-clfs_mgmt_policy_type">CLFS_MGMT_POLICY_TYPE</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-removelogpolicy
     * @since windows6.0.6000
     */
    static RemoveLogPolicy(hLog, ePolicyType) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\RemoveLogPolicy", "ptr", hLog, "int", ePolicyType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The QueryLogPolicy function allows you to obtain a policy that is installed for the specified log.
     * @param {HANDLE} hLog The handle to the log to query.
     * @param {Integer} ePolicyType Specifies the type of policy to query for. Policy types are enumerated in <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmt/ne-clfsmgmt-clfs_mgmt_policy_type">CLFS_MGMT_POLICY_TYPE</a>.
     * @param {Pointer<CLFS_MGMT_POLICY>} pPolicyBuffer A pointer to a buffer to receive the returned policies.
     * @param {Pointer<UInt32>} pcbPolicyBuffer A pointer to the size of <i>pPolicyBuffer</i>. If the buffer is not large enough, <i>pcbPolicyBuffer</i> receives the size buffer required to successfully retrieve the specified policies.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-querylogpolicy
     * @since windows6.0.6000
     */
    static QueryLogPolicy(hLog, ePolicyType, pPolicyBuffer, pcbPolicyBuffer) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\QueryLogPolicy", "ptr", hLog, "int", ePolicyType, "ptr", pPolicyBuffer, "uint*", pcbPolicyBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds or deletes containers from a log based on the state of the installed policies.
     * @param {HANDLE} hLog A handle to a log.
     * @param {Pointer<UInt64>} pDesiredSize 
     * @param {Pointer<UInt64>} pResultingSize A pointer to a valid ULONGLONG data variable, receives the number of containers in the resized log upon success.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-setlogfilesizewithpolicy
     * @since windows6.0.6000
     */
    static SetLogFileSizeWithPolicy(hLog, pDesiredSize, pResultingSize) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\SetLogFileSizeWithPolicy", "ptr", hLog, "uint*", pDesiredSize, "uint*", pResultingSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Called by a managed log client when an attempt to reserve or append to a log fails with a log full error message. The log manager attempts to resolve the log full condition for the client, and notifies the client when the outcome is known.
     * @param {HANDLE} hLog A handle to the log on which to resolve the log full condition. The handle must have been registered with <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmtw32/nf-clfsmgmtw32-registermanageablelogclient">RegisterManageableLogClient</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Valid values include the following:
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-handlelogfull
     * @since windows6.0.6000
     */
    static HandleLogFull(hLog) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\HandleLogFull", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The LogTailAdvanceFailure function is called by a log client to indicate that it cannot comply with a request from log management to advance its tail.
     * @param {HANDLE} hLog A handle to the log on which to resolve the log full condition.
     * @param {Integer} dwReason Win32 error code with the reason for the failure For a list of possible values, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Valid values include the following:
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-logtailadvancefailure
     * @since windows6.0.6000
     */
    static LogTailAdvanceFailure(hLog, dwReason) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\LogTailAdvanceFailure", "ptr", hLog, "uint", dwReason, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The RegisterForLogWriteNotification function is called by a managed log client to enable or disable log write notifications.
     * @param {HANDLE} hLog A handle to the log on which to resolve the log full condition.
     * @param {Integer} cbThreshold Number of bytes to be written to the log file before the notification is sent.
     * @param {BOOL} fEnable If <b>TRUE</b>, the notification is enabled. If <b>FALSE</b>, the notification is disabled.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Valid values include the following:
     * @see https://docs.microsoft.com/windows/win32/api//clfsmgmtw32/nf-clfsmgmtw32-registerforlogwritenotification
     * @since windows6.0.6000
     */
    static RegisterForLogWriteNotification(hLog, cbThreshold, fEnable) {
        hLog := hLog is Win32Handle ? NumGet(hLog, "ptr") : hLog

        A_LastError := 0

        result := DllCall("clfsw32.dll\RegisterForLogWriteNotification", "ptr", hLog, "uint", cbThreshold, "int", fEnable, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a list of users for the specified file.
     * @param {PWSTR} lpFileName The name of the file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pUsers A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a> structure that receives the list of users.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-queryusersonencryptedfile
     * @since windows5.1.2600
     */
    static QueryUsersOnEncryptedFile(lpFileName, pUsers) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\QueryUsersOnEncryptedFile", "ptr", lpFileName, "ptr", pUsers, "uint")
        return result
    }

    /**
     * Retrieves a list of recovery agents for the specified file.
     * @param {PWSTR} lpFileName The name of the file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pRecoveryAgents A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a> structure that receives a list of recovery agents.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-queryrecoveryagentsonencryptedfile
     * @since windows5.1.2600
     */
    static QueryRecoveryAgentsOnEncryptedFile(lpFileName, pRecoveryAgents) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\QueryRecoveryAgentsOnEncryptedFile", "ptr", lpFileName, "ptr", pRecoveryAgents, "uint")
        return result
    }

    /**
     * Removes specified certificate hashes from a specified file.
     * @param {PWSTR} lpFileName The name of the file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pHashes A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a> structure that contains a list of certificate hashes to be removed from the file.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-removeusersfromencryptedfile
     * @since windows5.1.2600
     */
    static RemoveUsersFromEncryptedFile(lpFileName, pHashes) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\RemoveUsersFromEncryptedFile", "ptr", lpFileName, "ptr", pHashes, "uint")
        return result
    }

    /**
     * Adds user keys to the specified encrypted file.
     * @param {PWSTR} lpFileName The name of the encrypted file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_LIST>} pEncryptionCertificates A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_list">ENCRYPTION_CERTIFICATE_LIST</a> structure that contains the list of new user keys to be added to the file.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-adduserstoencryptedfile
     * @since windows5.1.2600
     */
    static AddUsersToEncryptedFile(lpFileName, pEncryptionCertificates) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\AddUsersToEncryptedFile", "ptr", lpFileName, "ptr", pEncryptionCertificates, "uint")
        return result
    }

    /**
     * Sets the user's current key to the specified certificate.
     * @param {Pointer<ENCRYPTION_CERTIFICATE>} pEncryptionCertificate A pointer to a certificate that will be the user's key. This parameter is a pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate">ENCRYPTION_CERTIFICATE</a> structure.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-setuserfileencryptionkey
     * @since windows5.1.2600
     */
    static SetUserFileEncryptionKey(pEncryptionCertificate) {
        result := DllCall("ADVAPI32.dll\SetUserFileEncryptionKey", "ptr", pEncryptionCertificate, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<ENCRYPTION_CERTIFICATE>} pEncryptionCertificate 
     * @param {Integer} dwCapabilities 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SetUserFileEncryptionKeyEx(pEncryptionCertificate, dwCapabilities, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("ADVAPI32.dll\SetUserFileEncryptionKeyEx", "ptr", pEncryptionCertificate, "uint", dwCapabilities, "uint", dwFlags, "ptr", pvReserved, "uint")
        return result
    }

    /**
     * Frees a certificate hash list.
     * @remarks
     * 
     * <b>ReFS:  </b>This function is not supported.
     * 
     * 
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pUsers A pointer to a certificate hash list structure, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a>, which was returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/nf-winefs-queryusersonencryptedfile">QueryUsersOnEncryptedFile</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/nf-winefs-queryrecoveryagentsonencryptedfile">QueryRecoveryAgentsOnEncryptedFile</a> function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-freeencryptioncertificatehashlist
     * @since windows5.1.2600
     */
    static FreeEncryptionCertificateHashList(pUsers) {
        DllCall("ADVAPI32.dll\FreeEncryptionCertificateHashList", "ptr", pUsers)
    }

    /**
     * Disables or enables encryption of the specified directory and the files in it.
     * @param {PWSTR} DirPath The name of the directory for which to enable or 
     *       disable encryption.
     * @param {BOOL} Disable Indicates whether to disable encryption (<b>TRUE</b>) or enable it 
     *       (<b>FALSE</b>).
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-encryptiondisable
     * @since windows5.1.2600
     */
    static EncryptionDisable(DirPath, Disable) {
        DirPath := DirPath is String ? StrPtr(DirPath) : DirPath

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\EncryptionDisable", "ptr", DirPath, "int", Disable, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies the EFS metadata from one file or directory to another.
     * @param {PWSTR} SrcFileName The name of the file or directory from which the EFS metadata is to be copied. This source file or directory must be encrypted.
     * @param {PWSTR} DstFileName The name of the file or directory to which the EFS metadata is to be copied. 
     * 
     * 
     * 
     * 
     * This destination file or directory does not have to be encrypted before the call to this function; however if this function completes successfully, it will be encrypted.
     * 
     * If the value of <i>SrcFileName</i> specifies a file, the value of this parameter must also specify a file, and likewise for directories. If a file or directory with the name specified by this parameter does not exist, a file or directory (depending on whether <i>SrcFileName</i> specifies a file or directory) will be created.
     * @param {Integer} dwCreationDistribution Describes how the destination file or directory identified by the <i>DstFileName</i> parameter value is to be opened. The following are the valid values of this parameter. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl>
     * <dt><b>CREATE_ALWAYS</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Always create the destination file or directory. Any value passed in this parameter other than <b>CREATE_NEW</b> will be processed as <b>CREATE_ALWAYS</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_NEW"></a><a id="create_new"></a><dl>
     * <dt><b>CREATE_NEW</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create the destination file or directory only if it does not already exist. If it does exist, and this value is specified, this function will fail.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwAttributes The file attributes of the destination file or directory. The <b>FILE_READ_ONLY</b> attribute is currently not processed by this function.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the destination file or directory, if it does not already exist. If you specify <b>NULL</b>, the file or directory gets a default security descriptor. The ACLs in the default security descriptor for a file or directory are inherited from its parent directory.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://docs.microsoft.com/windows/win32/api//winefs/nf-winefs-duplicateencryptioninfofile
     * @since windows5.1.2600
     */
    static DuplicateEncryptionInfoFile(SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes) {
        SrcFileName := SrcFileName is String ? StrPtr(SrcFileName) : SrcFileName
        DstFileName := DstFileName is String ? StrPtr(DstFileName) : DstFileName

        result := DllCall("ADVAPI32.dll\DuplicateEncryptionInfoFile", "ptr", SrcFileName, "ptr", DstFileName, "uint", dwCreationDistribution, "uint", dwAttributes, "ptr", lpSecurityAttributes, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} lpFileName 
     * @param {Pointer<UInt32>} pcbMetadata 
     * @param {Pointer<Byte>} ppbMetadata 
     * @returns {Integer} 
     * @deprecated
     */
    static GetEncryptedFileMetadata(lpFileName, pcbMetadata, ppbMetadata) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\GetEncryptedFileMetadata", "ptr", lpFileName, "uint*", pcbMetadata, "char*", ppbMetadata, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} lpFileName 
     * @param {Pointer<Byte>} pbOldMetadata 
     * @param {Pointer<Byte>} pbNewMetadata 
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH>} pOwnerHash 
     * @param {Integer} dwOperation 
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pCertificatesAdded 
     * @returns {Integer} 
     * @deprecated
     */
    static SetEncryptedFileMetadata(lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\SetEncryptedFileMetadata", "ptr", lpFileName, "char*", pbOldMetadata, "char*", pbNewMetadata, "ptr", pOwnerHash, "uint", dwOperation, "ptr", pCertificatesAdded, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} pbMetadata 
     * @returns {String} Nothing - always returns an empty string
     * @deprecated
     */
    static FreeEncryptedFileMetadata(pbMetadata) {
        DllCall("ADVAPI32.dll\FreeEncryptedFileMetadata", "char*", pbMetadata)
    }

    /**
     * 
     * @returns {Integer} 
     */
    static LZStart() {
        result := DllCall("KERNEL32.dll\LZStart", "int")
        return result
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static LZDone() {
        DllCall("KERNEL32.dll\LZDone")
    }

    /**
     * 
     * @param {Integer} hfSource 
     * @param {Integer} hfDest 
     * @returns {Integer} 
     */
    static CopyLZFile(hfSource, hfDest) {
        result := DllCall("KERNEL32.dll\CopyLZFile", "int", hfSource, "int", hfDest, "int")
        return result
    }

    /**
     * Copies a source file to a destination file.
     * @param {Integer} hfSource A handle to the source file.
     * @param {Integer} hfDest A handle to the destination file.
     * @returns {Integer} If the function succeeds, the return value specifies the size, in bytes, of the destination file.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZCopy</b> calls neither 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is a list of error codes that 
     * <b>LZCopy</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADOUTHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the destination file is not valid. The file cannot be written.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_READ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file format is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzcopy
     * @since windows5.1.2600
     */
    static LZCopy(hfSource, hfDest) {
        result := DllCall("KERNEL32.dll\LZCopy", "int", hfSource, "int", hfDest, "int")
        return result
    }

    /**
     * Allocates memory for the internal data structures required to decompress files, and then creates and initializes them.
     * @param {Integer} hfSource A handle to the file.
     * @returns {Integer} If the function succeeds, the return value is a new LZ file handle.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZInit</b> calls neither 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is the list of the error codes that 
     * <b>LZInit</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_UNKNOWNALG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is compressed with an unrecognized compression algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzinit
     * @since windows5.1.2600
     */
    static LZInit(hfSource) {
        result := DllCall("KERNEL32.dll\LZInit", "int", hfSource, "int")
        return result
    }

    /**
     * Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm.
     * @param {PSTR} lpszSource The name of the compressed file.
     * @param {PSTR} lpszBuffer A pointer to a buffer that receives the original name of the compressed file.
     * @returns {Integer} If the function succeeds, the return value is 1.
     * 
     * If the function fails, the return value is LZERROR_BADVALUE. There is no extended error information for this function; do not call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>GetExpandedName</b> calls neither 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</div>
     * <div> </div>
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-getexpandednamea
     * @since windows5.1.2600
     */
    static GetExpandedNameA(lpszSource, lpszBuffer) {
        lpszSource := lpszSource is String ? StrPtr(lpszSource) : lpszSource
        lpszBuffer := lpszBuffer is String ? StrPtr(lpszBuffer) : lpszBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetExpandedNameA", "ptr", lpszSource, "ptr", lpszBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm.
     * @param {PWSTR} lpszSource The name of the compressed file.
     * @param {PWSTR} lpszBuffer A pointer to a buffer that receives the original name of the compressed file.
     * @returns {Integer} If the function succeeds, the return value is 1.
     * 
     * If the function fails, the return value is LZERROR_BADVALUE. There is no extended error information for this function; do not call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>GetExpandedName</b> calls neither 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</div>
     * <div> </div>
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-getexpandednamew
     * @since windows5.1.2600
     */
    static GetExpandedNameW(lpszSource, lpszBuffer) {
        lpszSource := lpszSource is String ? StrPtr(lpszSource) : lpszSource
        lpszBuffer := lpszBuffer is String ? StrPtr(lpszBuffer) : lpszBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetExpandedNameW", "ptr", lpszSource, "ptr", lpszBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates, opens, reopens, or deletes the specified file.
     * @param {PSTR} lpFileName The name of the file.
     * @param {Pointer<OFSTRUCT>} lpReOpenBuf A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that is to receive 
     *        information about the file when the file is first opened. The structure can be used in subsequent calls to the 
     *        <b>LZOpenFile</b> function to see the open file.
     * 
     * The <b>szPathName</b> member of this structure contains characters from the original 
     *        equipment manufacturer (OEM) character set.
     * @param {Integer} wStyle 
     * @returns {Integer} If the function succeeds and the value specified by the <i>wStyle</i> parameter is not 
     *        <b>OF_READ</b>, the return value is a handle identifying the file. If the file is compressed 
     *        and opened with <i>wStyle</i> set to <b>OF_READ</b>, the return value is 
     *        a special file handle.
     * 
     * If the function fails, the return value is an <b>LZERROR_*</b> code. These codes have 
     *        values less than zero. There is no extended error information for this function; do not call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>LZOpenFile</b> calls neither 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     *        <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a 
     *        thread's last-error code.</div>
     * <div> </div>
     * The following is the list of the error codes that <b>LZOpenFile</b> can return upon 
     *        failure.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * <dt>-1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * <dt>-5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzopenfilea
     * @since windows5.1.2600
     */
    static LZOpenFileA(lpFileName, lpReOpenBuf, wStyle) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("KERNEL32.dll\LZOpenFileA", "ptr", lpFileName, "ptr", lpReOpenBuf, "ushort", wStyle, "int")
        return result
    }

    /**
     * Creates, opens, reopens, or deletes the specified file.
     * @param {PWSTR} lpFileName The name of the file.
     * @param {Pointer<OFSTRUCT>} lpReOpenBuf A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that is to receive 
     *        information about the file when the file is first opened. The structure can be used in subsequent calls to the 
     *        <b>LZOpenFile</b> function to see the open file.
     * 
     * The <b>szPathName</b> member of this structure contains characters from the original 
     *        equipment manufacturer (OEM) character set.
     * @param {Integer} wStyle 
     * @returns {Integer} If the function succeeds and the value specified by the <i>wStyle</i> parameter is not 
     *        <b>OF_READ</b>, the return value is a handle identifying the file. If the file is compressed 
     *        and opened with <i>wStyle</i> set to <b>OF_READ</b>, the return value is 
     *        a special file handle.
     * 
     * If the function fails, the return value is an <b>LZERROR_*</b> code. These codes have 
     *        values less than zero. There is no extended error information for this function; do not call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>LZOpenFile</b> calls neither 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     *        <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a 
     *        thread's last-error code.</div>
     * <div> </div>
     * The following is the list of the error codes that <b>LZOpenFile</b> can return upon 
     *        failure.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * <dt>-1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * <dt>-5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzopenfilew
     * @since windows5.1.2600
     */
    static LZOpenFileW(lpFileName, lpReOpenBuf, wStyle) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("KERNEL32.dll\LZOpenFileW", "ptr", lpFileName, "ptr", lpReOpenBuf, "ushort", wStyle, "int")
        return result
    }

    /**
     * Moves a file pointer the specified number of bytes from a starting position.
     * @param {Integer} hFile A handle to the file.
     * @param {Integer} lOffset The number of bytes by which to move the file pointer.
     * @param {Integer} iOrigin 
     * @returns {Integer} If the function succeeds, the return value specifies the offset from the beginning of the file to the new pointer position.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZSeek</b> calls neither <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is the list of error codes that 
     * <b>LZSeek</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADVALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters is outside the range of acceptable values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzseek
     * @since windows5.1.2600
     */
    static LZSeek(hFile, lOffset, iOrigin) {
        result := DllCall("KERNEL32.dll\LZSeek", "int", hFile, "int", lOffset, "int", iOrigin, "int")
        return result
    }

    /**
     * Reads (at most) the specified number of bytes from a file and copies them into a buffer.
     * @param {Integer} hFile A handle to the file.
     * @param {Pointer} lpBuffer A pointer to a buffer that receives the bytes read from the file. Ensure that this buffer is larger than <i>cbRead</i>.
     * @param {Integer} cbRead The count of bytes to be read.
     * @returns {Integer} If the function succeeds, the return value specifies the number of bytes read.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZRead</b> calls neither <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href="/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is the list of error codes that 
     * <b>LZRead</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADOUTHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the destination file is not valid. The file cannot be written.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADVALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the input parameters is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_READ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file format is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_WRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is insufficient space for the output file.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzread
     * @since windows5.1.2600
     */
    static LZRead(hFile, lpBuffer, cbRead) {
        result := DllCall("KERNEL32.dll\LZRead", "int", hFile, "ptr", lpBuffer, "int", cbRead, "int")
        return result
    }

    /**
     * Closes a file that was opened by using the LZOpenFile function.
     * @remarks
     * 
     * The handle identifying the file must be retrieved by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a> function. If the handle is retrieved by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfile">OpenFile</a> function, an error occurs.
     * 
     * If the file has been compressed by the Lempel-Ziv algorithm and opened by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a>, 
     * <b>LZClose</b> frees any global heap space that was allocated to expand the file.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * 
     * 
     * @param {Integer} hFile A handle to the file to be closed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//lzexpand/nf-lzexpand-lzclose
     * @since windows5.1.2600
     */
    static LZClose(hFile) {
        DllCall("KERNEL32.dll\LZClose", "int", hFile)
    }

    /**
     * Indicates whether compression should be used on a particular volume, and if so, which compression algorithm should be used.
     * @param {PWSTR} Volume Specifies the path to the volume whose compression state is desired.
     * @param {Pointer<UInt32>} Algorithm Points to a ULONG value. If the function returns TRUE, indicating compression is desired, this value will contain the algorithm that should be used for this volume.
     * @returns {BOOL} If binaries on this volume should be compressed, the return value is TRUE; otherwise it is FALSE. This function will return FALSE if the system does not support compression on the specified volume.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofshouldcompressbinaries
     */
    static WofShouldCompressBinaries(Volume, Algorithm) {
        Volume := Volume is String ? StrPtr(Volume) : Volume

        result := DllCall("WOFUTIL.dll\WofShouldCompressBinaries", "ptr", Volume, "uint*", Algorithm, "int")
        return result
    }

    /**
     * Used to query the version of the driver used to support a particular provider.
     * @param {HANDLE} FileOrVolumeHandle A handle to a file or volume opened with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or a similar API.
     * @param {Integer} Provider Indicates which provider the version query is intended for. Multiple versions of Wof may exist on the same volume at the same time for different providers.
     * @param {Pointer<UInt32>} WofVersion Pointer to a ULONG which will contain the version upon successful completion of this function.
     * @returns {HRESULT} This function returns an HRESULT indicating success or the reason for failure. If no driver is attached on the specified volume for the specified provider, the function will fail with HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION).
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofgetdriverversion
     */
    static WofGetDriverVersion(FileOrVolumeHandle, Provider, WofVersion) {
        FileOrVolumeHandle := FileOrVolumeHandle is Win32Handle ? NumGet(FileOrVolumeHandle, "ptr") : FileOrVolumeHandle

        result := DllCall("WOFUTIL.dll\WofGetDriverVersion", "ptr", FileOrVolumeHandle, "uint", Provider, "uint*", WofVersion, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Used to change a file from being backed by a physical file to one backed by a system data provider.
     * @param {HANDLE} FileHandle A handle to a file opened with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or a similar API.
     * @param {Integer} Provider Indicates which provider is backing this file. Currently defined providers are: 
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>Indicates that the data for the file should be obtained from a WIM file.  On access, data is transparently extracted from the WIM file and provided to applications.  If the file contents are modified, data is transparently decompressed and the file is restored to the same physical form it had if this API were not used.</td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>Indicates that the data for the file should be compressed and stored with the file itself. On access, data is transparently decompressed and provided to applications. If the file contents are modified, data is transparently decompressed and the file is restored to the same physical form it had if this API were not used. This provider requires Windows 10.</td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ExternalFileInfo Provides data specific to the specified provider. Data structures for each defined provider are: 
     * 	  
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wim_external_file_info">WIM_EXTERNAL_FILE_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wof_file_compression_info_v1">WOF_FILE_COMPRESSION_INFO</a>
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Length Specifies the length of provider specific data, in bytes. This should correspond to the structures defined above: 
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>sizeof(WIM_EXTERNAL_FILE_INFO)</td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>sizeof(WOF_FILE_COMPRESSION_INFO)</td>
     * </tr>
     * </table>
     * @returns {HRESULT} This function returns an HRESULT indicating success or the reason for failure.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofsetfiledatalocation
     */
    static WofSetFileDataLocation(FileHandle, Provider, ExternalFileInfo, Length) {
        FileHandle := FileHandle is Win32Handle ? NumGet(FileHandle, "ptr") : FileHandle

        result := DllCall("WOFUTIL.dll\WofSetFileDataLocation", "ptr", FileHandle, "uint", Provider, "ptr", ExternalFileInfo, "uint", Length, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Used to determine if a file is being backed by a physical file or is backed by a system data provider, and optionally indicates which provider or additional data about the file.
     * @param {PWSTR} FilePath Specifies the path to the file for which the backing state is desired.
     * @param {Pointer<BOOL>} IsExternalFile Optionally points to a BOOL value. On successful return, this value will be TRUE if the object is externally backed, FALSE if it is a physical file.
     * @param {Pointer<UInt32>} Provider Optionally points to a ULONG value. On successful return, this value will be set to the provider that externally backs this object. Currently defined providers are: 
     * 	  		
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>Indicates that the data for the file resides in a separate WIM file.  On access, data is transparently extracted, decompressed and provided to applications.  If the file contents are modified, data is transparently decompressed and the file is restored to a regular file. </td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>Indicates that the data for the file should be compressed and stored with the file itself. On access, data is transparently decompressed and provided to applications. If the file contents are modified, data is transparently decompressed and the file is restored to a regular file. This provider requires Windows 10.</td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ExternalFileInfo Optionally points to a caller allocated buffer. On successful return, this buffer will contain additional information about the state of the file. If this value is provided, <b>BufferLength</b> must also be specified. Data structures for each defined provider are:
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wim_external_file_info">WIM_EXTERNAL_FILE_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wof_file_compression_info_v1">WOF_FILE_COMPRESSION_INFO</a>
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} BufferLength Optionally points to a value that contains the length of the buffer specified in <b>ExternalFileInfo</b>. On return, this value will be set to the size of the buffer consumed, or the size of the buffer required. If the buffer is of insufficient length, this function will succeed indicating the required size and will not populate the buffer in <b>ExternalFileInfo</b>. This length should correspond to one of the structures defined above: 
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>sizeof(WIM_EXTERNAL_FILE_INFO)</td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>sizeof(WOF_FILE_COMPRESSION_INFO)</td>
     * </tr>
     * </table>
     * @returns {HRESULT} This function returns an HRESULT indicating success or the reason for failure. If the buffer specified in <i>ExternalFileInfo</i> is not of the correct size, the function will return S_OK and indicate the required buffer size in <i>BufferLength</i>.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofisexternalfile
     */
    static WofIsExternalFile(FilePath, IsExternalFile, Provider, ExternalFileInfo, BufferLength) {
        FilePath := FilePath is String ? StrPtr(FilePath) : FilePath

        result := DllCall("WOFUTIL.dll\WofIsExternalFile", "ptr", FilePath, "ptr", IsExternalFile, "uint*", Provider, "ptr", ExternalFileInfo, "uint*", BufferLength, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enumerates all the data sources from a specified provider for a specified volume.
     * @param {PWSTR} VolumeName The volume name hosting the files for which the backing data sources are requested.
     * @param {Integer} Provider Indicates which provider’s data sources are being requested.  Supported providers for this operation are: 
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM </td>
     * <td>Indicates that the function should return the WIM files which are providing data for placeholder files on the specified volume.</td>
     * </tr>
     * </table>
     * @param {Pointer<WofEnumEntryProc>} EnumProc The callback function for each data source. The enumeration will stop          if <i>EnumProc</i> returns <b>FALSE</b>.
     * @param {Pointer<Void>} UserData User defined data passed to <i>EnumProc</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofenumentries
     */
    static WofEnumEntries(VolumeName, Provider, EnumProc, UserData) {
        VolumeName := VolumeName is String ? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofEnumEntries", "ptr", VolumeName, "uint", Provider, "ptr", EnumProc, "ptr", UserData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Adds a single WIM data source to a volume such that files can be created on the volume which are stored within the WIM.
     * @param {PWSTR} VolumeName The path to the volume upon which files residing in the WIM should be created.
     * @param {PWSTR} WimPath The path to the WIM file which should be used to provide data to files.
     * @param {Integer} WimType The type of WIM. Can be <b>WIM_BOOT_OS_WIM</b> or <b>WIM_BOOT_NOT_OS_WIM</b>.
     * @param {Integer} WimIndex Index of the image in the WIM which is applied.
     * @param {Pointer<Int64>} DataSourceId On successful return, contains the data source used to identify the entry.  This data source can be used to create new files with <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/nf-wofapi-wofsetfiledatalocation">WofSetFileDataLocation</a>.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofwimaddentry
     */
    static WofWimAddEntry(VolumeName, WimPath, WimType, WimIndex, DataSourceId) {
        VolumeName := VolumeName is String ? StrPtr(VolumeName) : VolumeName
        WimPath := WimPath is String ? StrPtr(WimPath) : WimPath

        result := DllCall("WOFUTIL.dll\WofWimAddEntry", "ptr", VolumeName, "ptr", WimPath, "uint", WimType, "uint", WimIndex, "int64*", DataSourceId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enumerates all of the files which are being backed by a specified WIM data source on a specified volume.
     * @param {PWSTR} VolumeName The path to the volume which hosts WIM-backed files.
     * @param {Integer} DataSourceId Identifier used to identify the WIM entry.
     * @param {Pointer<WofEnumFilesProc>} EnumProc The callback function for file provided by the WIM entry.
     * @param {Pointer<Void>} UserData Optional user defined data passed to <i>EnumProc</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofwimenumfiles
     */
    static WofWimEnumFiles(VolumeName, DataSourceId, EnumProc, UserData) {
        VolumeName := VolumeName is String ? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofWimEnumFiles", "ptr", VolumeName, "int64", DataSourceId, "ptr", EnumProc, "ptr", UserData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Temporarily removes a WIM data source from backing files on a volume until the volume is remounted or the data source is updated with WofWimUpdateEntry.
     * @param {PWSTR} VolumeName The volume name which contained files whose data was provided by the WIM.
     * @param {Integer} DataSourceId Identifies the WIM entry.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofwimsuspendentry
     */
    static WofWimSuspendEntry(VolumeName, DataSourceId) {
        VolumeName := VolumeName is String ? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofWimSuspendEntry", "ptr", VolumeName, "int64", DataSourceId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes a single WIM data source from backing files on a volume.
     * @param {PWSTR} VolumeName The volume name which contained files whose data was provided by the WIM.
     * @param {Integer} DataSourceId Identifes the WIM entry.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofwimremoveentry
     */
    static WofWimRemoveEntry(VolumeName, DataSourceId) {
        VolumeName := VolumeName is String ? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofWimRemoveEntry", "ptr", VolumeName, "int64", DataSourceId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Updates a WIM entry to point to a different WIM file location.
     * @param {PWSTR} VolumeName The volume name which contains files whose data is provided by the WIM.
     * @param {Integer} DataSourceId Identifies the WIM entry.
     * @param {PWSTR} NewWimPath The new location of the WIM file.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-wofwimupdateentry
     */
    static WofWimUpdateEntry(VolumeName, DataSourceId, NewWimPath) {
        VolumeName := VolumeName is String ? StrPtr(VolumeName) : VolumeName
        NewWimPath := NewWimPath is String ? StrPtr(NewWimPath) : NewWimPath

        result := DllCall("WOFUTIL.dll\WofWimUpdateEntry", "ptr", VolumeName, "int64", DataSourceId, "ptr", NewWimPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enumerates all of the files which are compressed with a specified compression algorithm on a specified volume.
     * @param {PWSTR} VolumeName A full path to the volume containing the files to enumerate.
     * @param {Integer} Algorithm The compression algorithm to enumerate.  For a list of valid compression algorithms, see <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wof_file_compression_info_v1">WOF_FILE_COMPRESSION_INFO_V1</a>.  If this value is MAX_ULONG, files compressed with any supported compression algorithm will be returned.
     * @param {Pointer<WofEnumFilesProc>} EnumProc The callback function for each data source. The enumeration will stop if <i>EnumProc</i> returns FALSE.
     * @param {Pointer<Void>} UserData User defined data passed to <i>EnumProc</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b xmlns:loc="http://microsoft.com/wdcml/l10n">S_OK</b>. Otherwise, it returns an <b xmlns:loc="http://microsoft.com/wdcml/l10n">HRESULT</b> error code.
     * @see https://docs.microsoft.com/windows/win32/api//wofapi/nf-wofapi-woffileenumfiles
     */
    static WofFileEnumFiles(VolumeName, Algorithm, EnumProc, UserData) {
        VolumeName := VolumeName is String ? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofFileEnumFiles", "ptr", VolumeName, "uint", Algorithm, "ptr", EnumProc, "ptr", UserData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a context to be used to read replication records.
     * @param {PWSTR} LogPath The path that identifies the Resource Manager's .blf file.
     * @param {CLS_LSN} BeginningLsn The first LSN in the range to be read.
     * @param {CLS_LSN} EndingLsn The last LSN in the range to be read.
     * @param {Pointer<TXF_ID>} TxfFileId The TxF identifier to search for in the LSN range. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/txfw32/ns-txfw32-txf_id">TXF_ID</a>.
     * @param {Pointer<Void>} TxfLogContext A pointer to the context created.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//txfw32/nf-txfw32-txflogcreatefilereadcontext
     * @since windows6.0.6000
     */
    static TxfLogCreateFileReadContext(LogPath, BeginningLsn, EndingLsn, TxfFileId, TxfLogContext) {
        LogPath := LogPath is String ? StrPtr(LogPath) : LogPath

        A_LastError := 0

        result := DllCall("txfw32.dll\TxfLogCreateFileReadContext", "ptr", LogPath, "ptr", BeginningLsn, "ptr", EndingLsn, "ptr", TxfFileId, "ptr", TxfLogContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a context that is required to read any replication records.
     * @param {PWSTR} LogPath Location of the RM's CLFS BLF.
     * @param {CLS_LSN} BeginningLsn Start of LSN range to search. (inclusive)
     * @param {CLS_LSN} EndingLsn End of LSN range to search. (inclusive)
     * @param {Pointer<Int64>} BeginningVirtualClock Start of the virtual clock.
     * @param {Pointer<Int64>} EndingVirtualClock End of the virtual clock.
     * @param {Integer} RecordTypeMask A mask value indicating the type of records.
     * @param {Pointer<Void>} TxfLogContext The returned context object.
     * @returns {BOOL} Returns S_OK on success.
     * @see https://docs.microsoft.com/windows/win32/api//txfw32/nf-txfw32-txflogcreaterangereadcontext
     */
    static TxfLogCreateRangeReadContext(LogPath, BeginningLsn, EndingLsn, BeginningVirtualClock, EndingVirtualClock, RecordTypeMask, TxfLogContext) {
        LogPath := LogPath is String ? StrPtr(LogPath) : LogPath

        result := DllCall("txfw32.dll\TxfLogCreateRangeReadContext", "ptr", LogPath, "ptr", BeginningLsn, "ptr", EndingLsn, "int64*", BeginningVirtualClock, "int64*", EndingVirtualClock, "uint", RecordTypeMask, "ptr", TxfLogContext, "int")
        return result
    }

    /**
     * Closes a read context created by the TxfLogCreateFileReadContext function.
     * @param {Pointer<Void>} TxfLogContext A pointer to the context.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//txfw32/nf-txfw32-txflogdestroyreadcontext
     * @since windows6.0.6000
     */
    static TxfLogDestroyReadContext(TxfLogContext) {
        A_LastError := 0

        result := DllCall("txfw32.dll\TxfLogDestroyReadContext", "ptr", TxfLogContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads the redo records from the log.
     * @param {Pointer<Void>} TxfLogContext A pointer to the context.
     * @param {Integer} BufferLength The size of the output buffer, in bytes.
     * @param {Pointer} Buffer A pointer to the buffer that receives the records. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/txfw32/ns-txfw32-txf_log_record_base">TXF_LOG_RECORD_BASE</a>.
     * @param {Pointer<UInt32>} BytesUsed The number of bytes written to the output buffer.
     * @param {Pointer<UInt32>} RecordCount The number of records written to the output buffer.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replication context is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some of the available records were copied into the buffer. Call this function again to retrieve the rest 
     * 	       of the records.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer is not large enough to contain even one record. If <i>BytesUsed</i> is 
     * 	       nonzero, then there was enough space to copy the 
     * 	       <a href="/windows/desktop/api/txfw32/ns-txfw32-txf_log_record_base">TXF_LOG_RECORD_BASE</a> structure, which indicates the 
     * 	       required buffer size to read the next complete record.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_CORRUPT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The format of the log file being processed is unrecognized.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//txfw32/nf-txfw32-txflogreadrecords
     * @since windows6.0.6000
     */
    static TxfLogReadRecords(TxfLogContext, BufferLength, Buffer, BytesUsed, RecordCount) {
        A_LastError := 0

        result := DllCall("txfw32.dll\TxfLogReadRecords", "ptr", TxfLogContext, "uint", BufferLength, "ptr", Buffer, "uint*", BytesUsed, "uint*", RecordCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {HANDLE} FileHandle 
     * @param {Pointer<TXF_ID>} TxfFileId 
     * @param {Pointer<CLS_LSN>} LastLsn 
     * @param {Pointer<UInt32>} TransactionState 
     * @param {Pointer<Guid>} LockingTransaction 
     * @returns {BOOL} 
     */
    static TxfReadMetadataInfo(FileHandle, TxfFileId, LastLsn, TransactionState, LockingTransaction) {
        FileHandle := FileHandle is Win32Handle ? NumGet(FileHandle, "ptr") : FileHandle

        result := DllCall("txfw32.dll\TxfReadMetadataInfo", "ptr", FileHandle, "ptr", TxfFileId, "ptr", LastLsn, "uint*", TransactionState, "ptr", LockingTransaction, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} RecordBuffer 
     * @param {Integer} RecordBufferLengthInBytes 
     * @param {Pointer} NameBuffer 
     * @param {Pointer<UInt32>} NameBufferLengthInBytes 
     * @param {Pointer<TXF_ID>} TxfId 
     * @returns {BOOL} 
     */
    static TxfLogRecordGetFileName(RecordBuffer, RecordBufferLengthInBytes, NameBuffer, NameBufferLengthInBytes, TxfId) {
        result := DllCall("txfw32.dll\TxfLogRecordGetFileName", "ptr", RecordBuffer, "uint", RecordBufferLengthInBytes, "ptr", NameBuffer, "uint*", NameBufferLengthInBytes, "ptr", TxfId, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} RecordBuffer 
     * @param {Integer} RecordBufferLengthInBytes 
     * @param {Pointer<UInt32>} GenericType 
     * @param {Pointer<Int64>} VirtualClock 
     * @returns {BOOL} 
     */
    static TxfLogRecordGetGenericType(RecordBuffer, RecordBufferLengthInBytes, GenericType, VirtualClock) {
        result := DllCall("txfw32.dll\TxfLogRecordGetGenericType", "ptr", RecordBuffer, "uint", RecordBufferLengthInBytes, "uint*", GenericType, "int64*", VirtualClock, "int")
        return result
    }

    /**
     * Sets the MiniVersion that a subsequent create should open.
     * @param {Integer} MiniVersion A USHORT identifying which version should be opened by create.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//txfw32/nf-txfw32-txfsetthreadminiversionforcreate
     */
    static TxfSetThreadMiniVersionForCreate(MiniVersion) {
        DllCall("txfw32.dll\TxfSetThreadMiniVersionForCreate", "ushort", MiniVersion)
    }

    /**
     * Returns the MiniVersion a subsequent create is set to open.
     * @param {Pointer<UInt16>} MiniVersion Pointer to a USHORT which will receive the result.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//txfw32/nf-txfw32-txfgetthreadminiversionforcreate
     */
    static TxfGetThreadMiniVersionForCreate(MiniVersion) {
        DllCall("txfw32.dll\TxfGetThreadMiniVersionForCreate", "ushort*", MiniVersion)
    }

    /**
     * Creates a new transaction object.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpTransactionAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *       structure that determines whether the returned handle can be inherited by child processes. If this parameter is 
     *       <b>NULL</b>, the handle cannot be inherited.
     *       
     * 
     * The <b>lpSecurityDescriptor</b> member of the structure specifies a 
     *        <a href="https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">security descriptor</a> for the new 
     *        event. If <i>lpTransactionAttributes</i> is <b>NULL</b>, the object gets 
     *        a default security descriptor. The access control lists (ACL) in the default security descriptor for a 
     *        transaction come from the primary or impersonation token of the creator.
     * @param {Pointer<Guid>} UOW Reserved. Must be zero (0).
     * @param {Integer} CreateOptions Any optional transaction instructions.  
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TRANSACTION_DO_NOT_PROMOTE"></a><a id="transaction_do_not_promote"></a><dl>
     * <dt><b>TRANSACTION_DO_NOT_PROMOTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The transaction cannot be distributed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} IsolationLevel Reserved; specify zero (0).
     * @param {Integer} IsolationFlags Reserved; specify zero (0).
     * @param {Integer} Timeout The time-out interval, in milliseconds. If a nonzero value is specified, the transaction will be aborted when the interval elapses if it has not already reached the prepared state.
     * 
     * Specify zero (0) or INFINITE to provide an infinite time-out.
     * @param {PWSTR} Description A user-readable description of the transaction.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the transaction.
     *       
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-createtransaction
     * @since windows6.0.6000
     */
    static CreateTransaction(lpTransactionAttributes, UOW, CreateOptions, IsolationLevel, IsolationFlags, Timeout, Description) {
        Description := Description is String ? StrPtr(Description) : Description

        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateTransaction", "ptr", lpTransactionAttributes, "ptr", UOW, "uint", CreateOptions, "uint", IsolationLevel, "uint", IsolationFlags, "uint", Timeout, "ptr", Description, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Opens an existing transaction.
     * @param {Integer} dwDesiredAccess The access to the transaction object. You must have read and write access to work with a transaction. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/transaction-access-masks">Transaction Access Masks</a> for a list of valid values.
     * @param {Pointer<Guid>} TransactionId The GUID that identifies the transaction to be opened. This is commonly referred to as  a unit of work for the transaction.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the transaction.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-opentransaction
     * @since windows6.0.6000
     */
    static OpenTransaction(dwDesiredAccess, TransactionId) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenTransaction", "uint", dwDesiredAccess, "ptr", TransactionId, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Requests that the specified transaction be committed.
     * @param {HANDLE} TransactionHandle A handle to the transaction to be committed. 
     * 
     * This handle must have been opened with the TRANSACTION_COMMIT access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Ktm/ktm-security-and-access-rights">KTM Security and Access Rights</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-committransaction
     * @since windows6.0.6000
     */
    static CommitTransaction(TransactionHandle) {
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitTransaction", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified transaction be committed.
     * @param {HANDLE} TransactionHandle A handle to the transaction to be committed. 
     * 
     * This handle must have been opened with the TRANSACTION_COMMIT access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Ktm/ktm-security-and-access-rights">KTM Security and Access Rights</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. Success means that the function completed synchronously, and the calling application does not need to wait for pending results.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-committransactionasync
     * @since windows6.0.6000
     */
    static CommitTransactionAsync(TransactionHandle) {
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitTransactionAsync", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified transaction be rolled back.
     * @param {HANDLE} TransactionHandle A handle to the transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-rollbacktransaction
     * @since windows6.0.6000
     */
    static RollbackTransaction(TransactionHandle) {
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackTransaction", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified transaction be rolled back. This function returns asynchronously.
     * @param {HANDLE} TransactionHandle A handle to the transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero, and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_IO_PENDING.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-rollbacktransactionasync
     * @since windows6.0.6000
     */
    static RollbackTransactionAsync(TransactionHandle) {
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackTransactionAsync", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains the identifier (ID) for the specified transaction.
     * @param {HANDLE} TransactionHandle A handle to the transaction.
     * @param {Pointer<Guid>} TransactionId A pointer to a variable that receives the ID of the transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-gettransactionid
     * @since windows6.0.6000
     */
    static GetTransactionId(TransactionHandle, TransactionId) {
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetTransactionId", "ptr", TransactionHandle, "ptr", TransactionId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns the requested information about the specified transaction.
     * @param {HANDLE} TransactionHandle A handle to the transaction. The handle must have  the TRANSACTION_QUERY_INFORMATION permission to retrieve the information.
     * @param {Pointer<UInt32>} Outcome A pointer to a buffer that receives the current outcome of the transaction. If the call to the <b>GetTransactionInformation</b> function is successful, this value will be one of the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ne-winnt-transaction_outcome">TRANSACTION_OUTCOME</a> enumeration values.
     * @param {Pointer<UInt32>} IsolationLevel Reserved.
     * @param {Pointer<UInt32>} IsolationFlags Reserved.
     * @param {Pointer<UInt32>} Timeout A pointer to a variable that receives the timeout value, in milliseconds, for this transaction.
     * @param {Integer} BufferLength The size of the <i>Description</i> parameter, in bytes. The buffer length value cannot be longer than the value of MAX_TRANSACTION_DESCRIPTION_LENGTH.
     * @param {PWSTR} Description A pointer to a buffer that receives the user-defined description of the transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-gettransactioninformation
     * @since windows6.0.6000
     */
    static GetTransactionInformation(TransactionHandle, Outcome, IsolationLevel, IsolationFlags, Timeout, BufferLength, Description) {
        Description := Description is String ? StrPtr(Description) : Description
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetTransactionInformation", "ptr", TransactionHandle, "uint*", Outcome, "uint*", IsolationLevel, "uint*", IsolationFlags, "uint*", Timeout, "uint", BufferLength, "ptr", Description, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the transaction information for the specified transaction.
     * @param {HANDLE} TransactionHandle A handle to the transaction. The handle must have the TRANSACTION_SET_INFORMATION permission to set the transaction information.
     * @param {Integer} IsolationLevel Reserved; specify zero.
     * @param {Integer} IsolationFlags Reserved.
     * @param {Integer} Timeout The timeout value, in milliseconds, for this transaction.
     * @param {PWSTR} Description The user-defined description of this transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-settransactioninformation
     * @since windows6.0.6000
     */
    static SetTransactionInformation(TransactionHandle, IsolationLevel, IsolationFlags, Timeout, Description) {
        Description := Description is String ? StrPtr(Description) : Description
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\SetTransactionInformation", "ptr", TransactionHandle, "uint", IsolationLevel, "uint", IsolationFlags, "uint", Timeout, "ptr", Description, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new transaction manager (TM) object and returns a handle with the specified access.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpTransactionAttributes The transaction <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> (ACLs) for the TM object.
     * @param {PWSTR} LogFileName The log file stream name.  If the stream does not exist in the log, it is created. To create a volatile TM, this parameter must be <b>NULL</b> and <i>CreateOptions</i> must specify TRANSACTION_MANAGER_VOLATILE, this transaction manager is considered volatile.
     * @param {Integer} CreateOptions Any optional attributes for the new TM.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TRANSACTION_MANAGER_VOLATILE"></a><a id="transaction_manager_volatile"></a><dl>
     * <dt><b>TRANSACTION_MANAGER_VOLATILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the TM is volatile, and does not perform recovery.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} CommitStrength Reserved; specify zero.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the transaction manager.  
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-createtransactionmanager
     * @since windows6.0.6000
     */
    static CreateTransactionManager(lpTransactionAttributes, LogFileName, CreateOptions, CommitStrength) {
        LogFileName := LogFileName is String ? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateTransactionManager", "ptr", lpTransactionAttributes, "ptr", LogFileName, "uint", CreateOptions, "uint", CommitStrength, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Opens an existing transaction manager.
     * @param {PWSTR} LogFileName The name of the log stream.  This stream must exist within a CLFS log file.
     * @param {Integer} DesiredAccess The access requested. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/transaction-manager-access-masks">Transaction Manager Access Masks</a> for a list of valid values.
     * @param {Integer} OpenOptions Reserved; specify zero.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the transaction manager.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-opentransactionmanager
     * @since windows6.0.6000
     */
    static OpenTransactionManager(LogFileName, DesiredAccess, OpenOptions) {
        LogFileName := LogFileName is String ? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenTransactionManager", "ptr", LogFileName, "uint", DesiredAccess, "uint", OpenOptions, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Opens an existing transaction manager.
     * @param {Pointer<Guid>} TransactionManagerId The identifier of the transaction to open.
     * @param {Integer} DesiredAccess The access requested. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/transaction-manager-access-masks">Transaction Manager Access Masks</a> for a list of valid values.
     * @param {Integer} OpenOptions Reserved; specify zero.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the transaction manager.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-opentransactionmanagerbyid
     * @since windows6.0.6000
     */
    static OpenTransactionManagerById(TransactionManagerId, DesiredAccess, OpenOptions) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenTransactionManagerById", "ptr", TransactionManagerId, "uint", DesiredAccess, "uint", OpenOptions, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Renames a transaction manager (TM) object. This function can only be used on named TM handles.
     * @param {PWSTR} LogFileName The name of the log stream.  This stream must exist within a CLFS log file.
     * @param {Pointer<Guid>} ExistingTransactionManagerGuid A value that specifies the current name of the TM.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-renametransactionmanager
     * @since windows6.0.6000
     */
    static RenameTransactionManager(LogFileName, ExistingTransactionManagerGuid) {
        LogFileName := LogFileName is String ? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("ktmw32.dll\RenameTransactionManager", "ptr", LogFileName, "ptr", ExistingTransactionManagerGuid, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Recovers information only to the specified virtual clock value.
     * @param {HANDLE} TransactionManagerHandle A handle to the transaction manager.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-rollforwardtransactionmanager
     * @since windows6.0.6000
     */
    static RollforwardTransactionManager(TransactionManagerHandle, TmVirtualClock) {
        TransactionManagerHandle := TransactionManagerHandle is Win32Handle ? NumGet(TransactionManagerHandle, "ptr") : TransactionManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RollforwardTransactionManager", "ptr", TransactionManagerHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Recovers a transaction manager's state from its log file.
     * @param {HANDLE} TransactionManagerHandle A handle to the transaction manager.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-recovertransactionmanager
     * @since windows6.0.6000
     */
    static RecoverTransactionManager(TransactionManagerHandle) {
        TransactionManagerHandle := TransactionManagerHandle is Win32Handle ? NumGet(TransactionManagerHandle, "ptr") : TransactionManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RecoverTransactionManager", "ptr", TransactionManagerHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains a virtual clock value from a transaction manager.
     * @param {HANDLE} TransactionManagerHandle A handle to the transaction manager to obtain a virtual clock value for.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value for the transaction manager. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-getcurrentclocktransactionmanager
     * @since windows6.0.6000
     */
    static GetCurrentClockTransactionManager(TransactionManagerHandle, TmVirtualClock) {
        TransactionManagerHandle := TransactionManagerHandle is Win32Handle ? NumGet(TransactionManagerHandle, "ptr") : TransactionManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetCurrentClockTransactionManager", "ptr", TransactionManagerHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains an identifier for the specified transaction manager.
     * @param {HANDLE} TransactionManagerHandle A handle to the transaction manager.
     * @param {Pointer<Guid>} TransactionManagerId A pointer to a variable that receives the identifier for the transaction manager.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-gettransactionmanagerid
     * @since windows6.0.6000
     */
    static GetTransactionManagerId(TransactionManagerHandle, TransactionManagerId) {
        TransactionManagerHandle := TransactionManagerHandle is Win32Handle ? NumGet(TransactionManagerHandle, "ptr") : TransactionManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetTransactionManagerId", "ptr", TransactionManagerHandle, "ptr", TransactionManagerId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new resource manager (RM) object, and associates the RM with a transaction manager (TM).
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpResourceManagerAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains the security attributes for the resource manager.  Specify <b>NULL</b> to obtain the default attributes.
     * @param {Pointer<Guid>} ResourceManagerId A pointer the resource manager GUID. This parameter is required and must not be <b>NULL</b>.
     * @param {Integer} CreateOptions Any optional attributes for the new RM.  
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RESOURCE_MANAGER_VOLATILE"></a><a id="resource_manager_volatile"></a><dl>
     * <dt><b>RESOURCE_MANAGER_VOLATILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the RM is volatile, and does not perform recovery.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HANDLE} TmHandle A handle to the TM that will manage the transactions for this RM.
     * @param {PWSTR} Description A description for this RM.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the RM.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-createresourcemanager
     * @since windows6.0.6000
     */
    static CreateResourceManager(lpResourceManagerAttributes, ResourceManagerId, CreateOptions, TmHandle, Description) {
        Description := Description is String ? StrPtr(Description) : Description
        TmHandle := TmHandle is Win32Handle ? NumGet(TmHandle, "ptr") : TmHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateResourceManager", "ptr", lpResourceManagerAttributes, "ptr", ResourceManagerId, "uint", CreateOptions, "ptr", TmHandle, "ptr", Description, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Opens an existing resource manager (RM).
     * @param {Integer} dwDesiredAccess The access requested for the RM. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/resource-manager-access-masks">Resource Manager Access Masks</a> for a list of valid values.
     * @param {HANDLE} TmHandle A handle to the transaction manager.
     * @param {Pointer<Guid>} ResourceManagerId The identifier  for this resource manager.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the resource manager.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-openresourcemanager
     * @since windows6.0.6000
     */
    static OpenResourceManager(dwDesiredAccess, TmHandle, ResourceManagerId) {
        TmHandle := TmHandle is Win32Handle ? NumGet(TmHandle, "ptr") : TmHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenResourceManager", "uint", dwDesiredAccess, "ptr", TmHandle, "ptr", ResourceManagerId, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Recovers a resource manager's state from its log file.
     * @param {HANDLE} ResourceManagerHandle A handle to the resource manager.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-recoverresourcemanager
     * @since windows6.0.6000
     */
    static RecoverResourceManager(ResourceManagerHandle) {
        ResourceManagerHandle := ResourceManagerHandle is Win32Handle ? NumGet(ResourceManagerHandle, "ptr") : ResourceManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RecoverResourceManager", "ptr", ResourceManagerHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests and receives a notification for a resource manager (RM). This function is used by the RM register to receive notifications when a transaction changes state.
     * @param {HANDLE} ResourceManagerHandle A handle  to the resource manager.
     * @param {Pointer<TRANSACTION_NOTIFICATION>} TransactionNotification A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a> 
     *       structure that receives the first available notification.
     * @param {Integer} NotificationLength The size of the <i>TransactionNotification</i> buffer, in bytes.
     * @param {Integer} dwMilliseconds The time, in milliseconds, for which the calling application is blocking while waiting for the notification 
     *       to become available. If no notifications are available when the timeout expires, 
     *       <b>ERROR_TIMEOUT</b> is returned.
     * @param {Pointer<UInt32>} ReturnLength A pointer to a variable that receives the actual size of the notification received by the 
     *       <i>TransactionNotification</i> parameter.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-getnotificationresourcemanager
     * @since windows6.0.6000
     */
    static GetNotificationResourceManager(ResourceManagerHandle, TransactionNotification, NotificationLength, dwMilliseconds, ReturnLength) {
        ResourceManagerHandle := ResourceManagerHandle is Win32Handle ? NumGet(ResourceManagerHandle, "ptr") : ResourceManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetNotificationResourceManager", "ptr", ResourceManagerHandle, "ptr", TransactionNotification, "uint", NotificationLength, "uint", dwMilliseconds, "uint*", ReturnLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests and receives asynchronous notification for a resource manager (RM). This function is used by the RM register to receive notifications when a transaction changes state.
     * @param {HANDLE} ResourceManagerHandle A handle  to the resource manager.
     * @param {Pointer<TRANSACTION_NOTIFICATION>} TransactionNotification A pointer to a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a> structure that 
     *       receives the first available notification.
     * @param {Integer} TransactionNotificationLength The size of the <i>TransactionNotification</i> buffer, in bytes.
     * @param {Pointer<UInt32>} ReturnLength A pointer to a variable that receives the actual size of the notification received by the 
     *       <i>TransactionNotification</i> parameter.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is 
     *       required for asynchronous operation.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-getnotificationresourcemanagerasync
     * @since windows6.0.6000
     */
    static GetNotificationResourceManagerAsync(ResourceManagerHandle, TransactionNotification, TransactionNotificationLength, ReturnLength, lpOverlapped) {
        ResourceManagerHandle := ResourceManagerHandle is Win32Handle ? NumGet(ResourceManagerHandle, "ptr") : ResourceManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetNotificationResourceManagerAsync", "ptr", ResourceManagerHandle, "ptr", TransactionNotification, "uint", TransactionNotificationLength, "uint*", ReturnLength, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates the specified I/O completion port with the specified resource manager (RM). This port receives all notifications for the RM.
     * @param {HANDLE} ResourceManagerHandle A handle to the resource manager.
     * @param {HANDLE} IoCompletionPortHandle A handle to the I/O completion port.
     * @param {Pointer} CompletionKey The user-defined identifier. Typically, it is used to associate the receive notification with a specific resource manager.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-setresourcemanagercompletionport
     * @since windows6.0.6000
     */
    static SetResourceManagerCompletionPort(ResourceManagerHandle, IoCompletionPortHandle, CompletionKey) {
        ResourceManagerHandle := ResourceManagerHandle is Win32Handle ? NumGet(ResourceManagerHandle, "ptr") : ResourceManagerHandle
        IoCompletionPortHandle := IoCompletionPortHandle is Win32Handle ? NumGet(IoCompletionPortHandle, "ptr") : IoCompletionPortHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\SetResourceManagerCompletionPort", "ptr", ResourceManagerHandle, "ptr", IoCompletionPortHandle, "ptr", CompletionKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an enlistment, sets its initial state, and opens a handle to the enlistment with the specified access.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpEnlistmentAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *       structure that contains the security attributes for the enlistment manager.  Specify 
     *       <b>NULL</b> to obtain the default attributes.
     * @param {HANDLE} ResourceManagerHandle A handle to the resource manager (RM) to enlist.
     * @param {HANDLE} TransactionHandle A handle to the transaction in which the RM is enlisting.
     * @param {Integer} NotificationMask The notifications this RM is requesting for the <i>TransactionHandle</i> parameter. For 
     *       a list of valid values, see <a href="https://docs.microsoft.com/windows/desktop/Ktm/notification-mask">NOTIFICATION_MASK</a>.
     * @param {Integer} CreateOptions Any optional enlistment instructions.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ENLISTMENT_SUPERIOR"></a><a id="enlistment_superior"></a><dl>
     * <dt><b>ENLISTMENT_SUPERIOR</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enlist as a superior transaction manager.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} EnlistmentKey A pointer to a user-defined structure used by the RM that is returned when a notification is sent in the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a> structure. This is 
     *       typically used to associate a private structure  with this specific transaction.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the enlistment.
     *       
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-createenlistment
     * @since windows6.0.6000
     */
    static CreateEnlistment(lpEnlistmentAttributes, ResourceManagerHandle, TransactionHandle, NotificationMask, CreateOptions, EnlistmentKey) {
        ResourceManagerHandle := ResourceManagerHandle is Win32Handle ? NumGet(ResourceManagerHandle, "ptr") : ResourceManagerHandle
        TransactionHandle := TransactionHandle is Win32Handle ? NumGet(TransactionHandle, "ptr") : TransactionHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateEnlistment", "ptr", lpEnlistmentAttributes, "ptr", ResourceManagerHandle, "ptr", TransactionHandle, "uint", NotificationMask, "uint", CreateOptions, "ptr", EnlistmentKey, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Opens an existing enlistment object, and returns a handle to the enlistment.
     * @param {Integer} dwDesiredAccess The access requested for this enlistment. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/enlistment-access-masks">Enlistment Access Masks</a> for a list of valid values.
     * @param {HANDLE} ResourceManagerHandle A handle to the resource manager.
     * @param {Pointer<Guid>} EnlistmentId The enlistment identifier.
     * @returns {HANDLE} If the function succeeds, the return value is a handle to the enlistment.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-openenlistment
     * @since windows6.0.6000
     */
    static OpenEnlistment(dwDesiredAccess, ResourceManagerHandle, EnlistmentId) {
        ResourceManagerHandle := ResourceManagerHandle is Win32Handle ? NumGet(ResourceManagerHandle, "ptr") : ResourceManagerHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenEnlistment", "uint", dwDesiredAccess, "ptr", ResourceManagerHandle, "ptr", EnlistmentId, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Recovers an enlistment's state.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Void>} EnlistmentKey The key to the enlistment to be recovered.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-recoverenlistment
     * @since windows6.0.6000
     */
    static RecoverEnlistment(EnlistmentHandle, EnlistmentKey) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RecoverEnlistment", "ptr", EnlistmentHandle, "ptr", EnlistmentKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves an opaque structure of recovery data from KTM.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Integer} BufferSize The size of the <i>Buffer</i> parameter, in bytes.
     * @param {Pointer<Void>} Buffer A pointer to a buffer that receives the enlistment recovery information.
     * @param {Pointer<UInt32>} BufferUsed A pointer to a variable that receives the actual number of bytes returned in the <i>Buffer</i> parameter.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-getenlistmentrecoveryinformation
     * @since windows6.0.6000
     */
    static GetEnlistmentRecoveryInformation(EnlistmentHandle, BufferSize, Buffer, BufferUsed) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetEnlistmentRecoveryInformation", "ptr", EnlistmentHandle, "uint", BufferSize, "ptr", Buffer, "uint*", BufferUsed, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains the identifier (ID) for the specified enlistment.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Guid>} EnlistmentId A pointer to a variables that receives the ID of the enlistment.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-getenlistmentid
     * @since windows6.0.6000
     */
    static GetEnlistmentId(EnlistmentHandle, EnlistmentId) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetEnlistmentId", "ptr", EnlistmentHandle, "ptr", EnlistmentId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an opaque, user-defined structure of recovery data from KTM.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Integer} BufferSize The size of <i>Buffer</i>, in bytes.
     * @param {Pointer<Void>} Buffer The recovery information.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-setenlistmentrecoveryinformation
     * @since windows6.0.6000
     */
    static SetEnlistmentRecoveryInformation(EnlistmentHandle, BufferSize, Buffer) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\SetEnlistmentRecoveryInformation", "ptr", EnlistmentHandle, "uint", BufferSize, "ptr", Buffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Prepares the transaction associated with this enlistment handle. This function is used by communication resource managers (sometimes called superior transaction managers).
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment for which the prepare operation has completed.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-prepareenlistment
     * @since windows6.0.6000
     */
    static PrepareEnlistment(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\PrepareEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Pre-prepares the transaction associated with this enlistment handle. This function is used by communication resource managers (sometimes called superior transaction managers).
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment for which the prepare operation has completed.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this transaction.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-preprepareenlistment
     * @since windows6.0.6000
     */
    static PrePrepareEnlistment(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\PrePrepareEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Commits the transaction associated with this enlistment handle. This function is used by communication resource managers (sometimes called superior transaction managers).
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment to commit.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this enlistment. If you specify 
     *       <b>NULL</b>, the virtual clock value is not changed.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned by a 
     *       subordinate TM.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-commitenlistment
     * @since windows6.0.6000
     */
    static CommitEnlistment(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Rolls back the specified transaction that is associated with an enlistment. This function cannot be called for read-only enlistments.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this enlistment. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-rollbackenlistment
     * @since windows6.0.6000
     */
    static RollbackEnlistment(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Signals that this resource manager has completed its preprepare work, so that other resource managers can now begin their prepare operations.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this preprepare operation. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-prepreparecomplete
     * @since windows6.0.6000
     */
    static PrePrepareComplete(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\PrePrepareComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that the resource manager (RM) has completed all processing necessary to guarantee that a commit or abort operation will succeed for the specified transaction.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this prepare complete notification. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-preparecomplete
     * @since windows6.0.6000
     */
    static PrepareComplete(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\PrepareComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified enlistment be converted to a read-only enlistment. A read-only enlistment cannot participate in the outcome of the transaction and is not durably recorded for recovery.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this enlistment. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-readonlyenlistment
     * @since windows6.0.6000
     */
    static ReadOnlyEnlistment(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\ReadOnlyEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that a resource manager (RM) has finished committing a transaction that was requested by the transaction manager (TM).
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment for which the commit operation is completed.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this transaction. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-commitcomplete
     * @since windows6.0.6000
     */
    static CommitComplete(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that the resource manager (RM) has successfully completed rolling back a transaction.
     * @param {HANDLE} EnlistmentHandle A handle the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this transaction. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-rollbackcomplete
     * @since windows6.0.6000
     */
    static RollbackComplete(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that the resource manager (RM) is refusing a single-phase request. When a transaction manager (TM) receives this call, it initiates a two-phase commit and sends a prepare request to all enlisted RMs.
     * @param {HANDLE} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received from the single-phase request notification. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://docs.microsoft.com/windows/win32/api//ktmw32/nf-ktmw32-singlephasereject
     * @since windows6.0.6000
     */
    static SinglePhaseReject(EnlistmentHandle, TmVirtualClock) {
        EnlistmentHandle := EnlistmentHandle is Win32Handle ? NumGet(EnlistmentHandle, "ptr") : EnlistmentHandle

        A_LastError := 0

        result := DllCall("ktmw32.dll\SinglePhaseReject", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Shares a server resource.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>.
     * @param {Pointer<UInt32>} parm_err Pointer to a value that receives the index of the first member of the share information structure that causes the <b>ERROR_INVALID_PARAMETER</b> error. If this parameter is <b>NULL</b>, the index is not returned on error. For more information, see the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsharesetinfo">NetShareSetInfo</a> function.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character or file system name is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_DuplicateShare</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name is already in use on this server.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_RedirectedPath</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not valid for a redirected resource. The specified device name is assigned to a shared resource.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_UnknownDevDir</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device or directory does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netshareadd
     * @since windows5.1.2600
     */
    static NetShareAdd(servername, level, buf, parm_err) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareAdd", "ptr", servername, "uint", level, "char*", buf, "uint*", parm_err, "uint")
        return result
    }

    /**
     * Retrieves information about each shared resource on a server.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated. Note that applications should consider this value only as a hint.
     * @param {Pointer<UInt32>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing share search. The handle should be zero on the first call and left unchanged for subsequent calls. If <i>resume_handle</i> is <b>NULL</b>, then no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value is a system error code. For a list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netshareenum
     * @since windows5.1.2600
     */
    static NetShareEnum(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareEnum", "ptr", servername, "uint", level, "char*", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr 
     * @param {Integer} prefmaxlen 
     * @param {Pointer<UInt32>} entriesread 
     * @param {Pointer<UInt32>} totalentries 
     * @param {Pointer<UInt32>} resume_handle 
     * @returns {Integer} 
     */
    static NetShareEnumSticky(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareEnumSticky", "ptr", servername, "uint", level, "char*", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * Retrieves information about a particular shared resource on a server.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {PWSTR} netname Pointer to a string that specifies the name of the share for which to return information.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function.
     * @returns {Integer} If the function succeeds, the return value is NERR_Success.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_NetNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsharegetinfo
     * @since windows5.1.2600
     */
    static NetShareGetInfo(servername, netname, level, bufptr) {
        servername := servername is String ? StrPtr(servername) : servername
        netname := netname is String ? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareGetInfo", "ptr", servername, "ptr", netname, "uint", level, "char*", bufptr, "uint")
        return result
    }

    /**
     * Sets the parameters of a shared resource.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {PWSTR} netname Pointer to a string that specifies the name of the share to set information on.
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>.
     * @param {Pointer<UInt32>} parm_err Pointer to a value that receives the index of the first member of the share information structure that causes the <b>ERROR_INVALID_PARAMETER</b> error. If this parameter is <b>NULL</b>, the index is not returned on error. For more information, see the following Remarks section.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid. For more information, see the following Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_NetNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsharesetinfo
     * @since windows5.1.2600
     */
    static NetShareSetInfo(servername, netname, level, buf, parm_err) {
        servername := servername is String ? StrPtr(servername) : servername
        netname := netname is String ? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareSetInfo", "ptr", servername, "ptr", netname, "uint", level, "char*", buf, "uint*", parm_err, "uint")
        return result
    }

    /**
     * Deletes a share name from a server's list of shared resources, disconnecting all connections to the shared resource.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {PWSTR} netname Pointer to a string that specifies the name of the share to delete.
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @returns {Integer} If the function succeeds, the return value is NERR_Success.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_NetNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsharedel
     * @since windows5.1.2600
     */
    static NetShareDel(servername, netname) {
        static reserved := 0 ;Reserved parameters must always be NULL

        servername := servername is String ? StrPtr(servername) : servername
        netname := netname is String ? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareDel", "ptr", servername, "ptr", netname, "uint", reserved, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} servername 
     * @param {PWSTR} netname 
     * @returns {Integer} 
     */
    static NetShareDelSticky(servername, netname) {
        static reserved := 0 ;Reserved parameters must always be NULL

        servername := servername is String ? StrPtr(servername) : servername
        netname := netname is String ? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareDelSticky", "ptr", servername, "ptr", netname, "uint", reserved, "uint")
        return result
    }

    /**
     * Checks whether or not a server is sharing a device.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {PWSTR} device Pointer to a string that specifies the name of the device to check for shared access.
     * @param {Pointer<UInt32>} type Pointer to a variable that receives a bitmask of flags that specify the type of the shared device. This parameter is set only if the function returns successfully. 
     * 
     * One of the following flags may be specified.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_DISKTREE"></a><a id="stype_disktree"></a><dl>
     * <dt><b>STYPE_DISKTREE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disk drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl>
     * <dt><b>STYPE_PRINTQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Print queue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_DEVICE"></a><a id="stype_device"></a><dl>
     * <dt><b>STYPE_DEVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Communication device.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_IPC"></a><a id="stype_ipc"></a><dl>
     * <dt><b>STYPE_IPC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Interprocess communication (IPC).
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * In addition, one or both of the following flags may be specified.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl>
     * <dt><b>STYPE_SPECIAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Special share reserved for interprocess communication (IPC$) or remote administration of the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth. For more information, see <a href="https://docs.microsoft.com/windows/desktop/NetShare/network-share-functions">Network Share Functions</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl>
     * <dt><b>STYPE_TEMPORARY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A temporary share.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_DeviceNotShared</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device is not shared.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsharecheck
     * @since windows5.1.2600
     */
    static NetShareCheck(servername, device, type) {
        servername := servername is String ? StrPtr(servername) : servername
        device := device is String ? StrPtr(device) : device

        result := DllCall("NETAPI32.dll\NetShareCheck", "ptr", servername, "ptr", device, "uint*", type, "uint")
        return result
    }

    /**
     * Deletes a share name from a server's list of shared resources, which disconnects all connections to that share.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>.
     * @returns {Integer} If the function succeeds, the return value is NERR_Success.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The request is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsharedelex
     * @since windows5.1.2600
     */
    static NetShareDelEx(servername, level, buf) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareDelEx", "ptr", servername, "uint", level, "char*", buf, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf 
     * @returns {Integer} 
     */
    static NetServerAliasAdd(servername, level, buf) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetServerAliasAdd", "ptr", servername, "uint", level, "char*", buf, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf 
     * @returns {Integer} 
     */
    static NetServerAliasDel(servername, level, buf) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetServerAliasDel", "ptr", servername, "uint", level, "char*", buf, "uint")
        return result
    }

    /**
     * 
     * @param {PWSTR} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr 
     * @param {Integer} prefmaxlen 
     * @param {Pointer<UInt32>} entriesread 
     * @param {Pointer<UInt32>} totalentries 
     * @param {Pointer<UInt32>} resumehandle 
     * @returns {Integer} 
     */
    static NetServerAliasEnum(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resumehandle) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetServerAliasEnum", "ptr", servername, "uint", level, "char*", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resumehandle, "uint")
        return result
    }

    /**
     * Provides information about sessions established on a server.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {PWSTR} UncClientName Pointer to a string that specifies the name of the computer session for which information is to be returned. If this parameter is <b>NULL</b>, 
     * <b>NetSessionEnum</b> returns information for all computer sessions on the server.
     * @param {PWSTR} username Pointer to a string that specifies the name of the user for which information is to be returned. If this parameter is <b>NULL</b>, 
     * <b>NetSessionEnum</b> returns information for all users.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter.
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated from the current resume position. Note that applications should consider this value only as a hint.
     * @param {Pointer<UInt32>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing session search. The handle should be zero on the first call and left unchanged for subsequent calls. If <i>resume_handle</i> is <b>NULL</b>, no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * More entries are available. Specify a large enough buffer to receive all entries.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_ClientNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session does not exist with the computer name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_InvalidComputer</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_UserNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user name could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsessionenum
     * @since windows5.1.2600
     */
    static NetSessionEnum(servername, UncClientName, username, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String ? StrPtr(servername) : servername
        UncClientName := UncClientName is String ? StrPtr(UncClientName) : UncClientName
        username := username is String ? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetSessionEnum", "ptr", servername, "ptr", UncClientName, "ptr", username, "uint", level, "char*", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * Ends a network session between a server and a workstation.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {PWSTR} UncClientName Pointer to a string that specifies the computer name of the client to disconnect. If the <i>UncClientName</i> parameter is <b>NULL</b>, then all the sessions of the user identified by the <i>username</i> parameter will be deleted on the server specified by the <i>servername</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsessionenum">NetSessionEnum</a>.
     * @param {PWSTR} username Pointer to a string that specifies the name of the user whose session is to be terminated. If this parameter is <b>NULL</b>, all users' sessions from the client specified by the <i>UncClientName</i> parameter are to be terminated.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_ClientNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session does not exist with that computer name.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsessiondel
     * @since windows5.1.2600
     */
    static NetSessionDel(servername, UncClientName, username) {
        servername := servername is String ? StrPtr(servername) : servername
        UncClientName := UncClientName is String ? StrPtr(UncClientName) : UncClientName
        username := username is String ? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetSessionDel", "ptr", servername, "ptr", UncClientName, "ptr", username, "uint")
        return result
    }

    /**
     * Retrieves information about a session established between a particular server and workstation.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {PWSTR} UncClientName Pointer to a string that specifies the name of the computer session for which information is to be returned. This parameter is required and cannot be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsessionenum">NetSessionEnum</a>.
     * @param {PWSTR} username Pointer to a string that specifies the name of the user whose session information is to be returned. This parameter is required and cannot be <b>NULL</b>.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_ClientNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session does not exist with the computer name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_InvalidComputer</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_UserNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user name could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netsessiongetinfo
     * @since windows5.1.2600
     */
    static NetSessionGetInfo(servername, UncClientName, username, level, bufptr) {
        servername := servername is String ? StrPtr(servername) : servername
        UncClientName := UncClientName is String ? StrPtr(UncClientName) : UncClientName
        username := username is String ? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetSessionGetInfo", "ptr", servername, "ptr", UncClientName, "ptr", username, "uint", level, "char*", bufptr, "uint")
        return result
    }

    /**
     * Lists all connections made to a shared resource on the server or all connections established from a particular computer.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {PWSTR} qualifier Pointer to a string that specifies a share name or computer name for the connections of interest. If it is a share name, then all the connections made to that share name are listed. If it is a computer name (for example, it starts with two backslash characters), then 
     * <b>NetConnectionEnum</b> lists all connections made from that computer to the server specified.
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the address of the buffer that receives the information. The format of this data depends on the value of the <i>level</i> parameter. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated from the current resume position. Note that applications should consider this value only as a hint.
     * @param {Pointer<UInt32>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing connection search. The handle should be zero on the first call and left unchanged for subsequent calls. If this parameter is <b>NULL</b>, then no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value is a system error code. For a list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netconnectionenum
     * @since windows5.1.2600
     */
    static NetConnectionEnum(servername, qualifier, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String ? StrPtr(servername) : servername
        qualifier := qualifier is String ? StrPtr(qualifier) : qualifier

        result := DllCall("NETAPI32.dll\NetConnectionEnum", "ptr", servername, "ptr", qualifier, "uint", level, "char*", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * Forces a resource to close. This function can be used when an error prevents closure by any other means. You should use NetFileClose with caution because it does not write data cached on the client system to the file before closing the file.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} fileid Specifies the file identifier of the opened resource instance to close.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file was not found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netfileclose
     * @since windows5.1.2600
     */
    static NetFileClose(servername, fileid) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetFileClose", "ptr", servername, "uint", fileid, "uint")
        return result
    }

    /**
     * Returns information about some or all open files on a server, depending on the parameters specified.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {PWSTR} basepath Pointer to a string that specifies a qualifier for the returned information. If this parameter is <b>NULL</b>, all open resources are enumerated. If this parameter is not <b>NULL</b>, the function enumerates only resources that have the value of the <i>basepath</i> parameter as a prefix. (A prefix is the portion of a path that comes before a backslash.)
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {PWSTR} username Pointer to a string that specifies the name of the user or the name of the connection. If the string begins with two backslashes ("\\"), then it indicates the name of the connection, for example, "\\127.0.0.1" or "\\ClientName". The part of the connection name after the backslashes is the same as the client name in the session information structure returned by the <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsessionenum">NetSessionEnum</a> function. If the string does not begin with two backslashes, then it indicates the name of the user. If this parameter is not <b>NULL</b>, its value serves as a qualifier for the enumeration. The files returned are limited to those that have user names or connection names that match the qualifier. If this parameter is <b>NULL</b>, no user-name qualifier is used.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This parameter is a pointer to a string that specifies the name of the user. If this parameter is not <b>NULL</b>, its value serves as a qualifier for the enumeration. The files returned are limited to those that have user names matching the qualifier. If this parameter is <b>NULL</b>, no user-name qualifier is used.
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the address of the buffer that receives the information. The format of this data depends on the value of the <i>level</i> parameter. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated from the current resume position. Note that applications should consider this value only as a hint.
     * @param {Pointer<UIntPtr>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing file search. The handle should be zero on the first call and left unchanged for subsequent calls. If this parameter is <b>NULL</b>, no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * More entries are available. Specify a large enough buffer to receive all entries.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_BufTooSmall</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The supplied buffer is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netfileenum
     * @since windows5.1.2600
     */
    static NetFileEnum(servername, basepath, username, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String ? StrPtr(servername) : servername
        basepath := basepath is String ? StrPtr(basepath) : basepath
        username := username is String ? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetFileEnum", "ptr", servername, "ptr", basepath, "ptr", username, "uint", level, "char*", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "ptr*", resume_handle, "uint")
        return result
    }

    /**
     * Retrieves information about a particular opening of a server resource.
     * @param {PWSTR} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} fileid Specifies the file identifier of the open resource for which to return information. The value of this parameter must have been returned in a previous enumeration call. For more information, see the following Remarks section.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the address of the buffer that receives the information. The format of this data depends on the value of the <i>level</i> parameter. This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_BufTooSmall</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The supplied buffer is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//lmshare/nf-lmshare-netfilegetinfo
     * @since windows5.1.2600
     */
    static NetFileGetInfo(servername, fileid, level, bufptr) {
        servername := servername is String ? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetFileGetInfo", "ptr", servername, "uint", fileid, "uint", level, "char*", bufptr, "uint")
        return result
    }

    /**
     * Retrieves operating statistics for a service. Currently, only the workstation and server services are supported.
     * @param {Pointer<SByte>} ServerName Pointer to a string that specifies the DNS or NetBIOS name of the server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<SByte>} Service Pointer to a string that specifies the name of the service about which to get the statistics. Only the values <b>SERVICE_SERVER</b> and <b>SERVICE_WORKSTATION</b> are currently allowed.
     * @param {Integer} Level Specifies the information level of the data. This parameter can be the following value. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="0"></a><dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return statistics about a workstation or a server. The <i>bufptr</i> parameter points to a 
     * <a href="https://docs.microsoft.com/windows/win32/api/lmstats/ns-lmstats-stat_workstation_0~r1">STAT_WORKSTATION_0</a> or a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmstats/ns-lmstats-stat_server_0">STAT_SERVER_0</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Options This parameter must be zero.
     * @param {Pointer<Byte>} Buffer Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value is a system error code. For a list of error codes, see 
     * <a href="/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @see https://docs.microsoft.com/windows/win32/api//lmstats/nf-lmstats-netstatisticsget
     * @since windows5.1.2600
     */
    static NetStatisticsGet(ServerName, Service, Level, Options, Buffer) {
        result := DllCall("NETAPI32.dll\NetStatisticsGet", "char*", ServerName, "char*", Service, "uint", Level, "uint", Options, "char*", Buffer, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<IORING_CAPABILITIES>} capabilities 
     * @returns {HRESULT} 
     */
    static QueryIoRingCapabilities(capabilities) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\QueryIoRingCapabilities", "ptr", capabilities, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {Integer} op 
     * @returns {BOOL} 
     */
    static IsIoRingOpSupported(ioRing, op) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\IsIoRingOpSupported", "ptr", ioRing, "int", op, "int")
        return result
    }

    /**
     * 
     * @param {Integer} ioringVersion 
     * @param {IORING_CREATE_FLAGS} flags 
     * @param {Integer} submissionQueueSize 
     * @param {Integer} completionQueueSize 
     * @param {Pointer<HIORING>} h 
     * @returns {HRESULT} 
     */
    static CreateIoRing(ioringVersion, flags, submissionQueueSize, completionQueueSize, h) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\CreateIoRing", "int", ioringVersion, "ptr", flags, "uint", submissionQueueSize, "uint", completionQueueSize, "ptr", h, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {Pointer<IORING_INFO>} info 
     * @returns {HRESULT} 
     */
    static GetIoRingInfo(ioRing, info) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\GetIoRingInfo", "ptr", ioRing, "ptr", info, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {Integer} waitOperations 
     * @param {Integer} milliseconds 
     * @param {Pointer<UInt32>} submittedEntries 
     * @returns {HRESULT} 
     */
    static SubmitIoRing(ioRing, waitOperations, milliseconds, submittedEntries) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\SubmitIoRing", "ptr", ioRing, "uint", waitOperations, "uint", milliseconds, "uint*", submittedEntries, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @returns {HRESULT} 
     */
    static CloseIoRing(ioRing) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\CloseIoRing", "ptr", ioRing, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {Pointer<IORING_CQE>} cqe 
     * @returns {HRESULT} 
     */
    static PopIoRingCompletion(ioRing, cqe) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\PopIoRingCompletion", "ptr", ioRing, "ptr", cqe, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {HANDLE} hEvent 
     * @returns {HRESULT} 
     */
    static SetIoRingCompletionEvent(ioRing, hEvent) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing
        hEvent := hEvent is Win32Handle ? NumGet(hEvent, "ptr") : hEvent

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\SetIoRingCompletionEvent", "ptr", ioRing, "ptr", hEvent, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {IORING_HANDLE_REF} file 
     * @param {Pointer} opToCancel 
     * @param {Pointer} userData 
     * @returns {HRESULT} 
     */
    static BuildIoRingCancelRequest(ioRing, file, opToCancel, userData) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingCancelRequest", "ptr", ioRing, "ptr", file, "ptr", opToCancel, "ptr", userData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {IORING_HANDLE_REF} fileRef 
     * @param {IORING_BUFFER_REF} dataRef 
     * @param {Integer} numberOfBytesToRead 
     * @param {Integer} fileOffset 
     * @param {Pointer} userData 
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} 
     */
    static BuildIoRingReadFile(ioRing, fileRef, dataRef, numberOfBytesToRead, fileOffset, userData, sqeFlags) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingReadFile", "ptr", ioRing, "ptr", fileRef, "ptr", dataRef, "uint", numberOfBytesToRead, "uint", fileOffset, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {Integer} count 
     * @param {Pointer<HANDLE>} handles 
     * @param {Pointer} userData 
     * @returns {HRESULT} 
     */
    static BuildIoRingRegisterFileHandles(ioRing, count, handles, userData) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingRegisterFileHandles", "ptr", ioRing, "uint", count, "ptr", handles, "ptr", userData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {Integer} count 
     * @param {Pointer<IORING_BUFFER_INFO>} buffers 
     * @param {Pointer} userData 
     * @returns {HRESULT} 
     */
    static BuildIoRingRegisterBuffers(ioRing, count, buffers, userData) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingRegisterBuffers", "ptr", ioRing, "uint", count, "ptr", buffers, "ptr", userData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {IORING_HANDLE_REF} fileRef 
     * @param {IORING_BUFFER_REF} bufferRef 
     * @param {Integer} numberOfBytesToWrite 
     * @param {Integer} fileOffset 
     * @param {Integer} writeFlags 
     * @param {Pointer} userData 
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} 
     */
    static BuildIoRingWriteFile(ioRing, fileRef, bufferRef, numberOfBytesToWrite, fileOffset, writeFlags, userData, sqeFlags) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("KERNEL32.dll\BuildIoRingWriteFile", "ptr", ioRing, "ptr", fileRef, "ptr", bufferRef, "uint", numberOfBytesToWrite, "uint", fileOffset, "int", writeFlags, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {IORING_HANDLE_REF} fileRef 
     * @param {Integer} flushMode 
     * @param {Pointer} userData 
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} 
     */
    static BuildIoRingFlushFile(ioRing, fileRef, flushMode, userData, sqeFlags) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("KERNEL32.dll\BuildIoRingFlushFile", "ptr", ioRing, "ptr", fileRef, "int", flushMode, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {IORING_HANDLE_REF} fileRef 
     * @param {Integer} segmentCount 
     * @param {Pointer<FILE_SEGMENT_ELEMENT>} segmentArray 
     * @param {Integer} numberOfBytesToRead 
     * @param {Integer} fileOffset 
     * @param {Pointer} userData 
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} 
     */
    static BuildIoRingReadFileScatter(ioRing, fileRef, segmentCount, segmentArray, numberOfBytesToRead, fileOffset, userData, sqeFlags) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("KERNEL32.dll\BuildIoRingReadFileScatter", "ptr", ioRing, "ptr", fileRef, "uint", segmentCount, "ptr", segmentArray, "uint", numberOfBytesToRead, "uint", fileOffset, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {HIORING} ioRing 
     * @param {IORING_HANDLE_REF} fileRef 
     * @param {Integer} segmentCount 
     * @param {Pointer<FILE_SEGMENT_ELEMENT>} segmentArray 
     * @param {Integer} numberOfBytesToWrite 
     * @param {Integer} fileOffset 
     * @param {Integer} writeFlags 
     * @param {Pointer} userData 
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} 
     */
    static BuildIoRingWriteFileGather(ioRing, fileRef, segmentCount, segmentArray, numberOfBytesToWrite, fileOffset, writeFlags, userData, sqeFlags) {
        ioRing := ioRing is Win32Handle ? NumGet(ioRing, "ptr") : ioRing

        result := DllCall("KERNEL32.dll\BuildIoRingWriteFileGather", "ptr", ioRing, "ptr", fileRef, "uint", segmentCount, "ptr", segmentArray, "uint", numberOfBytesToWrite, "uint", fileOffset, "int", writeFlags, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {PWSTR} virtualPath 
     * @param {PWSTR} backingPath 
     * @param {Integer} createBindLinkFlags 
     * @param {Integer} exceptionCount 
     * @param {Pointer<PWSTR>} exceptionPaths 
     * @returns {HRESULT} 
     */
    static CreateBindLink(virtualPath, backingPath, createBindLinkFlags, exceptionCount, exceptionPaths) {
        virtualPath := virtualPath is String ? StrPtr(virtualPath) : virtualPath
        backingPath := backingPath is String ? StrPtr(backingPath) : backingPath

        result := DllCall("BINDFLTAPI.dll\CreateBindLink", "ptr", virtualPath, "ptr", backingPath, "int", createBindLinkFlags, "uint", exceptionCount, "ptr", exceptionPaths, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {PWSTR} virtualPath 
     * @returns {HRESULT} 
     */
    static RemoveBindLink(virtualPath) {
        virtualPath := virtualPath is String ? StrPtr(virtualPath) : virtualPath

        result := DllCall("BINDFLTAPI.dll\RemoveBindLink", "ptr", virtualPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enables or disables file system redirection for the calling thread.
     * @param {BOOLEAN} Wow64FsEnableRedirection Indicates the type of request for WOW64 system folder redirection. If 
     *       <b>TRUE</b>, requests redirection be enabled; if <b>FALSE</b>, requests 
     *       redirection be disabled.
     * @returns {BOOLEAN} Boolean value indicating whether the function succeeded. If <b>TRUE</b>, the function 
     *       succeeded; if <b>FALSE</b>, the function failed.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-wow64enablewow64fsredirection
     * @since windows6.0.6000
     */
    static Wow64EnableWow64FsRedirection(Wow64FsEnableRedirection) {
        result := DllCall("KERNEL32.dll\Wow64EnableWow64FsRedirection", "char", Wow64FsEnableRedirection, "char")
        return result
    }

    /**
     * Disables file system redirection for the calling thread. File system redirection is enabled by default.
     * @param {Pointer<Void>} OldValue The WOW64 file system redirection value. The system uses this parameter to store information necessary to 
     *        revert (re-enable) file system redirection.
     * 
     * <div class="alert"><b>Note</b>  This value is for system use only. To avoid unpredictable behavior, do not modify this value in any 
     *        way.</div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection
     * @since windows6.0.6000
     */
    static Wow64DisableWow64FsRedirection(OldValue) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\Wow64DisableWow64FsRedirection", "ptr", OldValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Restores file system redirection for the calling thread.
     * @param {Pointer<Void>} OlValue TBD
     * @returns {BOOL} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is <b>FALSE</b> (zero). To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection
     * @since windows6.0.6000
     */
    static Wow64RevertWow64FsRedirection(OlValue) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\Wow64RevertWow64FsRedirection", "ptr", OlValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.
     * @param {PSTR} lpApplicationName The full path of the file whose executable type is to be determined.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<UInt32>} lpBinaryType A pointer to a variable to receive information about the executable type of the file specified by 
     *       <i>lpApplicationName</i>. The following constants are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_32BIT_BINARY"></a><a id="scs_32bit_binary"></a><dl>
     * <dt><b>SCS_32BIT_BINARY</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 32-bit Windows-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_64BIT_BINARY"></a><a id="scs_64bit_binary"></a><dl>
     * <dt><b>SCS_64BIT_BINARY</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 64-bit Windows-based application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_DOS_BINARY"></a><a id="scs_dos_binary"></a><dl>
     * <dt><b>SCS_DOS_BINARY</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_OS216_BINARY"></a><a id="scs_os216_binary"></a><dl>
     * <dt><b>SCS_OS216_BINARY</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit OS/2-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_PIF_BINARY"></a><a id="scs_pif_binary"></a><dl>
     * <dt><b>SCS_PIF_BINARY</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A PIF file that executes an MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_POSIX_BINARY"></a><a id="scs_posix_binary"></a><dl>
     * <dt><b>SCS_POSIX_BINARY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A POSIX – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_WOW_BINARY"></a><a id="scs_wow_binary"></a><dl>
     * <dt><b>SCS_WOW_BINARY</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit Windows-based application
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the file is executable, the return value is nonzero. The function sets the variable pointed to by 
     *        <i>lpBinaryType</i> to indicate the file's executable type.
     * 
     * If the file is not executable, or if the function fails, the return value is zero. To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the file is a DLL, 
     *        the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getbinarytypea
     * @since windows5.1.2600
     */
    static GetBinaryTypeA(lpApplicationName, lpBinaryType) {
        lpApplicationName := lpApplicationName is String ? StrPtr(lpApplicationName) : lpApplicationName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetBinaryTypeA", "ptr", lpApplicationName, "uint*", lpBinaryType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.
     * @param {PWSTR} lpApplicationName The full path of the file whose executable type is to be determined.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<UInt32>} lpBinaryType A pointer to a variable to receive information about the executable type of the file specified by 
     *       <i>lpApplicationName</i>. The following constants are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_32BIT_BINARY"></a><a id="scs_32bit_binary"></a><dl>
     * <dt><b>SCS_32BIT_BINARY</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 32-bit Windows-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_64BIT_BINARY"></a><a id="scs_64bit_binary"></a><dl>
     * <dt><b>SCS_64BIT_BINARY</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 64-bit Windows-based application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_DOS_BINARY"></a><a id="scs_dos_binary"></a><dl>
     * <dt><b>SCS_DOS_BINARY</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_OS216_BINARY"></a><a id="scs_os216_binary"></a><dl>
     * <dt><b>SCS_OS216_BINARY</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit OS/2-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_PIF_BINARY"></a><a id="scs_pif_binary"></a><dl>
     * <dt><b>SCS_PIF_BINARY</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A PIF file that executes an MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_POSIX_BINARY"></a><a id="scs_posix_binary"></a><dl>
     * <dt><b>SCS_POSIX_BINARY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A POSIX – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_WOW_BINARY"></a><a id="scs_wow_binary"></a><dl>
     * <dt><b>SCS_WOW_BINARY</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit Windows-based application
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the file is executable, the return value is nonzero. The function sets the variable pointed to by 
     *        <i>lpBinaryType</i> to indicate the file's executable type.
     * 
     * If the file is not executable, or if the function fails, the return value is zero. To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the file is a DLL, 
     *        the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getbinarytypew
     * @since windows5.1.2600
     */
    static GetBinaryTypeW(lpApplicationName, lpBinaryType) {
        lpApplicationName := lpApplicationName is String ? StrPtr(lpApplicationName) : lpApplicationName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetBinaryTypeW", "ptr", lpApplicationName, "uint*", lpBinaryType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the short path form of the specified path.
     * @param {PSTR} lpszLongPath The path string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * @param {PSTR} lpszShortPath A pointer to a buffer to receive the null-terminated short form of the path that 
     *        <i>lpszLongPath</i> specifies.
     * 
     * Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i> 
     *        will always return the required buffer size for a specified <i>lpszLongPath</i>.
     * @param {Integer} cchBuffer The size of the buffer  that <i>lpszShortPath</i> points to, in 
     *        <b>TCHARs</b>.
     * 
     * Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to <i>lpszShortPath</i>, not including the terminating null 
     *        character.
     * 
     * If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is 
     *        the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getshortpathnamea
     * @since windows5.1.2600
     */
    static GetShortPathNameA(lpszLongPath, lpszShortPath, cchBuffer) {
        lpszLongPath := lpszLongPath is String ? StrPtr(lpszLongPath) : lpszLongPath
        lpszShortPath := lpszShortPath is String ? StrPtr(lpszShortPath) : lpszShortPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetShortPathNameA", "ptr", lpszLongPath, "ptr", lpszShortPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form as a transacted operation.
     * @param {PSTR} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> (260) 
     *        characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and 
     *        prepend "\\?\" to the path. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * The path must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {PSTR} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHAR</b>s.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHAR</b>s, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHAR</b>s, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not exist, the return value is zero. To 
     *        get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlongpathnametransacteda
     * @since windows6.0.6000
     */
    static GetLongPathNameTransactedA(lpszShortPath, lpszLongPath, cchBuffer, hTransaction) {
        lpszShortPath := lpszShortPath is String ? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String ? StrPtr(lpszLongPath) : lpszLongPath
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameTransactedA", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form as a transacted operation.
     * @param {PWSTR} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> (260) 
     *        characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and 
     *        prepend "\\?\" to the path. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * The path must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {PWSTR} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHAR</b>s.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHAR</b>s, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHAR</b>s, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not exist, the return value is zero. To 
     *        get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlongpathnametransactedw
     * @since windows6.0.6000
     */
    static GetLongPathNameTransactedW(lpszShortPath, lpszLongPath, cchBuffer, hTransaction) {
        lpszShortPath := lpszShortPath is String ? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String ? StrPtr(lpszLongPath) : lpszLongPath
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameTransactedW", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the notification modes for a file handle, allowing you to specify how completion notifications work for the specified file.
     * @param {HANDLE} FileHandle A handle to the file.
     * @param {Integer} Flags The modes to be set.  One or more modes can be set at the same time; however, after a mode has been set for 
     *       a file handle, it cannot be removed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SKIP_COMPLETION_PORT_ON_SUCCESS"></a><a id="file_skip_completion_port_on_success"></a><dl>
     * <dt><b>FILE_SKIP_COMPLETION_PORT_ON_SUCCESS</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the following three conditions are true, the I/O Manager does not queue a completion entry to the port, 
     *          when it would ordinarily do so. The conditions are:
     *          <ul>
     * <li>A completion port is associated with the file handle.</li>
     * <li>The file is opened for asynchronous I/O.</li>
     * <li>A request returns success immediately without returning 
     *            <b>ERROR_PENDING</b>.</li>
     * </ul>
     * 
     * 
     * When the <i>FileHandle</i> parameter is a socket, this mode is only compatible with 
     *          Layered Service Providers (LSP) that return Installable File Systems (IFS) handles. To detect whether a 
     *          non-IFS LSP is installed, use the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function and examine the 
     *          <b>dwServiceFlag1</b> member in each returned 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. If the 
     *          <b>XP1_IFS_HANDLES</b> (0x20000) bit is cleared then the specified LSP is not an IFS LSP. 
     *          Vendors that have non-IFS LSPs are encouraged to migrate to the 
     *          <a href="https://docs.microsoft.com/windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a> 
     *          (WFP).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SKIP_SET_EVENT_ON_HANDLE"></a><a id="file_skip_set_event_on_handle"></a><dl>
     * <dt><b>FILE_SKIP_SET_EVENT_ON_HANDLE</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The I/O Manager does not set the event for the file object if a request returns with a success code, or the 
     *          error returned is <b>ERROR_PENDING</b> and the function that is called is not a 
     *          synchronous function.
     * 
     * If an explicit event is provided for the request, it is still signaled.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilecompletionnotificationmodes
     * @since windows6.0.6000
     */
    static SetFileCompletionNotificationModes(FileHandle, Flags) {
        FileHandle := FileHandle is Win32Handle ? NumGet(FileHandle, "ptr") : FileHandle

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileCompletionNotificationModes", "ptr", FileHandle, "char", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the short name for the specified file.
     * @param {HANDLE} hFile A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access 
     *        right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the 
     *        <b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.
     * @param {PSTR} lpShortName A pointer to a string that specifies the short name for the file.
     * 
     *  Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.
     * 
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     *       <b>GetLastError</b> may return one of the following error 
     *        codes that are specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified short name is not unique.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileshortnamea
     * @since windows5.1.2600
     */
    static SetFileShortNameA(hFile, lpShortName) {
        lpShortName := lpShortName is String ? StrPtr(lpShortName) : lpShortName
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileShortNameA", "ptr", hFile, "ptr", lpShortName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the short name for the specified file.
     * @param {HANDLE} hFile A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access 
     *        right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the 
     *        <b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.
     * @param {PWSTR} lpShortName A pointer to a string that specifies the short name for the file.
     * 
     *  Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.
     * 
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     *       <b>GetLastError</b> may return one of the following error 
     *        codes that are specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified short name is not unique.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileshortnamew
     * @since windows5.1.2600
     */
    static SetFileShortNameW(hFile, lpShortName) {
        lpShortName := lpShortName is String ? StrPtr(lpShortName) : lpShortName
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileShortNameW", "ptr", hFile, "ptr", lpShortName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the tape position on the specified device.
     * @param {HANDLE} hDevice Handle to the device on which to set the tape position. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwPositionMethod 
     * @param {Integer} dwPartition Partition to position within. If <i>dwPartition</i> is zero, the current partition is used. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last.
     * @param {Integer} dwOffsetLow Low-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter.
     * @param {Integer} dwOffsetHigh High-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter. If the high-order bits are not required, this parameter should be zero.
     * @param {BOOL} bImmediate Indicates whether to return as soon as the move operation begins. If this parameter is <b>TRUE</b>, the function returns immediately; if <b>FALSE</b>, the function does not return until the move operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-settapeposition
     * @since windows5.1.2600
     */
    static SetTapePosition(hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\SetTapePosition", "ptr", hDevice, "uint", dwPositionMethod, "uint", dwPartition, "uint", dwOffsetLow, "uint", dwOffsetHigh, "int", bImmediate, "uint")
        return result
    }

    /**
     * Retrieves the current address of the tape, in logical or absolute blocks.
     * @param {HANDLE} hDevice Handle to the device on which to get the tape position. This handle is created by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * @param {Integer} dwPositionType 
     * @param {Pointer<UInt32>} lpdwPartition Pointer to a variable that receives the number of the current tape partition. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last. When a device-specific block address is retrieved, or if the device supports only one partition, this parameter receives zero.
     * @param {Pointer<UInt32>} lpdwOffsetLow Pointer to a variable that receives the low-order bits of the current tape position.
     * @param {Pointer<UInt32>} lpdwOffsetHigh Pointer to a variable that receives the high-order bits of the current tape position. This parameter can be <b>NULL</b> if the high-order bits are not required.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapeposition
     * @since windows5.1.2600
     */
    static GetTapePosition(hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\GetTapePosition", "ptr", hDevice, "uint", dwPositionType, "uint*", lpdwPartition, "uint*", lpdwOffsetLow, "uint*", lpdwOffsetHigh, "uint")
        return result
    }

    /**
     * Prepares the tape to be accessed or removed.
     * @param {HANDLE} hDevice Handle to the device preparing the tape. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwOperation 
     * @param {BOOL} bImmediate If this parameter is <b>TRUE</b>, the function returns immediately. If it is <b>FALSE</b>, the function does not return until the operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-preparetape
     * @since windows5.1.2600
     */
    static PrepareTape(hDevice, dwOperation, bImmediate) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\PrepareTape", "ptr", hDevice, "uint", dwOperation, "int", bImmediate, "uint")
        return result
    }

    /**
     * Erases all or part of a tape.
     * @param {HANDLE} hDevice Handle to the device where the tape is to be erased. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwEraseType 
     * @param {BOOL} bImmediate If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the erase operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-erasetape
     * @since windows5.1.2600
     */
    static EraseTape(hDevice, dwEraseType, bImmediate) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\EraseTape", "ptr", hDevice, "uint", dwEraseType, "int", bImmediate, "uint")
        return result
    }

    /**
     * Reformats a tape.
     * @param {HANDLE} hDevice Handle to the device where the new partition is to be created. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwPartitionMethod 
     * @param {Integer} dwCount Number of partitions to create. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-gettapeparameters">GetTapeParameters</a> function provides the maximum number of partitions a tape can support.
     * @param {Integer} dwSize Size of each partition, in megabytes. This value is ignored if the <i>dwPartitionMethod</i> parameter is <b>TAPE_SELECT_PARTITIONS</b>.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createtapepartition
     * @since windows5.1.2600
     */
    static CreateTapePartition(hDevice, dwPartitionMethod, dwCount, dwSize) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\CreateTapePartition", "ptr", hDevice, "uint", dwPartitionMethod, "uint", dwCount, "uint", dwSize, "uint")
        return result
    }

    /**
     * Writes a specified number of filemarks, setmarks, short filemarks, or long filemarks to a tape device.
     * @param {HANDLE} hDevice Handle to the device on which to write tapemarks. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwTapemarkType 
     * @param {Integer} dwTapemarkCount Number of tapemarks to write.
     * @param {BOOL} bImmediate If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writetapemark
     * @since windows5.1.2600
     */
    static WriteTapemark(hDevice, dwTapemarkType, dwTapemarkCount, bImmediate) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\WriteTapemark", "ptr", hDevice, "uint", dwTapemarkType, "uint", dwTapemarkCount, "int", bImmediate, "uint")
        return result
    }

    /**
     * Determines whether the tape device is ready to process tape commands.
     * @param {HANDLE} hDevice Handle to the device for which to get the device status. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @returns {Integer} If the tape device is ready to accept appropriate tape-access commands without returning errors, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_REQUIRES_CLEANING</b></dt>
     * <dt>1165L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape drive is capable of reporting that it requires cleaning, and reports that it does require cleaning.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapestatus
     * @since windows5.1.2600
     */
    static GetTapeStatus(hDevice) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\GetTapeStatus", "ptr", hDevice, "uint")
        return result
    }

    /**
     * Retrieves information that describes the tape or the tape drive.
     * @param {HANDLE} hDevice Handle to the device about which information is sought. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwOperation 
     * @param {Pointer<UInt32>} lpdwSize Pointer to a variable that receives the size, in bytes, of the buffer specified by the <i>lpTapeInformation</i> parameter. If the buffer is too small, this parameter receives the required size.
     * @param {Pointer} lpTapeInformation Pointer to a structure that contains the requested information. If the <i>dwOperation</i> parameter is <b>GET_TAPE_MEDIA_INFORMATION</b>, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_get_media_parameters">TAPE_GET_MEDIA_PARAMETERS</a> structure.
     * 
     * If <i>dwOperation</i> is <b>GET_TAPE_DRIVE_INFORMATION</b>, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_get_drive_parameters">TAPE_GET_DRIVE_PARAMETERS</a> structure.
     * @returns {Integer} If the function succeeds, the return value is <b>NO_ERROR</b>.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-gettapeparameters
     * @since windows5.1.2600
     */
    static GetTapeParameters(hDevice, dwOperation, lpdwSize, lpTapeInformation) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\GetTapeParameters", "ptr", hDevice, "uint", dwOperation, "uint*", lpdwSize, "ptr", lpTapeInformation, "uint")
        return result
    }

    /**
     * Specifies the block size of a tape or configures the tape device.
     * @param {HANDLE} hDevice Handle to the device for which to set configuration information. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwOperation 
     * @param {Pointer<Void>} lpTapeInformation Pointer to a structure that contains the information to set. If the <i>dwOperation</i> parameter is SET_TAPE_MEDIA_INFORMATION, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_set_media_parameters">TAPE_SET_MEDIA_PARAMETERS</a> structure. 
     * 
     * 
     * 
     * 
     * If <i>dwOperation</i> is SET_TAPE_DRIVE_INFORMATION, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_set_drive_parameters">TAPE_SET_DRIVE_PARAMETERS</a> structure.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-settapeparameters
     * @since windows5.1.2600
     */
    static SetTapeParameters(hDevice, dwOperation, lpTapeInformation) {
        hDevice := hDevice is Win32Handle ? NumGet(hDevice, "ptr") : hDevice

        result := DllCall("KERNEL32.dll\SetTapeParameters", "ptr", hDevice, "uint", dwOperation, "ptr", lpTapeInformation, "uint")
        return result
    }

    /**
     * Encrypts a file or directory.
     * @param {PSTR} lpFileName The name of the file or directory to be encrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, 
     *        <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-encryptfilea
     * @since windows5.1.2600
     */
    static EncryptFileA(lpFileName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\EncryptFileA", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Encrypts a file or directory.
     * @param {PWSTR} lpFileName The name of the file or directory to be encrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, 
     *        <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-encryptfilew
     * @since windows5.1.2600
     */
    static EncryptFileW(lpFileName) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\EncryptFileW", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decrypts an encrypted file or directory.
     * @param {PSTR} lpFileName The name of the file or directory to be decrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-decryptfilea
     * @since windows5.1.2600
     */
    static DecryptFileA(lpFileName) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\DecryptFileA", "ptr", lpFileName, "uint", dwReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decrypts an encrypted file or directory.
     * @param {PWSTR} lpFileName The name of the file or directory to be decrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-decryptfilew
     * @since windows5.1.2600
     */
    static DecryptFileW(lpFileName) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\DecryptFileW", "ptr", lpFileName, "uint", dwReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the encryption status of the specified file.
     * @param {PSTR} lpFileName The name of the file.
     * @param {Pointer<UInt32>} lpStatus A pointer to a variable that receives the encryption status of the file. This parameter can be one of the 
     *       following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ENCRYPTABLE"></a><a id="file_encryptable"></a><dl>
     * <dt><b>FILE_ENCRYPTABLE</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file can be encrypted.
     *         
     * 
     * <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on 
     *           these editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_IS_ENCRYPTED"></a><a id="file_is_encrypted"></a><dl>
     * <dt><b>FILE_IS_ENCRYPTED</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY"></a><a id="file_read_only"></a><dl>
     * <dt><b>FILE_READ_ONLY</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a read-only file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ROOT_DIR"></a><a id="file_root_dir"></a><dl>
     * <dt><b>FILE_ROOT_DIR</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a root directory. Root directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_ATTR"></a><a id="file_system_attr"></a><dl>
     * <dt><b>FILE_SYSTEM_ATTR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system file. System files cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_DIR"></a><a id="file_system_dir"></a><dl>
     * <dt><b>FILE_SYSTEM_DIR</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system directory. System directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_NOT_SUPPORT"></a><a id="file_system_not_support"></a><dl>
     * <dt><b>FILE_SYSTEM_NOT_SUPPORT</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system does not support file encryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNKNOWN"></a><a id="file_unknown"></a><dl>
     * <dt><b>FILE_UNKNOWN</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The encryption status is unknown. The file may be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_USER_DISALLOWED"></a><a id="file_user_disallowed"></a><dl>
     * <dt><b>FILE_USER_DISALLOWED</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reserved for future use.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-fileencryptionstatusa
     * @since windows5.1.2600
     */
    static FileEncryptionStatusA(lpFileName, lpStatus) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\FileEncryptionStatusA", "ptr", lpFileName, "uint*", lpStatus, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the encryption status of the specified file.
     * @param {PWSTR} lpFileName The name of the file.
     * @param {Pointer<UInt32>} lpStatus A pointer to a variable that receives the encryption status of the file. This parameter can be one of the 
     *       following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ENCRYPTABLE"></a><a id="file_encryptable"></a><dl>
     * <dt><b>FILE_ENCRYPTABLE</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file can be encrypted.
     *         
     * 
     * <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on 
     *           these editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_IS_ENCRYPTED"></a><a id="file_is_encrypted"></a><dl>
     * <dt><b>FILE_IS_ENCRYPTED</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY"></a><a id="file_read_only"></a><dl>
     * <dt><b>FILE_READ_ONLY</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a read-only file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ROOT_DIR"></a><a id="file_root_dir"></a><dl>
     * <dt><b>FILE_ROOT_DIR</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a root directory. Root directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_ATTR"></a><a id="file_system_attr"></a><dl>
     * <dt><b>FILE_SYSTEM_ATTR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system file. System files cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_DIR"></a><a id="file_system_dir"></a><dl>
     * <dt><b>FILE_SYSTEM_DIR</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system directory. System directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_NOT_SUPPORT"></a><a id="file_system_not_support"></a><dl>
     * <dt><b>FILE_SYSTEM_NOT_SUPPORT</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system does not support file encryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNKNOWN"></a><a id="file_unknown"></a><dl>
     * <dt><b>FILE_UNKNOWN</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The encryption status is unknown. The file may be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_USER_DISALLOWED"></a><a id="file_user_disallowed"></a><dl>
     * <dt><b>FILE_USER_DISALLOWED</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reserved for future use.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-fileencryptionstatusw
     * @since windows5.1.2600
     */
    static FileEncryptionStatusW(lpFileName, lpStatus) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\FileEncryptionStatusW", "ptr", lpFileName, "uint*", lpStatus, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens an encrypted file in order to backup (export) or restore (import) the file.
     * @param {PSTR} lpFileName The name of the file to be opened. The string must consist of characters from the Windows character set.
     * @param {Integer} ulFlags The operation to be performed. This parameter may be one of the
     *          following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Open the file for export
     *                                      (backup).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_IMPORT"></a><a id="create_for_import"></a><dl>
     * <dt><b>CREATE_FOR_IMPORT</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened for import
     *                                      (restore).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_DIR"></a><a id="create_for_dir"></a><dl>
     * <dt><b>CREATE_FOR_DIR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OVERWRITE_HIDDEN"></a><a id="overwrite_hidden"></a><dl>
     * <dt><b>OVERWRITE_HIDDEN</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Overwrite a hidden file on import.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvContext The address of a  context
     *          block that must be presented in subsequent calls to 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a>, or 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.  Do not modify it.
     * @returns {Integer} If the function succeeds, it returns <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in
     *       WinError.h. You can use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the
     *       <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
     *       the error.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openencryptedfilerawa
     * @since windows5.1.2600
     */
    static OpenEncryptedFileRawA(lpFileName, ulFlags, pvContext) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\OpenEncryptedFileRawA", "ptr", lpFileName, "uint", ulFlags, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Opens an encrypted file in order to backup (export) or restore (import) the file.
     * @param {PWSTR} lpFileName The name of the file to be opened. The string must consist of characters from the Windows character set.
     * @param {Integer} ulFlags The operation to be performed. This parameter may be one of the
     *          following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Open the file for export
     *                                      (backup).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_IMPORT"></a><a id="create_for_import"></a><dl>
     * <dt><b>CREATE_FOR_IMPORT</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened for import
     *                                      (restore).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_DIR"></a><a id="create_for_dir"></a><dl>
     * <dt><b>CREATE_FOR_DIR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OVERWRITE_HIDDEN"></a><a id="overwrite_hidden"></a><dl>
     * <dt><b>OVERWRITE_HIDDEN</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Overwrite a hidden file on import.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvContext The address of a  context
     *          block that must be presented in subsequent calls to 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a>, or 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.  Do not modify it.
     * @returns {Integer} If the function succeeds, it returns <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in
     *       WinError.h. You can use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the
     *       <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
     *       the error.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openencryptedfileraww
     * @since windows5.1.2600
     */
    static OpenEncryptedFileRawW(lpFileName, ulFlags, pvContext) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\OpenEncryptedFileRawW", "ptr", lpFileName, "uint", ulFlags, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Backs up (export) encrypted files.
     * @param {Pointer<PFE_EXPORT_FUNC>} pfExportCallback A pointer to the export callback function. The system calls the callback function multiple times, each time 
     *       passing a block of the file's data to the callback function until the entire file has been read. For more 
     *       information, see <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a>.
     * @param {Pointer<Void>} pvCallbackContext A pointer to an application-defined and allocated context block. The system passes this pointer to the 
     *       callback function as a parameter so that the callback function can have access to application-specific data. 
     *       This can be a structure and can contain any data the application needs, such as the handle to the file that will 
     *       contain the backup copy of the encrypted file.
     * @param {Pointer<Void>} pvContext A pointer to a system-defined context block. The context block is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> function. Do not modify 
     *       it.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in WinError.h. You can use 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the 
     *        <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readencryptedfileraw
     * @since windows5.1.2600
     */
    static ReadEncryptedFileRaw(pfExportCallback, pvCallbackContext, pvContext) {
        result := DllCall("ADVAPI32.dll\ReadEncryptedFileRaw", "ptr", pfExportCallback, "ptr", pvCallbackContext, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Restores (import) encrypted files.
     * @param {Pointer<PFE_IMPORT_FUNC>} pfImportCallback A pointer to the import callback function. The system calls the callback function multiple times, each time 
     *       passing a buffer that will be filled by the callback function with a portion of backed-up file's data. When the 
     *       callback function signals that the entire file has been processed, it tells the system that the restore 
     *       operation is finished. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a>.
     * @param {Pointer<Void>} pvCallbackContext A pointer to an application-defined and allocated context block. The system passes this pointer to the 
     *       callback function as a parameter so that the callback function can have access to application-specific data. 
     *       This can be a structure and can contain any data the application needs, such as the handle to the file that will 
     *       contain the backup copy of the encrypted file.
     * @param {Pointer<Void>} pvContext A pointer to a system-defined context block. The context block is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> function. Do not modify 
     *       it.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in WinError.h. You can use 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the 
     *        <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-writeencryptedfileraw
     * @since windows5.1.2600
     */
    static WriteEncryptedFileRaw(pfImportCallback, pvCallbackContext, pvContext) {
        result := DllCall("ADVAPI32.dll\WriteEncryptedFileRaw", "ptr", pfImportCallback, "ptr", pvCallbackContext, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Closes an encrypted file after a backup or restore operation, and frees associated system resources.
     * @remarks
     * 
     * The <b>CloseEncryptedFileRaw</b> function frees allocated system resources
     *       such as the system-defined context block and closes the file.
     * 
     * The  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> functions handle backup and restore of unencrypted files.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * @param {Pointer<Void>} pvContext A pointer to a system-defined context block. The
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> function returns the context block.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-closeencryptedfileraw
     * @since windows5.1.2600
     */
    static CloseEncryptedFileRaw(pvContext) {
        DllCall("ADVAPI32.dll\CloseEncryptedFileRaw", "ptr", pvContext)
    }

    /**
     * Creates, opens, reopens, or deletes a file.
     * @param {PSTR} lpFileName The name of the file.
     * 
     * The string must consist of characters from the 8-bit Windows character set. The 
     *        <b>OpenFile</b> function does not support Unicode file names or 
     *        opening named pipes.
     * @param {Pointer<OFSTRUCT>} lpReOpenBuff A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that receives 
     *        information about a file when it is first opened.
     * 
     * The structure can be used in subsequent calls to the 
     *        <b>OpenFile</b> function to see an open file.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure contains a path string 
     *        member with a length that is limited to <b>OFS_MAXPATHNAME</b> characters, which is 128 
     *        characters. Because of this, you cannot use the <b>OpenFile</b> 
     *        function to open a file with a path length that exceeds 128 characters. The 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function does not have this path 
     *        length limitation.
     * @param {Integer} uStyle The action to be taken.
     * @returns {Integer} If the function succeeds, the return value specifies a file handle to use when performing file I/O. To close the file, call the <a href="/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function using this handle.
     * 
     * If the function fails, the return value is <b>HFILE_ERROR</b>. To get extended error 
     *        information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfile
     * @since windows5.1.2600
     */
    static OpenFile(lpFileName, lpReOpenBuff, uStyle) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\OpenFile", "ptr", lpFileName, "ptr", lpReOpenBuff, "uint", uStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Back up a file or directory, including the security information.
     * @param {HANDLE} hFile Handle to the file or directory to be backed up. To obtain the handle, call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. The SACLs are not read unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. For more information, see [File security and access rights](/windows/win32/fileio/file-security-and-access-rights).
     * 
     * The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.
     * 
     * The <b>BackupRead</b> function may fail if 
     *       <b>CreateFile</b> was called with the flag 
     *       <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value 
     *       <b>ERROR_INVALID_PARAMETER</b>.
     * @param {Pointer} lpBuffer Pointer to a buffer that receives the data.
     * @param {Integer} nNumberOfBytesToRead Length of the buffer, in bytes. The buffer size must be greater than the size of a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-win32_stream_id">WIN32_STREAM_ID</a> structure.
     * @param {Pointer<UInt32>} lpNumberOfBytesRead Pointer to a variable that receives the number of bytes read.
     * 
     * If the function returns a nonzero value, and the variable pointed to by 
     *       <i>lpNumberOfBytesRead</i> is zero, then all the data associated with the file handle has 
     *       been read.
     * @param {BOOL} bAbort Indicates whether you have finished using <b>BackupRead</b> 
     *       on the handle. While you are backing up the file, specify this parameter as <b>FALSE</b>. 
     *       Once you are done using <b>BackupRead</b>, you must call 
     *       <b>BackupRead</b> one more time specifying 
     *       <b>TRUE</b> for this parameter and passing the appropriate 
     *       <i>lpContext</i>. <i>lpContext</i> must be passed when 
     *       <i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.
     * @param {BOOL} bProcessSecurity Indicates whether the function will restore the access-control list (ACL) data for the file or directory.
     * 
     * If <i>bProcessSecurity</i> is <b>TRUE</b>, the ACL data will be backed 
     *       up.
     * @param {Pointer<Void>} lpContext Pointer to a variable that receives a pointer to an internal data structure used by 
     *       <b>BackupRead</b> to maintain context information during a 
     *       backup operation.
     * 
     * You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b> 
     *       before the first call to <b>BackupRead</b> for the specified 
     *       file or directory. The function allocates memory for the data structure, and then sets the variable to point to 
     *       that structure. You must not change <i>lpContext</i> or the variable that it points to 
     *       between calls to <b>BackupRead</b>.
     * 
     * To release the memory used by the data structure, call 
     *       <b>BackupRead</b> with the 
     *       <i>bAbort</i> parameter set to <b>TRUE</b> when the backup operation is complete.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupread
     * @since windows5.1.2600
     */
    static BackupRead(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\BackupRead", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToRead, "uint*", lpNumberOfBytesRead, "int", bAbort, "int", bProcessSecurity, "ptr", lpContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Seeks forward in a data stream initially accessed by using the BackupRead or BackupWrite function.
     * @param {HANDLE} hFile Handle to the file or directory. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * 
     * The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.
     * @param {Integer} dwLowBytesToSeek Low-order part of the number of bytes to seek.
     * @param {Integer} dwHighBytesToSeek High-order part of the number of bytes to seek.
     * @param {Pointer<UInt32>} lpdwLowByteSeeked Pointer to a variable that receives the low-order bits of the number of bytes the function actually seeks.
     * @param {Pointer<UInt32>} lpdwHighByteSeeked Pointer to a variable that receives the high-order bits of the number of bytes the function actually seeks.
     * @param {Pointer<Void>} lpContext Pointer to an internal data structure used by the function. This structure must be the same structure that was initialized by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> function. An application must not touch the contents of this structure.
     * @returns {BOOL} If the function could seek the requested amount, the function returns a nonzero value.
     * 
     * If the function could not seek the requested amount, the function returns zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupseek
     * @since windows5.1.2600
     */
    static BackupSeek(hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\BackupSeek", "ptr", hFile, "uint", dwLowBytesToSeek, "uint", dwHighBytesToSeek, "uint*", lpdwLowByteSeeked, "uint*", lpdwHighByteSeeked, "ptr", lpContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Restore a file or directory that was backed up using BackupRead.
     * @param {HANDLE} hFile Handle to the file or directory to be restored. To obtain the handle, call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. The SACLs are not restored unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. To ensure that the integrity ACEs are restored correctly, the file handle must also have been created with the <b>WRITE_OWNER</b> access right. For more information, see [File security and access rights](/windows/win32/fileio/file-security-and-access-rights).
     * 
     * The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.
     * 
     * The <b>BackupWrite</b> function may fail if 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> was called with the flag 
     *       <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value
     *       <b>ERROR_INVALID_PARAMETER</b>.
     * @param {Pointer} lpBuffer Pointer to a buffer that the function writes data from.
     * @param {Integer} nNumberOfBytesToWrite Size of the buffer, in bytes. The buffer size must be greater than the size of a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-win32_stream_id">WIN32_STREAM_ID</a> structure.
     * @param {Pointer<UInt32>} lpNumberOfBytesWritten Pointer to a variable that receives the number of bytes written.
     * @param {BOOL} bAbort Indicates whether you have finished using <b>BackupWrite</b> on the handle. 
     *       While you are restoring the file, specify this parameter as <b>FALSE</b>. After you are done 
     *       using <b>BackupWrite</b>, you must call <b>BackupWrite</b> 
     *       one more time specifying <b>TRUE</b> for this parameter and passing the appropriate 
     *       <i>lpContext</i>. <i>lpContext</i> must be passed when 
     *       <i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.
     * @param {BOOL} bProcessSecurity Specifies whether the function will restore the access-control list (ACL) data for the file or directory.
     * 
     * If <i>bProcessSecurity</i> is <b>TRUE</b>, you need to specify 
     *       <b>WRITE_OWNER</b> and <b>WRITE_DAC</b> access when opening the file or 
     *       directory handle. If the handle does not have those access rights, the operating system denies access to the 
     *       ACL data, and ACL data restoration will not occur.
     * @param {Pointer<Void>} lpContext Pointer to a variable that receives a pointer to an internal data structure used by 
     *       <b>BackupWrite</b> to maintain context information during a restore operation.
     * 
     * You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b> 
     *       before the first call to <b>BackupWrite</b> for the specified file or directory. The 
     *       function allocates memory for the data structure, and then sets the variable to point to that structure. You 
     *       must not change <i>lpContext</i> or the variable that it points to between calls to 
     *       <b>BackupWrite</b>.
     * 
     * To release the memory used by the data structure, call <b>BackupWrite</b> with the 
     *       <i>bAbort</i> parameter set to <b>TRUE</b> when the restore operation is 
     *       complete.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-backupwrite
     * @since windows5.1.2600
     */
    static BackupWrite(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\BackupWrite", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToWrite, "uint*", lpNumberOfBytesWritten, "int", bAbort, "int", bProcessSecurity, "ptr", lpContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Fills a buffer with strings that specify valid drives in the system.
     * @param {Integer} nBufferLength The maximum size of the buffer pointed to by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>. This size does not include the terminating null character. If this 
     *       parameter is zero, <i>lpBuffer</i> is not used.
     * @param {PSTR} lpBuffer A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the 
     *       system, plus with an additional null character. Each string is a device name.
     * @returns {Integer} If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, 
     *        not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a 
     *        Unicode (UTF-16) null character uses two bytes.
     * 
     * If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. 
     *        It is the size of the buffer required to hold the drive strings.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getlogicaldrivestringsa
     * @since windows5.1.2600
     */
    static GetLogicalDriveStringsA(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLogicalDriveStringsA", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the per-process mode that the SearchPath function uses when locating files.
     * @param {Integer} Flags The search mode to use.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE"></a><a id="base_search_path_enable_safe_searchmode"></a><dl>
     * <dt><b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enable safe process search mode for the process.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE"></a><a id="base_search_path_disable_safe_searchmode"></a><dl>
     * <dt><b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disable safe process search mode for the process.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BASE_SEARCH_PATH_PERMANENT"></a><a id="base_search_path_permanent"></a><dl>
     * <dt><b>BASE_SEARCH_PATH_PERMANENT</b></dt>
     * <dt>0x00008000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Optional flag to use in combination with 
     *          <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b> to make this mode permanent for this 
     *          process. This is done by bitwise <b>OR</b> operation:
     * 
     * <c>(BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT)</c>
     * 
     * This flag cannot be combined with the <b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b> 
     *         flag.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the operation completes successfully, the 
     *        <b>SetSearchPathMode</b> function returns a nonzero 
     *        value.
     * 
     * If the operation fails, the <b>SetSearchPathMode</b> 
     *        function returns zero. To get extended error information, call the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the <b>SetSearchPathMode</b> function fails because a 
     *        parameter value is not valid, the value returned by the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will be 
     *        <b>ERROR_INVALID_PARAMETER</b>.
     * 
     * If the <b>SetSearchPathMode</b> function fails because 
     *        the combination of current state and parameter value is not valid, the value returned by the 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will be 
     *        <b>ERROR_ACCESS_DENIED</b>. For more information, see the Remarks section.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setsearchpathmode
     * @since windows6.1
     */
    static SetSearchPathMode(Flags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetSearchPathMode", "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory with the attributes of a specified template directory.
     * @param {PSTR} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PSTR} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path. To create all intermediate directories on the path, use the 
     *         <a href="/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedirectoryexa">SHCreateDirectoryEx</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectoryexa
     * @since windows5.1.2600
     */
    static CreateDirectoryExA(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes) {
        lpTemplateDirectory := lpTemplateDirectory is String ? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String ? StrPtr(lpNewDirectory) : lpNewDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryExA", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory with the attributes of a specified template directory.
     * @param {PWSTR} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PWSTR} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path. To create all intermediate directories on the path, use the 
     *         <a href="/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedirectoryexa">SHCreateDirectoryEx</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectoryexw
     * @since windows5.1.2600
     */
    static CreateDirectoryExW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes) {
        lpTemplateDirectory := lpTemplateDirectory is String ? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String ? StrPtr(lpNewDirectory) : lpNewDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryExW", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory as a transacted operation, with the attributes of a specified template directory.
     * @param {PSTR} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.  This parameter can be 
     *        <b>NULL</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {PSTR} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * You cannot create a child directory with a parent directory that has encryption disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectorytransacteda
     * @since windows6.0.6000
     */
    static CreateDirectoryTransactedA(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction) {
        lpTemplateDirectory := lpTemplateDirectory is String ? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String ? StrPtr(lpNewDirectory) : lpNewDirectory
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryTransactedA", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory as a transacted operation, with the attributes of a specified template directory.
     * @param {PWSTR} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.  This parameter can be 
     *        <b>NULL</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {PWSTR} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * You cannot create a child directory with a parent directory that has encryption disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createdirectorytransactedw
     * @since windows6.0.6000
     */
    static CreateDirectoryTransactedW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction) {
        lpTemplateDirectory := lpTemplateDirectory is String ? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String ? StrPtr(lpNewDirectory) : lpNewDirectory
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryTransactedW", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory as a transacted operation.
     * @param {PSTR} lpPathName The path of the directory to be removed. The path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-removedirectorytransacteda
     * @since windows6.0.6000
     */
    static RemoveDirectoryTransactedA(lpPathName, hTransaction) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryTransactedA", "ptr", lpPathName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory as a transacted operation.
     * @param {PWSTR} lpPathName The path of the directory to be removed. The path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-removedirectorytransactedw
     * @since windows6.0.6000
     */
    static RemoveDirectoryTransactedW(lpPathName, hTransaction) {
        lpPathName := lpPathName is String ? StrPtr(lpPathName) : lpPathName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryTransactedW", "ptr", lpPathName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file as a transacted operation.
     * @param {PSTR} lpFileName The name of the file.
     * 
     * This string can use short (the 8.3 form) or long file names. This string can be a share or volume name.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string  for the drive and path,  in 
     *       <b>TCHARs</b>.
     * @param {PSTR} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<PSTR>} lpFilePart A pointer to a buffer that receives the address (in <i>lpBuffer</i>) of the final file 
     *        name component in the path. Specify <b>NULL</b> if you do not need to receive this 
     *        information.
     * 
     * If <i>lpBuffer</i> points to a directory and not a file, 
     *        <i>lpFilePart</i> receives 0 (zero).
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfullpathnametransacteda
     * @since windows6.0.6000
     */
    static GetFullPathNameTransactedA(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameTransactedA", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file as a transacted operation.
     * @param {PWSTR} lpFileName The name of the file.
     * 
     * This string can use short (the 8.3 form) or long file names. This string can be a share or volume name.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string  for the drive and path,  in 
     *       <b>TCHARs</b>.
     * @param {PWSTR} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<PWSTR>} lpFilePart A pointer to a buffer that receives the address (in <i>lpBuffer</i>) of the final file 
     *        name component in the path. Specify <b>NULL</b> if you do not need to receive this 
     *        information.
     * 
     * If <i>lpBuffer</i> points to a directory and not a file, 
     *        <i>lpFilePart</i> receives 0 (zero).
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfullpathnametransactedw
     * @since windows6.0.6000
     */
    static GetFullPathNameTransactedW(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String ? StrPtr(lpBuffer) : lpBuffer
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameTransactedW", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Defines, redefines, or deletes MS-DOS device names.
     * @param {Integer} dwFlags The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
     * @param {PSTR} lpDeviceName A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or 
     *       deleting. The device name string must not have a colon as the last character, unless a drive letter is being 
     *       defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a 
     *       trailing backslash ("\") allowed.
     * @param {PSTR} lpTargetPath A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the 
     *       <b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path 
     *       string.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-definedosdevicea
     * @since windows5.1.2600
     */
    static DefineDosDeviceA(dwFlags, lpDeviceName, lpTargetPath) {
        lpDeviceName := lpDeviceName is String ? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String ? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DefineDosDeviceA", "uint", dwFlags, "ptr", lpDeviceName, "ptr", lpTargetPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about MS-DOS device names.
     * @param {PSTR} lpDeviceName An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing 
     *        backslash; for example, use "C:", not "C:\\".
     * 
     * This parameter can be <b>NULL</b>. In that case, the 
     *        <b>QueryDosDevice</b> function will store a list of all 
     *        existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.
     * @param {PSTR} lpTargetPath A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or 
     *        more null-terminated strings. The final null-terminated string is followed by an additional 
     *        <b>NULL</b>.
     * 
     * If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves 
     *        information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first 
     *        null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated 
     *        strings represent undeleted prior mappings for the device.
     * 
     * If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of 
     *        all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing 
     *        MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.
     * @param {Integer} ucchMax The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by 
     *       <i>lpTargetPath</i>.
     * @returns {Integer} If the function succeeds, the return value is the number of <b>TCHARs</b> stored into 
     *        the buffer pointed to by <i>lpTargetPath</i>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the buffer is too small, the function fails and the last error code is 
     *        <b>ERROR_INSUFFICIENT_BUFFER</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-querydosdevicea
     * @since windows5.1.2600
     */
    static QueryDosDeviceA(lpDeviceName, lpTargetPath, ucchMax) {
        lpDeviceName := lpDeviceName is String ? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String ? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\QueryDosDeviceA", "ptr", lpDeviceName, "ptr", lpTargetPath, "uint", ucchMax, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file, file stream, or directory as a transacted operation.
     * @param {PSTR} lpFileName The name of an object to be created or opened.
     * 
     * The object must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. For information on special device names, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * @param {Integer} dwDesiredAccess The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly 
     *        used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both 
     *        (<b>GENERIC_READ</b> | <b>GENERIC_WRITE</b>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * If this parameter is zero, the application can query  file, directory, or device attributes without accessing 
     *        that file or device. For more information, see the Remarks section of this topic.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified in an open request 
     *        that has an open handle. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the 
     *        following table).
     * 
     * If this parameter is zero and 
     *        <b>CreateFileTransacted</b> succeeds, the object cannot 
     *        be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section 
     *        of this topic.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an open request 
     *        that has an open handle, because that would result in the following sharing violation: 
     *        <b>ERROR_SHARING_VIOLATION</b>. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * To enable a process to share an object while another process has the object open, use a combination of one or
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains an optional 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> and also determines whether 
     *        or not the returned handle can be inherited by child processes. The parameter can be 
     *        <b>NULL</b>.
     * 
     * If the <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle 
     *        returned by <b>CreateFileTransacted</b> cannot be 
     *        inherited by any child processes your application may create and the object associated with the returned handle 
     *        gets a default security descriptor.
     * 
     * The <b>bInheritHandle</b> member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * The  <b>lpSecurityDescriptor</b> member of the structure specifies 
     *        a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> for an object, but may 
     *        also be <b>NULL</b>.
     * 
     * If <b>lpSecurityDescriptor</b> member is <b>NULL</b>, the object 
     *        associated with the returned handle is assigned a default security descriptor.
     * 
     * <b>CreateFileTransacted</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file, but continues to use the 
     *        <b>bInheritHandle</b> member.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwCreationDisposition An action to take on files that exist and  do not exist.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwFlagsAndAttributes The file attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default 
     *        value.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of 
     *        buffering behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  <p class="note">When <b>CreateFileTransacted</b> opens an existing 
     *         file, it generally combines the file flags with the file attributes of the existing file, and ignores any file 
     *         attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * </div>
     * <div> </div>
     * The following file attributes and flags are used only for file objects, not other types of objects that 
     *        <b>CreateFileTransacted</b> opens (additional 
     *        information can be found in the Remarks section of this topic). For more advanced access to file attributes, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all 
     *        file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.  File systems avoid writing data back to mass storage 
     *          if sufficient cache memory is available, because an application deletes a temporary file after a handle is 
     *          closed. In that case, the system can entirely avoid writing the data.  Otherwise, the data is written after 
     *          the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the 
     *          calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> 
     *          and <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after the last transacted writer handle to the file is closed, 
     *          provided that the transaction is still active. If a file has been marked for deletion and a transacted writer 
     *          handle is still open after the transaction completes, the file will not be deleted.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened with no system caching. This flag does not affect hard disk caching or memory 
     *          mapped files. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum 
     *          asynchronous performance, because the I/O does not rely on the synchronous operations of the memory manager. 
     *          However, some I/O operations take more time, because data is not being held in the cache. Also, the file 
     *          metadata may still be cached. To flush the metadata to disk, use the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function.
     * 
     * An application must meet certain requirements when working with files that are opened with 
     *          <b>FILE_FLAG_NO_BUFFERING</b>:
     * 
     * <ul>
     * <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector 
     *           size.</li>
     * <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For 
     *           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, 
     *           or 2048 bytes, but not of 335, 981, or 7171 bytes.</li>
     * <li>Buffer addresses for read and write operations should be sector aligned, which means aligned on 
     *           addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this 
     *           requirement may not be enforced.</li>
     * </ul>
     * One way to align buffers on integer multiples of the volume sector size is to use 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> to allocate the buffers. It allocates 
     *          memory that is aligned on addresses that are integer multiples of the operating system's memory page size. 
     *          Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses 
     *          that are integer multiples of a volume sector size. Memory pages are 4 or 8 KB in size; sectors are 512 bytes 
     *          (hard disks), 2048 bytes (CD), or 4096 bytes (hard disks), and therefore, volume sectors can never be larger 
     *          than memory pages.
     * 
     * An application can determine a volume sector size by calling the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not occur; 
     *          <b>CreateFileTransacted</b> will attempt to open the 
     *          reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the 
     *          reparse point is operational. This flag cannot be used with the <b>CREATE_ALWAYS</b> 
     *          flag. If the file is not a reparse point, then this flag is ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for asynchronous I/O. When the operation is complete, the event 
     *          specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is set to the 
     *          signaled state. Operations that take a significant amount of time to process return 
     *          <b>ERROR_IO_PENDING</b>.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations. The system does 
     *          not maintain the file pointer, therefore you must pass the file position to the read and write functions in 
     *          the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure or update the file 
     *          pointer.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed according to POSIX rules. This includes allowing multiple files with names, 
     *          differing only in case, for file systems that support that naming. Use care when using this option, because 
     *          files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed randomly. The system can use this as a hint to optimize file caching.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed sequentially from beginning to end. The system can use this as a hint to 
     *          optimize file caching. If an application moves the file pointer for random access, optimum caching may not 
     *          occur. However, correct operation is still guaranteed.
     * 
     * Specifying this flag can increase performance for applications that read large files using sequential 
     *          access. Performance gains can be even more noticeable for applications that read large files mostly 
     *          sequentially, but occasionally skip over small ranges of bytes.
     * 
     * This flag  has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in 
     *          effect, then the data is written to the system cache, but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in 
     *          effect, then the data is immediately flushed to disk without going through the system cache. The operating 
     *          system also requests a write-through the hard disk cache to persistent media. However, not all hardware 
     *          supports this write-through capability.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i> parameter can also specify Security Quality of Service 
     *        information. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling 
     *        application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {HANDLE} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created. This parameter can be 
     *        <b>NULL</b>.
     * 
     * When opening an existing file, 
     *        <b>CreateFileTransacted</b> ignores the template 
     *        file.
     * 
     * When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @param {Pointer<UInt32>} pusMiniVersion The miniversion to be opened. If the transaction specified in <i>hTransaction</i> is not 
     *        the transaction that is modifying the file, this parameter should be <b>NULL</b>. Otherwise, 
     *        this parameter can be a miniversion identifier returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_txfs_create_miniversion">FSCTL_TXFS_CREATE_MINIVERSION</a> control
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransacteda
     * @since windows6.0.6000
     */
    static CreateFileTransactedA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion) {
        static lpExtendedParameter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTemplateFile := hTemplateFile is Win32Handle ? NumGet(hTemplateFile, "ptr") : hTemplateFile
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileTransactedA", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile, "ptr", hTransaction, "uint*", pusMiniVersion, "ptr", lpExtendedParameter, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Creates or opens a file, file stream, or directory as a transacted operation.
     * @param {PWSTR} lpFileName The name of an object to be created or opened.
     * 
     * The object must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. For information on special device names, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * @param {Integer} dwDesiredAccess The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly 
     *        used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both 
     *        (<b>GENERIC_READ</b> | <b>GENERIC_WRITE</b>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * If this parameter is zero, the application can query  file, directory, or device attributes without accessing 
     *        that file or device. For more information, see the Remarks section of this topic.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified in an open request 
     *        that has an open handle. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the 
     *        following table).
     * 
     * If this parameter is zero and 
     *        <b>CreateFileTransacted</b> succeeds, the object cannot 
     *        be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section 
     *        of this topic.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an open request 
     *        that has an open handle, because that would result in the following sharing violation: 
     *        <b>ERROR_SHARING_VIOLATION</b>. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * To enable a process to share an object while another process has the object open, use a combination of one or
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains an optional 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> and also determines whether 
     *        or not the returned handle can be inherited by child processes. The parameter can be 
     *        <b>NULL</b>.
     * 
     * If the <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle 
     *        returned by <b>CreateFileTransacted</b> cannot be 
     *        inherited by any child processes your application may create and the object associated with the returned handle 
     *        gets a default security descriptor.
     * 
     * The <b>bInheritHandle</b> member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * The  <b>lpSecurityDescriptor</b> member of the structure specifies 
     *        a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> for an object, but may 
     *        also be <b>NULL</b>.
     * 
     * If <b>lpSecurityDescriptor</b> member is <b>NULL</b>, the object 
     *        associated with the returned handle is assigned a default security descriptor.
     * 
     * <b>CreateFileTransacted</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file, but continues to use the 
     *        <b>bInheritHandle</b> member.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwCreationDisposition An action to take on files that exist and  do not exist.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwFlagsAndAttributes The file attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default 
     *        value.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of 
     *        buffering behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  <p class="note">When <b>CreateFileTransacted</b> opens an existing 
     *         file, it generally combines the file flags with the file attributes of the existing file, and ignores any file 
     *         attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * </div>
     * <div> </div>
     * The following file attributes and flags are used only for file objects, not other types of objects that 
     *        <b>CreateFileTransacted</b> opens (additional 
     *        information can be found in the Remarks section of this topic). For more advanced access to file attributes, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all 
     *        file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.  File systems avoid writing data back to mass storage 
     *          if sufficient cache memory is available, because an application deletes a temporary file after a handle is 
     *          closed. In that case, the system can entirely avoid writing the data.  Otherwise, the data is written after 
     *          the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the 
     *          calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> 
     *          and <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after the last transacted writer handle to the file is closed, 
     *          provided that the transaction is still active. If a file has been marked for deletion and a transacted writer 
     *          handle is still open after the transaction completes, the file will not be deleted.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened with no system caching. This flag does not affect hard disk caching or memory 
     *          mapped files. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum 
     *          asynchronous performance, because the I/O does not rely on the synchronous operations of the memory manager. 
     *          However, some I/O operations take more time, because data is not being held in the cache. Also, the file 
     *          metadata may still be cached. To flush the metadata to disk, use the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function.
     * 
     * An application must meet certain requirements when working with files that are opened with 
     *          <b>FILE_FLAG_NO_BUFFERING</b>:
     * 
     * <ul>
     * <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector 
     *           size.</li>
     * <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For 
     *           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, 
     *           or 2048 bytes, but not of 335, 981, or 7171 bytes.</li>
     * <li>Buffer addresses for read and write operations should be sector aligned, which means aligned on 
     *           addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this 
     *           requirement may not be enforced.</li>
     * </ul>
     * One way to align buffers on integer multiples of the volume sector size is to use 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> to allocate the buffers. It allocates 
     *          memory that is aligned on addresses that are integer multiples of the operating system's memory page size. 
     *          Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses 
     *          that are integer multiples of a volume sector size. Memory pages are 4 or 8 KB in size; sectors are 512 bytes 
     *          (hard disks), 2048 bytes (CD), or 4096 bytes (hard disks), and therefore, volume sectors can never be larger 
     *          than memory pages.
     * 
     * An application can determine a volume sector size by calling the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not occur; 
     *          <b>CreateFileTransacted</b> will attempt to open the 
     *          reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the 
     *          reparse point is operational. This flag cannot be used with the <b>CREATE_ALWAYS</b> 
     *          flag. If the file is not a reparse point, then this flag is ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for asynchronous I/O. When the operation is complete, the event 
     *          specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is set to the 
     *          signaled state. Operations that take a significant amount of time to process return 
     *          <b>ERROR_IO_PENDING</b>.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations. The system does 
     *          not maintain the file pointer, therefore you must pass the file position to the read and write functions in 
     *          the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure or update the file 
     *          pointer.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed according to POSIX rules. This includes allowing multiple files with names, 
     *          differing only in case, for file systems that support that naming. Use care when using this option, because 
     *          files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed randomly. The system can use this as a hint to optimize file caching.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed sequentially from beginning to end. The system can use this as a hint to 
     *          optimize file caching. If an application moves the file pointer for random access, optimum caching may not 
     *          occur. However, correct operation is still guaranteed.
     * 
     * Specifying this flag can increase performance for applications that read large files using sequential 
     *          access. Performance gains can be even more noticeable for applications that read large files mostly 
     *          sequentially, but occasionally skip over small ranges of bytes.
     * 
     * This flag  has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in 
     *          effect, then the data is written to the system cache, but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in 
     *          effect, then the data is immediately flushed to disk without going through the system cache. The operating 
     *          system also requests a write-through the hard disk cache to persistent media. However, not all hardware 
     *          supports this write-through capability.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i> parameter can also specify Security Quality of Service 
     *        information. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling 
     *        application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {HANDLE} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created. This parameter can be 
     *        <b>NULL</b>.
     * 
     * When opening an existing file, 
     *        <b>CreateFileTransacted</b> ignores the template 
     *        file.
     * 
     * When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @param {Pointer<UInt32>} pusMiniVersion The miniversion to be opened. If the transaction specified in <i>hTransaction</i> is not 
     *        the transaction that is modifying the file, this parameter should be <b>NULL</b>. Otherwise, 
     *        this parameter can be a miniversion identifier returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_txfs_create_miniversion">FSCTL_TXFS_CREATE_MINIVERSION</a> control
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createfiletransactedw
     * @since windows6.0.6000
     */
    static CreateFileTransactedW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion) {
        static lpExtendedParameter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTemplateFile := hTemplateFile is Win32Handle ? NumGet(hTemplateFile, "ptr") : hTemplateFile
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileTransactedW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile, "ptr", hTransaction, "uint*", pusMiniVersion, "ptr", lpExtendedParameter, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Reopens the specified file system object with different access rights, sharing mode, and flags.
     * @param {HANDLE} hOriginalFile A handle to the object to be reopened. The object must have been created by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwDesiredAccess The required access to the object. For a list of values, see 
     * 	      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You 
     * 	      cannot request an access mode that conflicts with the sharing mode specified in a previous open request whose 
     * 	      handle is still open.
     * 
     * If this parameter is zero (0), the application can query device attributes without accessing the device. This 
     *        is useful if an application wants to determine the size of a floppy disk drive and the formats it supports 
     *        without requiring a floppy in the drive.
     * @param {Integer} dwShareMode The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode 
     *        specified in a previous open request whose handle is still open.
     * 
     * If this parameter is zero (0) and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> succeeds, 
     *        the object cannot be shared and cannot be opened again until the handle is closed.
     * 
     * To enable other processes to share the object while your process has it open, use a combination of one or
     * @param {Integer} dwFlagsAndAttributes 
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to the specified file.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-reopenfile
     * @since windows6.0.6000
     */
    static ReOpenFile(hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes) {
        hOriginalFile := hOriginalFile is Win32Handle ? NumGet(hOriginalFile, "ptr") : hOriginalFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReOpenFile", "ptr", hOriginalFile, "uint", dwDesiredAccess, "uint", dwShareMode, "uint", dwFlagsAndAttributes, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Sets the attributes for a file or directory as a transacted operation.
     * @param {PSTR} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * For a list of file attribute value and their descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. This parameter can be 
     *        one or more values, combined using the bitwise-OR operator. However, all other values override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileattributestransacteda
     * @since windows6.0.6000
     */
    static SetFileAttributesTransactedA(lpFileName, dwFileAttributes, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesTransactedA", "ptr", lpFileName, "uint", dwFileAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the attributes for a file or directory as a transacted operation.
     * @param {PWSTR} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * For a list of file attribute value and their descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. This parameter can be 
     *        one or more values, combined using the bitwise-OR operator. However, all other values override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfileattributestransactedw
     * @since windows6.0.6000
     */
    static SetFileAttributesTransactedW(lpFileName, dwFileAttributes, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesTransactedW", "ptr", lpFileName, "uint", dwFileAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory as a transacted operation.
     * @param {PSTR} lpFileName The name of the file or directory.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The level of attribute information to retrieve.
     *       
     * 
     * This parameter can be the following value from the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     *       
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>. If the <i>fInfoLevelId</i> parameter is 
     *        <b>GetFileExInfoStandard</b> then this parameter points to a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileattributestransacteda
     * @since windows6.0.6000
     */
    static GetFileAttributesTransactedA(lpFileName, fInfoLevelId, lpFileInformation, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesTransactedA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory as a transacted operation.
     * @param {PWSTR} lpFileName The name of the file or directory.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The level of attribute information to retrieve.
     *       
     * 
     * This parameter can be the following value from the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     *       
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>. If the <i>fInfoLevelId</i> parameter is 
     *        <b>GetFileExInfoStandard</b> then this parameter points to a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileattributestransactedw
     * @since windows6.0.6000
     */
    static GetFileAttributesTransactedW(lpFileName, fInfoLevelId, lpFileInformation, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesTransactedW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file as a transacted operation.
     * @param {PSTR} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<UInt32>} lpFileSizeHigh A pointer to a variable that receives the high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcompressedfilesizetransacteda
     * @since windows6.0.6000
     */
    static GetCompressedFileSizeTransactedA(lpFileName, lpFileSizeHigh, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeTransactedA", "ptr", lpFileName, "uint*", lpFileSizeHigh, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file as a transacted operation.
     * @param {PWSTR} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<UInt32>} lpFileSizeHigh A pointer to a variable that receives the high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getcompressedfilesizetransactedw
     * @since windows6.0.6000
     */
    static GetCompressedFileSizeTransactedW(lpFileName, lpFileSizeHigh, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeTransactedW", "ptr", lpFileName, "uint*", lpFileSizeHigh, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file as a transacted operation.
     * @param {PSTR} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletefiletransacteda
     * @since windows6.0.6000
     */
    static DeleteFileTransactedA(lpFileName, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileTransactedA", "ptr", lpFileName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file as a transacted operation.
     * @param {PWSTR} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletefiletransactedw
     * @since windows6.0.6000
     */
    static DeleteFileTransactedW(lpFileName, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileTransactedW", "ptr", lpFileName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the specified name can be used to create a file on a FAT file system.
     * @param {PSTR} lpName The file name, in 8.3 format.
     * @param {PSTR} lpOemName A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} OemNameSize The size of the <i>lpOemName</i> buffer, in characters. If 
     *       <i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).
     * @param {Pointer<BOOL>} pbNameContainsSpaces Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If 
     *       the name is not a valid 8.3 FAT file system name, this parameter is undefined.
     * @param {Pointer<BOOL>} pbNameLegal If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when 
     *       the current OEM code page is applied to the file name.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3a
     * @since windows6.0.6000
     */
    static CheckNameLegalDOS8Dot3A(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal) {
        lpName := lpName is String ? StrPtr(lpName) : lpName
        lpOemName := lpOemName is String ? StrPtr(lpOemName) : lpOemName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CheckNameLegalDOS8Dot3A", "ptr", lpName, "ptr", lpOemName, "uint", OemNameSize, "ptr", pbNameContainsSpaces, "ptr", pbNameLegal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the specified name can be used to create a file on a FAT file system.
     * @param {PWSTR} lpName The file name, in 8.3 format.
     * @param {PSTR} lpOemName A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} OemNameSize The size of the <i>lpOemName</i> buffer, in characters. If 
     *       <i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).
     * @param {Pointer<BOOL>} pbNameContainsSpaces Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If 
     *       the name is not a valid 8.3 FAT file system name, this parameter is undefined.
     * @param {Pointer<BOOL>} pbNameLegal If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when 
     *       the current OEM code page is applied to the file name.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-checknamelegaldos8dot3w
     * @since windows6.0.6000
     */
    static CheckNameLegalDOS8Dot3W(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal) {
        lpName := lpName is String ? StrPtr(lpName) : lpName
        lpOemName := lpOemName is String ? StrPtr(lpOemName) : lpOemName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CheckNameLegalDOS8Dot3W", "ptr", lpName, "ptr", lpOemName, "uint", OemNameSize, "ptr", pbNameContainsSpaces, "ptr", pbNameLegal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name as a transacted operation.
     * @param {PSTR} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and 
     *        all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 
     *        32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the 
     *        path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *        receives information about a found file or subdirectory.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
     * 
     * If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended 
     *        error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransacteda
     * @since windows6.0.6000
     */
    static FindFirstFileTransactedA(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags, hTransaction) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileTransactedA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags, "ptr", hTransaction, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name as a transacted operation.
     * @param {PWSTR} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and 
     *        all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 
     *        32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the 
     *        path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *        receives information about a found file or subdirectory.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
     * 
     * If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended 
     *        error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfiletransactedw
     * @since windows6.0.6000
     */
    static FindFirstFileTransactedW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags, hTransaction) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileTransactedW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags, "ptr", hTransaction, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Copies an existing file to a new file.
     * @param {PSTR} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, 
     *       <b>CopyFile</b> fails, and 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {PSTR} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {BOOL} bFailIfExists If this parameter is <b>TRUE</b> and the new file specified by 
     *       <i>lpNewFileName</i> already exists, the function fails. If this parameter is 
     *       <b>FALSE</b> and the new file already exists, the function overwrites the existing file and 
     *       succeeds.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfilea
     * @since windows5.1.2600
     */
    static CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int", bFailIfExists, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file.
     * @param {PWSTR} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, 
     *       <b>CopyFile</b> fails, and 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {PWSTR} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {BOOL} bFailIfExists If this parameter is <b>TRUE</b> and the new file specified by 
     *       <i>lpNewFileName</i> already exists, the function fails. If this parameter is 
     *       <b>FALSE</b> and the new file already exists, the function overwrites the existing file and 
     *       succeeds.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfilew
     * @since windows5.1.2600
     */
    static CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int", bFailIfExists, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file, notifying the application of its progress through a callback function.
     * @param {PSTR} lpExistingFileName The name of an existing file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, the 
     *       <b>CopyFileEx</b> function fails, and the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {PSTR} lpNewFileName The name of the new file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to 
     *        the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<BOOL>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_ALLOW_DECRYPTED_DESTINATION"></a><a id="copy_file_allow_decrypted_destination"></a><dl>
     * <dt><b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_NO_BUFFERING"></a><a id="copy_file_no_buffering"></a><dl>
     * <dt><b>COPY_FILE_NO_BUFFERING</b></dt>
     * <dt>0x00001000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended 
     *         for very large file transfers.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexa
     * @since windows5.1.2600
     */
    static CopyFileExA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileExA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "ptr", pbCancel, "uint", dwCopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file, notifying the application of its progress through a callback function.
     * @param {PWSTR} lpExistingFileName The name of an existing file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, the 
     *       <b>CopyFileEx</b> function fails, and the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {PWSTR} lpNewFileName The name of the new file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to 
     *        the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<BOOL>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_ALLOW_DECRYPTED_DESTINATION"></a><a id="copy_file_allow_decrypted_destination"></a><dl>
     * <dt><b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_NO_BUFFERING"></a><a id="copy_file_no_buffering"></a><dl>
     * <dt><b>COPY_FILE_NO_BUFFERING</b></dt>
     * <dt>0x00001000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended 
     *         for very large file transfers.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfileexw
     * @since windows5.1.2600
     */
    static CopyFileExW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileExW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "ptr", pbCancel, "uint", dwCopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file as a transacted operation, notifying the application of its progress through a callback function.
     * @param {PSTR} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * If <i>lpExistingFileName</i> does not exist, the 
     *        <b>CopyFileTransacted</b> function fails, and the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {PSTR} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<BOOL>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * 
     * If you attempt to call this function with a handle to a transaction that has already been rolled back, 
     *        <b>CopyFileTransacted</b> will return either 
     *        <b>ERROR_TRANSACTION_NOT_ACTIVE</b> or 
     *        <b>ERROR_INVALID_TRANSACTION</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransacteda
     * @since windows6.0.6000
     */
    static CopyFileTransactedA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileTransactedA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "ptr", pbCancel, "uint", dwCopyFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file as a transacted operation, notifying the application of its progress through a callback function.
     * @param {PWSTR} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * If <i>lpExistingFileName</i> does not exist, the 
     *        <b>CopyFileTransacted</b> function fails, and the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {PWSTR} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<BOOL>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * 
     * If you attempt to call this function with a handle to a transaction that has already been rolled back, 
     *        <b>CopyFileTransacted</b> will return either 
     *        <b>ERROR_TRANSACTION_NOT_ACTIVE</b> or 
     *        <b>ERROR_INVALID_TRANSACTION</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfiletransactedw
     * @since windows6.0.6000
     */
    static CopyFileTransactedW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileTransactedW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "ptr", pbCancel, "uint", dwCopyFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file, notifying the application of its progress through a callback function.
     * @param {PWSTR} pwszExistingFileName The name of an existing file.
     * 
     * To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\".  See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, the 
     *        <b>CopyFile2</b> function fails returns 
     *        <c>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</c>.
     * @param {PWSTR} pwszNewFileName The name of the new file.
     * 
     * To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<COPYFILE2_EXTENDED_PARAMETERS>} pExtendedParameters Optional address of a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-copyfile2_extended_parameters">COPYFILE2_EXTENDED_PARAMETERS</a> 
     *       structure.
     * @returns {HRESULT} If the function succeeds, the return value will return <b>TRUE</b> when passed to the 
     *       <a href="/windows/desktop/api/winerror/nf-winerror-succeeded">SUCCEEDED</a> macro.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation completed successfully.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_REQUEST_PAUSED)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation was paused by a <b>COPYFILE2_PROGRESS_PAUSE</b> return from the 
     *         <a href="/windows/desktop/api/winbase/nc-winbase-pcopyfile2_progress_routine">CopyFile2ProgressRoutine</a> callback 
     *         function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation was paused by a <b>COPYFILE2_PROGRESS_CANCEL</b> or 
     *         <b>COPYFILE2_PROGRESS_STOP</b> return from the 
     *         <a href="/windows/desktop/api/winbase/nc-winbase-pcopyfile2_progress_routine">CopyFile2ProgressRoutine</a> callback 
     *         function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>dwCopyFlags</b> member of the 
     *         <a href="/windows/desktop/api/winbase/ns-winbase-copyfile2_extended_parameters">COPYFILE2_EXTENDED_PARAMETERS</a> structure 
     *         passed through the <i>pExtendedParameters</i> parameter contains the 
     *         <b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name existed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>dwCopyFlags</b> member of the 
     *         <a href="/windows/desktop/api/winbase/ns-winbase-copyfile2_extended_parameters">COPYFILE2_EXTENDED_PARAMETERS</a> structure 
     *         passed through the <i>pExtendedParameters</i> parameter contains the 
     *         <b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name existed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-copyfile2
     * @since windows8.0
     */
    static CopyFile2(pwszExistingFileName, pwszNewFileName, pExtendedParameters) {
        pwszExistingFileName := pwszExistingFileName is String ? StrPtr(pwszExistingFileName) : pwszExistingFileName
        pwszNewFileName := pwszNewFileName is String ? StrPtr(pwszNewFileName) : pwszNewFileName

        result := DllCall("KERNEL32.dll\CopyFile2", "ptr", pwszExistingFileName, "ptr", pwszNewFileName, "ptr", pExtendedParameters, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Moves an existing file or a directory, including its children.
     * @param {PSTR} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PSTR} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *        different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilea
     * @since windows5.1.2600
     */
    static MoveFileA(lpExistingFileName, lpNewFileName) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or a directory, including its children.
     * @param {PWSTR} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PWSTR} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *        different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilew
     * @since windows5.1.2600
     */
    static MoveFileW(lpExistingFileName, lpNewFileName) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or directory, including its children, with various move options.
     * @param {PSTR} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share, because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PSTR} lpNewFileName The new name of the file or directory on the local computer.
     * 
     * When moving a file, the destination can be on a different file system or volume. If the destination is on 
     *        another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in 
     *        <i>dwFlags</i>.
     * 
     * When moving a directory, the destination must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is  <b>NULL</b>, 
     *        <b>MoveFileEx</b> registers the 
     *        <i>lpExistingFileName</i> file to be deleted when the system restarts. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefileexa
     * @since windows5.1.2600
     */
    static MoveFileExA(lpExistingFileName, lpNewFileName, dwFlags) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileExA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or directory, including its children, with various move options.
     * @param {PWSTR} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share, because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PWSTR} lpNewFileName The new name of the file or directory on the local computer.
     * 
     * When moving a file, the destination can be on a different file system or volume. If the destination is on 
     *        another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in 
     *        <i>dwFlags</i>.
     * 
     * When moving a directory, the destination must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is  <b>NULL</b>, 
     *        <b>MoveFileEx</b> registers the 
     *        <i>lpExistingFileName</i> file to be deleted when the system restarts. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefileexw
     * @since windows5.1.2600
     */
    static MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileExW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.
     * @param {PSTR} lpExistingFileName The name of the existing file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PSTR} lpNewFileName The new name of the file or directory  on the local computer.
     * 
     * When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If 
     *        <i>lpNewFileName</i> is on another drive, you must set the 
     *        <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.
     * 
     * When moving a directory, <i>lpExistingFileName</i> and 
     *        <i>lpNewFileName</i> must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is <b>NULL</b>, 
     *        <b>MoveFileWithProgress</b> registers 
     *        <i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it 
     *        cannot access the registry to store the information about the delete operation. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilewithprogressa
     * @since windows5.1.2600
     */
    static MoveFileWithProgressA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileWithProgressA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves a file or directory, including its children. You can provide a callback function that receives progress notifications.
     * @param {PWSTR} lpExistingFileName The name of the existing file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PWSTR} lpNewFileName The new name of the file or directory  on the local computer.
     * 
     * When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If 
     *        <i>lpNewFileName</i> is on another drive, you must set the 
     *        <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.
     * 
     * When moving a directory, <i>lpExistingFileName</i> and 
     *        <i>lpNewFileName</i> must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is <b>NULL</b>, 
     *        <b>MoveFileWithProgress</b> registers 
     *        <i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it 
     *        cannot access the registry to store the information about the delete operation. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefilewithprogressw
     * @since windows5.1.2600
     */
    static MoveFileWithProgressW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileWithProgressW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or a directory, including its children, as a transacted operation.
     * @param {PSTR} lpExistingFileName The current name of the existing file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {PSTR} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *       different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransacteda
     * @since windows6.0.6000
     */
    static MoveFileTransactedA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileTransactedA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or a directory, including its children, as a transacted operation.
     * @param {PWSTR} lpExistingFileName The current name of the existing file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {PWSTR} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *       different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-movefiletransactedw
     * @since windows6.0.6000
     */
    static MoveFileTransactedW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String ? StrPtr(lpNewFileName) : lpNewFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileTransactedW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces one file with another file, with the option of creating a backup copy of the original file.
     * @param {PSTR} lpReplacedFileName The name of the file to be replaced.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * This file is opened with the <b>GENERIC_READ</b>, <b>DELETE</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. The sharing mode is 
     *        <b>FILE_SHARE_READ</b> | <b>FILE_SHARE_WRITE</b> | 
     *        <b>FILE_SHARE_DELETE</b>.
     * 
     * The caller must have write access to the file to be replaced. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {PSTR} lpReplacementFileName The name of the file that will replace the <i>lpReplacedFileName</i> file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * The function attempts to open this file with the <b>SYNCHRONIZE</b>, 
     *        <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights so that it can preserve 
     *        all attributes and ACLs. If this fails, the function attempts to open the file with the 
     *        <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights. No sharing mode is 
     *        specified.
     * @param {PSTR} lpBackupFileName The name of the file that will serve as a backup copy of the <i>lpReplacedFileName</i> 
     *        file. If this parameter is <b>NULL</b>, no backup file is created. See the Remarks section for implementation details on the backup file. 
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwReplaceFlags 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following are possible error codes 
     *        for this function.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT</b></dt>
     * <dt>1176 (0x498)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be renamed. If <i>lpBackupFileName</i> was specified, 
     *          the replaced and replacement files retain their original file names. Otherwise, the replaced file no longer 
     *          exists and the replacement file exists under its original name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</b></dt>
     * <dt>1177 (0x499)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be moved.  The replacement file still exists under its original name; 
     *          however, it has inherited the file streams and attributes from the file it is replacing. The file to be 
     *          replaced still exists with a different name. If <i>lpBackupFileName</i> is specified, it 
     *          will be the name of the replaced file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_REMOVE_REPLACED</b></dt>
     * <dt>1175 (0x497)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replaced file could not be deleted. The replaced and replacement files retain their original file 
     *          names.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If any other error is returned, such as <b>ERROR_INVALID_PARAMETER</b>, the replaced and 
     *        replacement files will retain their original file names. In this scenario, a backup file 
     *        does not exist and it is not guaranteed that the 
     *        replacement file will have inherited all of the attributes and streams of the replaced file.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-replacefilea
     * @since windows5.1.2600
     */
    static ReplaceFileA(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags) {
        static lpExclude := 0, lpReserved := 0 ;Reserved parameters must always be NULL

        lpReplacedFileName := lpReplacedFileName is String ? StrPtr(lpReplacedFileName) : lpReplacedFileName
        lpReplacementFileName := lpReplacementFileName is String ? StrPtr(lpReplacementFileName) : lpReplacementFileName
        lpBackupFileName := lpBackupFileName is String ? StrPtr(lpBackupFileName) : lpBackupFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReplaceFileA", "ptr", lpReplacedFileName, "ptr", lpReplacementFileName, "ptr", lpBackupFileName, "uint", dwReplaceFlags, "ptr", lpExclude, "ptr", lpReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces one file with another file, with the option of creating a backup copy of the original file.
     * @param {PWSTR} lpReplacedFileName The name of the file to be replaced.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * This file is opened with the <b>GENERIC_READ</b>, <b>DELETE</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. The sharing mode is 
     *        <b>FILE_SHARE_READ</b> | <b>FILE_SHARE_WRITE</b> | 
     *        <b>FILE_SHARE_DELETE</b>.
     * 
     * The caller must have write access to the file to be replaced. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {PWSTR} lpReplacementFileName The name of the file that will replace the <i>lpReplacedFileName</i> file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * The function attempts to open this file with the <b>SYNCHRONIZE</b>, 
     *        <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights so that it can preserve 
     *        all attributes and ACLs. If this fails, the function attempts to open the file with the 
     *        <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights. No sharing mode is 
     *        specified.
     * @param {PWSTR} lpBackupFileName The name of the file that will serve as a backup copy of the <i>lpReplacedFileName</i> 
     *        file. If this parameter is <b>NULL</b>, no backup file is created. See the Remarks section for implementation details on the backup file. 
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwReplaceFlags 
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following are possible error codes 
     *        for this function.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT</b></dt>
     * <dt>1176 (0x498)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be renamed. If <i>lpBackupFileName</i> was specified, 
     *          the replaced and replacement files retain their original file names. Otherwise, the replaced file no longer 
     *          exists and the replacement file exists under its original name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</b></dt>
     * <dt>1177 (0x499)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be moved.  The replacement file still exists under its original name; 
     *          however, it has inherited the file streams and attributes from the file it is replacing. The file to be 
     *          replaced still exists with a different name. If <i>lpBackupFileName</i> is specified, it 
     *          will be the name of the replaced file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_REMOVE_REPLACED</b></dt>
     * <dt>1175 (0x497)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replaced file could not be deleted. The replaced and replacement files retain their original file 
     *          names.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If any other error is returned, such as <b>ERROR_INVALID_PARAMETER</b>, the replaced and 
     *        replacement files will retain their original file names. In this scenario, a backup file 
     *        does not exist and it is not guaranteed that the 
     *        replacement file will have inherited all of the attributes and streams of the replaced file.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-replacefilew
     * @since windows5.1.2600
     */
    static ReplaceFileW(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags) {
        static lpExclude := 0, lpReserved := 0 ;Reserved parameters must always be NULL

        lpReplacedFileName := lpReplacedFileName is String ? StrPtr(lpReplacedFileName) : lpReplacedFileName
        lpReplacementFileName := lpReplacementFileName is String ? StrPtr(lpReplacementFileName) : lpReplacementFileName
        lpBackupFileName := lpBackupFileName is String ? StrPtr(lpBackupFileName) : lpBackupFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReplaceFileW", "ptr", lpReplacedFileName, "ptr", lpReplacementFileName, "ptr", lpBackupFileName, "uint", dwReplaceFlags, "ptr", lpExclude, "ptr", lpReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file.
     * @param {PSTR} lpFileName The name of the new file.
     *       
     * 
     * This parameter may include the path but cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PSTR} lpExistingFileName The name of the existing file.
     *       
     * 
     * This parameter may include the path cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.
     * 
     * If you pass a name longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinka
     * @since windows5.1.2600
     */
    static CreateHardLinkA(lpFileName, lpExistingFileName) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkA", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file.
     * @param {PWSTR} lpFileName The name of the new file.
     *       
     * 
     * This parameter may include the path but cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PWSTR} lpExistingFileName The name of the existing file.
     *       
     * 
     * This parameter may include the path cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.
     * 
     * If you pass a name longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinkw
     * @since windows5.1.2600
     */
    static CreateHardLinkW(lpFileName, lpExistingFileName) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkW", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file as a transacted operation.
     * @param {PSTR} lpFileName The name of the new file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {PSTR} lpExistingFileName The name of the existing file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 
     *        links are created for a file, an error results.
     * 
     * The files must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinktransacteda
     * @since windows6.0.6000
     */
    static CreateHardLinkTransactedA(lpFileName, lpExistingFileName, hTransaction) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkTransactedA", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file as a transacted operation.
     * @param {PWSTR} lpFileName The name of the new file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {PWSTR} lpExistingFileName The name of the existing file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 
     *        links are created for a file, an error results.
     * 
     * The files must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createhardlinktransactedw
     * @since windows6.0.6000
     */
    static CreateHardLinkTransactedW(lpFileName, lpExistingFileName, hTransaction) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String ? StrPtr(lpExistingFileName) : lpExistingFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkTransactedW", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the first stream in the specified file or directory as a transacted operation.
     * @param {PWSTR} lpFileName The fully qualified file name.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).
     * @param {Integer} InfoLevel The information level of the returned data. This parameter is one of the values in the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ne-fileapi-stream_info_levels">STREAM_INFO_LEVELS</a> enumeration type.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FindStreamInfoStandard"></a><a id="findstreaminfostandard"></a><a id="FINDSTREAMINFOSTANDARD"></a><dl>
     * <dt><b>FindStreamInfoStandard</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data is returned in a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_find_stream_data">WIN32_FIND_STREAM_DATA</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFindStreamData A pointer to a buffer that receives the file data. The format of this data depends on the value of 
     *        the <i>InfoLevel</i> parameter.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle that can be used in subsequent calls to the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a>function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirststreamtransactedw
     * @since windows6.0.6000
     */
    static FindFirstStreamTransactedW(lpFileName, InfoLevel, lpFindStreamData, hTransaction) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstStreamTransactedW", "ptr", lpFileName, "int", InfoLevel, "ptr", lpFindStreamData, "uint", dwFlags, "ptr", hTransaction, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Creates an enumeration of all the hard links to the specified file as a transacted operation. The function returns a handle to the enumeration that can be used on subsequent calls to the FindNextFileNameW function.
     * @param {PWSTR} lpFileName The name of the file.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).
     * @param {Integer} dwFlags Reserved; specify zero (0).
     * @param {Pointer<UInt32>} StringLength The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If this 
     *        call fails and the error is <b>ERROR_MORE_DATA</b> (234), the value that is returned by this 
     *        parameter is the size that the buffer pointed to by <i>LinkName</i> must be to contain all 
     *        the data.
     * @param {PWSTR} LinkName A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle that can be used with the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextfilenamew">FindNextFileNameW</a> function or closed with the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To  
     *       get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *       function.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstfilenametransactedw
     * @since windows6.0.6000
     */
    static FindFirstFileNameTransactedW(lpFileName, dwFlags, StringLength, LinkName, hTransaction) {
        lpFileName := lpFileName is String ? StrPtr(lpFileName) : lpFileName
        LinkName := LinkName is String ? StrPtr(LinkName) : LinkName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileNameTransactedW", "ptr", lpFileName, "uint", dwFlags, "uint*", StringLength, "ptr", LinkName, "ptr", hTransaction, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Sets the label of a file system volume.
     * @param {PSTR} lpRootPathName A pointer to a string that contains the volume's drive letter (for example, X:\) or the path 
     *       of a mounted folder that is associated with the volume (for example, Y:\MountX\). The string must 
     *       end with a trailing backslash ('\'). If this parameter is <b>NULL</b>, the root of the 
     *       current directory is used.
     * @param {PSTR} lpVolumeName A pointer to a string that contains the new label for the volume. If this parameter is 
     *       <b>NULL</b>, the function deletes any existing label from the specified volume and does not 
     *       assign a new label.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumelabela
     * @since windows5.1.2600
     */
    static SetVolumeLabelA(lpRootPathName, lpVolumeName) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeName := lpVolumeName is String ? StrPtr(lpVolumeName) : lpVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeLabelA", "ptr", lpRootPathName, "ptr", lpVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the label of a file system volume.
     * @param {PWSTR} lpRootPathName A pointer to a string that contains the volume's drive letter (for example, X:\) or the path 
     *       of a mounted folder that is associated with the volume (for example, Y:\MountX\). The string must 
     *       end with a trailing backslash ('\'). If this parameter is <b>NULL</b>, the root of the 
     *       current directory is used.
     * @param {PWSTR} lpVolumeName A pointer to a string that contains the new label for the volume. If this parameter is 
     *       <b>NULL</b>, the function deletes any existing label from the specified volume and does not 
     *       assign a new label.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumelabelw
     * @since windows5.1.2600
     */
    static SetVolumeLabelW(lpRootPathName, lpVolumeName) {
        lpRootPathName := lpRootPathName is String ? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeName := lpVolumeName is String ? StrPtr(lpVolumeName) : lpVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeLabelW", "ptr", lpRootPathName, "ptr", lpVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that bandwidth for the specified file stream be reserved. The reservation is specified as a number of bytes in a period of milliseconds for I/O requests on the specified file handle.
     * @param {HANDLE} hFile A handle to the file.
     * @param {Integer} nPeriodMilliseconds The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the 
     *       kernel until the time the I/O should be completed. The minimum supported value for the file 
     *       stream can be determined by looking at the value returned through the 
     *       <i>lpPeriodMilliseconds</i> parameter to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function, 
     *       on a handle that has not had a bandwidth reservation set.
     * @param {Integer} nBytesPerPeriod The bandwidth to reserve, in bytes per period. The maximum supported value for the file 
     *       stream can be determined by looking at the value returned through the 
     *       <i>lpBytesPerPeriod</i> parameter to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function, 
     *       on a handle that has not had a bandwidth reservation set.
     * @param {BOOL} bDiscardable Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation 
     *       before the period expires. If one of the drivers for the specified file stream does not support this 
     *       functionality, this function may return success and ignore the flag. To verify whether the setting will be 
     *       honored, call the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function 
     *       using the same <i>hFile</i> handle and examine the <i>*pDiscardable</i> 
     *       return value.
     * @param {Pointer<UInt32>} lpTransferSize A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by 
     *       the application. All I/O requests should be multiples of <i>TransferSize</i>.
     * @param {Pointer<UInt32>} lpNumOutstandingRequests A pointer to a variable that receives the number of <i>TransferSize</i> chunks the 
     *       application should allow to be outstanding with the operating system. This allows the storage stack to keep the 
     *       device busy and allows maximum throughput.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * A reservation can fail if there is not enough bandwidth available on the volume because of existing 
     *        reservations; in this case <b>ERROR_NO_SYSTEM_RESOURCES</b> is returned.
     * 
     * To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setfilebandwidthreservation
     * @since windows6.0.6000
     */
    static SetFileBandwidthReservation(hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileBandwidthReservation", "ptr", hFile, "uint", nPeriodMilliseconds, "uint", nBytesPerPeriod, "int", bDiscardable, "uint*", lpTransferSize, "uint*", lpNumOutstandingRequests, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the bandwidth reservation properties of the volume on which the specified file resides.
     * @param {HANDLE} hFile A handle to the file.
     * @param {Pointer<UInt32>} lpPeriodMilliseconds A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the 
     *       time from which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has 
     *       been reserved for this handle, then the value returned is the minimum reservation period supported for this 
     *       volume.
     * @param {Pointer<UInt32>} lpBytesPerPeriod A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the 
     *       volume. If no bandwidth has been reserved for this handle, then the value returned is the maximum number of 
     *       bytes per period supported for the volume.
     * @param {Pointer<BOOL>} pDiscardable <b>TRUE</b> if I/O should be completed with an error if a driver is unable to satisfy an 
     *       I/O operation before the period expires. <b>FALSE</b> if the underlying subsystem does not 
     *       support failing in this manner.
     * @param {Pointer<UInt32>} lpTransferSize The minimum size of any individual I/O request that may be issued by the application. All I/O requests 
     *       should be multiples of <i>TransferSize</i>. If no bandwidth has been reserved for this 
     *       handle, then the value returned is the minimum transfer size supported for this volume.
     * @param {Pointer<UInt32>} lpNumOutstandingRequests The number of <i>TransferSize</i> chunks  allowed to be outstanding with the operating 
     *       system.
     * @returns {BOOL} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfilebandwidthreservation
     * @since windows6.0.6000
     */
    static GetFileBandwidthReservation(hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileBandwidthReservation", "ptr", hFile, "uint*", lpPeriodMilliseconds, "uint*", lpBytesPerPeriod, "ptr", pDiscardable, "uint*", lpTransferSize, "uint*", lpNumOutstandingRequests, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information that describes the changes within the specified directory.
     * @param {HANDLE} hDirectory A handle to the directory to be monitored. This directory must be opened with the 
     *       <b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.
     * @param {Pointer} lpBuffer A pointer to the <b>DWORD</b>-aligned formatted buffer in which the read results are 
     *       to be returned. The structure of this buffer is defined by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structure. This 
     *       buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value 
     *       is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks 
     *       section.
     * @param {Integer} nBufferLength The size of the buffer that is pointed to by the <i>lpBuffer</i> parameter, in 
     *       bytes.
     * @param {BOOL} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the 
     *       specified directory. If this parameter is <b>FALSE</b>, the function monitors only the 
     *       directory specified by the <i>hDirectory</i> parameter.
     * @param {Integer} dwNotifyFilter The filter criteria that the function checks to determine if the wait operation has completed. This
     * @param {Pointer<UInt32>} lpBytesReturned For synchronous calls, this parameter receives the number of bytes transferred into the 
     *       <i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use 
     *       an asynchronous notification technique to retrieve the number of bytes transferred.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that supplies 
     *       data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The 
     *       <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not 
     *       used.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to a completion routine to be called when the operation has been completed or canceled and the 
     *       calling thread is in an alertable wait state. For more information about this completion routine, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation 
     *        succeeded. For asynchronous calls, this indicates that the operation was successfully queued.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the network redirector or the target file system does not support this operation, the function fails with 
     *        <b>ERROR_INVALID_FUNCTION</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesw
     * @since windows5.1.2600
     */
    static ReadDirectoryChangesW(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine) {
        hDirectory := hDirectory is Win32Handle ? NumGet(hDirectory, "ptr") : hDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadDirectoryChangesW", "ptr", hDirectory, "ptr", lpBuffer, "uint", nBufferLength, "int", bWatchSubtree, "uint", dwNotifyFilter, "uint*", lpBytesReturned, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information that describes the changes within the specified directory, which can include extended information if that information type is specified.
     * @param {HANDLE} hDirectory A handle to the directory to be monitored. This directory must be opened with the 
     *       <b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.
     * @param {Pointer} lpBuffer A pointer to the <b>DWORD</b>-aligned formatted buffer in which <b>ReadDirectoryChangesExW</b> should return the read results. The structure of this buffer is defined by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> structure if the value of the <i>ReadDirectoryNotifyInformationClass</i> parameter is <b>ReadDirectoryNotifyExtendedInformation</b>, or by the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structure if <i>ReadDirectoryNotifyInformationClass</i> is <b>ReadDirectoryNotifyInformation</b>.
     * 
     * This 
     *       buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value 
     *       is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks 
     *       section.
     * @param {Integer} nBufferLength The size of the buffer to which the <i>lpBuffer</i> parameter points, in 
     *       bytes.
     * @param {BOOL} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the 
     *       specified directory. If this parameter is <b>FALSE</b>, the function monitors only the 
     *       directory specified by the <i>hDirectory</i> parameter.
     * @param {Integer} dwNotifyFilter The filter criteria that the function checks to determine if the wait operation has completed. This
     * @param {Pointer<UInt32>} lpBytesReturned For synchronous calls, this parameter receives the number of bytes transferred into the 
     *       <i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use 
     *       an asynchronous notification technique to retrieve the number of bytes transferred.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that supplies 
     *       data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The 
     *       <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not 
     *       used.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to a completion routine to be called when the operation has been completed or canceled and the 
     *       calling thread is in an alertable wait state. For more information about this completion routine, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.
     * @param {Integer} ReadDirectoryNotifyInformationClass The type of   information that
     *         <b>ReadDirectoryChangesExW</b> should write to the buffer to which the <i>lpBuffer</i> parameter points. Specify <b>ReadDirectoryNotifyInformation</b> to indicate 
     *         that the information should consist of <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structures, or <b>ReadDirectoryNotifyExtendedInformation</b>to indicate 
     *         that the information should consist of <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> structures.
     * @returns {BOOL} If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation 
     *        succeeded. For asynchronous calls, this indicates that the operation was successfully queued.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the network redirector or the target file system does not support this operation, the function fails with 
     *        <b>ERROR_INVALID_FUNCTION</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-readdirectorychangesexw
     * @since windows10.0.16299
     */
    static ReadDirectoryChangesExW(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass) {
        hDirectory := hDirectory is Win32Handle ? NumGet(hDirectory, "ptr") : hDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadDirectoryChangesExW", "ptr", hDirectory, "ptr", lpBuffer, "uint", nBufferLength, "int", bWatchSubtree, "uint", dwNotifyFilter, "uint*", lpBytesReturned, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int", ReadDirectoryNotifyInformationClass, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the name of a volume on a computer.
     * @param {PSTR} lpszVolumeName A pointer to a buffer that receives a null-terminated string that specifies a volume 
     *       <b>GUID</b> path for the first volume that is found.
     * @param {Integer} cchBufferLength The length of the buffer to receive the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> and 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> functions.
     * 
     * If the function fails to find any volumes, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstvolumea
     * @since windows5.1.2600
     */
    static FindFirstVolumeA(lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeA", "ptr", lpszVolumeName, "uint", cchBufferLength, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Continues a volume search started by a call to the FindFirstVolume function.
     * @param {HANDLE} hFindVolume The volume search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.
     * @param {PSTR} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no matching files can be found, the 
     *        <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findnextvolumea
     * @since windows5.1.2600
     */
    static FindNextVolumeA(hFindVolume, lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName
        hFindVolume := hFindVolume is Win32Handle ? NumGet(hFindVolume, "ptr") : hFindVolume

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeA", "ptr", hFindVolume, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the name of a mounted folder on the specified volume.
     * @param {PSTR} lpszRootPathName A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.
     * @param {PSTR} lpszVolumeMountPoint A pointer to a buffer that receives the name of the first mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the path to the mounted folder, in 
     *       <b>TCHAR</b>s.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> and 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions.
     * 
     * If the function fails to find a mounted folder on the volume, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstvolumemountpointa
     * @since windows5.1.2600
     */
    static FindFirstVolumeMountPointA(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength) {
        lpszRootPathName := lpszRootPathName is String ? StrPtr(lpszRootPathName) : lpszRootPathName
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeMountPointA", "ptr", lpszRootPathName, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Retrieves the name of a mounted folder on the specified volume.
     * @param {PWSTR} lpszRootPathName A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.
     * @param {PWSTR} lpszVolumeMountPoint A pointer to a buffer that receives the name of the first mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the path to the mounted folder, in 
     *       <b>TCHAR</b>s.
     * @returns {HANDLE} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> and 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions.
     * 
     * If the function fails to find a mounted folder on the volume, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findfirstvolumemountpointw
     * @since windows5.1.2600
     */
    static FindFirstVolumeMountPointW(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength) {
        lpszRootPathName := lpszRootPathName is String ? StrPtr(lpszRootPathName) : lpszRootPathName
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeMountPointW", "ptr", lpszRootPathName, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Continues a mounted folder search started by a call to the FindFirstVolumeMountPoint function.
     * @param {HANDLE} hFindVolumeMountPoint A mounted folder search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.
     * @param {PSTR} lpszVolumeMountPoint A pointer to a buffer that receives the name of the mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the mounted folder name, in 
     *       <b>TCHARs</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no more mounted folders can be found, 
     *        the <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findnextvolumemountpointa
     * @since windows5.1.2600
     */
    static FindNextVolumeMountPointA(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        hFindVolumeMountPoint := hFindVolumeMountPoint is Win32Handle ? NumGet(hFindVolumeMountPoint, "ptr") : hFindVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeMountPointA", "ptr", hFindVolumeMountPoint, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a mounted folder search started by a call to the FindFirstVolumeMountPoint function.
     * @param {HANDLE} hFindVolumeMountPoint A mounted folder search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.
     * @param {PWSTR} lpszVolumeMountPoint A pointer to a buffer that receives the name of the mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the mounted folder name, in 
     *       <b>TCHARs</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no more mounted folders can be found, 
     *        the <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> function.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findnextvolumemountpointw
     * @since windows5.1.2600
     */
    static FindNextVolumeMountPointW(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        hFindVolumeMountPoint := hFindVolumeMountPoint is Win32Handle ? NumGet(hFindVolumeMountPoint, "ptr") : hFindVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeMountPointW", "ptr", hFindVolumeMountPoint, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes the specified mounted folder search handle.
     * @param {HANDLE} hFindVolumeMountPoint The mounted folder search handle to be closed. This handle must have been previously opened by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-findvolumemountpointclose
     * @since windows5.1.2600
     */
    static FindVolumeMountPointClose(hFindVolumeMountPoint) {
        hFindVolumeMountPoint := hFindVolumeMountPoint is Win32Handle ? NumGet(hFindVolumeMountPoint, "ptr") : hFindVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindVolumeMountPointClose", "ptr", hFindVolumeMountPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates a volume with a drive letter or a directory on another volume.
     * @param {PSTR} lpszVolumeMountPoint The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory 
     *       on another volume (for example, "Y:\MountX\"). The string must end with a trailing backslash ('\').
     * @param {PSTR} lpszVolumeName A volume <b>GUID</b> path for the volume. This string must be of the form 
     *       "\\\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies 
     *       the volume. The "\\\\?\" turns off path parsing and is ignored as part of the path, as discussed in 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumemountpointa
     * @since windows5.1.2600
     */
    static SetVolumeMountPointA(lpszVolumeMountPoint, lpszVolumeName) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeMountPointA", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates a volume with a drive letter or a directory on another volume.
     * @param {PWSTR} lpszVolumeMountPoint The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\") or a directory 
     *       on another volume (for example, "Y:\MountX\"). The string must end with a trailing backslash ('\').
     * @param {PWSTR} lpszVolumeName A volume <b>GUID</b> path for the volume. This string must be of the form 
     *       "\\\\?\\Volume{<i>GUID</i>}\\" where <i>GUID</i> is a <b>GUID</b> that identifies 
     *       the volume. The "\\\\?\\" turns off path parsing and is ignored as part of the path, as discussed in 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-setvolumemountpointw
     * @since windows5.1.2600
     */
    static SetVolumeMountPointW(lpszVolumeMountPoint, lpszVolumeName) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeMountPointW", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes a drive letter or mounted folder.
     * @param {PSTR} lpszVolumeMountPoint The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, 
     *       "X:\" or "Y:\MountX\".
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-deletevolumemountpointa
     * @since windows5.1.2600
     */
    static DeleteVolumeMountPointA(lpszVolumeMountPoint) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteVolumeMountPointA", "ptr", lpszVolumeMountPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a volume GUID path for the volume that is associated with the specified volume mount point ( drive letter, volume GUID path, or mounted folder).
     * @param {PSTR} lpszVolumeMountPoint A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\"). The string must end with a trailing backslash ('\').
     * @param {PSTR} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.
     * @param {Integer} cchBufferLength The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getvolumenameforvolumemountpointa
     * @since windows5.1.2600
     */
    static GetVolumeNameForVolumeMountPointA(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String ? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeNameForVolumeMountPointA", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the volume mount point where the specified path is mounted.
     * @param {PSTR} lpszFileName A pointer to the input path string. Both absolute and relative file and directory names, for example 
     *        "..", are acceptable in this path.
     * 
     * If you specify a relative directory or file name without a volume qualifier, 
     *        <b>GetVolumePathName</b> returns the drive letter of the 
     *        boot volume.
     * 
     * If this parameter is an empty string, "", the function fails but the last error is set to 
     *        <b>ERROR_SUCCESS</b>.
     * @param {PSTR} lpszVolumePathName A pointer to a string that receives the volume mount point for the input path.
     * @param {Integer} cchBufferLength The length of the output buffer, in <b>TCHARs</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *       <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getvolumepathnamea
     * @since windows5.1.2600
     */
    static GetVolumePathNameA(lpszFileName, lpszVolumePathName, cchBufferLength) {
        lpszFileName := lpszFileName is String ? StrPtr(lpszFileName) : lpszFileName
        lpszVolumePathName := lpszVolumePathName is String ? StrPtr(lpszVolumePathName) : lpszVolumePathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNameA", "ptr", lpszFileName, "ptr", lpszVolumePathName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a list of drive letters and mounted folder paths for the specified volume.
     * @param {PSTR} lpszVolumeName A volume <b>GUID</b> path for the volume. A volume <b>GUID</b> 
     *       path is of the form 
     *       "\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".
     * @param {PSTR} lpszVolumePathNames A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an 
     *       array of null-terminated strings terminated by an additional <b>NULL</b> character. If the 
     *       buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.
     * @param {Integer} cchBufferLength The length of the <i>lpszVolumePathNames</i> buffer, in 
     *       <b>TCHARs</b>, including all <b>NULL</b> characters.
     * @param {Pointer<UInt32>} lpcchReturnLength If the call is successful, this parameter is the number of <b>TCHARs</b> copied to 
     *       the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer 
     *       required to hold the complete list, in <b>TCHARs</b>.
     * @returns {BOOL} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the buffer is not large enough to 
     *        hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the 
     *        <i>lpcchReturnLength</i> parameter receives the required buffer size.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getvolumepathnamesforvolumenamea
     * @since windows5.1.2600
     */
    static GetVolumePathNamesForVolumeNameA(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength) {
        lpszVolumeName := lpszVolumeName is String ? StrPtr(lpszVolumeName) : lpszVolumeName
        lpszVolumePathNames := lpszVolumePathNames is String ? StrPtr(lpszVolumePathNames) : lpszVolumePathNames

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNamesForVolumeNameA", "ptr", lpszVolumeName, "ptr", lpszVolumePathNames, "uint", cchBufferLength, "uint*", lpcchReturnLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file information for the specified file.
     * @param {HANDLE} hFile A handle to the file that contains the information to be retrieved.
     * 
     * This handle should not be a pipe handle.
     * @param {Integer} FileInformationClass A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-file_info_by_handle_class">FILE_INFO_BY_HANDLE_CLASS</a> enumeration 
     *        value that specifies the type of information to be retrieved.
     * 
     * For a table of valid values, see the Remarks section.
     * @param {Pointer} lpFileInformation A pointer to the buffer that receives the requested file information. The structure that is returned 
     *       corresponds to the class that is specified by <i>FileInformationClass</i>. For a table of 
     *       valid structure types, see the Remarks section.
     * @param {Integer} dwBufferSize The size of the <i>lpFileInformation</i> buffer, in bytes.
     * @returns {BOOL} If the function succeeds, the return value is nonzero and file information data is contained in the buffer 
     *        pointed to by the <i>lpFileInformation</i> parameter.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-getfileinformationbyhandleex
     * @since windows6.0.6000
     */
    static GetFileInformationByHandleEx(hFile, FileInformationClass, lpFileInformation, dwBufferSize) {
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileInformationByHandleEx", "ptr", hFile, "int", FileInformationClass, "ptr", lpFileInformation, "uint", dwBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {PWSTR} FileName 
     * @param {Integer} FileInformationClass 
     * @param {Pointer} FileInfoBuffer 
     * @param {Integer} FileInfoBufferSize 
     * @returns {BOOL} 
     */
    static GetFileInformationByName(FileName, FileInformationClass, FileInfoBuffer, FileInfoBufferSize) {
        FileName := FileName is String ? StrPtr(FileName) : FileName

        result := DllCall("KERNEL32.dll\GetFileInformationByName", "ptr", FileName, "int", FileInformationClass, "ptr", FileInfoBuffer, "uint", FileInfoBufferSize, "int")
        return result
    }

    /**
     * Opens the file that matches the specified identifier.
     * @param {HANDLE} hVolumeHint A handle to any file on a volume or share on which the file to be opened is stored.
     * @param {Pointer<FILE_ID_DESCRIPTOR>} lpFileId A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_descriptor">FILE_ID_DESCRIPTOR</a> that identifies 
     *        the file to open.
     * @param {Integer} dwDesiredAccess The access to the object. Access can be read, write, or both.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access
     *       Rights</a>. You cannot request an access mode that conflicts with the sharing mode that is specified in an
     *       open request that has an open handle.
     * 
     * If this parameter is zero (0), the application can query file and device attributes without accessing a
     *       device. This is useful for an application to determine the size of a floppy disk drive and the formats it
     *       supports without requiring a floppy in a drive. It can also be used to test for the existence of a file or
     *       directory without opening them for read or write access.
     * @param {Integer} dwShareMode The sharing mode of an object, which can be read, write, both, or none.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an open request 
     *        that has an open handle, because that would result in the following sharing violation: 
     *        (<b>ERROR_SHARING_VIOLATION</b>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * If this parameter is zero (0) and <b>OpenFileById</b> 
     *        succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more 
     *        information, see the Remarks section of this topic.
     * 
     * The sharing options remain in effect until you close the handle to an object.
     * 
     * To enable a processes to share an object while another process has the object open, use a combination of one
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes Reserved.
     * @param {Integer} dwFlagsAndAttributes The file flags.
     * 
     * When <b>OpenFileById</b> opens a file, it combines the file 
     *        flags with existing file attributes, and ignores any supplied file attributes. This parameter can include any 
     *        combination of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file is being opened for a backup or restore operation. The system ensures that the calling process 
     *          overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and 
     *          <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions  instead of a file handle. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system opens a file with no system caching. This flag does not affect hard disk caching. When combined 
     *          with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous performance, because 
     *          the I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take 
     *          more time, because data is not being held in the cache. Also, the file metadata may still be cached. To flush 
     *          the metadata to disk, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 
     *          function.
     * 
     * An application must meet certain requirements when working with files that are opened with 
     *          <b>FILE_FLAG_NO_BUFFERING</b>:
     * 
     * <ul>
     * <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector 
     *           size.</li>
     * <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For 
     *           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or 
     *           2048 bytes, but not of 335, 981, or 7171 bytes.</li>
     * <li>Buffer addresses for read and write operations should be sector aligned, which means aligned on 
     *           addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this 
     *           requirement may not be enforced.</li>
     * </ul>
     * One way to align buffers on integer multiples of the volume sector size is to use 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> to allocate the buffers. It allocates 
     *          memory that is aligned on addresses that are integer multiples of the operating system's memory page size. 
     *          Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses 
     *          that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes 
     *          (hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages.
     * 
     * An application can determine a volume sector size by calling the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is used, normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> 
     *          processing does not occur, and <b>OpenFileById</b> attempts 
     *          to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that 
     *          controls the reparse point is operational. This flag cannot be used with the 
     *          <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is 
     *          ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for asynchronous I/O. When the operation is complete, the event 
     *          specified to the call in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is 
     *          set to the signaled state. Operations that take a significant amount of time to process return 
     *          <b>ERROR_IO_PENDING</b>.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations. The system does 
     *          not maintain the file pointer, therefore you must pass the file position to the read and write functions in 
     *          the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a>  structure or update the file 
     *          pointer.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file is accessed randomly. The system can use this as a hint to optimize file caching.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file is accessed sequentially from beginning to end. The system can use this as a hint to optimize file 
     *          caching. If an application moves the file pointer for random access, optimum caching may not occur. However, 
     *          correct operation is still guaranteed.
     * 
     * Specifying this flag can increase performance for applications that read large files using sequential 
     *          access. Performance gains can be even more noticeable for applications that read large files mostly 
     *          sequentially, but occasionally skip over small ranges of bytes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system writes through any intermediate cache and goes directly to disk.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in 
     *          effect, then the data is written to the system cache, but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in 
     *          effect, then the data is immediately flushed to disk without going through the system cache. The operating 
     *          system also requests a write-through the hard disk cache to persistent media. However, not all hardware 
     *          supports this write-through capability.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {HANDLE} If the function succeeds, the return value is an open handle to a specified file.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-openfilebyid
     * @since windows6.0.6000
     */
    static OpenFileById(hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes) {
        hVolumeHint := hVolumeHint is Win32Handle ? NumGet(hVolumeHint, "ptr") : hVolumeHint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\OpenFileById", "ptr", hVolumeHint, "ptr", lpFileId, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwFlagsAndAttributes, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * Creates a symbolic link.
     * @param {PSTR} lpSymlinkFileName The symbolic link to be created.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PSTR} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     *  If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as 
     *       an absolute link; otherwise, the link is treated as a relative link.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE"></a><a id="symbolic_link_flag_allow_unprivileged_create"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com/windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOLEAN} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinka
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkA(lpSymlinkFileName, lpTargetFileName, dwFlags) {
        lpSymlinkFileName := lpSymlinkFileName is String ? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String ? StrPtr(lpTargetFileName) : lpTargetFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkA", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a symbolic link.
     * @param {PWSTR} lpSymlinkFileName The symbolic link to be created.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {PWSTR} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     *  If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as 
     *       an absolute link; otherwise, the link is treated as a relative link.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE"></a><a id="symbolic_link_flag_allow_unprivileged_create"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com/windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {BOOLEAN} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinkw
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkW(lpSymlinkFileName, lpTargetFileName, dwFlags) {
        lpSymlinkFileName := lpSymlinkFileName is String ? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String ? StrPtr(lpTargetFileName) : lpTargetFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkW", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a symbolic link as a transacted operation.
     * @param {PSTR} lpSymlinkFileName The symbolic link to be created.
     * @param {PSTR} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     * If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an 
     *        absolute link; otherwise, the link is treated as a relative link.
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOLEAN} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinktransacteda
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkTransactedA(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction) {
        lpSymlinkFileName := lpSymlinkFileName is String ? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String ? StrPtr(lpTargetFileName) : lpTargetFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkTransactedA", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "ptr", hTransaction, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a symbolic link as a transacted operation.
     * @param {PWSTR} lpSymlinkFileName The symbolic link to be created.
     * @param {PWSTR} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     * If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an 
     *        absolute link; otherwise, the link is treated as a relative link.
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {HANDLE} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {BOOLEAN} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//winbase/nf-winbase-createsymboliclinktransactedw
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkTransactedW(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction) {
        lpSymlinkFileName := lpSymlinkFileName is String ? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String ? StrPtr(lpTargetFileName) : lpTargetFileName
        hTransaction := hTransaction is Win32Handle ? NumGet(hTransaction, "ptr") : hTransaction

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkTransactedW", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "ptr", hTransaction, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

;@endregion Methods
}
