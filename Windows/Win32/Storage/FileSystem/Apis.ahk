#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.Storage.FileSystem
 * @version v4.0.30319
 */
class FileSystem {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static MAXIMUM_REPARSE_DATA_BUFFER_SIZE => 16384

    /**
     * @type {String}
     */
    static EA_CONTAINER_NAME => "ContainerName"

    /**
     * @type {String}
     */
    static EA_CONTAINER_SIZE => "ContainerSize"

    /**
     * @type {String}
     */
    static CLFS_BASELOG_EXTENSION => ".blf"

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_REENTRANT_FILE_SYSTEM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_NON_REENTRANT_FILTER => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_REENTRANT_FILTER => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_IGNORE_SHARE_ACCESS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_READ_IN_PROGRESS => 128

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_MINIFILTER_LEVEL => 256

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_HIDDEN_SYSTEM_LOG => 512

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MARSHALLING_FLAG_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MARSHALLING_FLAG_DISABLE_BUFF_INIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_FILTER_INTERMEDIATE_LEVEL => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_FLAG_FILTER_TOP_LEVEL => 32

    /**
     * @type {String}
     */
    static CLFS_CONTAINER_STREAM_PREFIX => "%BLF%:"

    /**
     * @type {String}
     */
    static CLFS_CONTAINER_RELATIVE_PREFIX => "%BLF%\"

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_VOLATILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_COMMIT_LOWEST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MANAGER_MAXIMUM_OPTION => 63

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_DO_NOT_PROMOTE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_MAXIMUM_OPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RESOURCE_MANAGER_VOLATILE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RESOURCE_MANAGER_COMMUNICATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RESOURCE_MANAGER_MAXIMUM_OPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CRM_PROTOCOL_MAXIMUM_OPTION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ENLISTMENT_SUPERIOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ENLISTMENT_MAXIMUM_OPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_MASK => 1073741823

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPREPARE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPARE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ROLLBACK => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPREPARE_COMPLETE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PREPARE_COMPLETE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT_COMPLETE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ROLLBACK_COMPLETE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_RECOVER => 256

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT => 512

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_DELEGATE_COMMIT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_RECOVER_QUERY => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ENLIST_PREPREPARE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_LAST_RECOVER => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_INDOUBT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROPAGATE_PULL => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROPAGATE_PUSH => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_MARSHAL => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_ENLIST_MASK => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_RM_DISCONNECTED => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_TM_ONLINE => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT_REQUEST => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROMOTE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_PROMOTE_NEW => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_REQUEST_OUTCOME => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFY_COMMIT_FINALIZE => 1073741824

    /**
     * @type {String}
     */
    static TRANSACTIONMANAGER_OBJECT_PATH => "\TransactionManager\"

    /**
     * @type {String}
     */
    static TRANSACTION_OBJECT_PATH => "\Transaction\"

    /**
     * @type {String}
     */
    static ENLISTMENT_OBJECT_PATH => "\Enlistment\"

    /**
     * @type {String}
     */
    static RESOURCE_MANAGER_OBJECT_PATH => "\ResourceManager\"

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KTM_MARSHAL_BLOB_VERSION_MAJOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static KTM_MARSHAL_BLOB_VERSION_MINOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_TRANSACTION_DESCRIPTION_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_BASE => 86

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS => 5636096

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_ONLINE => 5685256

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_OFFLINE => 5685260

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_CLUSTERED => 5636144

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_GPT_ATTRIBUTES => 5636152

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE => 5636100

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_OFFLINE => 5636112

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_IO_CAPABLE => 5636116

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_FAILOVER_SET => 5636120

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_VOLUME_NUMBER => 5636124

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_LOGICAL_TO_PHYSICAL => 5636128

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_PHYSICAL_TO_LOGICAL => 5636132

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_PARTITION => 5636136

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_READ_PLEX => 5652526

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_SET_GPT_ATTRIBUTES => 5636148

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_BC_PROPERTIES => 5652540

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_ALLOCATE_BC_STREAM => 5685312

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_FREE_BC_STREAM => 5685316

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_BC_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_DYNAMIC => 5636168

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_PREPARE_FOR_CRITICAL_IO => 5685324

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_ALLOCATION_HINT => 5652562

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_UPDATE_PROPERTIES => 5636180

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_QUERY_MINIMUM_SHRINK_SIZE => 5652568

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_PREPARE_FOR_SHRINK => 5685340

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_IS_CSV => 5636192

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_POST_ONLINE => 5685348

    /**
     * @type {Integer (UInt32)}
     */
    static IOCTL_VOLUME_GET_CSVBLOCKCACHE_CALLBACK => 5685352

    /**
     * @type {Integer (UInt32)}
     */
    static CSV_BLOCK_CACHE_CALLBACK_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CSV_BLOCK_AND_FILE_CACHE_CALLBACK_VERSION => 2

    /**
     * @type {String}
     */
    static PARTITION_BASIC_DATA_GUID => "{ebd0a0a2-b9e5-4433-87c0-68b6b72699c7}"

    /**
     * @type {String}
     */
    static PARTITION_BSP_GUID => "{57434f53-4df9-45b9-8e9e-2370f006457c}"

    /**
     * @type {String}
     */
    static PARTITION_CLUSTER_GUID => "{db97dba9-0840-4bae-97f0-ffb9a327c7e1}"

    /**
     * @type {String}
     */
    static PARTITION_DPP_GUID => "{57434f53-94cb-43f0-a533-d73c10cfa57d}"

    /**
     * @type {String}
     */
    static PARTITION_ENTRY_UNUSED_GUID => "{00000000-0000-0000-0000-000000000000}"

    /**
     * @type {String}
     */
    static PARTITION_LDM_DATA_GUID => "{af9b60a0-1431-4f62-bc68-3311714a69ad}"

    /**
     * @type {String}
     */
    static PARTITION_LDM_METADATA_GUID => "{5808c8aa-7e8f-42e0-85d2-e1e90434cfb3}"

    /**
     * @type {String}
     */
    static PARTITION_LEGACY_BL_GUID => "{424ca0e2-7cb2-4fb9-8143-c52a99398bc6}"

    /**
     * @type {String}
     */
    static PARTITION_LEGACY_BL_GUID_BACKUP => "{424c3e6c-d79f-49cb-935d-36d71467a288}"

    /**
     * @type {String}
     */
    static PARTITION_MAIN_OS_GUID => "{57434f53-8f45-405e-8a23-186d8a4330d3}"

    /**
     * @type {String}
     */
    static PARTITION_MSFT_RECOVERY_GUID => "{de94bba4-06d1-4d40-a16a-bfd50179d6ac}"

    /**
     * @type {String}
     */
    static PARTITION_MSFT_RESERVED_GUID => "{e3c9e316-0b5c-4db8-817d-f92df00215ae}"

    /**
     * @type {String}
     */
    static PARTITION_MSFT_SNAPSHOT_GUID => "{caddebf1-4400-4de8-b103-12117dcf3ccf}"

    /**
     * @type {String}
     */
    static PARTITION_OS_DATA_GUID => "{57434f53-23f2-44d5-a830-67bbdaa609f9}"

    /**
     * @type {String}
     */
    static PARTITION_PATCH_GUID => "{8967a686-96aa-6aa8-9589-a84256541090}"

    /**
     * @type {String}
     */
    static PARTITION_PRE_INSTALLED_GUID => "{57434f53-7fe0-4196-9b42-427b51643484}"

    /**
     * @type {String}
     */
    static PARTITION_SBL_CACHE_SSD_GUID => "{eeff8352-dd2a-44db-ae83-bee1cf7481dc}"

    /**
     * @type {String}
     */
    static PARTITION_SBL_CACHE_SSD_RESERVED_GUID => "{dcc0c7c1-55ad-4f17-9d43-4bc776e0117e}"

    /**
     * @type {String}
     */
    static PARTITION_SBL_CACHE_HDD_GUID => "{03aaa829-ebfc-4e7e-aac9-c4d76c63b24b}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_FILES_GUID => "{57434f53-432e-4014-ae4c-8deaa9c0006a}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_METADATA_GUID => "{57434f53-c691-4a05-bb4e-703dafd229ce}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_RESERVE_GUID => "{57434f53-4b81-460b-a319-ffb6fe136d14}"

    /**
     * @type {String}
     */
    static PARTITION_SERVICING_STAGING_ROOT_GUID => "{57434f53-e84d-4e84-aaf3-ecbbbd04b9df}"

    /**
     * @type {String}
     */
    static PARTITION_SPACES_GUID => "{e75caf8f-f680-4cee-afa3-b001e56efc2d}"

    /**
     * @type {String}
     */
    static PARTITION_SPACES_DATA_GUID => "{e7addcb4-dc34-4539-9a76-ebbd07be6f7e}"

    /**
     * @type {String}
     */
    static PARTITION_SYSTEM_GUID => "{c12a7328-f81f-11d2-ba4b-00a0c93ec93b}"

    /**
     * @type {String}
     */
    static PARTITION_WINDOWS_SYSTEM_GUID => "{57434f53-e3e3-4631-a5c5-26d2243873aa}"

    /**
     * @type {Integer (UInt32)}
     */
    static _FT_TYPES_DEFINITION_ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MGMT_POLICY_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOG_POLICY_OVERWRITE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LOG_POLICY_PERSIST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MGMT_CLIENT_REGISTRATION_VERSION => 1

    /**
     * @type {String}
     */
    static CLSID_DiskQuotaControl => "{7988b571-ec89-11cf-9c00-00aa00a14f56}"

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_DISABLED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_TRACK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_ENFORCE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_STATE_MASK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_FILESTATE_INCOMPLETE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_FILESTATE_REBUILDING => 512

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_FILESTATE_MASK => 768

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_LOGFLAG_USER_THRESHOLD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_LOGFLAG_USER_LIMIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_RESOLVED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_UNAVAILABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_DELETED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_INVALID => 3

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_UNKNOWN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static DISKQUOTA_USER_ACCOUNT_UNRESOLVED => 5

    /**
     * @type {Integer (UInt32)}
     */
    static INVALID_FILE_SIZE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static INVALID_SET_FILE_POINTER => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static INVALID_FILE_ATTRIBUTES => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_NETNAME_PARMNUM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_TYPE_PARMNUM => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_REMARK_PARMNUM => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_PERMISSIONS_PARMNUM => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_MAX_USES_PARMNUM => 6

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_CURRENT_USES_PARMNUM => 7

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_PATH_PARMNUM => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_PASSWD_PARMNUM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_FILE_SD_PARMNUM => 501

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_SERVER_PARMNUM => 503

    /**
     * @type {Integer (UInt32)}
     */
    static SHARE_QOS_POLICY_PARMNUM => 504

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1_NUM_ELEMENTS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SHI2_NUM_ELEMENTS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED1 => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED2 => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED3 => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED4 => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED5 => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static STYPE_RESERVED_ALL => 1073741568

    /**
     * @type {Integer (UInt32)}
     */
    static SHI_USES_UNLIMITED => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DFS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DFS_ROOT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_MASK_EXT => 8240

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_MASK => 48

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_MANUAL_REINT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_AUTO_REINT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_VDO => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CSC_CACHE_NONE => 48

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_FORCE_SHARED_DELETE => 512

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_FORCE_LEVELII_OPLOCK => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ENABLE_HASH => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ENABLE_CA => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ENCRYPT_DATA => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_RESERVED => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DISABLE_CLIENT_BUFFERING => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_IDENTITY_REMOTING => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_CLUSTER_MANAGED => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_COMPRESS_DATA => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_ISOLATED_TRANSPORT => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static SHI1005_FLAGS_DISABLE_DIRECTORY_HANDLE_LEASING => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static SESI1_NUM_ELEMENTS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SESI2_NUM_ELEMENTS => 9

    /**
     * @type {Integer (UInt32)}
     */
    static STATSOPT_CLR => 1

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_BADINHANDLE => -1

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_BADOUTHANDLE => -2

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_READ => -3

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_WRITE => -4

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_GLOBALLOC => -5

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_GLOBLOCK => -6

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_BADVALUE => -7

    /**
     * @type {Integer (Int32)}
     */
    static LZERROR_UNKNOWNALG => -8

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OBJECTNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_DESCRIPTION_LENGTH => 127

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_DEVICENAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_SERIALNUMBER_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_REVISION_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_BARCODE_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_SEQUENCE_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_VENDORNAME_LENGTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_PRODUCTNAME_LENGTH => 128

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_USERNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_APPLICATIONNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_COMPUTERNAME_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_I1_MESSAGE_LENGTH => 127

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_MESSAGE_LENGTH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_POOLHIERARCHY_LENGTH => 512

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OMIDLABELID_LENGTH => 255

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OMIDLABELTYPE_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_OMIDLABELINFO_LENGTH => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_MAXATTR_LENGTH => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static NTMS_MAXATTR_NAMELEN => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NTMSMLI_MAXTYPE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static NTMSMLI_MAXIDSIZE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static NTMSMLI_MAXAPPDESCR => 256

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_COMMIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_ABORT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_PREPARE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TXF_LOG_RECORD_GENERIC_TYPE_DATA => 8

    /**
     * @type {Integer (UInt32)}
     */
    static VS_VERSION_INFO => 1

    /**
     * @type {Integer (UInt32)}
     */
    static VS_USER_DEFINED => 100

    /**
     * @type {Integer (Int32)}
     */
    static VS_FFI_SIGNATURE => -17890115

    /**
     * @type {Integer (Int32)}
     */
    static VS_FFI_STRUCVERSION => 65536

    /**
     * @type {Integer (Int32)}
     */
    static VS_FFI_FILEFLAGSMASK => 63

    /**
     * @type {Integer (UInt32)}
     */
    static WINEFS_SETUSERKEY_SET_CAPABILITIES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_COMPATIBILITY_VERSION_NCRYPT_PROTECTOR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_COMPATIBILITY_VERSION_PFILE_PROTECTOR => 6

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_SUBVER_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_EFS_SUBVER_EFS_CERT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_PFILE_SUBVER_RMS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_PFILE_SUBVER_APPX => 3

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_SID_SIZE => 256

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_ADD_USER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_REMOVE_USER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_REPLACE_USER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static EFS_METADATA_GENERAL_OP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static WOF_PROVIDER_WIM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WOF_PROVIDER_FILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_PROVIDER_HASH_SIZE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_BOOT_OS_WIM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_BOOT_NOT_OS_WIM => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_ENTRY_FLAG_NOT_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_ENTRY_FLAG_SUSPENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_EXTERNAL_FILE_INFO_FLAG_NOT_ACTIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WIM_EXTERNAL_FILE_INFO_FLAG_SUSPENDED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_XPRESS4K => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_LZX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_XPRESS8K => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FILE_PROVIDER_COMPRESSION_XPRESS16K => 3

    /**
     * @type {Integer (Int32)}
     */
    static COPYFILE2_MESSAGE_COPY_OFFLOAD => 1

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFILE2_IO_CYCLE_SIZE_MIN => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFILE2_IO_CYCLE_SIZE_MAX => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static COPYFILE2_IO_RATE_MIN => 512

    /**
     * @type {Integer (Byte)}
     */
    static ClfsNullRecord => 0x00

    /**
     * @type {Integer (Byte)}
     */
    static ClfsDataRecord => 0x01

    /**
     * @type {Integer (Byte)}
     */
    static ClfsRestartRecord => 0x02

    /**
     * @type {Integer (Byte)}
     */
    static ClfsClientRecord => 0x03

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerInitializing => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerInactive => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerActive => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerActivePendingDelete => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerPendingArchive => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ClsContainerPendingArchiveAndDelete => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerInitializing => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerInactive => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerActive => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerActivePendingDelete => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerPendingArchive => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ClfsContainerPendingArchiveAndDelete => 32

    /**
     * @type {Integer (UInt32)}
     */
    static CLFS_MAX_CONTAINER_INFO => 256

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_INIT => 0x01

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_FORWARD => 0x02

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_BACKWARD => 0x04

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_CLOSE => 0x08

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_INITIALIZED => 0x10

    /**
     * @type {Integer (Byte)}
     */
    static CLFS_SCAN_BUFFERED => 0x20
;@endregion Constants

;@region Methods
    /**
     * Searches for a specified file in a specified path. (Unicode)
     * @remarks
     * If the <i>lpPath</i> parameter is <b>NULL</b>, 
     *      <b>SearchPath</b> searches for a matching file based on the current 
     *      value of the following registry value:
     * 
     * 
     * <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>CurrentControlSet</b>&#92;<b>Control</b>&#92;<b>Session Manager</b>&#92;<b>SafeProcessSearchMode</b>
     * 
     * 
     * 
     * When the value of this <b>REG_DWORD</b> registry value is set to 1, 
     *      <b>SearchPath</b> first searches the folders that are specified in 
     *      the system path, and then searches the current working folder. When the value of this registry value is set to 0, 
     *      the computer first searches the current working folder, and then searches the folders that are specified in the 
     *      system path. The system default value for this registry key is 0.
     * 
     * The search mode used by the <b>SearchPath</b> function can also 
     *      be set per-process by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setsearchpathmode">SetSearchPathMode</a> 
     *      function.
     * 
     * The <b>SearchPath</b> function is not recommended as a method of 
     *      locating a .dll file if the intended use of the output is in a call to the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function. This can result in locating the 
     *      wrong .dll file because the search order of the <b>SearchPath</b> 
     *      function differs from the search order used by the 
     *      <b>LoadLibrary</b> function. If you need to locate and load a 
     *      .dll file, use the <b>LoadLibrary</b> function. 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>SearchPathW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The processenv.h header defines SearchPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpPath The path to be searched for the file.
     * 
     * If this parameter is <b>NULL</b>, the 
     *        function searches for a matching file using a registry-dependent system  search path. For more information, see 
     *        the Remarks section.
     * @param {Pointer<Char>} lpFileName The name of the file for which to search.
     * @param {Pointer<Char>} lpExtension The extension to be added to the file name when searching for the file. The first character of the file name 
     *        extension must be a period (.). The extension is added only if the specified file name does not end with an 
     *        extension.
     * 
     * If a file name extension is not required or if the file name contains an extension, this parameter can be 
     *        <b>NULL</b>.
     * @param {Integer} nBufferLength The size of the buffer that receives the valid path and file name (including the terminating null 
     *       character), in <b>TCHARs</b>.
     * @param {Pointer<Char>} lpBuffer A pointer to the buffer to receive the path and file name of the file found. The  string is a 
     *       null-terminated string.
     * @param {Pointer<Char>} lpFilePart A pointer to the variable to receive the address (within <i>lpBuffer</i>) of the last 
     *       component of the valid path and file name, which is the address of the character immediately following the final 
     *       backslash (\\) in the path.
     * @returns {Integer} If the function succeeds, the value returned is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to the buffer, not including the terminating null character. If the return value is 
     *        greater than <i>nBufferLength</i>, the value returned is the size of the buffer that is 
     *        required to hold the path, including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/processenv/nf-processenv-searchpathw
     * @since windows5.1.2600
     */
    static SearchPathW(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart) {
        lpPath := lpPath is String? StrPtr(lpPath) : lpPath
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpExtension := lpExtension is String? StrPtr(lpExtension) : lpExtension
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SearchPathW", "ptr", lpPath, "ptr", lpFileName, "ptr", lpExtension, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches for a specified file in a specified path. (ANSI)
     * @remarks
     * If the <i>lpPath</i> parameter is <b>NULL</b>, 
     *      <b>SearchPath</b> searches for a matching file based on the current 
     *      value of the following registry value:
     * 
     * 
     * <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>CurrentControlSet</b>&#92;<b>Control</b>&#92;<b>Session Manager</b>&#92;<b>SafeProcessSearchMode</b>
     * 
     * 
     * 
     * When the value of this <b>REG_DWORD</b> registry value is set to 1, 
     *      <b>SearchPath</b> first searches the folders that are specified in 
     *      the system path, and then searches the current working folder. When the value of this registry value is set to 0, 
     *      the computer first searches the current working folder, and then searches the folders that are specified in the 
     *      system path. The system default value for this registry key is 0.
     * 
     * The search mode used by the <b>SearchPath</b> function can also 
     *      be set per-process by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setsearchpathmode">SetSearchPathMode</a> 
     *      function.
     * 
     * The <b>SearchPath</b> function is not recommended as a method of 
     *      locating a .dll file if the intended use of the output is in a call to the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function. This can result in locating the 
     *      wrong .dll file because the search order of the <b>SearchPath</b> 
     *      function differs from the search order used by the 
     *      <b>LoadLibrary</b> function. If you need to locate and load a 
     *      .dll file, use the <b>LoadLibrary</b> function. 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>SearchPathW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The processenv.h header defines SearchPath as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpPath The path to be searched for the file.
     * 
     * If this parameter is <b>NULL</b>, the 
     *        function searches for a matching file using a registry-dependent system  search path. For more information, see 
     *        the Remarks section.
     * @param {Pointer<Byte>} lpFileName The name of the file for which to search.
     * @param {Pointer<Byte>} lpExtension The extension to be added to the file name when searching for the file. The first character of the file name 
     *        extension must be a period (.). The extension is added only if the specified file name does not end with an 
     *        extension.
     * 
     * If a file name extension is not required or if the file name contains an extension, this parameter can be 
     *        <b>NULL</b>.
     * @param {Integer} nBufferLength The size of the buffer that receives the valid path and file name (including the terminating null 
     *       character), in <b>TCHARs</b>.
     * @param {Pointer<Byte>} lpBuffer A pointer to the buffer to receive the path and file name of the file found. The  string is a 
     *       null-terminated string.
     * @param {Pointer<Byte>} lpFilePart A pointer to the variable to receive the address (within <i>lpBuffer</i>) of the last 
     *       component of the valid path and file name, which is the address of the character immediately following the final 
     *       backslash (\\) in the path.
     * @returns {Integer} If the function succeeds, the value returned is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to the buffer, not including the terminating null character. If the return value is 
     *        greater than <i>nBufferLength</i>, the value returned is the size of the buffer that is 
     *        required to hold the path, including the terminating null character.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/processenv/nf-processenv-searchpatha
     * @since windows5.1.2600
     */
    static SearchPathA(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart) {
        lpPath := lpPath is String? StrPtr(lpPath) : lpPath
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpExtension := lpExtension is String? StrPtr(lpExtension) : lpExtension
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SearchPathA", "ptr", lpPath, "ptr", lpFileName, "ptr", lpExtension, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Compares two file times.
     * @param {Pointer<FILETIME>} lpFileTime1 A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the 
     *      first file time.
     * @param {Pointer<FILETIME>} lpFileTime2 A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the 
     *      second file time.
     * @returns {Integer} The return value is one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>-1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * First file time is earlier than second file time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * First file time is equal to second file time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * First file time is later than second file time.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-comparefiletime
     * @since windows5.1.2600
     */
    static CompareFileTime(lpFileTime1, lpFileTime2) {
        result := DllCall("KERNEL32.dll\CompareFileTime", "ptr", lpFileTime1, "ptr", lpFileTime2, "int")
        return result
    }

    /**
     * Creates a new directory. (CreateDirectoryA)
     * @remarks
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *     directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption 
     *     attributes of its parent directory. 
     * 
     * An application can obtain a handle to a directory by calling 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> with the 
     *     <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see 
     *     <b>CreateFile</b>.
     * 
     * To support inheritance functions that query the security descriptor of this object may heuristically determine 
     *     and report that inheritance is in effect. See 
     *     <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a> 
     *     for more information.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpPathName The path of the directory to be created.
     * 
     * For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory. If <i>lpSecurityAttributes</i> is 
     *        <b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default 
     *        security descriptor for a  directory are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        (This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.)
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist; this function will only create the final directory in 
     *         the path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createdirectorya
     * @since windows5.1.2600
     */
    static CreateDirectoryA(lpPathName, lpSecurityAttributes) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryA", "ptr", lpPathName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory. (CreateDirectoryW)
     * @remarks
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *     directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption 
     *     attributes of its parent directory. 
     * 
     * An application can obtain a handle to a directory by calling 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> with the 
     *     <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see 
     *     <b>CreateFile</b>.
     * 
     * To support inheritance functions that query the security descriptor of this object may heuristically determine 
     *     and report that inheritance is in effect. See 
     *     <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a> 
     *     for more information.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpPathName The path of the directory to be created.
     * 
     * For the ANSI version of this function, there is a default string size limit for paths of 248 characters (<b>MAX_PATH</b> - enough room for a 8.3 filename). To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryW</b>), you can opt-in to remove the 248 character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory. If <i>lpSecurityAttributes</i> is 
     *        <b>NULL</b>, the directory gets a default security descriptor. The ACLs in the default 
     *        security descriptor for a  directory are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        (This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.)
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist; this function will only create the final directory in 
     *         the path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createdirectoryw
     * @since windows5.1.2600
     */
    static CreateDirectoryW(lpPathName, lpSecurityAttributes) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryW", "ptr", lpPathName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:\_file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. (ANSI)
     * @remarks
     * <b>CreateFile</b> was originally developed specifically for file 
     *     interaction but has since been expanded and enhanced to include most other types of I/O devices and mechanisms 
     *     available to Windows developers. This section attempts to cover the varied issues developers may experience when 
     *     using <b>CreateFile</b> in different contexts and with different I/O 
     *     types. The text attempts to use the word <i>file</i> only when referring specifically to data stored in an 
     *     actual file on a file system. However, some uses of <i>file</i> may be referring more generally to an I/O 
     *     object that supports file-like mechanisms. This liberal use of the term <i>file</i> is particularly 
     *     prevalent in constant names and parameter names because of the previously mentioned historical reasons.
     * 
     * When an application is finished using the object handle returned by 
     *     <b>CreateFile</b>, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close the handle. This not only 
     *     frees up system resources, but can have wider influence on things like sharing the file or device and committing 
     *     data to disk. Specifics are noted within this topic as appropriate.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A sharing violation occurs if an attempt is made to open a file or directory for deletion on a remote 
     *      computer when the value of the <i>dwDesiredAccess</i> parameter is the 
     *      <b>DELETE</b> access flag (0x00010000) <b>OR</b>'ed with any other access flag, and the remote file 
     *      or directory has not been opened with <b>FILE_SHARE_DELETE</b>. To avoid the sharing violation 
     *      in this scenario, open the remote file or directory with the <b>DELETE</b> access right only, 
     *      or call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> without first opening the file or 
     *      directory for deletion.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *      directories. On volumes that have a mounted file system with this support, a new file inherits the compression 
     *      and encryption attributes of its directory.
     * 
     * You cannot use <b>CreateFile</b> to control compression, 
     *      decompression, or decryption on a file or directory. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>, 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</a>, 
     *      and <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>For backward compatibility purposes, <b>CreateFile</b> does 
     *      not apply inheritance rules when you specify a security descriptor in 
     *      <i>lpSecurityAttributes</i>. To support inheritance, functions that later query the security 
     *      descriptor of this file may heuristically determine and report that inheritance is in effect. For more 
     *      information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.
     * 
     * As stated previously, if the <i>lpSecurityAttributes</i> parameter is 
     *      <b>NULL</b>, the handle returned by 
     *      <b>CreateFile</b> cannot be inherited by any child processes your 
     *      application may create. The following information regarding this parameter also applies:
     * 
     * <ul>
     * <li>If the <b>bInheritHandle</b> member variable is not <b>FALSE</b>, 
     *       which is any nonzero value, then the handle can be inherited. Therefore it is critical this structure member be 
     *       properly initialized to <b>FALSE</b> if you do not intend the handle to be inheritable.</li>
     * <li>The access control lists (ACL) in the default security descriptor for a file or directory are inherited 
     *       from its parent directory.</li>
     * <li>The target file system must support security on files and directories for the 
     *       <b>lpSecurityDescriptor</b> member to have an effect on them, which can be determined by 
     *       using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>.</li>
     * </ul>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that <b>CreateFile</b> with supersede disposition will fail if performed on a file where there is already an open alternate data stream.
     * 
     * <h3><a id="Symbolic_Link_Behavior"></a><a id="symbolic_link_behavior"></a><a id="SYMBOLIC_LINK_BEHAVIOR"></a>Symbolic Link Behavior</h3>
     * If the call to this function creates a file, there is no change in behavior. Also, consider the following 
     *       information regarding <b>FILE_FLAG_OPEN_REPARSE_POINT</b>:
     * 
     * <ul>
     * <li>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *          symbolic link.</li>
     * <li>If <b>TRUNCATE_EXISTING</b> or <b>FILE_FLAG_DELETE_ON_CLOSE</b> 
     *          are specified, the file affected is a symbolic link.</li>
     * </ul>
     * </li>
     * <li>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is not specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *          target.</li>
     * <li>If <b>CREATE_ALWAYS</b>, <b>TRUNCATE_EXISTING</b>, or 
     *          <b>FILE_FLAG_DELETE_ON_CLOSE</b> are specified, the file affected is the target.</li>
     * </ul>
     * </li>
     * </ul>
     * <h3><a id="caching_behavior"></a><a id="CACHING_BEHAVIOR"></a>Caching Behavior</h3>
     * Several of the possible values for the <i>dwFlagsAndAttributes</i> parameter are used by 
     *       <b>CreateFile</b> to control or affect how the data associated 
     *       with the handle is cached by the system. They are:
     * 
     * <ul>
     * <li><b>FILE_FLAG_NO_BUFFERING</b></li>
     * <li><b>FILE_FLAG_RANDOM_ACCESS</b></li>
     * <li><b>FILE_FLAG_SEQUENTIAL_SCAN</b></li>
     * <li><b>FILE_FLAG_WRITE_THROUGH</b></li>
     * <li><b>FILE_ATTRIBUTE_TEMPORARY</b></li>
     * </ul>
     * If none of these flags is specified, the system uses a default general-purpose caching scheme. Otherwise, the 
     *       system caching behaves as specified for each flag.
     * 
     * Some of these flags should not be combined. For instance, combining 
     *       <b>FILE_FLAG_RANDOM_ACCESS</b> with <b>FILE_FLAG_SEQUENTIAL_SCAN</b> is 
     *       self-defeating.
     * 
     * Specifying the <b>FILE_FLAG_SEQUENTIAL_SCAN</b> flag can increase performance for 
     *       applications that read large files using sequential access. Performance gains can be even more noticeable for 
     *       applications that read large files mostly sequentially, but occasionally skip forward over small ranges of 
     *       bytes. If an application moves the file pointer for random access, optimum caching performance most likely will 
     *       not occur. However, correct operation is still guaranteed.
     * 
     * The flags <b>FILE_FLAG_WRITE_THROUGH</b> and 
     *       <b>FILE_FLAG_NO_BUFFERING</b> are independent and may be combined.
     * 
     * If <b>FILE_FLAG_WRITE_THROUGH</b> is used but 
     *       <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in effect, 
     *       then the data is written to the system cache but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_WRITE_THROUGH</b> and <b>FILE_FLAG_NO_BUFFERING</b> are 
     *       both specified, so that system caching is not in effect, then the data is immediately flushed to disk without 
     *       going through the Windows system cache. The operating system also requests a write-through of the hard disk's 
     *       local hardware cache to persistent media.
     * 
     * <div class="alert"><b>Note</b>  Not all hard disk hardware supports this write-through capability.</div>
     * <div> </div>
     * Proper use of the <b>FILE_FLAG_NO_BUFFERING</b> flag requires special application 
     *       considerations. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * A write-through request via <b>FILE_FLAG_WRITE_THROUGH</b> also causes NTFS to flush any 
     *       metadata changes, such as a time stamp update or a rename operation, that result from processing the request. 
     *       For this reason, the <b>FILE_FLAG_WRITE_THROUGH</b> flag is often used with the 
     *       <b>FILE_FLAG_NO_BUFFERING</b> flag as a replacement for calling the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function after each write, which can 
     *       cause unnecessary performance penalties. Using these flags together avoids those penalties. For general 
     *       information about the caching of files and metadata, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-caching">File Caching</a>.
     * 
     * When <b>FILE_FLAG_NO_BUFFERING</b> is combined with 
     *       <b>FILE_FLAG_OVERLAPPED</b>, the flags give maximum asynchronous performance, because the I/O 
     *       does not rely on the synchronous operations of the memory manager. However, some I/O operations take more time, 
     *       because data is not being held in the cache. Also, the file metadata may still be cached (for example, when 
     *       creating an empty file). To ensure that the metadata is flushed to disk, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function.
     * 
     * Specifying the <b>FILE_ATTRIBUTE_TEMPORARY</b> attribute causes file systems to avoid 
     *       writing data back to mass storage if sufficient cache memory is available, because an application deletes a 
     *       temporary file after a handle is closed. In that case, the system can entirely avoid writing the data. Although 
     *       it does not directly control data caching in the same way as the previously mentioned flags, the 
     *       <b>FILE_ATTRIBUTE_TEMPORARY</b> attribute does tell the system to hold as much as possible in 
     *       the system cache without writing and therefore may be of concern for certain applications.
     * 
     * <h3><a id="Files"></a><a id="files"></a><a id="FILES"></a>Files</h3>
     * If you rename or delete a file and then restore it shortly afterward, the system searches the cache for file 
     *       information to restore. Cached information includes its short/long name pair and creation time.
     * 
     * If you call <b>CreateFile</b> on a file that is pending deletion 
     *       as a result of a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>, the function 
     *       fails. The operating system delays file deletion until all handles to the file are closed. 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The <i>dwDesiredAccess</i> parameter can be zero, allowing the application to query file 
     *       attributes without accessing the file if the application is running with adequate security settings. This is 
     *       useful to test for the existence of a file without opening it for read and/or write access, or to obtain other 
     *       statistics about the file or directory. See 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-and-setting-file-information">Obtaining and Setting File Information</a> 
     *       and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>.
     * 
     * If <b>CREATE_ALWAYS</b> and <b>FILE_ATTRIBUTE_NORMAL</b> are 
     *       specified, <b>CreateFile</b> fails and sets the last error to 
     *       <b>ERROR_ACCESS_DENIED</b> if the file exists and has the 
     *       <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_SYSTEM</b> attribute. 
     *       To avoid the error, specify the same attributes as the existing file.
     * 
     * When an application creates a file across a network, it is better to use 
     *       <c>GENERIC_READ | GENERIC_WRITE</c> for 
     *       <i>dwDesiredAccess</i> than to use <b>GENERIC_WRITE</b> alone. The 
     *       resulting code is faster, because the redirector can use the cache manager and send fewer SMBs with more data. 
     *       This combination also avoids an issue where writing to a file across a network can occasionally return 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * <h3><a id="synchronous_and_asynchronous_i_o_handles"></a><a id="SYNCHRONOUS_AND_ASYNCHRONOUS_I_O_HANDLES"></a>Synchronous and Asynchronous I/O Handles</h3>
     * <b>CreateFile</b> provides for creating a file or device handle 
     *       that is either synchronous or asynchronous. A synchronous handle behaves such that I/O function calls using that 
     *       handle are blocked until they complete, while an asynchronous file handle makes it possible for the system to 
     *       return immediately from I/O function calls, whether they completed the I/O operation or not. As stated 
     *       previously, this synchronous versus asynchronous behavior is determined by specifying 
     *       <b>FILE_FLAG_OVERLAPPED</b> within the <i>dwFlagsAndAttributes</i> 
     *       parameter. There are several complexities and potential pitfalls when using asynchronous I/O; for more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * <h3><a id="File_Streams"></a><a id="file_streams"></a><a id="FILE_STREAMS"></a>File Streams</h3>
     * On NTFS file systems, you can use <b>CreateFile</b> to create 
     *       separate streams within a file. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <h3><a id="Directories"></a><a id="directories"></a><a id="DIRECTORIES"></a>Directories</h3>
     * An application cannot create a directory by using 
     *       <b>CreateFile</b>, therefore only the 
     *       <b>OPEN_EXISTING</b> value is valid for 
     *       <i>dwCreationDisposition</i> for this use case. To create a directory, the application must 
     *       call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>.
     * 
     * To open a directory using <b>CreateFile</b>, specify the 
     *       <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag as part of 
     *       <i>dwFlagsAndAttributes</i>. Appropriate security checks still apply when this flag is used 
     *       without <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges.
     * 
     * When using <b>CreateFile</b> to open a directory during 
     *       defragmentation of a FAT or FAT32 file system volume, do not specify the 
     *       <b>MAXIMUM_ALLOWED</b> access right. Access to the directory is denied if this is done. 
     *       Specify the <b>GENERIC_READ</b> access right instead.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-directory-management">About Directory Management</a>.
     * 
     * <h3><a id="Physical_Disks_and_Volumes"></a><a id="physical_disks_and_volumes"></a><a id="PHYSICAL_DISKS_AND_VOLUMES"></a>Physical Disks and Volumes</h3>
     * Direct access to the disk or to a volume is restricted. 
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>Direct access to the disk or to a volume is not restricted in this manner.
     * 
     * You can use the <b>CreateFile</b> function to open a physical 
     *       disk drive or a volume, which returns a direct access storage device (DASD) handle that can be used with the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function. This enables you to access 
     *       the disk or volume directly, for example such disk metadata as the partition table. However, this type of access 
     *       also exposes the disk drive or volume to potential data loss, because an incorrect write to a disk using this 
     *       mechanism could make its contents inaccessible to the operating system. To ensure data integrity, be sure to 
     *       become familiar with <b>DeviceIoControl</b> and how other 
     *       APIs behave differently with a direct access handle as opposed to a file system handle.
     * 
     * The following requirements must be met for such a call to succeed:
     * 
     * <ul>
     * <li>The caller must have administrative privileges. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</li>
     * <li>The <i>dwCreationDisposition</i> parameter must have the 
     *        <b>OPEN_EXISTING</b> flag.</li>
     * <li>When opening a volume or floppy disk, the <i>dwShareMode</i> parameter must have the 
     *        <b>FILE_SHARE_WRITE</b> flag.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  The <i>dwDesiredAccess</i> parameter can be zero, allowing the application to query 
     *       device attributes without accessing a device. This is useful for an application to determine the size of a 
     *       floppy disk drive and the formats it supports without requiring a floppy disk in a drive, for instance. It can 
     *       also be used for reading statistics without requiring higher-level data read/write permission.</div>
     * <div> </div>
     * When opening a physical drive <i>x</i>:, the 
     *       <i>lpFileName</i> string should be the following form: 
     *       "\\.\PhysicalDrive<i>X</i>". Hard disk numbers 
     *       start at zero. The following table shows some examples of physical drive strings.
     * 
     * <table>
     * <tr>
     * <th>String</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>"\\.\PhysicalDrive0"</td>
     * <td>Opens the first physical drive.</td>
     * </tr>
     * <tr>
     * <td>"\\.\PhysicalDrive2"</td>
     * <td>Opens the third physical drive.</td>
     * </tr>
     * </table>
     *  
     * 
     * To obtain the physical drive identifier for a volume, open a handle to the volume and call the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a>. 
     *       This control code returns the disk number and offset for each of the volume's one or more extents; a volume can 
     *       span multiple physical disks.
     * 
     * For an example of opening a physical drive, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/DevIO/calling-deviceiocontrol">Calling DeviceIoControl</a>.
     * 
     * When opening a volume or removable media drive (for example, a floppy disk drive or flash memory thumb drive), 
     *       the <i>lpFileName</i> string should be the following form: 
     *       "\\.&#92;<i>X</i>:". Do not use a trailing backslash 
     *       (\\), which indicates the root directory of a drive. The following table shows some examples of drive strings.
     * 
     * <table>
     * <tr>
     * <th>String</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>"\\.\A:"</td>
     * <td>Opens floppy disk drive A.</td>
     * </tr>
     * <tr>
     * <td>"\\.\C:"</td>
     * <td>Opens the C: volume.</td>
     * </tr>
     * <tr>
     * <td>"\\.\C:\"</td>
     * <td>Opens the file system of the C: volume.</td>
     * </tr>
     * </table>
     *  
     * 
     * You can also open a volume by referring to its volume name. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * 
     * A volume contains one or more mounted file systems. Volume handles can be opened as noncached at the 
     *       discretion of the particular file system, even when the noncached option is not specified in 
     *       <b>CreateFile</b>. You should assume that all Microsoft file 
     *       systems open volume handles as noncached. The restrictions on noncached I/O for files also apply to volumes.
     * 
     * A file system may or may not require buffer alignment even though the data is noncached. However, if the 
     *       noncached option is specified when opening a volume, buffer alignment is enforced regardless of the file system 
     *       on the volume. It is recommended on all file systems that you open volume handles as noncached, and follow the 
     *       noncached I/O restrictions.
     * 
     * <div class="alert"><b>Note</b>  To read or write to the last few sectors of the volume, you must call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> and specify 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>. This signals 
     *       the file system driver not to perform any I/O boundary checks on partition read or write calls. Instead, 
     *       boundary checks are performed by the device driver.</div>
     * <div> </div>
     * <h3><a id="Changer_Device"></a><a id="changer_device"></a><a id="CHANGER_DEVICE"></a>Changer Device</h3>
     * The <b>IOCTL_CHANGER_*</b> control codes for 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> accept a handle to a changer device. 
     *       To open a changer device, use a file name of the following form: 
     *       "\\.\Changer<i>x</i>" where 
     *       <i>x</i> is a number that indicates which device to open, starting with zero. To open 
     *       changer device zero in an application that is written in C or C++, use the following file name: 
     *       "\\.\Changer0".
     * 
     * <h3><a id="Tape_Drives"></a><a id="tape_drives"></a><a id="TAPE_DRIVES"></a>Tape Drives</h3>
     * You can open tape drives by using a file name of the following form: 
     *       "\\.\TAPE<i>x</i>" where 
     *       <i>x</i> is a number that indicates which drive to open, starting with tape drive zero. To 
     *       open tape drive zero in an application that is written in C or C++, use the following file name: 
     *       "\\.\TAPE0".
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/Backup/backup">Backup</a>.
     * 
     * <h3><a id="Communications_Resources"></a><a id="communications_resources"></a><a id="COMMUNICATIONS_RESOURCES"></a>Communications Resources</h3>
     * The <b>CreateFile</b> function can create a handle to a 
     *       communications resource, such as the serial port COM1. For communications resources, 
     *       the <i>dwCreationDisposition</i> parameter must be 
     *       <b>OPEN_EXISTING</b>, the <i>dwShareMode</i> parameter must be zero 
     *       (exclusive access), and the <i>hTemplateFile</i> parameter must be 
     *       <b>NULL</b>. Read, write, or read/write access can be specified, and the handle can be opened 
     *       for overlapped I/O.
     * 
     * To specify a COM port number greater than 9, use the following syntax: 
     *       "\\\\.\COM10". This syntax works for all port numbers and hardware that 
     *       allows COM port numbers to be specified.
     * 
     * For more information about communications, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/DevIO/communications-resources">Communications</a>.
     * 
     * <h3><a id="Consoles"></a><a id="consoles"></a><a id="CONSOLES"></a>Consoles</h3>
     * The <b>CreateFile</b> function can create a handle to console 
     *       input (CONIN$). If the process has an open handle to it as a result of inheritance or 
     *       duplication, it can also create a handle to the active screen buffer (CONOUT$). The 
     *       calling process must be attached to an inherited console or one allocated by the 
     *       <a href="https://docs.microsoft.com/windows/console/allocconsole">AllocConsole</a> function. For console handles, set the 
     *       <b>CreateFile</b> parameters as follows.
     * 
     * <table>
     * <tr>
     * <th>Parameters</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td>
     * <i>lpFileName</i>
     * 
     * </td>
     * <td>
     * Use the CONIN$ value to specify console input.
     * 
     * Use the CONOUT$ value to specify console output.
     * 
     * CONIN$ gets a handle to the console input buffer, even if the 
     *          <a href="https://docs.microsoft.com/windows/console/setstdhandle">SetStdHandle</a> function redirects the standard input 
     *          handle. To get the standard input handle, use the 
     *          <a href="https://docs.microsoft.com/windows/console/getstdhandle">GetStdHandle</a> function.
     * 
     * CONOUT$ gets a handle to the active screen buffer, even if 
     *          <a href="https://docs.microsoft.com/windows/console/setstdhandle">SetStdHandle</a> redirects the standard output handle. To 
     *          get the standard output handle, use <a href="https://docs.microsoft.com/windows/console/getstdhandle">GetStdHandle</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwDesiredAccess</i>
     * 
     * </td>
     * <td>
     * <c>GENERIC_READ | GENERIC_WRITE</c> is preferred, but either one can 
     *          limit access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwShareMode</i>
     * 
     * </td>
     * <td>
     * When opening CONIN$, specify 
     *          <b>FILE_SHARE_READ</b>. When opening CONOUT$, specify 
     *          <b>FILE_SHARE_WRITE</b>.
     * 
     * If the calling process inherits the console, or if a child process should be able to access the console, 
     *          this parameter must be <c>FILE_SHARE_READ | FILE_SHARE_WRITE</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>lpSecurityAttributes</i>
     * 
     * </td>
     * <td>
     * If you want the console to be inherited, the <b>bInheritHandle</b> member of the 
     *          <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure 
     *          must be <b>TRUE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwCreationDisposition</i>
     * 
     * </td>
     * <td>
     * You should specify <b>OPEN_EXISTING</b> when using 
     *          <b>CreateFile</b> to open the console.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwFlagsAndAttributes</i>
     * 
     * </td>
     * <td>
     * Ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>hTemplateFile</i>
     * 
     * </td>
     * <td>
     * Ignored.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following table shows various settings of <i>dwDesiredAccess</i> and 
     *       <i>lpFileName</i>.
     * 
     * <table>
     * <tr>
     * <th><i>lpFileName</i></th>
     * <th><i>dwDesiredAccess</i></th>
     * <th>Result</th>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><b>GENERIC_READ</b></td>
     * <td>Opens console for input.</td>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><b>GENERIC_WRITE</b></td>
     * <td>Opens console for output.</td>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><c>GENERIC_READ | GENERIC_WRITE</c></td>
     * <td>Causes <b>CreateFile</b> to fail; 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *         <b>ERROR_FILE_NOT_FOUND</b>.</td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Mailslots"></a><a id="mailslots"></a><a id="MAILSLOTS"></a>Mailslots</h3>
     * If <b>CreateFile</b> opens the client end of a mailslot, the 
     *       function returns <b>INVALID_HANDLE_VALUE</b> if the mailslot client attempts to open a local 
     *       mailslot before the mailslot server has created it with the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot</a> function.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/ipc/mailslots">Mailslots</a>.
     * 
     * <h3><a id="Pipes"></a><a id="pipes"></a><a id="PIPES"></a>Pipes</h3>
     * If <b>CreateFile</b> opens the client end of a named pipe, the 
     *       function uses any instance of the named pipe that is in the listening state. The opening process can duplicate 
     *       the handle as many times as required, but after it is opened, the named pipe instance cannot be opened by 
     *       another client. The access that is specified when a pipe is opened must be compatible with the access that is 
     *       specified in the <i>dwOpenMode</i> parameter of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.
     * 
     * If the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function was not 
     *       successfully called on the server prior to this operation, a pipe will not exist and 
     *       <b>CreateFile</b> will fail with 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * 
     * If there is at least one active pipe instance but there are no available listener pipes on the server, which 
     *       means all pipe instances are currently connected, 
     *      <b>CreateFile</b> fails with 
     *      <b>ERROR_PIPE_BUSY</b>.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/ipc/pipes">Pipes</a>.
     * @param {Pointer<Byte>} lpFileName The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * For information on special device names, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or 0 to indicate neither).
     * 
     * The most commonly used values are <b>GENERIC_READ</b>, 
     *        <b>GENERIC_WRITE</b>, or both 
     *        (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device 
     *        attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would 
     *        have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the 
     *        <i>dwShareMode</i> parameter in an open request that already has an open handle.
     * 
     * For more information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or 
     *        none (refer to the following table). Access requests to attributes or extended attributes are not affected by 
     *        this flag.
     * 
     * If this parameter is zero and <b>CreateFile</b> succeeds, the 
     *        file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. 
     *        For more information, see the Remarks section.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an existing 
     *        request that has an open handle. <b>CreateFile</b> would fail and 
     *        the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return 
     *        <b>ERROR_SHARING_VIOLATION</b>.
     * 
     * To enable a process to share a file or device while another process has the file or device open, use a
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains two separate but related data members: an optional security descriptor, and a Boolean 
     *        value that determines whether the returned handle can be inherited by child processes.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If this parameter is <b>NULL</b>, the handle returned by 
     *        <b>CreateFile</b> cannot be inherited by any child processes the 
     *        application may create and the file or device associated with the returned handle gets a default security 
     *        descriptor.
     * 
     * The <b>lpSecurityDescriptor</b> member of the structure specifies a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If 
     *        this member is <b>NULL</b>, the file or device associated with the returned handle is 
     *        assigned a default security descriptor.
     * 
     * <b>CreateFile</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues 
     *        to use the <b>bInheritHandle</b> member.
     * 
     * The <b>bInheritHandle</b> member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     * 
     * For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwFlagsAndAttributes The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most 
     *        common default value for files.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_\*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_\*</b>) for control of 
     *        file or device caching behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_\*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally 
     *        combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied 
     *        as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div>
     * <div> </div>
     * Some of the following file attributes and flags may only apply to files and not necessarily all other types 
     *        of devices that <b>CreateFile</b> can open. For additional 
     *        information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * For more advanced access to file attributes, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list 
     *        of all file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the calling 
     *          process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and 
     *          <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after all of its handles are closed, which includes the specified 
     *          handle and any other open or duplicated handles.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with no system caching for data reads and writes. This flag does not 
     *          affect hard disk caching or memory mapped files.
     * 
     * There are strict requirements for successfully working with files opened with 
     *          <b>CreateFile</b> using the 
     *          <b>FILE_FLAG_NO_BUFFERING</b> flag, for details see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not 
     *          occur; <b>CreateFile</b> will attempt to open the reparse 
     *          point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse 
     *          point is operational.
     * 
     * This flag cannot be used with the <b>CREATE_ALWAYS</b> flag.
     * 
     * If the file is not a reparse point, then this flag is ignored.
     * 
     * For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened or created for asynchronous I/O.
     * 
     * When subsequent I/O operations are completed on this handle, the event specified in the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the 
     *          signaled state.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * For information about considerations when using a file handle created with this flag, see the 
     *          <a href="#synchronous_and_asynchronous_i_o_handles">Synchronous and Asynchronous I/O Handles</a> 
     *          section of this topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access will occur according to POSIX rules. This includes allowing multiple files with names, differing 
     *          only in case, for file systems that support that naming. Use care when using this option, because files 
     *          created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be random. The system can use this as a hint to optimize file caching.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize 
     *          file caching.
     * 
     * This flag should not be used if read-behind (that is, reverse scans) will be used.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * For additional information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i> parameter can also specify SQOS information. For more 
     *        information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the 
     *        calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {Pointer<Void>} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * When opening an existing file, <b>CreateFile</b> ignores this 
     *        parameter.
     * 
     * When opening a new encrypted file, the file inherits the discretionary access control list from its parent 
     *        directory. For additional information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilea
     * @since windows5.1.2600
     */
    static CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileA", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:\_file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. (Unicode)
     * @remarks
     * <b>CreateFile</b> was originally developed specifically for file 
     *     interaction but has since been expanded and enhanced to include most other types of I/O devices and mechanisms 
     *     available to Windows developers. This section attempts to cover the varied issues developers may experience when 
     *     using <b>CreateFile</b> in different contexts and with different I/O 
     *     types. The text attempts to use the word <i>file</i> only when referring specifically to data stored in an 
     *     actual file on a file system. However, some uses of <i>file</i> may be referring more generally to an I/O 
     *     object that supports file-like mechanisms. This liberal use of the term <i>file</i> is particularly 
     *     prevalent in constant names and parameter names because of the previously mentioned historical reasons.
     * 
     * When an application is finished using the object handle returned by 
     *     <b>CreateFile</b>, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close the handle. This not only 
     *     frees up system resources, but can have wider influence on things like sharing the file or device and committing 
     *     data to disk. Specifics are noted within this topic as appropriate.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>A sharing violation occurs if an attempt is made to open a file or directory for deletion on a remote 
     *      computer when the value of the <i>dwDesiredAccess</i> parameter is the 
     *      <b>DELETE</b> access flag (0x00010000) <b>OR</b>'ed with any other access flag, and the remote file 
     *      or directory has not been opened with <b>FILE_SHARE_DELETE</b>. To avoid the sharing violation 
     *      in this scenario, open the remote file or directory with the <b>DELETE</b> access right only, 
     *      or call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> without first opening the file or 
     *      directory for deletion.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *      directories. On volumes that have a mounted file system with this support, a new file inherits the compression 
     *      and encryption attributes of its directory.
     * 
     * You cannot use <b>CreateFile</b> to control compression, 
     *      decompression, or decryption on a file or directory. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>, 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</a>, 
     *      and <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>For backward compatibility purposes, <b>CreateFile</b> does 
     *      not apply inheritance rules when you specify a security descriptor in 
     *      <i>lpSecurityAttributes</i>. To support inheritance, functions that later query the security 
     *      descriptor of this file may heuristically determine and report that inheritance is in effect. For more 
     *      information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.
     * 
     * As stated previously, if the <i>lpSecurityAttributes</i> parameter is 
     *      <b>NULL</b>, the handle returned by 
     *      <b>CreateFile</b> cannot be inherited by any child processes your 
     *      application may create. The following information regarding this parameter also applies:
     * 
     * <ul>
     * <li>If the <b>bInheritHandle</b> member variable is not <b>FALSE</b>, 
     *       which is any nonzero value, then the handle can be inherited. Therefore it is critical this structure member be 
     *       properly initialized to <b>FALSE</b> if you do not intend the handle to be inheritable.</li>
     * <li>The access control lists (ACL) in the default security descriptor for a file or directory are inherited 
     *       from its parent directory.</li>
     * <li>The target file system must support security on files and directories for the 
     *       <b>lpSecurityDescriptor</b> member to have an effect on them, which can be determined by 
     *       using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>.</li>
     * </ul>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that <b>CreateFile</b> with supersede disposition will fail if performed on a file where there is already an open alternate data stream.
     * 
     * <h3><a id="Symbolic_Link_Behavior"></a><a id="symbolic_link_behavior"></a><a id="SYMBOLIC_LINK_BEHAVIOR"></a>Symbolic Link Behavior</h3>
     * If the call to this function creates a file, there is no change in behavior. Also, consider the following 
     *       information regarding <b>FILE_FLAG_OPEN_REPARSE_POINT</b>:
     * 
     * <ul>
     * <li>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *          symbolic link.</li>
     * <li>If <b>TRUNCATE_EXISTING</b> or <b>FILE_FLAG_DELETE_ON_CLOSE</b> 
     *          are specified, the file affected is a symbolic link.</li>
     * </ul>
     * </li>
     * <li>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is not specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *          target.</li>
     * <li>If <b>CREATE_ALWAYS</b>, <b>TRUNCATE_EXISTING</b>, or 
     *          <b>FILE_FLAG_DELETE_ON_CLOSE</b> are specified, the file affected is the target.</li>
     * </ul>
     * </li>
     * </ul>
     * <h3><a id="caching_behavior"></a><a id="CACHING_BEHAVIOR"></a>Caching Behavior</h3>
     * Several of the possible values for the <i>dwFlagsAndAttributes</i> parameter are used by 
     *       <b>CreateFile</b> to control or affect how the data associated 
     *       with the handle is cached by the system. They are:
     * 
     * <ul>
     * <li><b>FILE_FLAG_NO_BUFFERING</b></li>
     * <li><b>FILE_FLAG_RANDOM_ACCESS</b></li>
     * <li><b>FILE_FLAG_SEQUENTIAL_SCAN</b></li>
     * <li><b>FILE_FLAG_WRITE_THROUGH</b></li>
     * <li><b>FILE_ATTRIBUTE_TEMPORARY</b></li>
     * </ul>
     * If none of these flags is specified, the system uses a default general-purpose caching scheme. Otherwise, the 
     *       system caching behaves as specified for each flag.
     * 
     * Some of these flags should not be combined. For instance, combining 
     *       <b>FILE_FLAG_RANDOM_ACCESS</b> with <b>FILE_FLAG_SEQUENTIAL_SCAN</b> is 
     *       self-defeating.
     * 
     * Specifying the <b>FILE_FLAG_SEQUENTIAL_SCAN</b> flag can increase performance for 
     *       applications that read large files using sequential access. Performance gains can be even more noticeable for 
     *       applications that read large files mostly sequentially, but occasionally skip forward over small ranges of 
     *       bytes. If an application moves the file pointer for random access, optimum caching performance most likely will 
     *       not occur. However, correct operation is still guaranteed.
     * 
     * The flags <b>FILE_FLAG_WRITE_THROUGH</b> and 
     *       <b>FILE_FLAG_NO_BUFFERING</b> are independent and may be combined.
     * 
     * If <b>FILE_FLAG_WRITE_THROUGH</b> is used but 
     *       <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in effect, 
     *       then the data is written to the system cache but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_WRITE_THROUGH</b> and <b>FILE_FLAG_NO_BUFFERING</b> are 
     *       both specified, so that system caching is not in effect, then the data is immediately flushed to disk without 
     *       going through the Windows system cache. The operating system also requests a write-through of the hard disk's 
     *       local hardware cache to persistent media.
     * 
     * <div class="alert"><b>Note</b>  Not all hard disk hardware supports this write-through capability.</div>
     * <div> </div>
     * Proper use of the <b>FILE_FLAG_NO_BUFFERING</b> flag requires special application 
     *       considerations. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * A write-through request via <b>FILE_FLAG_WRITE_THROUGH</b> also causes NTFS to flush any 
     *       metadata changes, such as a time stamp update or a rename operation, that result from processing the request. 
     *       For this reason, the <b>FILE_FLAG_WRITE_THROUGH</b> flag is often used with the 
     *       <b>FILE_FLAG_NO_BUFFERING</b> flag as a replacement for calling the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function after each write, which can 
     *       cause unnecessary performance penalties. Using these flags together avoids those penalties. For general 
     *       information about the caching of files and metadata, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-caching">File Caching</a>.
     * 
     * When <b>FILE_FLAG_NO_BUFFERING</b> is combined with 
     *       <b>FILE_FLAG_OVERLAPPED</b>, the flags give maximum asynchronous performance, because the I/O 
     *       does not rely on the synchronous operations of the memory manager. However, some I/O operations take more time, 
     *       because data is not being held in the cache. Also, the file metadata may still be cached (for example, when 
     *       creating an empty file). To ensure that the metadata is flushed to disk, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function.
     * 
     * Specifying the <b>FILE_ATTRIBUTE_TEMPORARY</b> attribute causes file systems to avoid 
     *       writing data back to mass storage if sufficient cache memory is available, because an application deletes a 
     *       temporary file after a handle is closed. In that case, the system can entirely avoid writing the data. Although 
     *       it does not directly control data caching in the same way as the previously mentioned flags, the 
     *       <b>FILE_ATTRIBUTE_TEMPORARY</b> attribute does tell the system to hold as much as possible in 
     *       the system cache without writing and therefore may be of concern for certain applications.
     * 
     * <h3><a id="Files"></a><a id="files"></a><a id="FILES"></a>Files</h3>
     * If you rename or delete a file and then restore it shortly afterward, the system searches the cache for file 
     *       information to restore. Cached information includes its short/long name pair and creation time.
     * 
     * If you call <b>CreateFile</b> on a file that is pending deletion 
     *       as a result of a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>, the function 
     *       fails. The operating system delays file deletion until all handles to the file are closed. 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The <i>dwDesiredAccess</i> parameter can be zero, allowing the application to query file 
     *       attributes without accessing the file if the application is running with adequate security settings. This is 
     *       useful to test for the existence of a file without opening it for read and/or write access, or to obtain other 
     *       statistics about the file or directory. See 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-and-setting-file-information">Obtaining and Setting File Information</a> 
     *       and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>.
     * 
     * If <b>CREATE_ALWAYS</b> and <b>FILE_ATTRIBUTE_NORMAL</b> are 
     *       specified, <b>CreateFile</b> fails and sets the last error to 
     *       <b>ERROR_ACCESS_DENIED</b> if the file exists and has the 
     *       <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_SYSTEM</b> attribute. 
     *       To avoid the error, specify the same attributes as the existing file.
     * 
     * When an application creates a file across a network, it is better to use 
     *       <c>GENERIC_READ | GENERIC_WRITE</c> for 
     *       <i>dwDesiredAccess</i> than to use <b>GENERIC_WRITE</b> alone. The 
     *       resulting code is faster, because the redirector can use the cache manager and send fewer SMBs with more data. 
     *       This combination also avoids an issue where writing to a file across a network can occasionally return 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * <h3><a id="synchronous_and_asynchronous_i_o_handles"></a><a id="SYNCHRONOUS_AND_ASYNCHRONOUS_I_O_HANDLES"></a>Synchronous and Asynchronous I/O Handles</h3>
     * <b>CreateFile</b> provides for creating a file or device handle 
     *       that is either synchronous or asynchronous. A synchronous handle behaves such that I/O function calls using that 
     *       handle are blocked until they complete, while an asynchronous file handle makes it possible for the system to 
     *       return immediately from I/O function calls, whether they completed the I/O operation or not. As stated 
     *       previously, this synchronous versus asynchronous behavior is determined by specifying 
     *       <b>FILE_FLAG_OVERLAPPED</b> within the <i>dwFlagsAndAttributes</i> 
     *       parameter. There are several complexities and potential pitfalls when using asynchronous I/O; for more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * <h3><a id="File_Streams"></a><a id="file_streams"></a><a id="FILE_STREAMS"></a>File Streams</h3>
     * On NTFS file systems, you can use <b>CreateFile</b> to create 
     *       separate streams within a file. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <h3><a id="Directories"></a><a id="directories"></a><a id="DIRECTORIES"></a>Directories</h3>
     * An application cannot create a directory by using 
     *       <b>CreateFile</b>, therefore only the 
     *       <b>OPEN_EXISTING</b> value is valid for 
     *       <i>dwCreationDisposition</i> for this use case. To create a directory, the application must 
     *       call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>.
     * 
     * To open a directory using <b>CreateFile</b>, specify the 
     *       <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag as part of 
     *       <i>dwFlagsAndAttributes</i>. Appropriate security checks still apply when this flag is used 
     *       without <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges.
     * 
     * When using <b>CreateFile</b> to open a directory during 
     *       defragmentation of a FAT or FAT32 file system volume, do not specify the 
     *       <b>MAXIMUM_ALLOWED</b> access right. Access to the directory is denied if this is done. 
     *       Specify the <b>GENERIC_READ</b> access right instead.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-directory-management">About Directory Management</a>.
     * 
     * <h3><a id="Physical_Disks_and_Volumes"></a><a id="physical_disks_and_volumes"></a><a id="PHYSICAL_DISKS_AND_VOLUMES"></a>Physical Disks and Volumes</h3>
     * Direct access to the disk or to a volume is restricted. 
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>Direct access to the disk or to a volume is not restricted in this manner.
     * 
     * You can use the <b>CreateFile</b> function to open a physical 
     *       disk drive or a volume, which returns a direct access storage device (DASD) handle that can be used with the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function. This enables you to access 
     *       the disk or volume directly, for example such disk metadata as the partition table. However, this type of access 
     *       also exposes the disk drive or volume to potential data loss, because an incorrect write to a disk using this 
     *       mechanism could make its contents inaccessible to the operating system. To ensure data integrity, be sure to 
     *       become familiar with <b>DeviceIoControl</b> and how other 
     *       APIs behave differently with a direct access handle as opposed to a file system handle.
     * 
     * The following requirements must be met for such a call to succeed:
     * 
     * <ul>
     * <li>The caller must have administrative privileges. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</li>
     * <li>The <i>dwCreationDisposition</i> parameter must have the 
     *       <b>OPEN_EXISTING</b> flag.</li>
     * <li>When opening a volume or floppy disk, the <i>dwShareMode</i> parameter must have the 
     *       <b>FILE_SHARE_WRITE</b> flag.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  The <i>dwDesiredAccess</i> parameter can be zero, allowing the application to query 
     *       device attributes without accessing a device. This is useful for an application to determine the size of a 
     *       floppy disk drive and the formats it supports without requiring a floppy disk in a drive, for instance. It can 
     *       also be used for reading statistics without requiring higher-level data read/write permission.</div>
     * <div> </div>
     * When opening a physical drive <i>x</i>:, the 
     *       <i>lpFileName</i> string should be the following form: 
     *       "\\.\PhysicalDrive<i>X</i>". Hard disk numbers 
     *       start at zero. The following table shows some examples of physical drive strings.
     * 
     * <table>
     * <tr>
     * <th>String</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>"\\.\PhysicalDrive0"</td>
     * <td>Opens the first physical drive.</td>
     * </tr>
     * <tr>
     * <td>"\\.\PhysicalDrive2"</td>
     * <td>Opens the third physical drive.</td>
     * </tr>
     * </table>
     *  
     * 
     * To obtain the physical drive identifier for a volume, open a handle to the volume and call the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a>. 
     *       This control code returns the disk number and offset for each of the volume's one or more extents; a volume can 
     *       span multiple physical disks.
     * 
     * For an example of opening a physical drive, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/DevIO/calling-deviceiocontrol">Calling DeviceIoControl</a>.
     * 
     * When opening a volume or removable media drive (for example, a floppy disk drive or flash memory thumb drive), 
     *       the <i>lpFileName</i> string should be the following form: 
     *       "\\.&#92;<i>X</i>:". Do not use a trailing backslash 
     *       (\\), which indicates the root directory of a drive. The following table shows some examples of drive strings.
     * 
     * <table>
     * <tr>
     * <th>String</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>"\\.\A:"</td>
     * <td>Opens floppy disk drive A.</td>
     * </tr>
     * <tr>
     * <td>"\\.\C:"</td>
     * <td>Opens the C: volume.</td>
     * </tr>
     * <tr>
     * <td>"\\.\C:\"</td>
     * <td>Opens the file system of the C: volume.</td>
     * </tr>
     * </table>
     *  
     * 
     * You can also open a volume by referring to its volume name. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * 
     * A volume contains one or more mounted file systems. Volume handles can be opened as noncached at the 
     *       discretion of the particular file system, even when the noncached option is not specified in 
     *       <b>CreateFile</b>. You should assume that all Microsoft file 
     *       systems open volume handles as noncached. The restrictions on noncached I/O for files also apply to volumes.
     * 
     * A file system may or may not require buffer alignment even though the data is noncached. However, if the 
     *       noncached option is specified when opening a volume, buffer alignment is enforced regardless of the file system 
     *       on the volume. It is recommended on all file systems that you open volume handles as noncached, and follow the 
     *       noncached I/O restrictions.
     * 
     * <div class="alert"><b>Note</b>  To read or write to the last few sectors of the volume, you must call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> and specify 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>. This signals 
     *       the file system driver not to perform any I/O boundary checks on partition read or write calls. Instead, 
     *       boundary checks are performed by the device driver.</div>
     * <div> </div>
     * <h3><a id="Changer_Device"></a><a id="changer_device"></a><a id="CHANGER_DEVICE"></a>Changer Device</h3>
     * The <b>IOCTL_CHANGER_*</b> control codes for 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> accept a handle to a changer device. 
     *       To open a changer device, use a file name of the following form: 
     *       "\\.\Changer<i>x</i>" where 
     *       <i>x</i> is a number that indicates which device to open, starting with zero. To open 
     *       changer device zero in an application that is written in C or C++, use the following file name: 
     *       "\\\\.\\Changer0".
     * 
     * <h3><a id="Tape_Drives"></a><a id="tape_drives"></a><a id="TAPE_DRIVES"></a>Tape Drives</h3>
     * You can open tape drives by using a file name of the following form: 
     *       "\\.\TAPE<i>x</i>" where 
     *       <i>x</i> is a number that indicates which drive to open, starting with tape drive zero. To 
     *       open tape drive zero in an application that is written in C or C++, use the following file name: 
     *       "\\\\.\\TAPE0".
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/Backup/backup">Backup</a>.
     * 
     * <h3><a id="Communications_Resources"></a><a id="communications_resources"></a><a id="COMMUNICATIONS_RESOURCES"></a>Communications Resources</h3>
     * The <b>CreateFile</b> function can create a handle to a 
     *       communications resource, such as the serial port COM1. For communications resources, 
     *       the <i>dwCreationDisposition</i> parameter must be 
     *       <b>OPEN_EXISTING</b>, the <i>dwShareMode</i> parameter must be zero 
     *       (exclusive access), and the <i>hTemplateFile</i> parameter must be 
     *       <b>NULL</b>. Read, write, or read/write access can be specified, and the handle can be opened 
     *       for overlapped I/O.
     * 
     * To specify a COM port number greater than 9, use the following syntax: 
     *       "\\.\COM10". This syntax works for all port numbers and hardware that 
     *       allows COM port numbers to be specified.
     * 
     * For more information about communications, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/DevIO/communications-resources">Communications</a>.
     * 
     * <h3><a id="Consoles"></a><a id="consoles"></a><a id="CONSOLES"></a>Consoles</h3>
     * The <b>CreateFile</b> function can create a handle to console 
     *       input (CONIN$). If the process has an open handle to it as a result of inheritance or 
     *       duplication, it can also create a handle to the active screen buffer (CONOUT$). The 
     *       calling process must be attached to an inherited console or one allocated by the 
     *       <a href="https://docs.microsoft.com/windows/console/allocconsole">AllocConsole</a> function. For console handles, set the 
     *       <b>CreateFile</b> parameters as follows.
     * 
     * <table>
     * <tr>
     * <th>Parameters</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td>
     * <i>lpFileName</i>
     * 
     * </td>
     * <td>
     * Use the CONIN$ value to specify console input.
     * 
     * Use the CONOUT$ value to specify console output.
     * 
     * CONIN$ gets a handle to the console input buffer, even if the 
     *          <a href="https://docs.microsoft.com/windows/console/setstdhandle">SetStdHandle</a> function redirects the standard input 
     *          handle. To get the standard input handle, use the 
     *          <a href="https://docs.microsoft.com/windows/console/getstdhandle">GetStdHandle</a> function.
     * 
     * CONOUT$ gets a handle to the active screen buffer, even if 
     *          <a href="https://docs.microsoft.com/windows/console/setstdhandle">SetStdHandle</a> redirects the standard output handle. To 
     *          get the standard output handle, use <a href="https://docs.microsoft.com/windows/console/getstdhandle">GetStdHandle</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwDesiredAccess</i>
     * 
     * </td>
     * <td>
     * <c>GENERIC_READ | GENERIC_WRITE</c> is preferred, but either one can 
     *          limit access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwShareMode</i>
     * 
     * </td>
     * <td>
     * When opening CONIN$, specify 
     *          <b>FILE_SHARE_READ</b>. When opening CONOUT$, specify 
     *          <b>FILE_SHARE_WRITE</b>.
     * 
     * If the calling process inherits the console, or if a child process should be able to access the console, 
     *          this parameter must be <c>FILE_SHARE_READ | FILE_SHARE_WRITE</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>lpSecurityAttributes</i>
     * 
     * </td>
     * <td>
     * If you want the console to be inherited, the <b>bInheritHandle</b> member of the 
     *          <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure 
     *          must be <b>TRUE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwCreationDisposition</i>
     * 
     * </td>
     * <td>
     * You should specify <b>OPEN_EXISTING</b> when using 
     *          <b>CreateFile</b> to open the console.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwFlagsAndAttributes</i>
     * 
     * </td>
     * <td>
     * Ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>hTemplateFile</i>
     * 
     * </td>
     * <td>
     * Ignored.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following table shows various settings of <i>dwDesiredAccess</i> and 
     *       <i>lpFileName</i>.
     * 
     * <table>
     * <tr>
     * <th><i>lpFileName</i></th>
     * <th><i>dwDesiredAccess</i></th>
     * <th>Result</th>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><b>GENERIC_READ</b></td>
     * <td>Opens console for input.</td>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><b>GENERIC_WRITE</b></td>
     * <td>Opens console for output.</td>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><c>GENERIC_READ | GENERIC_WRITE</c></td>
     * <td>Causes <b>CreateFile</b> to fail; 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *         <b>ERROR_FILE_NOT_FOUND</b>.</td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Mailslots"></a><a id="mailslots"></a><a id="MAILSLOTS"></a>Mailslots</h3>
     * If <b>CreateFile</b> opens the client end of a mailslot, the 
     *       function returns <b>INVALID_HANDLE_VALUE</b> if the mailslot client attempts to open a local 
     *       mailslot before the mailslot server has created it with the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot</a> function.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/ipc/mailslots">Mailslots</a>.
     * 
     * <h3><a id="Pipes"></a><a id="pipes"></a><a id="PIPES"></a>Pipes</h3>
     * If <b>CreateFile</b> opens the client end of a named pipe, the 
     *       function uses any instance of the named pipe that is in the listening state. The opening process can duplicate 
     *       the handle as many times as required, but after it is opened, the named pipe instance cannot be opened by 
     *       another client. The access that is specified when a pipe is opened must be compatible with the access that is 
     *       specified in the <i>dwOpenMode</i> parameter of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.
     * 
     * If the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function was not 
     *       successfully called on the server prior to this operation, a pipe will not exist and 
     *       <b>CreateFile</b> will fail with 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * 
     * If there is at least one active pipe instance but there are no available listener pipes on the server, which 
     *       means all pipe instances are currently connected, 
     *      <b>CreateFile</b> fails with 
     *      <b>ERROR_PIPE_BUSY</b>.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/ipc/pipes">Pipes</a>.
     * @param {Pointer<Char>} lpFileName The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     * To extend this limit to 32,767 wide characters, use this Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * For information on special device names, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are <b>GENERIC_READ</b>, 
     *        <b>GENERIC_WRITE</b>, or both 
     *        (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device 
     *        attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would 
     *        have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the 
     *        <i>dwShareMode</i> parameter in an open request that already has an open handle.
     * 
     * For more information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or 
     *        none (refer to the following table). Access requests to attributes or extended attributes are not affected by 
     *        this flag.
     * 
     * If this parameter is zero and <b>CreateFile</b> succeeds, the 
     *        file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. 
     *        For more information, see the Remarks section.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an existing 
     *        request that has an open handle. <b>CreateFile</b> would fail and 
     *        the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return 
     *        <b>ERROR_SHARING_VIOLATION</b>.
     * 
     * To enable a process to share a file or device while another process has the file or device open, use a
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains two separate but related data members: an optional security descriptor, and a Boolean 
     *        value that determines whether the returned handle can be inherited by child processes.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If this parameter is <b>NULL</b>, the handle returned by 
     *        <b>CreateFile</b> cannot be inherited by any child processes the 
     *        application may create and the file or device associated with the returned handle gets a default security 
     *        descriptor.
     * 
     * The <b>lpSecurityDescriptor</b> member of the structure specifies a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> for a file or device. If 
     *        this member is <b>NULL</b>, the file or device associated with the returned handle is 
     *        assigned a default security descriptor.
     * 
     * <b>CreateFile</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file or device, but continues 
     *        to use the <b>bInheritHandle</b> member.
     * 
     * The <b>bInheritHandle</b> member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     * 
     * For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwFlagsAndAttributes The file or device attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most 
     *        common default value for files.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of 
     *        file or device caching behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  When <b>CreateFile</b> opens an existing file, it generally 
     *        combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied 
     *        as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.</div>
     * <div> </div>
     * Some of the following file attributes and flags may only apply to files and not necessarily all other types 
     *        of devices that <b>CreateFile</b> can open. For additional 
     *        information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * For more advanced access to file attributes, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list 
     *        of all file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the calling 
     *          process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and 
     *          <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after all of its handles are closed, which includes the specified 
     *          handle and any other open or duplicated handles.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with no system caching for data reads and writes. This flag does not 
     *          affect hard disk caching or memory mapped files.
     * 
     * There are strict requirements for successfully working with files opened with 
     *          <b>CreateFile</b> using the 
     *          <b>FILE_FLAG_NO_BUFFERING</b> flag, for details see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not 
     *          occur; <b>CreateFile</b> will attempt to open the reparse 
     *          point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse 
     *          point is operational.
     * 
     * This flag cannot be used with the <b>CREATE_ALWAYS</b> flag.
     * 
     * If the file is not a reparse point, then this flag is ignored.
     * 
     * For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened or created for asynchronous I/O.
     * 
     * When subsequent I/O operations are completed on this handle, the event specified in the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the 
     *          signaled state.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * For information about considerations when using a file handle created with this flag, see the 
     *          <a href="#synchronous_and_asynchronous_i_o_handles">Synchronous and Asynchronous I/O Handles</a> 
     *          section of this topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access will occur according to POSIX rules. This includes allowing multiple files with names, differing 
     *          only in case, for file systems that support that naming. Use care when using this option, because files 
     *          created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be random. The system can use this as a hint to optimize file caching.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize 
     *          file caching.
     * 
     * This flag should not be used if read-behind (that is, reverse scans) will be used.
     * 
     * This flag has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * For more information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * For additional information, see the <a href="#caching_behavior">Caching Behavior</a> section of this 
     *          topic.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i> parameter can also specify SQOS information. For more 
     *        information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the 
     *        calling application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {Pointer<Void>} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * When opening an existing file, <b>CreateFile</b> ignores this 
     *        parameter.
     * 
     * When opening a new encrypted file, the file inherits the discretionary access control list from its parent 
     *        directory. For additional information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfilew
     * @since windows5.1.2600
     */
    static CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Defines, redefines, or deletes MS-DOS device names. (DefineDosDeviceW)
     * @remarks
     * MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path 
     *     into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The 
     *     <b>DefineDosDevice</b> function enables an application to modify the junctions used to 
     *     implement the MS-DOS device namespace.
     * 
     * To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices 
     *     known to the system, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-querydosdevicew">QueryDosDevice</a> 
     *     function.
     * 
     * To define a drive letter assignment that is persistent across boots and not a network share, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setvolumemountpointa">SetVolumeMountPoint</a> function. If the volume to 
     *     be mounted already has a drive letter assigned to it, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletevolumemountpointw">DeleteVolumeMountPoint</a> function to remove the 
     *     assignment.
     * 
     * Drive letters and device names defined at system boot time are protected from redefinition and deletion unless 
     *     the user is an administrator.
     * 
     * Starting with Windows XP, this function creates a device name for a caller that is not running in 
     *     the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in 
     *     the "LocalSystem" context, the function creates the device name in the Global MS-DOS device 
     *     namespace. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.
     * @param {Integer} dwFlags The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
     * @param {Pointer<Char>} lpDeviceName A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or 
     *       deleting. The device name string must not have a colon as the last character, unless a drive letter is being 
     *       defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a 
     *       trailing backslash (\\) allowed.
     * @param {Pointer<Char>} lpTargetPath A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the 
     *       <b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path 
     *       string.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-definedosdevicew
     * @since windows5.1.2600
     */
    static DefineDosDeviceW(dwFlags, lpDeviceName, lpTargetPath) {
        lpDeviceName := lpDeviceName is String? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DefineDosDeviceW", "uint", dwFlags, "ptr", lpDeviceName, "ptr", lpTargetPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file. (DeleteFileA)
     * @remarks
     * If an application attempts to delete a file that does not exist, the 
     *     <b>DeleteFile</b> function fails with 
     *     <b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with 
     *     <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The following list identifies some tips for deleting, removing, or closing files:
     *    
     * 
     * <ul>
     * <li>To delete a read-only file, first you must remove the read-only attribute.</li>
     * <li>To delete or rename a file, you must have either delete permission on the file, or delete child permission 
     *       in the parent directory.</li>
     * <li>To recursively delete the files in a directory, use the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> function.</li>
     * <li>To remove an empty directory, use the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> function.</li>
     * <li>To close an open file, use the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function.</li>
     * </ul>
     * If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of 
     *      new files are inherited, then you can create a file without being able to delete it. However, then you can create 
     *      a file, and then get all the access you request on the handle that is returned to you at the time you create the 
     *      file.
     * 
     * If you request delete permission at the time you create a file, you can delete or rename the file with that 
     *      handle, but not with any other handle. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * The <b>DeleteFile</b> function fails if an application attempts 
     *     to delete a file that has other handles open for normal I/O or as a memory-mapped file 
     *     (<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).
     * 
     * The <b>DeleteFile</b> function marks a file for deletion on 
     *     close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls 
     *     to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> to open the file fail with 
     *     <b>ERROR_ACCESS_DENIED</b>.
     * 
     * Symbolic link behavior—
     * 
     * If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you 
     *      must call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> and specify 
     *      <b>FILE_FLAG_DELETE_ON_CLOSE</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-deletefilea
     * @since windows5.1.2600
     */
    static DeleteFileA(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileA", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file. (DeleteFileW)
     * @remarks
     * If an application attempts to delete a file that does not exist, the 
     *     <b>DeleteFile</b> function fails with 
     *     <b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with 
     *     <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The following list identifies some tips for deleting, removing, or closing files:
     *    
     * 
     * <ul>
     * <li>To delete a read-only file, first you must remove the read-only attribute.</li>
     * <li>To delete or rename a file, you must have either delete permission on the file, or delete child permission 
     *       in the parent directory.</li>
     * <li>To recursively delete the files in a directory, use the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> function.</li>
     * <li>To remove an empty directory, use the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> function.</li>
     * <li>To close an open file, use the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function.</li>
     * </ul>
     * If you set up a directory with all access except delete and delete child, and the access control lists (ACL) of 
     *      new files are inherited, then you can create a file without being able to delete it. However, then you can create 
     *      a file, and then get all the access you request on the handle that is returned to you at the time you create the 
     *      file.
     * 
     * If you request delete permission at the time you create a file, you can delete or rename the file with that 
     *      handle, but not with any other handle. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * The <b>DeleteFile</b> function fails if an application attempts 
     *     to delete a file that has other handles open for normal I/O or as a memory-mapped file 
     *     (<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).
     * 
     * The <b>DeleteFile</b> function marks a file for deletion on 
     *     close. Therefore, the file deletion does not occur until the last handle to the file is closed. Subsequent calls 
     *     to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> to open the file fail with 
     *     <b>ERROR_ACCESS_DENIED</b>.
     * 
     * Symbolic link behavior—
     * 
     * If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you 
     *      must call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> and specify 
     *      <b>FILE_FLAG_DELETE_ON_CLOSE</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>DeleteFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-deletefilew
     * @since windows5.1.2600
     */
    static DeleteFileW(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileW", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes a drive letter or mounted folder. (DeleteVolumeMountPointW)
     * @remarks
     * Deleting a mounted folder does not cause the underlying directory to be deleted.
     * 
     * If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder, 
     *     the function does nothing. The directory is not deleted.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.
     * @param {Pointer<Char>} lpszVolumeMountPoint The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, 
     *       "X:\" or "Y:\MountX\".
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-deletevolumemountpointw
     * @since windows5.1.2600
     */
    static DeleteVolumeMountPointW(lpszVolumeMountPoint) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteVolumeMountPointW", "ptr", lpszVolumeMountPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a file time to a local file time.
     * @remarks
     * To account for daylight saving time when converting a file time to a local time, use the following sequence of functions in place of using <b>FileTimeToLocalFileTime</b>:
     *     
     *                 
     * 
     * <ol>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/timezoneapi/nf-timezoneapi-filetimetosystemtime">FileTimeToSystemTime</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/timezoneapi/nf-timezoneapi-systemtimetotzspecificlocaltime">SystemTimeToTzSpecificLocalTime</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/timezoneapi/nf-timezoneapi-systemtimetofiletime">SystemTimeToFileTime</a>
     * </li>
     * </ol>
     * @param {Pointer<FILETIME>} lpFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure containing the UTC-based file time to be converted into a local file time.
     * @param {Pointer<FILETIME>} lpLocalFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the converted local file time. This parameter cannot be the same as the <i>lpFileTime</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-filetimetolocalfiletime
     * @since windows5.1.2600
     */
    static FileTimeToLocalFileTime(lpFileTime, lpLocalFileTime) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FileTimeToLocalFileTime", "ptr", lpFileTime, "ptr", lpLocalFileTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW, FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
     * @remarks
     * After the <b>FindClose</b> function is called, the handle 
     *     specified by the <i>hFindFile</i> parameter cannot be used in subsequent calls to the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilenamew">FindNextFileNameW</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a>, or 
     *     <b>FindClose</b> functions.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFindFile The file search handle.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findclose
     * @since windows5.1.2600
     */
    static FindClose(hFindFile) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindClose", "ptr", hFindFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Stops change notification handle monitoring.
     * @remarks
     * After the <b>FindCloseChangeNotification</b> function is called, the handle 
     *     specified by the <i>hChangeHandle</i> parameter cannot be used in subsequent calls to either the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextchangenotification">FindNextChangeNotification</a> or 
     * <b>FindCloseChangeNotification</b> function.
     * 
     * Change notifications can also be used in the 
     * <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">wait functions</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * See remark
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Application might experience false positives on CsvFs pause/resume.
     * @param {Pointer<Void>} hChangeHandle A handle to a change notification handle created by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findclosechangenotification
     * @since windows5.1.2600
     */
    static FindCloseChangeNotification(hChangeHandle) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindCloseChangeNotification", "ptr", hChangeHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a change notification handle and sets up initial change notification filter conditions. (ANSI)
     * @remarks
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the 
     * <b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.
     * 
     * After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextchangenotification">FindNextChangeNotification</a> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclosechangenotification">FindCloseChangeNotification</a> function.
     * 
     * Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system. 
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.
     * 
     * If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * See remark
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Application might experience false positives on CsvFs pause/resume.
     * @param {Pointer<Byte>} lpPathName The full path of the directory to be watched. 
     * 
     * 
     * This cannot be a relative path or an empty string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Integer} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.
     * @param {Integer} dwNotifyFilter 
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to a find change notification object.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstchangenotificationa
     * @since windows5.1.2600
     */
    static FindFirstChangeNotificationA(lpPathName, bWatchSubtree, dwNotifyFilter) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstChangeNotificationA", "ptr", lpPathName, "int", bWatchSubtree, "uint", dwNotifyFilter)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a change notification handle and sets up initial change notification filter conditions. (Unicode)
     * @remarks
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">wait functions</a> can monitor the specified directory or subtree by using the handle returned by the 
     * <b>FindFirstChangeNotification</b> function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.
     * 
     * After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextchangenotification">FindNextChangeNotification</a> function and the appropriate wait function. When the handle is no longer needed, it can be closed by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclosechangenotification">FindCloseChangeNotification</a> function.
     * 
     * Notifications may not be returned when calling <b>FindFirstChangeNotification</b> for a remote file system. 
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the notification handle is created for the target.
     * 
     * If an application has registered to receive change notifications for a directory that contains symbolic links, the application is only notified when the symbolic links have been changed, not the target files.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * See remark
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Application might experience false positives on CsvFs pause/resume.
     * @param {Pointer<Char>} lpPathName The full path of the directory to be watched. 
     * 
     * 
     * This cannot be a relative path or an empty string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Integer} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the specified directory; if it is <b>FALSE</b>, it monitors only the specified directory.
     * @param {Integer} dwNotifyFilter 
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to a find change notification object.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstchangenotificationw
     * @since windows5.1.2600
     */
    static FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstChangeNotificationW", "ptr", lpPathName, "int", bWatchSubtree, "uint", dwNotifyFilter)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used). (ANSI)
     * @remarks
     * The <b>FindFirstFile</b> function opens a search handle and 
     *     returns information about the first file that the file system finds with a name that matches the specified 
     *     pattern. This may or may not be the first file or directory that appears in a directory-listing application (such 
     *     as the dir command) when given the same file name string pattern. This is because 
     *     <b>FindFirstFile</b> does no sorting of the search results. For 
     *     additional information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.
     * 
     * The following list identifies some other search characteristics:
     * 
     * <ul>
     * <li>The search is performed strictly on the name of the file, not on any attributes such as a date or a file 
     *       type (for other options, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a>).</li>
     * <li>The search includes the long and short file names.</li>
     * <li>An attempt to open a search with a trailing backslash always fails.</li>
     * <li>Passing an invalid string, <b>NULL</b>, or empty string for the 
     *       <i>lpFileName</i> parameter is not a valid use of this function. Results in this case are 
     *       undefined.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be 
     *     current at the time this function is called. To be assured of getting the current NTFS file system file 
     *     attributes, call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * After the search handle is established, you can use it to search for other files that match the same pattern 
     *     by using the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> function.
     * 
     * When the search handle is no longer needed, close it by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function, not 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a>.
     * 
     * As stated previously, you cannot use a trailing backslash (\\) in the <i>lpFileName</i> 
     *     input string for <b>FindFirstFile</b>, therefore it may not be 
     *     obvious how to search root directories. If you want to see files or get the attributes of a root directory, the 
     *     following options would apply:
     * 
     * <ul>
     * <li>To examine files in a root directory, you can use "C:\*" and step through the 
     *       directory by using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.</li>
     * <li>To get the attributes of a root directory, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Prepending the string "\\?\" does not allow access to the root 
     *      directory.</div>
     * <div> </div>
     * 
     * On network shares, you can use an <i>lpFileName</i> in the form of the following: 
     *     "\\\\Server\\Share\\*". However, you cannot use an <i>lpFileName</i> 
     *     that points to the share itself; for example, "\\\\Server\\Share" is not valid.
     * 
     * To examine a directory that is not a root directory, use the path to that directory, without a trailing 
     *     backslash. For example, an argument of "C:\\Windows" returns information about the 
     *     directory "C:\\Windows", not about a directory or file in 
     *     "C:\\Windows". To examine the files and directories in 
     *     "C:\\Windows", use an <i>lpFileName</i> of 
     *     "C:\\Windows\\*".
     * 
     * Be aware that some other thread or process could create or delete a file with this name between the time you 
     *     query for the result and the time you act on the information. If this is a potential concern for your application, 
     *     one possible solution is to use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with 
     *     <b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b> 
     *     (which fails if the file does not exist).
     * 
     * If you are writing a 32-bit application to list all the files in a directory and the application may be  run 
     *     on a 64-bit computer, you should call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a> function 
     *     before calling <b>FindFirstFile</b> and call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> after the 
     *     last call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> buffer contains information about 
     *     the symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to 
     *        the root and all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<WIN32_FIND_DATAA>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *       receives information about a found file or directory.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no matching files can be found, the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstfilea
     * @since windows5.1.2600
     */
    static FindFirstFileA(lpFileName, lpFindFileData) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileA", "ptr", lpFileName, "ptr", lpFindFileData)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used). (Unicode)
     * @remarks
     * The <b>FindFirstFile</b> function opens a search handle and 
     *     returns information about the first file that the file system finds with a name that matches the specified 
     *     pattern. This may or may not be the first file or directory that appears in a directory-listing application (such 
     *     as the dir command) when given the same file name string pattern. This is because 
     *     <b>FindFirstFile</b> does no sorting of the search results. For 
     *     additional information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilew">FindNextFile</a>.
     * 
     * The following list identifies some other search characteristics:
     * 
     * <ul>
     * <li>The search is performed strictly on the name of the file, not on any attributes such as a date or a file 
     *       type (for other options, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexw">FindFirstFileEx</a>).</li>
     * <li>The search includes the long and short file names.</li>
     * <li>An attempt to open a search with a trailing backslash always fails.</li>
     * <li>Passing an invalid string, <b>NULL</b>, or empty string for the 
     *       <i>lpFileName</i> parameter is not a valid use of this function. Results in this case are 
     *       undefined.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be 
     *     current at the time this function is called. To be assured of getting the current NTFS file system file 
     *     attributes, call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * After the search handle is established, you can use it to search for other files that match the same pattern 
     *     by using the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilew">FindNextFile</a> function.
     * 
     * When the search handle is no longer needed, close it by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function, not 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a>.
     * 
     * As stated previously, you cannot use a trailing backslash (\\) in the <i>lpFileName</i> 
     *     input string for <b>FindFirstFile</b>, therefore it may not be 
     *     obvious how to search root directories. If you want to see files or get the attributes of a root directory, the 
     *     following options would apply:
     * 
     * <ul>
     * <li>To examine files in a root directory, you can use "C:\*" and step through the 
     *       directory by using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilew">FindNextFile</a>.</li>
     * <li>To get the attributes of a root directory, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw">GetFileAttributes</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Prepending the string "\\?\" does not allow access to the root 
     *      directory.</div>
     * <div> </div>
     * 
     * On network shares, you can use an <i>lpFileName</i> in the form of the following: 
     *     "\\\\Server\\Share\\*". However, you cannot use an <i>lpFileName</i> 
     *     that points to the share itself; for example, "\\\\Server\\Share" is not valid.
     * 
     * To examine a directory that is not a root directory, use the path to that directory, without a trailing 
     *     backslash. For example, an argument of "C:\\Windows" returns information about the 
     *     directory "C:\\Windows", not about a directory or file in 
     *     "C:\\Windows". To examine the files and directories in 
     *     "C:\\Windows", use an <i>lpFileName</i> of 
     *     "C:\\Windows\\*".
     * 
     * Be aware that some other thread or process could create or delete a file with this name between the time you 
     *     query for the result and the time you act on the information. If this is a potential concern for your application, 
     *     one possible solution is to use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilew">CreateFile</a> function with 
     *     <b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b> 
     *     (which fails if the file does not exist).
     * 
     * If you are writing a 32-bit application to list all the files in a directory and the application may be  run 
     *     on a 64-bit computer, you should call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a> function 
     *     before calling <b>FindFirstFile</b> and call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> after the 
     *     last call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilew">FindNextFile</a>. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataw">WIN32_FIND_DATA</a> buffer contains information about 
     *     the symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access permissions to 
     *        the root and all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<WIN32_FIND_DATAW>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *       receives information about a found file or directory.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilew">FindNextFile</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no matching files can be found, the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstfilew
     * @since windows5.1.2600
     */
    static FindFirstFileW(lpFileName, lpFindFileData) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileW", "ptr", lpFileName, "ptr", lpFindFileData)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name and attributes that match those specified. (FindFirstFileExA)
     * @remarks
     * The <b>FindFirstFileEx</b> function opens a search handle 
     *     and returns information about the first file that the file system finds with a name that matches the specified 
     *     pattern. This may or may not be the first file or directory that appears in a directory-listing application (such 
     *     as the dir command) when given the same file name string pattern. This is because 
     *     <b>FindFirstFileEx</b> does no sorting of the search results. 
     *     For additional information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.
     * 
     * The following list identifies some other search characteristics:
     * 
     * <ul>
     * <li>The search is performed strictly on the name of the file, not on any attributes such as a date or a file 
     *       type.</li>
     * <li>The search includes the long and short file names.</li>
     * <li>An attempt to open a search with a trailing backslash always fails.</li>
     * <li>Passing an invalid string, <b>NULL</b>, or empty string for the 
     *       <i>lpFileName</i> parameter is not a valid use of this function. Results in this case are 
     *       undefined.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be 
     *      current at the time this function is called. To be assured of getting the current NTFS file system file 
     *      attributes, call the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * If the underlying file system does not support the specified type of filtering, other than directory 
     *     filtering, <b>FindFirstFileEx</b> fails with the error 
     *     <b>ERROR_NOT_SUPPORTED</b>. The application must use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> type 
     *     <b>FileExSearchNameMatch</b> and perform its own filtering.
     * 
     * After the search handle is established, use it in the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> function to search for other 
     *     files that match the same pattern with the same filtering that is being performed. When the search handle is not 
     *     needed, it should be closed by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * As stated previously, you cannot use a trailing backslash (\\) in the <i>lpFileName</i> 
     *     input string for <b>FindFirstFileEx</b>, therefore it may not 
     *     be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the 
     *     following options would apply:
     * 
     * <ul>
     * <li>To examine files in a root directory, you can use "C:\*" and step through the directory by 
     *       using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.</li>
     * <li>To get the attributes of a root directory, use 
     *       the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.</div>
     * <div> </div>
     * 
     * On network shares, you can use an <i>lpFileName</i> in the form of the following: 
     *     "\\\\server\\service\\*". However, you cannot use an <i>lpFileName</i> that points 
     *     to the share itself; for example, "\\\\server\\service" is not valid.
     * 
     * To examine a directory that is not a root directory, use the path to that directory, without a trailing 
     *     backslash. For example, an argument of "C:\\Windows" returns information about the 
     *     directory "C:\\Windows", not about a directory or file in 
     *     "C:\\Windows". To examine the files and directories in 
     *     "C:\\Windows", use an <i>lpFileName</i> of 
     *     "C:\\Windows\\*".
     * 
     * The following call:
     * 
     * 
     * ```cpp
     * FindFirstFileEx( lpFileName, 
     *                  FindExInfoStandard, 
     *                  lpFindData, 
     *                  FindExSearchNameMatch, 
     *                  NULL, 
     *                  0 );
     * ```
     * 
     * 
     * Is equivalent to the following call:
     * 
     * 
     * ```cpp
     * FindFirstFile( lpFileName, lpFindData );
     * ```
     * 
     * 
     * Be aware that some other thread or process could create or delete a file with this name between the time you 
     *     query for the result and the time you act on the information. If this is a potential concern for your application, 
     *     one possible solution is to use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with 
     *     <b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b> 
     *     (which fails if the file does not exist).
     * 
     * If you are writing a 32-bit application to list all the files in a directory and the application may be run on 
     *     a 64-bit computer, you should call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a> before 
     *     calling <b>FindFirstFileEx</b> and call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> after the 
     *     last call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> buffer contains information about 
     *     the symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all 
     *        subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and 
     *        prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the buffer that receives the file data.
     *       
     * 
     * The pointer type is determined by the level of information that is specified in the 
     *        <i>fInfoLevelId</i> parameter.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_LARGE_FETCH"></a><a id="find_first_ex_large_fetch"></a><dl>
     * <dt><b>FIND_FIRST_EX_LARGE_FETCH</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses a larger buffer for directory queries, which can increase performance of the find operation.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY"></a><a id="find_first_ex_on_disk_entries_only"></a><dl>
     * <dt><b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstfileexa
     * @since windows5.1.2600
     */
    static FindFirstFileExA(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileExA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name and attributes that match those specified. (FindFirstFileExW)
     * @remarks
     * The <b>FindFirstFileEx</b> function opens a search handle 
     *     and returns information about the first file that the file system finds with a name that matches the specified 
     *     pattern. This may or may not be the first file or directory that appears in a directory-listing application (such 
     *     as the dir command) when given the same file name string pattern. This is because 
     *     <b>FindFirstFileEx</b> does no sorting of the search results. 
     *     For additional information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.
     * 
     * The following list identifies some other search characteristics:
     * 
     * <ul>
     * <li>The search is performed strictly on the name of the file, not on any attributes such as a date or a file 
     *       type.</li>
     * <li>The search includes the long and short file names.</li>
     * <li>An attempt to open a search with a trailing backslash always fails.</li>
     * <li>Passing an invalid string, <b>NULL</b>, or empty string for the 
     *       <i>lpFileName</i> parameter is not a valid use of this function. Results in this case are 
     *       undefined.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be 
     *      current at the time this function is called. To be assured of getting the current NTFS file system file 
     *      attributes, call the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * If the underlying file system does not support the specified type of filtering, other than directory 
     *     filtering, <b>FindFirstFileEx</b> fails with the error 
     *     <b>ERROR_NOT_SUPPORTED</b>. The application must use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> type 
     *     <b>FileExSearchNameMatch</b> and perform its own filtering.
     * 
     * After the search handle is established, use it in the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> function to search for other 
     *     files that match the same pattern with the same filtering that is being performed. When the search handle is not 
     *     needed, it should be closed by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * As stated previously, you cannot use a trailing backslash (\\) in the <i>lpFileName</i> 
     *     input string for <b>FindFirstFileEx</b>, therefore it may not 
     *     be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the 
     *     following options would apply:
     * 
     * <ul>
     * <li>To examine files in a root directory, you can use "C:\*" and step through the directory by 
     *       using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.</li>
     * <li>To get the attributes of a root directory, use 
     *       the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.</div>
     * <div> </div>
     * 
     * On network shares, you can use an <i>lpFileName</i> in the form of the following: 
     *     "\\\\server\\service\\*". However, you cannot use an <i>lpFileName</i> that points 
     *     to the share itself; for example, "\\\\server\\service" is not valid.
     * 
     * To examine a directory that is not a root directory, use the path to that directory, without a trailing 
     *     backslash. For example, an argument of "C:\\Windows" returns information about the 
     *     directory "C:\\Windows", not about a directory or file in 
     *     "C:\\Windows". To examine the files and directories in 
     *     "C:\\Windows", use an <i>lpFileName</i> of 
     *     "C:\\Windows\\*".
     * 
     * The following call:
     * 
     * 
     * ```cpp
     * FindFirstFileEx( lpFileName, 
     *                  FindExInfoStandard, 
     *                  lpFindData, 
     *                  FindExSearchNameMatch, 
     *                  NULL, 
     *                  0 );
     * ```
     * 
     * 
     * Is equivalent to the following call:
     * 
     * 
     * ```cpp
     * FindFirstFile( lpFileName, lpFindData );
     * ```
     * 
     * 
     * Be aware that some other thread or process could create or delete a file with this name between the time you 
     *     query for the result and the time you act on the information. If this is a potential concern for your application, 
     *     one possible solution is to use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with 
     *     <b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b> 
     *     (which fails if the file does not exist).
     * 
     * If you are writing a 32-bit application to list all the files in a directory and the application may be run on 
     *     a 64-bit computer, you should call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a> before 
     *     calling <b>FindFirstFileEx</b> and call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> after the 
     *     last call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> buffer contains information about 
     *     the symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string 
     *        or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period, or  directory name, the user must have access to the root and all 
     *        subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function (<b>FindFirstFileExW</b>), and 
     *        prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>FindFirstFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the buffer that receives the file data.
     *       
     * 
     * The pointer type is determined by the level of information that is specified in the 
     *        <i>fInfoLevelId</i> parameter.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_LARGE_FETCH"></a><a id="find_first_ex_large_fetch"></a><dl>
     * <dt><b>FIND_FIRST_EX_LARGE_FETCH</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uses a larger buffer for directory queries, which can increase performance of the find operation.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY"></a><a id="find_first_ex_on_disk_entries_only"></a><dl>
     * <dt><b>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present. 
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the 
     *        <i>lpFindFileData</i> parameter contains information about the first file or directory 
     *        found.
     * 
     * If the function fails or fails to locate files from the search string in the 
     *        <i>lpFileName</i> parameter, the return value is 
     *        <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are 
     *        indeterminate. To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstfileexw
     * @since windows5.1.2600
     */
    static FindFirstFileExW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileExW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the name of a volume on a computer. (FindFirstVolumeW)
     * @remarks
     * The <b>FindFirstVolume</b> function opens a volume search handle and returns 
     *     information about the first volume found on a computer. After the search handle is established, you can use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> function to search for other volumes. When 
     *     the search handle is no longer needed, close it by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> function.
     * 
     * You should not assume any correlation between the order of the volumes that are returned by these functions 
     *     and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume 
     *     order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Char>} lpszVolumeName A pointer to a buffer that receives a null-terminated string that specifies a volume 
     *       <b>GUID</b> path for the first volume that is found.
     * @param {Integer} cchBufferLength The length of the buffer to receive the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> functions.
     * 
     * If the function fails to find any volumes, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstvolumew
     * @since windows5.1.2600
     */
    static FindFirstVolumeW(lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeW", "ptr", lpszVolumeName, "uint", cchBufferLength)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the operating system signal a change notification handle the next time it detects an appropriate change.
     * @remarks
     * After the 
     * <b>FindNextChangeNotification</b> function returns successfully, the application can wait for notification that a change has occurred by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">wait functions</a>.
     * 
     * If a change occurs after a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> but before a call to 
     * <b>FindNextChangeNotification</b>, the operating system records the change. When 
     * <b>FindNextChangeNotification</b> is executed, the recorded change immediately satisfies a wait for the change notification.
     * 
     * Each successful call to **FindNextChangeNotification** must be followed by a call to one of the wait functions. If the wait function returns for any reason other than the change notification handle being signaled (for example, if the wait times out), the application must retry the wait. Failing to follow this rule can cause the system to eventually run out of resources. It can also cause the application to miss some change notifications.
     * 
     * When <i>hChangeHandle</i> is no longer needed, close it by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclosechangenotification">FindCloseChangeNotification</a> function.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * See remark
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Application might experience false positives on CsvFs pause/resume.
     * @param {Pointer<Void>} hChangeHandle A handle to a change notification handle created by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstchangenotificationa">FindFirstChangeNotification</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findnextchangenotification
     * @since windows5.1.2600
     */
    static FindNextChangeNotification(hChangeHandle) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextChangeNotification", "ptr", hChangeHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted functions. (ANSI)
     * @remarks
     * This function uses the same search filters that were used to create the search handle passed in the 
     *     <i>hFindFile</i> parameter. For additional information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a>.
     * 
     * The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is 
     *     dependent on the file system. If the data  must be sorted, 
     *     the application must do the ordering after obtaining all the results.
     * 
     * <div class="alert"><b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be 
     *     current at the time this function is called. To be assured of getting the current NTFS file system file 
     *     attributes, call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * The order in which this function returns the file names is dependent on the file system type. With the NTFS 
     *     file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems, 
     *     the names are usually returned in the order the files were written to the disk, which may or may not be in 
     *     alphabetical order. However, as stated previously, these behaviors are not guaranteed.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> buffer contains information about the 
     *     symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the file enumeration handle, then the files that are returned are subject 
     *       to transaction isolation rules.
     * @param {Pointer<Void>} hFindFile The search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a> function.
     * @param {Pointer<WIN32_FIND_DATAA>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure 
     *       that receives information about the found file or subdirectory.
     * @returns {Integer} If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i> 
     *        parameter contains information about the next file or directory found.
     * 
     * If the function fails, the return value is zero and the contents of <i>lpFindFileData</i> 
     *        are indeterminate. To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no more matching files can be found, the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_NO_MORE_FILES</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findnextfilea
     * @since windows5.1.2600
     */
    static FindNextFileA(hFindFile, lpFindFileData) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextFileA", "ptr", hFindFile, "ptr", lpFindFileData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a file search from a previous call to the FindFirstFile, FindFirstFileEx, or FindFirstFileTransacted functions. (Unicode)
     * @remarks
     * This function uses the same search filters that were used to create the search handle passed in the 
     *     <i>hFindFile</i> parameter. For additional information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a>.
     * 
     * The order in which the search returns the files, such as alphabetical order, is not guaranteed, and is 
     *     dependent on the file system. If the data  must be sorted, 
     *     the application must do the ordering after obtaining all the results.
     * 
     * <div class="alert"><b>Note</b>  In rare cases or on a heavily loaded system, file attribute information on NTFS file systems may not be 
     *     current at the time this function is called. To be assured of getting the current NTFS file system file 
     *     attributes, call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * The order in which this function returns the file names is dependent on the file system type. With the NTFS 
     *     file system and CDFS file systems, the names are usually returned in alphabetical order. With FAT file systems, 
     *     the names are usually returned in the order the files were written to the disk, which may or may not be in 
     *     alphabetical order. However, as stated previously, these behaviors are not guaranteed.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> buffer contains information about the 
     *     symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the file enumeration handle, then the files that are returned are subject 
     *       to transaction isolation rules.
     * @param {Pointer<Void>} hFindFile The search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfileexa">FindFirstFileEx</a> function.
     * @param {Pointer<WIN32_FIND_DATAW>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure 
     *       that receives information about the found file or subdirectory.
     * @returns {Integer} If the function succeeds, the return value is nonzero and  the <i>lpFindFileData</i> 
     *        parameter contains information about the next file or directory found.
     * 
     * If the function fails, the return value is zero and the contents of <i>lpFindFileData</i> 
     *        are indeterminate. To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function fails because no more matching files can be found, the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_NO_MORE_FILES</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findnextfilew
     * @since windows5.1.2600
     */
    static FindNextFileW(hFindFile, lpFindFileData) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextFileW", "ptr", hFindFile, "ptr", lpFindFileData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a volume search started by a call to the FindFirstVolume function. (FindNextVolumeW)
     * @remarks
     * After the search handle is established by calling 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a>, you can use the 
     *     <b>FindNextVolume</b> function to search for other volumes.
     * 
     * You should not assume any correlation between the order of the volumes that are returned by these functions 
     *     and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume 
     *     order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Void>} hFindVolume The volume search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.
     * @param {Pointer<Char>} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no matching files can be found, the 
     *        <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findnextvolumew
     * @since windows5.1.2600
     */
    static FindNextVolumeW(hFindVolume, lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeW", "ptr", hFindVolume, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes the specified volume search handle.
     * @remarks
     * After the 
     * <b>FindVolumeClose</b> function is called, the handle <i>hFindVolume</i> cannot be used in subsequent calls to either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> or 
     * <b>FindVolumeClose</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Void>} hFindVolume The volume search handle to be closed. This handle must have been previously opened by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findvolumeclose
     * @since windows5.1.2600
     */
    static FindVolumeClose(hFindVolume) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindVolumeClose", "ptr", hFindVolume, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Flushes the buffers of a specified file and causes all buffered data to be written to a file.
     * @remarks
     * Typically the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a> functions write data to an internal buffer that the operating system writes to a disk or communication pipe on a regular basis. The 
     * <b>FlushFileBuffers</b> function writes all the buffered information for a specified file to the device or pipe.
     * 
     * Due to disk caching interactions within the system, the 
     * <b>FlushFileBuffers</b> function can be inefficient when used after every write to a disk drive device when many writes are being performed separately. If an application is  performing multiple writes to disk and also needs to ensure critical data is 
     * written to persistent media, the application should use unbuffered I/O  instead of frequently calling <b>FlushFileBuffers</b>. To open a file for unbuffered I/O, call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the <b>FILE_FLAG_NO_BUFFERING</b> and <b>FILE_FLAG_WRITE_THROUGH</b> flags. This prevents the file contents from being cached and flushes the metadata to disk with each write. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * 
     * To flush all open files on a volume, call <b>FlushFileBuffers</b> with a handle to the volume. The caller must have administrative privileges. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>. 
     * 
     * When opening a volume with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>, the <i>lpFileName</i> string should be the following form: \\.&#92;<i>x</i>: or \\?\Volume{<i>GUID</i>}. Do not use a trailing backslash in the volume name, because that indicates the root directory of a drive.  
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the open file. 
     * 
     * The file handle must have the <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * If <i>hFile</i> is a handle to a communications device, the function only flushes the transmit buffer.
     * 
     * If <i>hFile</i> is a handle to the server end of a named pipe, the function does not return until the client has read all buffered data from the pipe.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The function fails if <i>hFile</i> is a handle to the console output. That is because the console output is not buffered. The function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_INVALID_HANDLE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-flushfilebuffers
     * @since windows5.1.2600
     */
    static FlushFileBuffers(hFile) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FlushFileBuffers", "ptr", hFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified disk, including the amount of free space on the disk. (ANSI)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">GetDiskFreeSpaceEx</a> function lets 
     *     you avoid some of the arithmetic that is required by the 
     *     <b>GetDiskFreeSpace</b> function.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the operation is performed 
     *     on the target.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpRootPathName The root directory of the disk for which information is to be returned. If this parameter is 
     *       <b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, 
     *       it must include a trailing backslash (for example, "\\\\MyServer\\MyShare\\"). Furthermore, a drive 
     *       specification must have a trailing backslash (for example, "C:\\"). The calling application must 
     *       have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.
     * @param {Pointer<UInt32>} lpSectorsPerCluster A pointer to a variable that receives the number of sectors per cluster.
     * @param {Pointer<UInt32>} lpBytesPerSector A pointer to a variable that receives the number of bytes per sector.
     * @param {Pointer<UInt32>} lpNumberOfFreeClusters A pointer to a variable that receives the total number of free clusters on the disk that are available to the 
     *        user who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of free clusters on the 
     *        disk.
     * @param {Pointer<UInt32>} lpTotalNumberOfClusters A pointer to a variable that receives the total number of clusters on the disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceA(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceA", "ptr", lpRootPathName, "uint*", lpSectorsPerCluster, "uint*", lpBytesPerSector, "uint*", lpNumberOfFreeClusters, "uint*", lpTotalNumberOfClusters, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the specified disk, including the amount of free space on the disk. (Unicode)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">GetDiskFreeSpaceEx</a> function lets 
     *     you avoid some of the arithmetic that is required by the 
     *     <b>GetDiskFreeSpace</b> function.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the operation is performed 
     *     on the target.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetDiskFreeSpace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpRootPathName The root directory of the disk for which information is to be returned. If this parameter is 
     *       <b>NULL</b>, the function uses the root of the current disk. If this parameter is a UNC name, 
     *       it must include a trailing backslash (for example, "\\\\MyServer\\MyShare\\"). Furthermore, a drive 
     *       specification must have a trailing backslash (for example, "C:\\"). The calling application must 
     *       have <b>FILE_LIST_DIRECTORY</b> access rights for this  directory.
     * @param {Pointer<UInt32>} lpSectorsPerCluster A pointer to a variable that receives the number of sectors per cluster.
     * @param {Pointer<UInt32>} lpBytesPerSector A pointer to a variable that receives the number of bytes per sector.
     * @param {Pointer<UInt32>} lpNumberOfFreeClusters A pointer to a variable that receives the total number of free clusters on the disk that are available to the 
     *        user who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of free clusters on the 
     *        disk.
     * @param {Pointer<UInt32>} lpTotalNumberOfClusters A pointer to a variable that receives the total number of clusters on the disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * If per-user disk quotas are in use, this value may be less than the total number of clusters on the disk.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacew
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceW(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceW", "ptr", lpRootPathName, "uint*", lpSectorsPerCluster, "uint*", lpBytesPerSector, "uint*", lpNumberOfFreeClusters, "uint*", lpTotalNumberOfClusters, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread. (ANSI)
     * @remarks
     * The values obtained by this function are of the type 
     *     <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>. Do not truncate these values to 32 
     *      bits.
     * 
     * The <b>GetDiskFreeSpaceEx</b> function returns zero (0) 
     *     for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all 
     *     CD requests unless the disk is an unwritten CD in a CD-RW drive.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the operation is performed 
     *     on the target.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpDirectoryName A directory on the disk.
     * 
     * If this parameter is <b>NULL</b>, the function uses the root of the current disk.
     * 
     * If this parameter is a UNC name, it must include a trailing backslash, for example, 
     *        "\\\\MyServer\\MyShare\\".
     * 
     * This parameter does not have to specify the root directory on a disk. The function accepts any directory on a 
     *        disk.
     * 
     * The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this  
     *        directory.
     * @param {Pointer<UInt64>} lpFreeBytesAvailableToCaller A pointer to a variable that receives the total number of free bytes on a disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.
     * @param {Pointer<UInt64>} lpTotalNumberOfBytes A pointer to a variable that receives the total number of bytes on a disk that are available to the user who 
     *        is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of bytes on a disk.
     * 
     * To determine the total number of bytes on a disk or volume, use 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.
     * @param {Pointer<UInt64>} lpTotalNumberOfFreeBytes A pointer to a variable that receives the total number of free bytes on a disk.
     * 
     * This parameter can be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceExA(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes) {
        lpDirectoryName := lpDirectoryName is String? StrPtr(lpDirectoryName) : lpDirectoryName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceExA", "ptr", lpDirectoryName, "uint*", lpFreeBytesAvailableToCaller, "uint*", lpTotalNumberOfBytes, "uint*", lpTotalNumberOfFreeBytes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the amount of space that is available on a disk volume, which is the total amount of space, the total amount of free space, and the total amount of free space available to the user that is associated with the calling thread. (Unicode)
     * @remarks
     * The values obtained by this function are of the type 
     *     <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">ULARGE_INTEGER</a>. Do not truncate these values to 32 
     *      bits.
     * 
     * The <b>GetDiskFreeSpaceEx</b> function returns zero (0) 
     *     for <i>lpTotalNumberOfFreeBytes</i> and <i>lpFreeBytesAvailable</i> for all 
     *     CD requests unless the disk is an unwritten CD in a CD-RW drive.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the operation is performed 
     *     on the target.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetDiskFreeSpaceEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpDirectoryName A directory on the disk.
     * 
     * If this parameter is <b>NULL</b>, the function uses the root of the current disk.
     * 
     * If this parameter is a UNC name, it must include a trailing backslash, for example, 
     *        "\\\\MyServer\\MyShare\\".
     * 
     * This parameter does not have to specify the root directory on a disk. The function accepts any directory on a 
     *        disk.
     * 
     * The calling application must have <b>FILE_LIST_DIRECTORY</b> access rights for this  
     *        directory.
     * @param {Pointer<UInt64>} lpFreeBytesAvailableToCaller A pointer to a variable that receives the total number of free bytes on a disk that are available to the user 
     *        who is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of free bytes on a disk.
     * @param {Pointer<UInt64>} lpTotalNumberOfBytes A pointer to a variable that receives the total number of bytes on a disk that are available to the user who 
     *        is associated with the calling thread.
     * 
     * This parameter can be <b>NULL</b>.
     * 
     * If per-user quotas are being used, this value may be less than the total number of bytes on a disk.
     * 
     * To determine the total number of bytes on a disk or volume, use 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>.
     * @param {Pointer<UInt64>} lpTotalNumberOfFreeBytes A pointer to a variable that receives the total number of free bytes on a disk.
     * 
     * This parameter can be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexw
     * @since windows5.1.2600
     */
    static GetDiskFreeSpaceExW(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes) {
        lpDirectoryName := lpDirectoryName is String? StrPtr(lpDirectoryName) : lpDirectoryName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetDiskFreeSpaceExW", "ptr", lpDirectoryName, "uint*", lpFreeBytesAvailableToCaller, "uint*", lpTotalNumberOfBytes, "uint*", lpTotalNumberOfFreeBytes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Gets disk space information for a volume at a given root path.
     * @remarks
     * The `rootPath` must be a root path, such as `C:\` or `D:\`, and not a subdirectory of a root path.
     * @param {Pointer<Byte>} rootPath A pointer to a string that contains the root directory of the volume to be queried.
     * 
     * If this parameter is `NULL`, the function uses the root of the current disk.
     * @param {Pointer<DISK_SPACE_INFORMATION>} diskSpaceInfo A [**DISK_SPACE_INFORMATION**](ns-fileapi-disk_space_information.md) structure containing information about the current disk space for the volume at the given root path.
     * @returns {HRESULT} Returns `TRUE` if the function succeeds, or `FALSE` if it fails. To get extended error information, call the `GetLastError` function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdiskspaceinformationa
     */
    static GetDiskSpaceInformationA(rootPath, diskSpaceInfo) {
        rootPath := rootPath is String? StrPtr(rootPath) : rootPath

        result := DllCall("KERNEL32.dll\GetDiskSpaceInformationA", "ptr", rootPath, "ptr", diskSpaceInfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Gets disk space information for a volume at a given root path.
     * @remarks
     * The `rootPath` must be a root path, such as `C:\` or `D:\`, and not a subdirectory of a root path.
     * @param {Pointer<Char>} rootPath A pointer to a string that contains the root directory of the volume to be queried.
     * 
     * If this parameter is `NULL`, the function uses the root of the current disk.
     * @param {Pointer<DISK_SPACE_INFORMATION>} diskSpaceInfo A [**DISK_SPACE_INFORMATION**](ns-fileapi-disk_space_information.md) structure containing information about the current disk space for the volume at the given root path.
     * @returns {HRESULT} Returns `TRUE` if the function succeeds, or `FALSE` if it fails. To get extended error information, call the `GetLastError` function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdiskspaceinformationw
     */
    static GetDiskSpaceInformationW(rootPath, diskSpaceInfo) {
        rootPath := rootPath is String? StrPtr(rootPath) : rootPath

        result := DllCall("KERNEL32.dll\GetDiskSpaceInformationW", "ptr", rootPath, "ptr", diskSpaceInfo, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive. (ANSI)
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpRootPathName The root directory for the drive.
     *       
     * 
     * A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the 
     *        root of the current directory.
     * @returns {Integer} The return value specifies the type of drive, which can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid; for example, there is no volume mounted at the specified path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has fixed media; for example, a hard disk drive or flash drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdrivetypea
     * @since windows5.1.2600
     */
    static GetDriveTypeA(lpRootPathName) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName

        result := DllCall("KERNEL32.dll\GetDriveTypeA", "ptr", lpRootPathName, "uint")
        return result
    }

    /**
     * Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive. (Unicode)
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetDriveType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpRootPathName The root directory for the drive.
     *       
     * 
     * A trailing backslash is required. If this parameter is <b>NULL</b>, the function uses the 
     *        root of the current directory.
     * @returns {Integer} The return value specifies the type of drive, which can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_UNKNOWN</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive type cannot be determined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_NO_ROOT_DIR</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The root path is invalid; for example, there is no volume mounted at the specified path.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOVABLE</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_FIXED</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive has fixed media; for example, a hard disk drive or flash drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_REMOTE</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a remote (network) drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_CDROM</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a CD-ROM drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>DRIVE_RAMDISK</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The drive is a RAM disk.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getdrivetypew
     * @since windows5.1.2600
     */
    static GetDriveTypeW(lpRootPathName) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName

        result := DllCall("KERNEL32.dll\GetDriveTypeW", "ptr", lpRootPathName, "uint")
        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory. (ANSI)
     * @remarks
     * When <b>GetFileAttributes</b> is called on a directory 
     *     that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory 
     *     in the volume that the mounted folder associates with the directory. To obtain the file attributes of the 
     *     associated volume, call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw">GetVolumeNameForVolumeMountPoint</a> to 
     *     obtain the name of the associated volume. Then use the resulting name in a call to 
     *     <b>GetFileAttributes</b>. The results are the attributes of 
     *     the root directory on the associated volume.
     * 
     * If you call <b>GetFileAttributes</b> for a network share, 
     *     the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function returns 
     *     attributes for the symbolic link.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * @param {Pointer<Byte>} lpFileName The name of the file or directory. 
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value contains the attributes of the specified file or directory. For a 
     *        list of attribute values and their descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
     * @since windows5.1.2600
     */
    static GetFileAttributesA(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesA", "ptr", lpFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory. (Unicode)
     * @remarks
     * When <b>GetFileAttributes</b> is called on a directory 
     *     that is a mounted folder, it returns the file system attributes of the directory, not those of the root directory 
     *     in the volume that the mounted folder associates with the directory. To obtain the file attributes of the 
     *     associated volume, call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw">GetVolumeNameForVolumeMountPoint</a> to 
     *     obtain the name of the associated volume. Then use the resulting name in a call to 
     *     <b>GetFileAttributes</b>. The results are the attributes of 
     *     the root directory on the associated volume.
     * 
     * If you call <b>GetFileAttributes</b> for a network share, 
     *     the function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_BAD_NETPATH</b>. You must specify a path to a subfolder on that share.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function returns 
     *     attributes for the symbolic link.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * @param {Pointer<Char>} lpFileName The name of the file or directory. 
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value contains the attributes of the specified file or directory. For a 
     *        list of attribute values and their descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * If the function fails, the return value is <b>INVALID_FILE_ATTRIBUTES</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfileattributesw
     * @since windows5.1.2600
     */
    static GetFileAttributesW(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesW", "ptr", lpFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves attributes for a specified file or directory. (ANSI)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> function retrieves file 
     *     system attribute information. <b>GetFileAttributesEx</b> 
     *     can obtain other sets of file or directory attribute information. Currently, 
     *     <b>GetFileAttributesEx</b> retrieves a set of standard 
     *     attributes that is a superset of the file system attribute information.
     * 
     * When the <b>GetFileAttributesEx</b> function is 
     *     called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root 
     *     directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the 
     *     associated volume, call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw">GetVolumeNameForVolumeMountPoint</a> to 
     *     obtain the name of the associated volume. Then use the resulting name in a call to 
     *     <b>GetFileAttributesEx</b>. The results are the attributes 
     *     of the root directory on the associated volume.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function returns 
     *     attributes for the symbolic link.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file or directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId A class of attribute information to retrieve.
     * 
     * This parameter can be the following value from the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfileattributesexa
     * @since windows5.1.2600
     */
    static GetFileAttributesExA(lpFileName, fInfoLevelId, lpFileInformation) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesExA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves attributes for a specified file or directory. (Unicode)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> function retrieves file 
     *     system attribute information. <b>GetFileAttributesEx</b> 
     *     can obtain other sets of file or directory attribute information. Currently, 
     *     <b>GetFileAttributesEx</b> retrieves a set of standard 
     *     attributes that is a superset of the file system attribute information.
     * 
     * When the <b>GetFileAttributesEx</b> function is 
     *     called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root 
     *     directory in the volume that the mounted folder associates with the directory. To obtain the attributes of the 
     *     associated volume, call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw">GetVolumeNameForVolumeMountPoint</a> to 
     *     obtain the name of the associated volume. Then use the resulting name in a call to 
     *     <b>GetFileAttributesEx</b>. The results are the attributes 
     *     of the root directory on the associated volume.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function returns 
     *     attributes for the symbolic link.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed.  So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation.  If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file or directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFileAttributesExW</b>), and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>GetFileAttributesExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} fInfoLevelId A class of attribute information to retrieve.
     * 
     * This parameter can be the following value from the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfileattributesexw
     * @since windows5.1.2600
     */
    static GetFileAttributesExW(lpFileName, fInfoLevelId, lpFileInformation) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesExW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file information for the specified file. (GetFileInformationByHandle)
     * @remarks
     * Depending on the underlying network features of the operating system and the type of server connected to, the 
     *     <b>GetFileInformationByHandle</b> function may fail, 
     *     return partial information, or full information for the given file.
     * 
     * You can compare the <b>VolumeSerialNumber</b> and <b>FileIndex</b> 
     *     members returned in the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-by_handle_file_information">BY_HANDLE_FILE_INFORMATION</a> structure to 
     *     determine if two paths map to the same target; for example, you can compare two file paths and determine if they 
     *     map to the same directory.
     * 
     * IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the thread at the time of the call, then the function returns the 
     *       compressed file size of the isolated file view. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.
     * @param {Pointer<Void>} hFile A handle to the file that contains the information to be retrieved.
     * 
     * This handle should not be a pipe handle.
     * @param {Pointer<BY_HANDLE_FILE_INFORMATION>} lpFileInformation A pointer to a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-by_handle_file_information">BY_HANDLE_FILE_INFORMATION</a> structure that 
     *       receives the file information.
     * @returns {Integer} If the function succeeds, the return value is nonzero and file information data is contained in the buffer 
     *        pointed to by the <i>lpFileInformation</i> parameter.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfileinformationbyhandle
     * @since windows5.1.2600
     */
    static GetFileInformationByHandle(hFile, lpFileInformation) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileInformationByHandle", "ptr", hFile, "ptr", lpFileInformation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the size of the specified file, in bytes.
     * @remarks
     * You cannot use the <b>GetFileSize</b> function with a handle of 
     *     a nonseeking device such as a pipe or a communications device. To determine the file type for 
     *     <i>hFile</i>, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfiletype">GetFileType</a> 
     *     function.
     * 
     * The <b>GetFileSize</b> function retrieves the uncompressed size 
     *     of a file. Use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize</a> 
     *     function to obtain the compressed size of a file.
     * 
     * Note that if the return value is <b>INVALID_FILE_SIZE</b> (0xffffffff), an application must 
     *     call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has 
     *     succeeded or failed. The reason the function may appear to fail when it has not is that 
     *     <i>lpFileSizeHigh</i> could be non-<b>NULL</b> or the file size could be 
     *     0xffffffff. In this case, <b>GetLastError</b> will return 
     *     <b>NO_ERROR</b> (0) upon success. Because of this behavior, it is recommended that you use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesizeex">GetFileSizeEx</a> instead.
     * 
     * <b>Transacted Operations:  </b>If there is a transaction bound to the file handle, then the function returns information for the isolated 
     *       file view.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file.
     * @param {Pointer<UInt32>} lpFileSizeHigh A pointer to the variable where the high-order doubleword of the file size is returned. This parameter can 
     *       be <b>NULL</b> if the application does not require the high-order doubleword.
     * @returns {Integer} If the function succeeds, the return value is the low-order doubleword of the file size, and, if 
     *        <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the 
     *        high-order doubleword of the file size into the variable pointed to by that parameter.
     * 
     * If the function fails and <i>lpFileSizeHigh</i> is <b>NULL</b>, the 
     *        return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. When 
     *        <i>lpFileSizeHigh</i> is <b>NULL</b>, the results returned for large 
     *        files are ambiguous, and you will not be able to determine the actual size of the file. It is recommended that 
     *        you use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesizeex">GetFileSizeEx</a> instead.
     * 
     * If the function fails and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the 
     *        return value is <b>INVALID_FILE_SIZE</b> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return a value other than 
     *        <b>NO_ERROR</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfilesize
     * @since windows5.1.2600
     */
    static GetFileSize(hFile, lpFileSizeHigh) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileSize", "ptr", hFile, "uint*", lpFileSizeHigh, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the size of the specified file.
     * @remarks
     * <b>Transacted Operations:  </b>If there is a transaction bound to the file handle, then the function returns information for the isolated 
     *       file view.
     * 
     * <b>Windows Store apps:  </b><b>GetFileSizeEx</b> is not supported. Use 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfileinformationbyhandleex">GetFileInformationByHandleEx</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file. The handle must have been created with the 
     *       <b>FILE_READ_ATTRIBUTES</b> access right or equivalent, or the caller must have sufficient permission on the directory that contains the file. 
     *       For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<Int64>} lpFileSize A pointer to a <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a> structure that 
     *       receives the file size, in bytes.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfilesizeex
     * @since windows5.1.2600
     */
    static GetFileSizeEx(hFile, lpFileSize) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileSizeEx", "ptr", hFile, "int64*", lpFileSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the file type of the specified file.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file.
     * @returns {Integer} The function returns one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_CHAR</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file is a character file, typically an LPT device or a console.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_DISK</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file is a disk file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_PIPE</b></dt>
     * <dt>0x0003</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified file is a socket, a named pipe, or an anonymous pipe.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_REMOTE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unused.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FILE_TYPE_UNKNOWN</b></dt>
     * <dt>0x0000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the type of the specified file is unknown, or the function failed.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * You can distinguish between a "valid" return of <b>FILE_TYPE_UNKNOWN</b> and its return due to a calling error (for example, passing an invalid handle to 
     * <b>GetFileType</b>) by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the function worked properly and <b>FILE_TYPE_UNKNOWN</b> was returned, a call to <b>GetLastError</b> will return <b>NO_ERROR</b>.
     * 
     * If the function returned <b>FILE_TYPE_UNKNOWN</b> due to an error in calling 
     * <b>GetFileType</b>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return the error code.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfiletype
     * @since windows5.1.2600
     */
    static GetFileType(hFile) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileType", "ptr", hFile, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the final path for the specified file. (ANSI)
     * @remarks
     * The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.
     * 
     *  A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link 
     *      named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be 
     *      "D:\yourdir".
     * 
     * The string that is returned by this function uses the "\\\\?\\" 
     *      syntax. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to a file or directory.
     * @param {Pointer<Byte>} lpszFilePath A pointer to a buffer that receives the path of <i>hFile</i>.
     * @param {Integer} cchFilePath The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is the length of the string received by 
     *        <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the 
     *        size of the terminating null character.
     * 
     * <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function, 
     *         <b>GetFinalPathNameByHandleA</b>, the return value 
     *         includes the size of the terminating null character.
     * 
     * If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the 
     *        terminating null character, the return value is the required buffer size, in 
     *        <b>TCHAR</b>s. This value includes the size of the terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle 
     *          was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive 
     *          letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to 
     *          identify it.
     * 
     * This return value can also be returned if you are searching for a volume <b>GUID</b> 
     *          path on a network share. Volume <b>GUID</b> paths are not created for network 
     *          shares.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid flags were specified for <i>dwFlags</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfinalpathnamebyhandlea
     * @since windows6.0.6000
     */
    static GetFinalPathNameByHandleA(hFile, lpszFilePath, cchFilePath, dwFlags) {
        lpszFilePath := lpszFilePath is String? StrPtr(lpszFilePath) : lpszFilePath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFinalPathNameByHandleA", "ptr", hFile, "ptr", lpszFilePath, "uint", cchFilePath, "uint", dwFlags, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the final path for the specified file. (Unicode)
     * @remarks
     * The Server Message Block (SMB) Protocol does not support queries for normalized paths. Consequently, when you call this function passing the handle of a file opened using SMB, and with the FILE_NAME_NORMALIZED flag, the function splits the path into its components and tries to query for the normalized name of each of those components in turn. If the user lacks access permission to any one of those components, then the function call fails with ERROR_ACCESS_DENIED.
     * 
     *  A final path is the path that is returned when a path is fully resolved. For example, for a symbolic link 
     *      named "C:\tmp\mydir" that points to "D:\yourdir", the final path would be 
     *      "D:\yourdir".
     * 
     * When using <b>VOLUME_NAME_DOS</b>, the string that is returned by this function uses the "\\\\?\\" 
     *      syntax. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     *      
     * When using <b>VOLUME_NAME_GUID</b>, the returned path will begin with a volume GUID path formatted like "\\\\?\\Volume{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\\".
     * 
     * When using <b>VOLUME_NAME_NT</b>, the returned path is for an NT device object, and will begin with a device name such as "\\Device\\HarddiskVolume1\\".  This type of path can not be used directly by Windows programs, as it resembles a relative path.
     * 
     * Some third-party drivers can create a drive letter or mount point without using the Mount Manager.  If the Mount Manager was not used to create the drive, then <b>VOLUME_NAME_DOS</b> or <b>VOLUME_NAME_GUID</b> will not succeed; only <b>VOLUME_NAME_NT</b> will be available.  To determine the drive letter for the volume device path, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-querydosdevicew">QueryDosDevice</a> function on every drive letter until a matching device name is found.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to a file or directory.
     * @param {Pointer<Char>} lpszFilePath A pointer to a buffer that receives the path of <i>hFile</i>.
     * @param {Integer} cchFilePath The size of <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value must include a <b>NULL</b> termination character.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is the length of the string received by 
     *        <i>lpszFilePath</i>, in <b>TCHAR</b>s. This value does not include the 
     *        size of the terminating null character.
     * 
     * <b>Windows Server 2008 and Windows Vista:  </b>For the ANSI version of this function, 
     *         <b>GetFinalPathNameByHandleA</b>, the return value 
     *         includes the size of the terminating null character.
     * 
     * If the function fails because <i>lpszFilePath</i> is too small to hold the string plus the 
     *        terminating null character, the return value is the required buffer size, in 
     *        <b>TCHAR</b>s. This value includes the size of the terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Can be returned if you are searching for a drive letter and one does not exist.  For example, the handle 
     *          was opened on a drive that is not currently mounted, or if you create a volume and do not assign it a drive 
     *          letter. If a volume has no drive letter, you can use the volume <b>GUID</b> path to 
     *          identify it.
     * 
     * This return value can also be returned if you are searching for a volume <b>GUID</b> 
     *          path on a network share. Volume <b>GUID</b> paths are not created for network 
     *          shares.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid flags were specified for <i>dwFlags</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfinalpathnamebyhandlew
     * @since windows6.0.6000
     */
    static GetFinalPathNameByHandleW(hFile, lpszFilePath, cchFilePath, dwFlags) {
        lpszFilePath := lpszFilePath is String? StrPtr(lpszFilePath) : lpszFilePath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFinalPathNameByHandleW", "ptr", hFile, "ptr", lpszFilePath, "uint", cchFilePath, "uint", dwFlags, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the date and time that a file or directory was created, last accessed, and last modified.
     * @remarks
     * Not all file systems can record creation and last access times and not all file systems record them in the 
     *     same manner. For example, on  FAT, create time has a resolution of 10 milliseconds, write time has a resolution of 
     *     2 seconds, and access time has a resolution of 1 day (really, the access date). Therefore, the 
     *     <b>GetFileTime</b> function may not return the same file time 
     *     information set using the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfiletime">SetFileTime</a> function.
     * 
     * NTFS delays updates to the last access time for a file by up to one hour after the last access. NTFS also 
     *     permits last access time updates to be disabled. Last access time is not updated on NTFS volumes by default.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>Last access time is updated on NTFS volumes by default.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/SysInfo/file-times">File Times</a>.
     * 
     * If you rename or delete a file, then restore it shortly thereafter, Windows searches the cache for file 
     *     information to restore. Cached information includes its short/long name pair and creation time.
     * @param {Pointer<Void>} hFile A handle to the file or directory for which dates and times are to be retrieved. The handle must have been 
     *       created using the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the 
     *       <b>GENERIC_READ</b> access right. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<FILETIME>} lpCreationTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the 
     *       date and time the file or directory was created. This parameter can be <b>NULL</b> if the 
     *       application does not require this information.
     * @param {Pointer<FILETIME>} lpLastAccessTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to 
     *       receive the date and time the file or directory was last accessed. The last access time includes the last time 
     *       the file or directory was written to, read from, or, in the case of executable files, run. This parameter can be 
     *       <b>NULL</b> if the application does not require this information.
     * @param {Pointer<FILETIME>} lpLastWriteTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to 
     *       receive the date and time the file or directory was last written to, truncated, or overwritten (for example, 
     *       with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a>). This date and time is not updated when 
     *       file attributes or security descriptors are changed. This parameter can be <b>NULL</b> if the 
     *       application does not require this information.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfiletime
     * @since windows5.1.2600
     */
    static GetFileTime(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileTime", "ptr", hFile, "ptr", lpCreationTime, "ptr", lpLastAccessTime, "ptr", lpLastWriteTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file. (Unicode)
     * @remarks
     * <b>GetFullPathName</b> merges the name of the current drive 
     *     and directory with a specified file name to determine the full path and file name of a specified file. It also 
     *     calculates the address of the file name portion of the full path and file name.
     * 
     * This function does not verify that the resulting path and file name are valid, or that they see an existing 
     *     file on the associated volume.
     * 
     * Note that the <i>lpFilePart</i> parameter does not 
     *     require string buffer space, but only enough for a single address. This is because it simply returns an address 
     *     within the buffer that already exists for <i>lpBuffer</i>.
     * 
     * Share and volume names are 
     *     valid input for <i>lpFileName</i>. For example, the following list identities the returned path 
     *     and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:
     * 
     * <ul>
     * <li>If you specify "\\test-2\q$\lh" the path returned is 
     *       "\\test-2\q$\lh"</li>
     * <li>If you specify "\\?\UNC\test-2\q$\lh" the path returned is 
     *       "\\?\UNC\test-2\q$\lh"</li>
     * <li>If you specify "U:" the path returned is the current directory on the 
     *       "U:\" drive</li>
     * </ul>
     * <b>GetFullPathName</b> does not convert the specified file 
     *     name, <i>lpFileName</i>. If the specified file name exists, you can use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlongpathnamea">GetLongPathName</a> or 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getshortpathnamew">GetShortPathName</a> to convert to long or short path 
     *     names, respectively.
     * 
     * If the return value is greater than or equal to the value specified in 
     *     <i>nBufferLength</i>, you can call the function again with a buffer that is large enough to 
     *     hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the 
     *     Example Code section.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * 
     * Relative paths passed to the <b>GetFullPathName</b> function are
     * interpreted as relative to the process's current directory.
     * The current directory state written by the
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory</a>
     * function is global to the process and can be changed by any thread at any time.
     * Applications should be aware that
     * consecutive calls to the <b>GetFullPathName</b> function with a relative path
     * may produce different results if the current directory changes between the two calls.
     * 
     * To avoid problems caused by inconsistent results,
     * multithreaded applications and shared library code should avoid using relative paths.
     * If a relative path is received, it should be consumed exactly once,
     * either by passing the relative path directly to a function like <b>CreateFile</b>,
     * or by converting it to an absolute path and using the absolute path
     * from that point forward.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpFileName The name of the  file.
     * 
     * This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume 
     *        name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>).
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string for the drive and path, in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Char>} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<Char>} lpFilePart A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final 
     *       file name component in the path. 
     * 
     * This parameter can be  <b>NULL</b>.
     * 
     * If <i>lpBuffer</i> 
     *       refers to a directory and not a file, <i>lpFilePart</i> receives zero.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew
     * @since windows5.1.2600
     */
    static GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameW", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file. (ANSI)
     * @remarks
     * <b>GetFullPathName</b> merges the name of the current drive 
     *     and directory with a specified file name to determine the full path and file name of a specified file. It also 
     *     calculates the address of the file name portion of the full path and file name.
     * 
     * This function does not verify that the resulting path and file name are valid, or that they see an existing 
     *     file on the associated volume.
     * 
     * Note that the <i>lpFilePart</i> parameter does not 
     *     require string buffer space, but only enough for a single address. This is because it simply returns an address 
     *     within the buffer that already exists for <i>lpBuffer</i>.
     * 
     * Share and volume names are 
     *     valid input for <i>lpFileName</i>. For example, the following list identities the returned path 
     *     and file names if test-2 is a remote computer and U: is a network mapped drive whose current directory is the root of the volume:
     * 
     * <ul>
     * <li>If you specify "\\test-2\q$\lh" the path returned is 
     *       "\\test-2\q$\lh"</li>
     * <li>If you specify "\\?\UNC\test-2\q$\lh" the path returned is 
     *       "\\?\UNC\test-2\q$\lh"</li>
     * <li>If you specify "U:" the path returned is the current directory on the 
     *       "U:\" drive</li>
     * </ul>
     * <b>GetFullPathName</b> does not convert the specified file 
     *     name, <i>lpFileName</i>. If the specified file name exists, you can use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlongpathnamea">GetLongPathName</a> or 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getshortpathnamew">GetShortPathName</a> to convert to long or short path 
     *     names, respectively.
     * 
     * If the return value is greater than or equal to the value specified in 
     *     <i>nBufferLength</i>, you can call the function again with a buffer that is large enough to 
     *     hold the path. For an example of this case in addition to using zero-length buffer for dynamic allocation, see the 
     *     Example Code section.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * 
     * Relative paths passed to the <b>GetFullPathName</b> function are
     * interpreted as relative to the process's current directory.
     * The current directory state written by the
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcurrentdirectory">SetCurrentDirectory</a>
     * function is global to the process and can be changed by any thread at any time.
     * Applications should be aware that
     * consecutive calls to the <b>GetFullPathName</b> function with a relative path
     * may produce different results if the current directory changes between the two calls.
     * 
     * To avoid problems caused by inconsistent results,
     * multithreaded applications and shared library code should avoid using relative paths.
     * If a relative path is received, it should be consumed exactly once,
     * either by passing the relative path directly to a function like <b>CreateFile</b>,
     * or by converting it to an absolute path and using the absolute path
     * from that point forward.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpFileName The name of the  file.
     * 
     * This parameter can be a short (the 8.3 form) or long file name. This string can also be a share or volume 
     *        name.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>GetFullPathNameW</b>).
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string for the drive and path, in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Byte>} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<Byte>} lpFilePart A pointer to a buffer that receives the address (within <i>lpBuffer</i>) of the final 
     *       file name component in the path. 
     * 
     * This parameter can be  <b>NULL</b>.
     * 
     * If <i>lpBuffer</i> 
     *       refers to a directory and not a file, <i>lpFilePart</i> receives zero.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getfullpathnamea
     * @since windows5.1.2600
     */
    static GetFullPathNameA(lpFileName, nBufferLength, lpBuffer, lpFilePart) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameA", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a bitmask representing the currently available disk drives.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @returns {Integer} If the function succeeds, the return value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getlogicaldrives
     * @since windows5.1.2600
     */
    static GetLogicalDrives() {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLogicalDrives", "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Fills a buffer with strings that specify valid drives in the system. (GetLogicalDriveStringsW)
     * @remarks
     * Each string in the buffer may be used wherever a root directory is required, such as for the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdrivetypea">GetDriveType</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> functions.
     * 
     * This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a 
     *     drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For 
     *     more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Integer} nBufferLength The maximum size of the buffer pointed to by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>. This size does not include the terminating null character. If this 
     *       parameter is zero, <i>lpBuffer</i> is not used.
     * @param {Pointer<Char>} lpBuffer A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the 
     *       system, plus with an additional null character. Each string is a device name.
     * @returns {Integer} If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, 
     *        not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a 
     *        Unicode (UTF-16) null character uses two bytes.
     * 
     * If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. 
     *        It is the size of the buffer required to hold the drive strings.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getlogicaldrivestringsw
     * @since windows5.1.2600
     */
    static GetLogicalDriveStringsW(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLogicalDriveStringsW", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form. (ANSI)
     * @remarks
     * On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow 
     *     this convention. Therefore, do not assume that you can skip calling 
     *     <b>GetLongPathName</b> if the path does not contain a tilde (~) 
     *     character.
     * 
     * If the file or directory exists but a long path is not found, 
     *     <b>GetLongPathName</b> succeeds, having copied the string 
     *     referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the 
     *     <i>lpszLongPath</i> parameter.
     * 
     * If the return value is greater than the value specified in <i>cchBuffer</i>, you can call 
     *     the function again with a buffer that is large enough to hold the path. For an example of this case, see the 
     *     Example Code section for <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a>.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * It is possible to have access to a file or directory but not have access to some of the parent directories of 
     *     that file or directory. As a result, <b>GetLongPathName</b> may 
     *     fail when it is unable to query the parent directory of a path component to determine the long name for that 
     *     component. This check can be skipped for directory components that have file extensions longer than 3 characters, 
     *     or total lengths longer than 12 characters. For more information, see the 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, 
     *        <b>GetLongPathNameA</b>, the name is limited to 
     *        <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the 
     *        Unicode version of the function, <b>GetLongPathNameW</b>, 
     *        and prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Byte>} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not 
     *        exist, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getlongpathnamea
     * @since windows5.1.2600
     */
    static GetLongPathNameA(lpszShortPath, lpszLongPath, cchBuffer) {
        lpszShortPath := lpszShortPath is String? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String? StrPtr(lpszLongPath) : lpszLongPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameA", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form. (Unicode)
     * @remarks
     * On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow 
     *     this convention. Therefore, do not assume that you can skip calling 
     *     <b>GetLongPathName</b> if the path does not contain a tilde (~) 
     *     character.
     * 
     * If the file or directory exists but a long path is not found, 
     *     <b>GetLongPathName</b> succeeds, having copied the string 
     *     referred to by the <i>lpszShortPath</i> parameter to the buffer referred to by the 
     *     <i>lpszLongPath</i> parameter.
     * 
     * If the return value is greater than the value specified in <i>cchBuffer</i>, you can call 
     *     the function again with a buffer that is large enough to hold the path. For an example of this case, see the 
     *     Example Code section for <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a>.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * It is possible to have access to a file or directory but not have access to some of the parent directories of 
     *     that file or directory. As a result, <b>GetLongPathName</b> may 
     *     fail when it is unable to query the parent directory of a path component to determine the long name for that 
     *     component. This check can be skipped for directory components that have file extensions longer than 3 characters, 
     *     or total lengths longer than 12 characters. For more information, see the 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, 
     *        <b>GetLongPathNameA</b>, the name is limited to 
     *        <b>MAX_PATH</b> (260) characters. To extend this limit to 32,767 wide characters, call the 
     *        Unicode version of the function, <b>GetLongPathNameW</b>, 
     *        and prepend "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetLongPathNameW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Char>} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not 
     *        exist, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getlongpathnamew
     * @since windows5.1.2600
     */
    static GetLongPathNameW(lpszShortPath, lpszLongPath, cchBuffer) {
        lpszShortPath := lpszShortPath is String? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String? StrPtr(lpszLongPath) : lpszLongPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameW", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The AreShortNamesEnabled function determines whether short names are enabled for the specified volume.
     * @param {Pointer<Void>} Handle The handle to the volume or the handle to a file or directory that resides on the volume to query.
     * @param {Pointer<Int32>} Enabled A pointer to a `BOOLEAN` value that receives the result of the query. If `TRUE`, short names are enabled for the volume, otherwise `FALSE` is returned.
     * @returns {Integer} A `BOOLEAN` value that indicates whether the function succeeded. If the function succeeds, the return value is `TRUE`. If the function fails, the return value is `FALSE`. To get extended error information, call the [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-areshortnamesenabled
     */
    static AreShortNamesEnabled(Handle, Enabled) {
        result := DllCall("KERNEL32.dll\AreShortNamesEnabled", "ptr", Handle, "int*", Enabled, "int")
        return result
    }

    /**
     * Retrieves the short path form of the specified path. (GetShortPathNameW)
     * @remarks
     * The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or 
     *     long path. The short form can be longer than the specified path.
     * 
     * If the return value is greater than the value specified in the <i>cchBuffer</i> parameter, 
     *     you can call the function again with a buffer that is large enough to hold the path. For an example of this case 
     *     in addition to using zero-length buffer for dynamic allocation, see the Example Code section.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * If the specified path is already in its short form  and conversion is not needed, the function simply copies 
     *     the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.
     * 
     * You can set the <i>lpszShortPath</i> parameter to the same value as the 
     *     <i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path 
     *     to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter 
     *     accurately represents the total size, in <b>TCHARs</b>, of this buffer.
     * 
     * You can obtain the long name of a file from the short name by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlongpathnamea">GetLongPathName</a> function. Alternatively, where 
     *     <b>GetLongPathName</b> is not available, you can call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> on each component of the path to get the 
     *     corresponding long name.
     * 
     * It is possible to have access to a file or directory but not have access to some of the parent directories of 
     *     that file or directory. As a result, <b>GetShortPathName</b> 
     *     may fail when it is unable to query the parent directory of a path component  to determine the short name for that 
     *     component. This check can be skipped for directory components that already meet the requirements of a short name. 
     *     For more information, see the 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support short names on shares with continuous availability capability.
     * 
     * Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.
     * @param {Pointer<Char>} lpszLongPath The path string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * @param {Pointer<Char>} lpszShortPath A pointer to a buffer to receive the null-terminated short form of the path that 
     *        <i>lpszLongPath</i> specifies.
     * 
     * Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i> 
     *        will always return the required buffer size for a specified <i>lpszLongPath</i>.
     * @param {Integer} cchBuffer The size of the buffer  that <i>lpszShortPath</i> points to, in 
     *        <b>TCHARs</b>.
     * 
     * Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to <i>lpszShortPath</i>, not including the terminating null 
     *        character.
     * 
     * If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is 
     *        the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getshortpathnamew
     * @since windows5.1.2600
     */
    static GetShortPathNameW(lpszLongPath, lpszShortPath, cchBuffer) {
        lpszLongPath := lpszLongPath is String? StrPtr(lpszLongPath) : lpszLongPath
        lpszShortPath := lpszShortPath is String? StrPtr(lpszShortPath) : lpszShortPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetShortPathNameW", "ptr", lpszLongPath, "ptr", lpszShortPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated. (GetTempFileNameW)
     * @remarks
     * The <b>GetTempFileName</b> function creates a temporary 
     *     file name of the following form:
     * 
     * <i>&lt;path&gt;</i>&#92;<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP
     * 
     * The following table describes the file name syntax.
     * 
     * <table>
     * <tr>
     * <th>Component</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><i>&lt;path&gt;</i></td>
     * <td>Path specified by the <i>lpPathName</i> parameter</td>
     * </tr>
     * <tr>
     * <td><i>&lt;pre&gt;</i></td>
     * <td>First three letters of the <i>lpPrefixString</i> string</td>
     * </tr>
     * <tr>
     * <td><i>&lt;uuuu&gt;</i></td>
     * <td>Hexadecimal value of <i>uUnique</i></td>
     * </tr>
     * </table>
     *  
     * 
     * If <i>uUnique</i> is zero, 
     *     <b>GetTempFileName</b> creates an empty file and closes it. If 
     *     <i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created, 
     *     because <b>GetTempFileName</b> is not able to guarantee that 
     *     the file name is unique.
     * 
     * Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits 
     *     <b>GetTempFileName</b> to a maximum of 65,535 unique file names 
     *     if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the 
     *     same.
     * 
     * Due to the algorithm used to generate file names, 
     *     <b>GetTempFileName</b> can perform poorly when creating a large 
     *     number of files with the same prefix. In such cases, it is recommended that you construct unique file names based 
     *     on <b>GUID</b>s.
     * 
     * Temporary files whose names have been created by this function are not automatically deleted. To delete these 
     *     files call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>.
     * 
     * To avoid problems resulting when converting an ANSI string, an application should call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to create a temporary file.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpPathName The directory path for the file name. Applications typically specify a period (.) for the current directory 
     *        or the result of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-gettemppatha">GetTempPath</a> function. The string 
     *        cannot be longer than <b>MAX_PATH</b>–14 characters or
     *        <b>GetTempFileName</b> will fail. If this parameter is 
     *        <b>NULL</b>, the function fails.
     * @param {Pointer<Char>} lpPrefixString The null-terminated prefix string. The function uses up to the first three characters of this string as the 
     *        prefix of the file name. This string must consist of characters in the OEM-defined character set.
     * @param {Integer} uUnique An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.
     * 
     * If <i>uUnique</i> is zero, the function attempts to form a unique file name using the 
     *        current system time. If the file already exists, the number is increased by one and the function tests if this 
     *        file already exists. This continues until a unique filename is found; the function creates a file by that name 
     *        and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when 
     *        <i>uUnique</i> is nonzero.
     * @param {Pointer<Char>} lpTempFileName A pointer to the buffer that receives the temporary file name. This buffer should be 
     *        <b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.
     * @returns {Integer} If the function succeeds, the return value specifies the unique numeric value used in the temporary file 
     *        name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same 
     *        number.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * The following is a possible return value.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUFFER_OVERFLOW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The length of the string pointed to by the <i>lpPathName</i> parameter is more than 
     *          <b>MAX_PATH</b>–14 characters.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettempfilenamew
     * @since windows5.1.2600
     */
    static GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName
        lpPrefixString := lpPrefixString is String? StrPtr(lpPrefixString) : lpPrefixString
        lpTempFileName := lpTempFileName is String? StrPtr(lpTempFileName) : lpTempFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempFileNameW", "ptr", lpPathName, "ptr", lpPrefixString, "uint", uUnique, "ptr", lpTempFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the file system and volume associated with the specified file.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * | Technology | Supported |
     * |--------|--------|
     * | Server Message Block (SMB) 3.0 protocol | No |
     * | SMB 3.0 Transparent Failover (TFO) | No |
     * | SMB 3.0 with Scale-out File Shares (SO) | No |
     * | Cluster Shared Volume File System (CsvFS) | Yes |
     * | Resilient File System (ReFS) | Yes |
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Void>} hFile A handle to the file.
     * @param {Pointer<Char>} lpVolumeNameBuffer A pointer to a buffer that receives the name of a specified volume. The maximum buffer size is `MAX_PATH+1`.
     * @param {Integer} nVolumeNameSize The length of a volume name buffer, in **WCHAR**s. The maximum buffer size is `MAX_PATH+1`.
     * 
     * This parameter is ignored if the volume name buffer is not supplied.
     * @param {Pointer<UInt32>} lpVolumeSerialNumber A pointer to a variable that receives the volume serial number.
     * 
     * This parameter can be **NULL** if the serial number is not required.
     * 
     * This function returns the volume serial number that the operating system assigns when a hard disk is formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the Windows Management Instrumentation (WMI) [Win32_PhysicalMedia](/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia) property **SerialNumber**.
     * @param {Pointer<UInt32>} lpMaximumComponentLength A pointer to a variable that receives the maximum length, in **WCHAR**s, of a file name component  that a specified file system supports.
     * 
     * A file name component is the portion of a file name between backslashes.
     * 
     * The value that is stored in the variable  that  *_lpMaximumComponentLength_ points to is used to indicate that a specified file system supports long names. For example, for a FAT file system that supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be supported on systems that use the NTFS file system.
     * @param {Pointer<UInt32>} lpFileSystemFlags A pointer to a variable that receives flags associated with the specified file system.
     * 
     * This parameter can be one or more of the following flags. However, **FILE_FILE_COMPRESSION** and **FILE_VOL_IS_COMPRESSED** are mutually exclusive.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a><dl>
     * <dt><b>FILE_CASE_SENSITIVE_SEARCH</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports case-sensitive file names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a><dl>
     * <dt><b>FILE_CASE_PRESERVED_NAMES</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports preserved case of file names when it places a name on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a id="file_unicode_on_disk"></a><dl>
     * <dt><b>FILE_UNICODE_ON_DISK</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports Unicode in file names as they appear on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a id="file_persistent_acls"></a><dl>
     * <dt><b>FILE_PERSISTENT_ACLS</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system preserves and enforces ACLs, and the FAT file system does not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a><dl>
     * <dt><b>FILE_FILE_COMPRESSION</b></dt>
     * <dt>0x00000010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports file-based compression.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a><dl>
     * <dt><b>FILE_VOLUME_QUOTAS</b></dt>
     * <dt>0x00000020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports disk quotas.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a><dl>
     * <dt><b>FILE_SUPPORTS_SPARSE_FILES</b></dt>
     * <dt>0x00000040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sparse files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a><dl>
     * <dt><b>FILE_SUPPORTS_REPARSE_POINTS</b></dt>
     * <dt>0x00000080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports re-parse points.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a><dl>
     * <dt><b>FILE_VOLUME_IS_COMPRESSED</b></dt>
     * <dt>0x00008000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is a compressed volume, for example, a DoubleSpace volume.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a><dl>
     * <dt><b>FILE_SUPPORTS_OBJECT_IDS</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports object identifiers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a id="file_supports_encryption"></a><dl>
     * <dt><b>FILE_SUPPORTS_ENCRYPTION</b></dt>
     * <dt>0x00020000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports the Encrypted File System (EFS). For more information, see <a href="https://docs.microsoft.com/windows/win32/FileIO/file-encryption">File Encryption</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a><dl>
     * <dt><b>FILE_NAMED_STREAMS</b></dt>
     * <dt>0x00040000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports named streams.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a><dl>
     * <dt><b>FILE_READ_ONLY_VOLUME</b></dt>
     * <dt>0x00080000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume is read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a><dl>
     * <dt><b>FILE_SEQUENTIAL_WRITE_ONCE</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports a single sequential write.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a id="file_supports_transactions"></a><dl>
     * <dt><b>FILE_SUPPORTS_TRANSACTIONS</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports transactions. For more information, see <a href="https://docs.microsoft.com/windows/win32/Ktm/about-ktm">About KTM</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a><dl>
     * <dt><b>FILE_SUPPORTS_HARD_LINKS</b></dt>
     * <dt>0x00400000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports hard links. For more information, see <a href="https://docs.microsoft.com/windows/win32/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * <b>Windows Vista and Windows Server 2008: </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a id="file_supports_extended_attributes"></a><dl>
     * <dt><b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports extended attributes. An extended attribute is a piece of application-specific metadata that an application can associate with a file and is not part of the file's data.
     * 
     * <b>Windows Vista and Windows Server 2008: </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a id="file_supports_open_by_file_id"></a><dl>
     * <dt><b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system supports open by FileID. For more information, see <a href="https://docs.microsoft.com/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.
     * 
     * <b>Windows Vista and Windows Server 2008: </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a><dl>
     * <dt><b>FILE_SUPPORTS_USN_JOURNAL</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports update sequence number (USN) journals. For more information, see <a href="https://docs.microsoft.com/windows/win32/FileIO/change-journal-records">Change Journal Records</a>.
     * 
     * <b>Windows Vista and Windows Server 2008:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a><dl>
     * <dt><b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpFileSystemNameBuffer A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS file system. The buffer size is specified by the _nFileSystemNameSize_ parameter.
     * @param {Integer} nFileSystemNameSize The length of the file system name buffer, in **WCHAR**s. The maximum buffer size is `MAX_PATH+1`.
     * 
     * This parameter is ignored if the file system name buffer is not supplied.
     * @returns {Integer} If all the requested information is retrieved, the return value is nonzero.
     * 
     * If not all the requested information is retrieved, the return value is zero. To get extended error information, call [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationbyhandlew
     * @since windows6.0.6000
     */
    static GetVolumeInformationByHandleW(hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize) {
        lpVolumeNameBuffer := lpVolumeNameBuffer is String? StrPtr(lpVolumeNameBuffer) : lpVolumeNameBuffer
        lpFileSystemNameBuffer := lpFileSystemNameBuffer is String? StrPtr(lpFileSystemNameBuffer) : lpFileSystemNameBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeInformationByHandleW", "ptr", hFile, "ptr", lpVolumeNameBuffer, "uint", nVolumeNameSize, "uint*", lpVolumeSerialNumber, "uint*", lpMaximumComponentLength, "uint*", lpFileSystemFlags, "ptr", lpFileSystemNameBuffer, "uint", nFileSystemNameSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the file system and volume associated with the specified root directory. (Unicode)
     * @remarks
     * When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
     *      drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
     *      or a compact disc, respectively. To prevent the system from displaying this message box, call the
     *      <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function with
     *      <b>SEM_FAILCRITICALERRORS</b>.
     * 
     * The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
     *      file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
     *      volume. When compression is volume-based, an entire volume is  compressed or not compressed.
     * 
     * The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
     *      compression. When compression is file-based, individual files can be compressed or not compressed.
     * 
     * The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
     *      mutually exclusive. Both bits cannot be returned set.
     * 
     * The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
     *      only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
     *      file system name is not altered to indicate support for long file names.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize</a> function obtains the
     *      compressed size of a file. The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>
     *      function can determine whether an individual file is compressed.
     * 
     * Symbolic link behavior—
     * 
     * If the path points to a symbolic link, the function returns volume information for the target.
     * 
     * Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If the volume supports file system transactions, the function returns
     *       <b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpRootPathName A pointer to a string that contains the root directory of the volume to be described.
     * 
     * If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
     *        backslash is required. For example, specify \\\\MyServer\\MyShare as
     *        "\\\\MyServer\\MyShare\\", or the C drive as
     *        "C:\\".
     * @param {Pointer<Char>} lpVolumeNameBuffer A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
     *        <i>nVolumeNameSize</i> parameter.
     * @param {Integer} nVolumeNameSize The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the volume name buffer is not supplied.
     * @param {Pointer<UInt32>} lpVolumeSerialNumber A pointer to a variable that receives the volume serial number.
     * 
     * This parameter can be <b>NULL</b> if the serial number is not required.
     * 
     * This function returns the volume serial number that the operating system assigns when a hard disk is
     *        formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
     *        Windows Management Instrumentation (WMI)
     *        <a href="https://docs.microsoft.com/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
     *        <b>SerialNumber</b>.
     * @param {Pointer<UInt32>} lpMaximumComponentLength A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
     *        name component  that a specified file system supports.
     * 
     * A file name component is the portion of a file name between backslashes.
     * 
     * The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
     *        is used to indicate that a specified file system supports long names. For example, for a FAT file system that
     *        supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
     *        also be supported on systems that use the NTFS file system.
     * @param {Pointer<UInt32>} lpFileSystemFlags A pointer to a variable that receives flags associated with the specified file system.
     * 
     * This parameter can be one or more of the following flags. However,
     *        <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
     *        exclusive.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a>
     * <b>FILE_CASE_SENSITIVE_SEARCH</b><br>0x00000001
     * </td>
     * <td width="60%">
     * The specified volume supports case-sensitive file names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a>
     * <b>FILE_CASE_PRESERVED_NAMES</b><br>0x00000002
     * </td>
     * <td width="60%">
     * The specified volume supports preserved case of file names when it places a name on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a id="file_unicode_on_disk"></a>
     * <b>FILE_UNICODE_ON_DISK</b><br>0x00000004
     * </td>
     * <td width="60%">
     * The specified volume supports Unicode in file names as they appear on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a id="file_persistent_acls"></a>
     * <b>FILE_PERSISTENT_ACLS</b><br>0x00000008
     * </td>
     * <td width="60%">
     * The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
     *         preserves and enforces ACLs, and the FAT file system does not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a>
     * <b>FILE_FILE_COMPRESSION</b><br>0x00000010
     * </td>
     * <td width="60%">
     * The specified volume supports file-based compression.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a>
     * <b>FILE_VOLUME_QUOTAS</b><br>0x00000020
     * </td>
     * <td width="60%">
     * The specified volume supports disk quotas.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a>
     * <b>FILE_SUPPORTS_SPARSE_FILES</b><br>0x00000040
     * </td>
     * <td width="60%">
     * The specified volume supports sparse files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a>
     * <b>FILE_SUPPORTS_REPARSE_POINTS</b><br>0x00000080
     * </td>
     * <td width="60%">
     * The specified volume supports reparse points.
     * 
     * <b>ReFS:  </b>ReFS supports reparse points but does not index them so
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> and
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> will not
     *           function as expected.
     * 
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_REMOTE_STORAGE"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_REMOTE_STORAGE</b><br>0x00000100
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_RETURNS_CLEANUP_RESULT_INFO"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_RETURNS_CLEANUP_RESULT_INFO</b><br>0x00000200
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_POSIX_UNLINK_RENAME"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_POSIX_UNLINK_RENAME</b><br>0x00000400
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a>
     * <b>FILE_VOLUME_IS_COMPRESSED</b><br>0x00008000
     * </td>
     * <td width="60%">
     * The specified volume is a compressed volume, for example, a DoubleSpace volume.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a>
     * <b>FILE_SUPPORTS_OBJECT_IDS</b><br>0x00010000
     * </td>
     * <td width="60%">
     * The specified volume supports object identifiers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a id="file_supports_encryption"></a>
     * <b>FILE_SUPPORTS_ENCRYPTION</b><br>0x00020000
     * </td>
     * <td width="60%">
     * The specified volume supports the Encrypted File System (EFS). For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a>
     * <b>FILE_NAMED_STREAMS</b><br>0x00040000
     * </td>
     * <td width="60%">
     * The specified volume supports named streams.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a>
     * <b>FILE_READ_ONLY_VOLUME</b><br>0x00080000
     * </td>
     * <td width="60%">
     * The specified volume is read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a>
     * <b>FILE_SEQUENTIAL_WRITE_ONCE</b><br>0x00100000
     * </td>
     * <td width="60%">
     * The specified volume supports a single sequential write.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a id="file_supports_transactions"></a>
     * <b>FILE_SUPPORTS_TRANSACTIONS</b><br>0x00200000
     * </td>
     * <td width="60%">
     * The specified volume supports transactions. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/Ktm/about-ktm">About KTM</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a>
     * <b>FILE_SUPPORTS_HARD_LINKS</b><br>0x00400000
     * </td>
     * <td width="60%">
     * The specified volume supports hard links. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a id="file_supports_extended_attributes"></a>
     * <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b><br>0x00800000
     * </td>
     * <td width="60%">
     * The specified volume supports extended attributes. An extended attribute is a piece of
     *         application-specific metadata that an application can associate with a file and is not part of the file's data.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a id="file_supports_open_by_file_id"></a>
     * <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b><br>0x01000000
     * </td>
     * <td width="60%">
     * The file system supports open by FileID. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a>
     * <b>FILE_SUPPORTS_USN_JOURNAL</b><br>0x02000000
     * </td>
     * <td width="60%">
     * The specified volume supports update sequence number (USN) journals. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_INTEGRITY_STREAMS"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_INTEGRITY_STREAMS</b><br>0x04000000
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a>
     * <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b><br>0x08000000
     * </td>
     * <td width="60%">
     * The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.
     * 
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_SPARSE_VDL"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_SPARSE_VDL</b><br>0x10000000
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     * <td width="40%"><a id="FILE_DAX_VOLUME"></a><a id="file_dax_volume"></a>
     * <b>FILE_DAX_VOLUME</b><br>0x20000000
     * </td>
     * <td width="60%">
     * The specified volume is a direct access (DAX) volume.
     * 
     * <div class="alert"><b>Note</b>  This flag was introduced in Windows 10, version 1607.</div>
     * <div> </div>
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_GHOSTING"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_GHOSTING</b><br>0x40000000
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * </table>
     * @param {Pointer<Char>} lpFileSystemNameBuffer A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
     *        file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.
     * @param {Integer} nFileSystemNameSize The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the file system name buffer is not supplied.
     * @returns {Integer} If all the requested information is retrieved, the return value is nonzero.
     * 
     * If not all the requested information is retrieved, the return value is zero. To get extended error
     *        information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationw
     * @since windows5.1.2600
     */
    static GetVolumeInformationW(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeNameBuffer := lpVolumeNameBuffer is String? StrPtr(lpVolumeNameBuffer) : lpVolumeNameBuffer
        lpFileSystemNameBuffer := lpFileSystemNameBuffer is String? StrPtr(lpFileSystemNameBuffer) : lpFileSystemNameBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeInformationW", "ptr", lpRootPathName, "ptr", lpVolumeNameBuffer, "uint", nVolumeNameSize, "uint*", lpVolumeSerialNumber, "uint*", lpMaximumComponentLength, "uint*", lpFileSystemFlags, "ptr", lpFileSystemNameBuffer, "uint", nFileSystemNameSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the volume mount point where the specified path is mounted. (GetVolumePathNameW)
     * @remarks
     * If a specified path is passed, **GetVolumePathName** returns the path to the volume mount point, which means that it returns the root of the volume where the end point of the specified path is located.
     * 
     * For example, assume that you have volume D mounted at `C:\Mnt\Ddrive` and volume E mounted at `C:\Mnt\Ddrive\Mnt\Edrive`. Also assume that you have a file with the path `E:\Dir\Subdir\MyFile`. If you pass `C:\Mnt\Ddrive\Mnt\Edrive\Dir\Subdir\MyFile` to **GetVolumePathName**, it returns the path `C:\Mnt\Ddrive\Mnt\Edrive\`.
     * 
     * If either a relative directory or a file is passed without a volume qualifier, the function returns the drive letter of the boot volume. The drive letter of the boot volume is also returned if an invalid file or directory name is specified without a valid volume qualifier. If a valid volume specifier is given, and the volume exists, but an invalid file or directory name is specified, the function will succeed and that volume name will be returned. For examples, see the Examples section of this topic.
     * 
     * You must specify a valid Win32 namespace path. If you specify an NT namespace path, for example, `\DosDevices\H:` or `\Device\HardDiskVolume6`, the function returns the drive letter of the boot volume, not the drive letter of that NT namespace path.
     * 
     * For more information about path names and namespaces, see [Naming Files, Paths, and Namespaces](/windows/win32/FileIO/naming-a-file).
     * 
     * You can specify both local and remote paths. If you specify a local path, **GetVolumePathName** returns a full path whose prefix is the longest prefix that represents a volume.
     * 
     * If a network share is specified, **GetVolumePathName** returns the shortest path for which [GetDriveType](/windows/win32/api/fileapi/nf-fileapi-getdrivetypea) returns **DRIVE_REMOTE**, which means that the path is validated as a remote drive that exists, which the current user can access.
     * 
     * There are certain special cases that do not return a trailing backslash. These occur when the output buffer length is one character too short. For example, if _lpszFileName_ is `C:` and _lpszVolumePathName_ is 4 characters long, the value returned is `C:\`; however, if _lpszVolumePathName_ is 3 characters long, the value returned is `C:`. A safer but slower way to set the size of the return buffer is to call the [GetFullPathName](/windows/win32/api/fileapi/nf-fileapi-getfullpathnamea) function, and then make sure that the buffer size is at least the same size as the full path that **GetFullPathName** returns. If the output buffer is more than one character too short, the function will fail and return an error.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * Technology | Supported
     * -----------|----------
     * Server Message Block (SMB) 3.0 protocol|No
     * SMB 3.0 Transparent Failover (TFO)|No
     * SMB 3.0 with Scale-out File Shares (SO)|No
     * Cluster Shared Volume File System (CsvFS)|Yes
     * Resilient File System (ReFS)|Yes
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Char>} lpszFileName A pointer to the input path string. Both absolute and relative file and directory names, for example, "..", are acceptable in this path.
     * 
     * If you specify a relative directory or file name without a volume qualifier, **GetVolumePathName** returns the drive letter of the boot volume.
     * 
     * If this parameter is an empty string, "", the function fails but the last error is set to **ERROR_SUCCESS**.
     * @param {Pointer<Char>} lpszVolumePathName A pointer to a string that receives the volume mount point for the input path.
     * @param {Integer} cchBufferLength The length of the output buffer, in **TCHARs**.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getvolumepathnamew
     * @since windows5.1.2600
     */
    static GetVolumePathNameW(lpszFileName, lpszVolumePathName, cchBufferLength) {
        lpszFileName := lpszFileName is String? StrPtr(lpszFileName) : lpszFileName
        lpszVolumePathName := lpszVolumePathName is String? StrPtr(lpszVolumePathName) : lpszVolumePathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNameW", "ptr", lpszFileName, "ptr", lpszVolumePathName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts a local file time to a file time based on the Coordinated Universal Time (UTC).
     * @remarks
     * <b>LocalFileTimeToFileTime</b> uses the current 
     *     settings for the time zone and daylight saving time. Therefore, if it is daylight saving time, this function will 
     *     take daylight saving time into account, even if the time you are converting is in standard time.
     * @param {Pointer<FILETIME>} lpLocalFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure that specifies the 
     *       local file time to be converted into a UTC-based file time.
     * @param {Pointer<FILETIME>} lpFileTime A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-filetime">FILETIME</a> structure to receive the 
     *       converted UTC-based file time. This parameter cannot be the same as the 
     *       <i>lpLocalFileTime</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-localfiletimetofiletime
     * @since windows5.1.2600
     */
    static LocalFileTimeToFileTime(lpLocalFileTime, lpFileTime) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\LocalFileTimeToFileTime", "ptr", lpLocalFileTime, "ptr", lpFileTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Locks the specified file for exclusive access by the calling process.
     * @remarks
     * If the call to <b>LockFile</b> completes synchronously, a completion entry may not be queued when a completion port is associated with the file handle.
     * 
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-unlockfile">UnlockFile</a> function unlocks a file region locked by 
     * <b>LockFile</b>.
     * 
     * Locking a region of a file gives the threads of the locking process exclusive access to the specified region using this file handle. If the file handle is  inherited by a process created by the locking process, the child process is not granted access to the locked region. If the locking process opens the file a second time, it cannot access the specified region through this second handle until it unlocks the region.
     * 
     * Locking a region of a file does not prevent reading or writing from a mapped file view.
     * 
     * You can lock bytes that are beyond the end of the current  file. This is useful to coordinate adding records to the end of a file.
     * 
     * Exclusive locks cannot overlap an existing locked region of a file. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-lockfileex">LockFileEx</a>.
     * 
     * If 
     * <b>LockFile</b> cannot lock a region of a file, it returns zero immediately. It does not block. To issue a file lock request that will block until the lock is acquired, use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-lockfileex">LockFileEx</a> without the <b>LOCKFILE_FAIL_IMMEDIATELY</b> flag.
     * 
     * If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file. The file handle must have been created with the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} dwFileOffsetLow The low-order 32 bits of the starting byte offset in the file where the lock should begin.
     * @param {Integer} dwFileOffsetHigh The high-order 32 bits of the starting byte offset in the file where the lock should begin.
     * @param {Integer} nNumberOfBytesToLockLow The low-order 32 bits of the length of the byte range to be locked.
     * @param {Integer} nNumberOfBytesToLockHigh The high-order 32 bits of the length of the byte range to be locked.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-lockfile
     * @since windows5.1.2600
     */
    static LockFile(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\LockFile", "ptr", hFile, "uint", dwFileOffsetLow, "uint", dwFileOffsetHigh, "uint", nNumberOfBytesToLockLow, "uint", nNumberOfBytesToLockHigh, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Locks the specified file for exclusive access by the calling process. This function can operate either synchronously or asynchronously and can request either an exclusive or a shared lock.
     * @remarks
     * Locking a region of a file is used to acquire shared or exclusive access to the specified region using this file handle. If the file handle is  inherited by a process created by the locking process, the child process is not granted access to the locked region. If the locking process opens the file a second time, it cannot access the specified region through this second handle until it unlocks the region.
     * 
     * Locking a portion of a file for exclusive access denies all other processes both read and write access to the specified region of the file. Locking a region that goes beyond the current end-of-file position is not an error.
     * 
     * Locking a portion of a file for shared access denies all processes write access to the specified region of the file, including the process that first locks the region. All processes can read the locked region.
     * 
     * Locking a region of a file does not prevent reading or writing from a mapped file view.
     * 
     * The 
     * <b>LockFileEx</b> function operates asynchronously if the file handle was opened for asynchronous I/O, unless the <b>LOCKFILE_FAIL_IMMEDIATELY</b> flag is specified. If an exclusive lock is requested for a range of a file that already has a shared or exclusive lock, the function returns the error <b>ERROR_IO_PENDING</b>. The system will signal the event specified in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure after the lock is granted. To determine when the lock has been granted, use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function or one of the 
     * <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">wait functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * If the file handle was not opened for asynchronous I/O and the lock is not available, this call waits until the lock is granted or an error occurs, unless the <b>LOCKFILE_FAIL_IMMEDIATELY</b> flag is specified.
     * 
     * Exclusive locks cannot overlap an existing locked region of a file. Shared locks can overlap a locked region provided locks held on that region are shared locks. A shared lock can overlap an exclusive lock if both locks were created using the same file handle. When a shared lock overlaps an exclusive lock, the only possible access is a read by the owner of the locks. 
     * If the same range is locked with an exclusive and a shared lock, two unlock operations are necessary to unlock the region; the first unlock operation unlocks the exclusive lock, the second unlock operation unlocks the shared lock.
     * 
     * 
     * If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file. The handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} dwFlags 
     * @param {Integer} nNumberOfBytesToLockLow The low-order 32 bits of the length of the byte range to lock.
     * @param {Integer} nNumberOfBytesToLockHigh The high-order 32 bits of the length of the byte range to lock.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that the function uses with the locking request. This structure, which is required, contains the file offset of the beginning of the lock range. You must initialize the <b>hEvent</b> member to a valid handle or zero.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, the return value is zero (<b>FALSE</b>). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-lockfileex
     * @since windows5.1.2600
     */
    static LockFileEx(hFile, dwFlags, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\LockFileEx", "ptr", hFile, "uint", dwFlags, "uint", dwReserved, "uint", nNumberOfBytesToLockLow, "uint", nNumberOfBytesToLockHigh, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about MS-DOS device names. (QueryDosDeviceW)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-definedosdevicew">DefineDosDevice</a> function enables an application 
     *     to create and modify the junctions used to implement the MS-DOS device namespace.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b><b>QueryDosDevice</b> first searches the Local MS-DOS 
     *      Device namespace for the specified device name. If the device name is not found, the function will then search 
     *      the Global MS-DOS Device namespace.
     * 
     * When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on 
     *      whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS 
     *      Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS 
     *      Device namespaces will be returned. If a device name exists in both namespaces, 
     *      <b>QueryDosDevice</b> will return the entry in the Local MS-DOS 
     *      Device namespace.
     * 
     * For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of 
     *      MS-DOS device names, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Char>} lpDeviceName An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing 
     *        backslash; for example, use "C:", not "C:\\".
     * 
     * This parameter can be <b>NULL</b>. In that case, the 
     *        <b>QueryDosDevice</b> function will store a list of all 
     *        existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.
     * @param {Pointer<Char>} lpTargetPath A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or 
     *        more null-terminated strings. The final null-terminated string is followed by an additional 
     *        <b>NULL</b>.
     * 
     * If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves 
     *        information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first 
     *        null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated 
     *        strings represent undeleted prior mappings for the device.
     * 
     * If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of 
     *        all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing 
     *        MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.
     * @param {Integer} ucchMax The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by 
     *       <i>lpTargetPath</i>.
     * @returns {Integer} If the function succeeds, the return value is the number of <b>TCHARs</b> stored into 
     *        the buffer pointed to by <i>lpTargetPath</i>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the buffer is too small, the function fails and the last error code is 
     *        <b>ERROR_INSUFFICIENT_BUFFER</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-querydosdevicew
     * @since windows5.1.2600
     */
    static QueryDosDeviceW(lpDeviceName, lpTargetPath, ucchMax) {
        lpDeviceName := lpDeviceName is String? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\QueryDosDeviceW", "ptr", lpDeviceName, "ptr", lpTargetPath, "uint", ucchMax, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
     * @remarks
     * The <b>ReadFile</b> function returns when one of the following 
     *      conditions occur:
     *      <ul>
     * <li>The number of bytes requested is read.</li>
     * <li>A write operation completes on the write end of the 
     *        pipe.</li>
     * <li>An asynchronous handle is being used and the read is occurring asynchronously.</li>
     * <li>An error occurs.</li>
     * </ul>
     * 
     * 
     * The <b>ReadFile</b> function may fail with 
     *     <b>ERROR_INVALID_USER_BUFFER</b> or <b>ERROR_NOT_ENOUGH_MEMORY</b> whenever 
     *     there are too many outstanding asynchronous I/O requests.
     * 
     * To cancel all pending asynchronous I/O operations, use either:
     *      <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelio">CancelIo</a>—this function only 
     *        cancels operations issued by the calling thread for the specified file handle.</li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a>—this function 
     *        cancels all operations issued by the threads for the specified file handle.</li>
     * </ul>
     * 
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> to cancel pending 
     *      synchronous I/O operations.
     * 
     * I/O operations that are canceled complete with the error <b>ERROR_OPERATION_ABORTED</b>.
     * 
     * The <b>ReadFile</b> function may fail with 
     *     <b>ERROR_NOT_ENOUGH_QUOTA</b>, which means the calling process's buffer could not be 
     *     page-locked. For additional information, see 
     *     <a href="https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsize">SetProcessWorkingSetSize</a>.
     * 
     * If part of a file is locked by another process and the read operation overlaps the locked portion, this 
     *     function fails.
     * 
     * Accessing the input buffer while a read operation is using the buffer may lead to corruption of the data read 
     *     into that buffer. Applications must not read from, write to, reallocate, or free the input buffer that a read 
     *     operation is using until the read operation completes. This can be particularly problematic when using an 
     *     asynchronous file handle. Additional information regarding synchronous versus asynchronous file handles can be 
     *     found in the <a href="https://docs.microsoft.com/">Synchronization and File Position</a> section and 
     *     in the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> reference topic.
     * 
     * Characters can be read from the console input buffer by using 
     *     <b>ReadFile</b> with a handle to console input. The console mode 
     *     determines the exact behavior of the <b>ReadFile</b> function. By 
     *     default, the console mode is <b>ENABLE_LINE_INPUT</b>, which indicates that 
     *     <b>ReadFile</b> should read until it reaches a carriage return. If you 
     *     press Ctrl+C, the call succeeds, but <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_OPERATION_ABORTED</b>. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * 
     * When reading from a communications device, the behavior of 
     *     <b>ReadFile</b> is determined by the current communication time-out as 
     *     set and retrieved by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getcommtimeouts">GetCommTimeouts</a> functions. Unpredictable results can 
     *     occur if you fail to set the time-out values. For more information about communication time-outs, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a>.
     * 
     * If <b>ReadFile</b> attempts to read from a mailslot that has a 
     *     buffer that is too small, the function returns <b>FALSE</b> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_INSUFFICIENT_BUFFER</b>.
     * 
     * There are strict requirements for successfully working with files opened with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> using the 
     *     <b>FILE_FLAG_NO_BUFFERING</b> flag. For details see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>, the 
     *      following conditions are in effect:
     *      <ul>
     * <li>The <i>lpOverlapped</i> parameter must point to a valid and unique 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, otherwise the 
     *        function can incorrectly report that the read operation is complete.</li>
     * <li>The <i>lpNumberOfBytesRead</i> parameter should be set to 
     *        <b>NULL</b>. Use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function to get the actual 
     *        number of bytes read. If the <i>hFile</i> parameter is associated with an I/O completion 
     *        port, you can also get the number of bytes read by calling the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function.</li>
     * </ul>
     * 
     * 
     * <h3><a id="synchronization_and_file_position"></a><a id="SYNCHRONIZATION_AND_FILE_POSITION"></a>Synchronization and File Position</h3>
     * If <i>hFile</i> is opened with <b>FILE_FLAG_OVERLAPPED</b>, it is an 
     *       asynchronous file handle; otherwise it is synchronous. The rules for using the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure are slightly different for each, 
     *       as previously noted.
     * 
     * <div class="alert"><b>Note</b>  If a file or device is opened for asynchronous I/O, subsequent calls to functions such as 
     *       <b>ReadFile</b> using that handle generally return immediately, but 
     *       can also behave synchronously with respect to blocked execution. For more information see 
     *       <a href="https://support.microsoft.com/kb/156932">http://support.microsoft.com/kb/156932</a>.</div>
     * <div> </div>
     * Considerations for working with asynchronous file handles:
     * 
     * <ul>
     * <li><b>ReadFile</b> may return before the read operation is 
     *        complete. In this scenario, <b>ReadFile</b> returns 
     *        <b>FALSE</b> and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        function returns <b>ERROR_IO_PENDING</b>, which allows the calling process to continue while 
     *        the system completes the read operation.</li>
     * <li>The <i>lpOverlapped</i> parameter must not be <b>NULL</b> and should 
     *        be used with the following facts in mind:
     *        <ul>
     * <li>Although the event specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 
     *          structure is set and reset automatically by the system, the offset that is specified in the 
     *          <b>OVERLAPPED</b> structure is not automatically 
     *          updated.</li>
     * <li><b>ReadFile</b> resets the event to a nonsignaled state when 
     *          it begins the I/O operation.</li>
     * <li>The event specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure 
     *          is set to a signaled state when the read operation is complete; until that time, the read operation is 
     *          considered pending.</li>
     * <li>Because the read operation starts at the offset that is specified in the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, and 
     *          <b>ReadFile</b> may return before the system-level read operation 
     *          is complete (read pending), neither the offset nor any other part of the structure should be modified, freed, 
     *          or reused by the application until the event is signaled (that is, the read completes).</li>
     * <li>If end-of-file (EOF) is detected during asynchronous operations, the call to 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for that operation 
     *          returns <b>FALSE</b> and 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *          <b>ERROR_HANDLE_EOF</b>.</li>
     * </ul>
     * </li>
     * </ul>
     * Considerations for working with synchronous file handles:
     * 
     * <ul>
     * <li>If <i>lpOverlapped</i> is <b>NULL</b>, the read operation starts at 
     *        the current file position and <b>ReadFile</b> does not return until 
     *        the operation is complete, and the system updates the file pointer before 
     *        <b>ReadFile</b> returns.</li>
     * <li>If <i>lpOverlapped</i> is not <b>NULL</b>, the read operation starts 
     *        at the offset that is specified in the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure and 
     *        <b>ReadFile</b> does not return until the read operation is 
     *        complete. The system updates the <b>OVERLAPPED</b> offset and the file pointer
     *        before <b>ReadFile</b> returns.</li>
     *  <li>If <i>lpOverlapped</i> is <b>NULL</b>, then when a synchronous read operation reaches the end of a file, 
     *        <b>ReadFile</b> returns <b>TRUE</b> and sets 
     *        <c>*lpNumberOfBytesRead</c> to zero.</li>
     *  <li>If <i>lpOverlapped</i> is not <b>NULL</b>, then when a synchronous read operation reaches the end of a file,
     *   <b>ReadFile</b> returns <b>FALSE</b> and
     *   <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns
     *   <b>ERROR_HANDLE_EOF</b>.</li>
     * </ul>
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> and 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * <h3><a id="pipes"></a><a id="PIPES"></a>Pipes</h3>
     * If an anonymous pipe is being used and the  write handle has been closed, when 
     *       <b>ReadFile</b> attempts to read using the pipe's corresponding read 
     *       handle, the function returns <b>FALSE</b> and 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_BROKEN_PIPE</b>.
     * 
     * If a named pipe is being read in message mode and the next message is longer than the 
     *       <i>nNumberOfBytesToRead</i> parameter specifies, 
     *       <b>ReadFile</b> returns <b>FALSE</b> and 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_MORE_DATA</b>. The remainder of the message can be read by a subsequent call to the 
     *       <b>ReadFile</b> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe</a> function.
     * 
     * If the <i>lpNumberOfBytesRead</i> parameter is zero when 
     *       <b>ReadFile</b> returns <b>TRUE</b> on a pipe, 
     *       the other end of the pipe called the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> function with 
     *       <i>nNumberOfBytesToWrite</i> set to zero.
     * 
     * For more information about pipes, see <a href="https://docs.microsoft.com/windows/desktop/ipc/pipes">Pipes</a>.
     * 
     * <h3><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the file handle, then the function returns data from the transacted view of 
     *       the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the 
     *       handle. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive, 
     *        socket, communications resource, mailslot, or  pipe).
     * 
     * The <i>hFile</i> parameter must have been created with read access. For more information, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * For asynchronous read operations, <i>hFile</i> can be any handle that is opened with the 
     *        <b>FILE_FLAG_OVERLAPPED</b> flag by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.
     * @param {Pointer} lpBuffer A pointer to the buffer that receives the data read from a file or device.
     * 
     * This buffer must remain valid for the duration of the read operation. The caller must not use this buffer 
     *        until the read operation is completed.
     * @param {Integer} nNumberOfBytesToRead The maximum number of bytes to be read.
     * @param {Pointer<UInt32>} lpNumberOfBytesRead A pointer to the variable that receives the number of bytes read when using a synchronous 
     *        <i>hFile</i> parameter. <b>ReadFile</b> sets 
     *        this value to zero  before doing any work or error checking. Use <b>NULL</b> for this 
     *        parameter if this is an asynchronous operation to avoid potentially erroneous results.
     * 
     * This parameter can be <b>NULL</b> only when the <i>lpOverlapped</i> 
     *        parameter is not <b>NULL</b>.
     * 
     * <b>Windows 7:  </b>This parameter can not be <b>NULL</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is 
     *        required if the <i>hFile</i> parameter was opened with 
     *        <b>FILE_FLAG_OVERLAPPED</b>, otherwise it can be <b>NULL</b>.
     * 
     * If <i>hFile</i> is opened with <b>FILE_FLAG_OVERLAPPED</b>, the 
     *        <i>lpOverlapped</i> parameter must point to a 
     *        valid and unique <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, otherwise the 
     *        function can incorrectly report that the read operation is complete.
     * 
     * For an <i>hFile</i> that supports byte offsets, if you use this parameter you must specify 
     *        a byte offset at which to start reading from the file or device. This offset is specified by setting the 
     *        <b>Offset</b> and <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For an 
     *        <i>hFile</i> that does not support byte offsets, <b>Offset</b> and 
     *        <b>OffsetHigh</b> are ignored.
     * 
     * For more information about different combinations of <i>lpOverlapped</i> and 
     *        <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the 
     *        **Synchronization and File Position** section.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, or is completing asynchronously, the return value is zero 
     *        (<b>FALSE</b>). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     *        <div class="alert"><b>Note</b>  The <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> code 
     *         <b>ERROR_IO_PENDING</b> is not a failure; it designates the read operation is pending 
     *         completion asynchronously. For more information, see Remarks.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-readfile
     * @since windows5.1.2600
     */
    static ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadFile", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToRead, "uint*", lpNumberOfBytesRead, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads data from the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when reading is completed or canceled and the calling thread is in an alertable wait state.
     * @remarks
     * When using <b>ReadFileEx</b> you should check 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> even when the function returns "success" to 
     *     check for conditions that are "successes" but have some outcome you might want to know about. For example, a 
     *     buffer overflow when calling <b>ReadFileEx</b> will return 
     *     <b>TRUE</b>, but <b>GetLastError</b> will 
     *     report the overflow with <b>ERROR_MORE_DATA</b>. If the function call is successful and there 
     *     are no warning conditions, <b>GetLastError</b> will return 
     *     <b>ERROR_SUCCESS</b>.
     * 
     * The <b>ReadFileEx</b> function may fail if there are too many 
     *     outstanding asynchronous I/O requests. In the event of such a failure, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> can return 
     *     <b>ERROR_INVALID_USER_BUFFER</b> or <b>ERROR_NOT_ENOUGH_MEMORY</b>.
     * 
     * To cancel all pending asynchronous I/O operations, use either:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelio">CancelIo</a>—this function only cancels 
     *       operations issued by the calling thread for the specified file handle.</li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a>—this function 
     *       cancels all operations issued by the threads for the specified file handle.</li>
     * </ul>
     * Use <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> to cancel pending 
     *      synchronous I/O operations.
     * 
     * I/O operations that are canceled complete with the error <b>ERROR_OPERATION_ABORTED</b>.
     * 
     * If part of the file specified by <i>hFile</i> is locked by another process, and the read 
     *     operation specified in a call to <b>ReadFileEx</b> overlaps the 
     *     locked portion, the call to <b>ReadFileEx</b> fails.
     * 
     * When attempting to read data from a mailslot whose buffer is too small, 
     *     <b>ReadFileEx</b> returns <b>FALSE</b>, and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_INSUFFICIENT_BUFFER</b>.
     * 
     * Accessing the input buffer while a read operation is using the buffer may lead to corruption of the data read 
     *     into that buffer. Applications must not read from, write to, reallocate, or free the input buffer that a read 
     *     operation is using until the read operation completes.
     * 
     * An application uses the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjectsex">MsgWaitForMultipleObjectsEx</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobjectex">WaitForSingleObjectEx</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjectsex">WaitForMultipleObjectsEx</a>, and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-sleepex">SleepEx</a> functions to enter an alertable wait state. For more 
     *     information about alertable waits and overlapped input/output, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/Sync/about-synchronization">About Synchronization</a>.
     * 
     * There are strict requirements for successfully working with files opened with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> using 
     *     <b>FILE_FLAG_NO_BUFFERING</b>. For details see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the file handle, then the function returns data from the transacted view of 
     *       the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the handle. 
     *       For additional information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.
     * @param {Pointer<Void>} hFile A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, 
     *        tape drive, socket, communications resource, mailslot, or pipe).
     * 
     * This parameter can be any handle opened with the <b>FILE_FLAG_OVERLAPPED</b> flag by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function, or a socket handle returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.
     * 
     * This handle also must have the <b>GENERIC_READ</b> access right. For more information on 
     *        access rights, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer} lpBuffer A pointer to a buffer that receives the data read from the file or device.
     * 
     * This buffer must remain valid for the duration of the read operation. The application should not use this 
     *        buffer until the read operation is completed.
     * @param {Integer} nNumberOfBytesToRead The number of bytes to be read.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure that 
     *        supplies data to be used during the asynchronous (overlapped) file read operation.
     * 
     * For files that support byte offsets, you must specify a byte offset at which to start reading from the file. 
     *        You specify this offset by setting the <b>Offset</b> and 
     *        <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For files or devices that do not 
     *        support byte offsets, <b>Offset</b> and <b>OffsetHigh</b> are 
     *        ignored.
     * 
     * The <b>ReadFileEx</b> function ignores the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's 
     *        <b>hEvent</b> member. An application is free to use that member for its own purposes in the 
     *        context of a <b>ReadFileEx</b> call. 
     *        <b>ReadFileEx</b> signals completion of its read operation by 
     *        calling, or queuing a call to, the completion routine pointed to by 
     *        <i>lpCompletionRoutine</i>, so it does not need an event handle.
     * 
     * The <b>ReadFileEx</b> function does use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure's 
     *        <b>Internal</b> and <b>InternalHigh</b> members. An application should 
     *        not set these members.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure must remain valid for 
     *        the duration of the read operation. It should not be a variable that can go out of scope while the read 
     *        operation is pending completion.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to the completion routine to be called when the read operation is complete and the calling thread 
     *       is in an alertable wait state. For more information about the completion routine, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped read 
     *        operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable 
     *        wait state, the system calls the function pointed to by <i>lpCompletionRoutine</i>, and the 
     *        wait state completes with a return code of <b>WAIT_IO_COMPLETION</b>.
     * 
     * If the function succeeds, and the file reading operation completes, but the calling thread is not in an 
     *        alertable wait state, the system queues the completion routine call, holding the call until the calling thread 
     *        enters an alertable wait state. For information about alertable waits and overlapped input/output operations, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/Sync/about-synchronization">About Synchronization</a>.
     * 
     * If <b>ReadFileEx</b> attempts to read past the 
     *        end-of-file (EOF), the call to 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for that operation returns 
     *        <b>FALSE</b> and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        returns <b>ERROR_HANDLE_EOF</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-readfileex
     * @since windows5.1.2600
     */
    static ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadFileEx", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToRead, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads data from a file and stores it in an array of buffers.
     * @remarks
     * This function is not supported for 32-bit applications by WOW64 on Itanium-based systems.
     * 
     * The [FILE_SEGMENT_ELEMENT structure](../winnt/ns-winnt-file_segment_element.md) is defined as follows:
     * 
     * 
     * ```cpp
     * typedef union _FILE_SEGMENT_ELEMENT {
     *     PVOID64 Buffer;
     *     ULONGLONG Alignment;
     * }FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
     * ```
     * 
     * Assigning a pointer to the **Buffer** member will sign-extend the value if the code is compiled as 32-bits; this can break large-address aware applications running on systems configured with <a href="https://docs.microsoft.com/windows/desktop/Memory/4-gigabyte-tuning">4-Gigabyte Tuning</a> or running on under WOW64 on 64-bit Windows. Therefore, use the **PtrToPtr64** macro when assigning pointers to **Buffer**.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the file handle, then the function returns data from the transacted view of 
     *       the file. A transacted read handle is guaranteed to show the same view of a file for the duration of the 
     *       handle.
     * @param {Pointer<Void>} hFile A handle to the file to be read.
     * 
     * The file handle must be created with the **GENERIC_READ** right, and the **FILE_FLAG_OVERLAPPED** and **FILE_FLAG_NO_BUFFERING** flags. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<FILE_SEGMENT_ELEMENT>} aSegmentArray A pointer to an array of [FILE_SEGMENT_ELEMENT structure](../winnt/ns-winnt-file_segment_element.md)  buffers that receives the data. For a description of this union, see [Remarks](#remarks).
     * 
     * Each element can receive one page of data.
     * 
     * > [!NOTE]
     * > To determine the size of a system page, use <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a>.
     * 
     * The array must contain enough elements to store *nNumberOfBytesToRead* bytes of data, plus one element for the terminating **NULL**. For example, if there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes 10 for the data and one for the **NULL**.
     * 
     * Each buffer must be at least the size of a system memory page and must be aligned on a system memory page size boundary. The system reads one system memory page of data into each buffer.
     * 
     * The function stores the data in the buffers in sequential order. For example, it stores data into the first buffer, then into the second buffer, and so on until each buffer is filled and all the data is stored, or there are no more buffers.
     * @param {Integer} nNumberOfBytesToRead The total number of bytes to be read from the file. Each element of *aSegmentArray* contains a one-page chunk of this total. Because the file must be opened with **FILE_FLAG_NO_BUFFERING**, the number of bytes must be a multiple of the sector size of the file system where the file is located.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure.
     * 
     * The **ReadFileScatter** function requires a valid 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. The *lpOverlapped* parameter cannot be **NULL**.
     * 
     * The **ReadFileScatter** function starts reading data from the file at a position that is specified by the **Offset** and **OffsetHigh** members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * The **ReadFileScatter** function may return before the read operation is complete. In that scenario, the **ReadFileScatter** function returns the value 0 (zero), and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value **ERROR_IO_PENDING**. This asynchronous operation of **ReadFileScatter** lets the calling process continue while the read operation completes. You can call the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-hasoverlappediocompleted">HasOverlappedIoCompleted</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> functions to obtain information about the completion of the read operation. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If **ReadFileScatter** attempts to read past the end-of-file (EOF), the call to <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> for that operation returns **FALSE** and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns **ERROR_HANDLE_EOF**.
     * 
     * If the function returns before the read operation is complete, the function returns zero (0), and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns **ERROR_IO_PENDING**.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-readfilescatter
     * @since windows5.1.2600
     */
    static ReadFileScatter(hFile, aSegmentArray, nNumberOfBytesToRead, lpOverlapped) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadFileScatter", "ptr", hFile, "ptr", aSegmentArray, "uint", nNumberOfBytesToRead, "uint*", lpReserved, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory. (ANSI)
     * @remarks
     * The <b>RemoveDirectory</b> function marks a directory for 
     *     deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.
     * 
     * To recursively delete the files in a directory, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> function.
     * 
     * <b>RemoveDirectory</b> removes a directory junction, even 
     *     if the contents of the target are not empty; the function removes directory junctions regardless of the state of 
     *     the target object. For more information on junctions, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpPathName The path of the directory to be removed. This path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-removedirectorya
     * @since windows5.1.2600
     */
    static RemoveDirectoryA(lpPathName) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryA", "ptr", lpPathName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory. (Unicode)
     * @remarks
     * The <b>RemoveDirectory</b> function marks a directory for 
     *     deletion on close. Therefore, the directory is not removed until the last handle to the directory is closed.
     * 
     * To recursively delete the files in a directory, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> function.
     * 
     * <b>RemoveDirectory</b> removes a directory junction, even 
     *     if the contents of the target are not empty; the function removes directory junctions regardless of the state of 
     *     the target object. For more information on junctions, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines RemoveDirectory as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpPathName The path of the directory to be removed. This path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>RemoveDirectoryW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-removedirectoryw
     * @since windows5.1.2600
     */
    static RemoveDirectoryW(lpPathName) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryW", "ptr", lpPathName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the physical file size for the specified file to the current position of the file pointer.
     * @remarks
     * The <b>SetEndOfFile</b> function can be used to truncate or extend a file. If the file is extended, the contents of the file between the old end of the file  and the new  end of the file are not defined.
     * 
     * Each file stream has the following:
     * 
     * <ul>
     * <li>File size: the size of the data in a file, to the byte.</li>
     * <li>Allocation size: the size of the space that is allocated for a file on a disk, which is always an even multiple of the cluster size.</li>
     * <li>Valid data length: the length of the data in a file that is actually written, to the byte. This value is always less than or equal to the file size.</li>
     * </ul>
     *   The <b>SetEndOfFile</b> function sets the file size. Use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfilevaliddata">SetFileValidData</a> to set the valid data length. 
     * 
     * If  
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfilemappinga">CreateFileMapping</a> is called to create a file mapping object for <i>hFile</i>, <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-unmapviewoffile">UnmapViewOfFile</a> must be called first to unmap all views and call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> to close the file mapping object before you can call 
     * <b>SetEndOfFile</b>.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the handle, then the change in the end-of-file position is transacted.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file to be extended or truncated.
     * 
     *  The file handle must be created with the <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setendoffile
     * @since windows5.1.2600
     */
    static SetEndOfFile(hFile) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetEndOfFile", "ptr", hFile, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the attributes for a file or directory. (ANSI)
     * @remarks
     * The following table describes how to set the attributes that cannot be set using 
     *     <b>SetFileAttributes</b>. For a complete list of all file 
     *     attribute values and their descriptions, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>How to Set</th>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_COMPRESSED</b>
     * 
     * 0x800
     * 
     * </td>
     * <td>
     * To set a file's compression state, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DEVICE</b>
     * 
     * 0x40
     * 
     * </td>
     * <td>
     * Reserved; do not use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DIRECTORY</b>
     * 
     * 0x10
     * 
     * </td>
     * <td>
     * Files cannot be converted into directories. To create a directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_ENCRYPTED</b>
     * 
     * 0x4000
     * 
     * </td>
     * <td>
     * To create an encrypted file, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the 
     *        <b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted 
     *        file, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-encryptfilea">EncryptFile</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
     * 
     * 0x400
     * 
     * </td>
     * <td>
     * To associate a reparse point with a file or directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
     * 
     * 0x200
     * 
     * </td>
     * <td>
     * To set a file's sparse attribute, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values 
     *        override <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that is an archive file or directory. Applications typically use this attribute to 
     *         mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is hidden. It is not included in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that does not have other attributes set. This attribute is valid only when used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></a><a id="file_attribute_not_content_indexed"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b></dt>
     * <dt>8192 (0x2000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is not to be indexed by the content indexing service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not available immediately. This attribute indicates that the file data is 
     *         physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical 
     *         storage management software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is read-only. Applications can read the file, but cannot write to it or delete it. This 
     *         attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or 
     *         the System attributes of folders in Windows Server 2003, in Windows XP, or in 
     *         Windows Vista.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that the operating system uses a part of, or uses exclusively.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is being used for temporary storage. File systems avoid writing data back to mass storage if 
     *         sufficient cache memory is available, because typically, an application deletes a temporary file after the 
     *         handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is 
     *         written after the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfileattributesa
     * @since windows5.1.2600
     */
    static SetFileAttributesA(lpFileName, dwFileAttributes) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesA", "ptr", lpFileName, "uint", dwFileAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the attributes for a file or directory. (Unicode)
     * @remarks
     * The following table describes how to set the attributes that cannot be set using 
     *     <b>SetFileAttributes</b>. For a complete list of all file 
     *     attribute values and their descriptions, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>How to Set</th>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_COMPRESSED</b>
     * 
     * 0x800
     * 
     * </td>
     * <td>
     * To set a file's compression state, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DEVICE</b>
     * 
     * 0x40
     * 
     * </td>
     * <td>
     * Reserved; do not use.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DIRECTORY</b>
     * 
     * 0x10
     * 
     * </td>
     * <td>
     * Files cannot be converted into directories. To create a directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_ENCRYPTED</b>
     * 
     * 0x4000
     * 
     * </td>
     * <td>
     * To create an encrypted file, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the 
     *        <b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file into an encrypted 
     *        file, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-encryptfilea">EncryptFile</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
     * 
     * 0x400
     * 
     * </td>
     * <td>
     * To associate a reparse point with a file or directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
     * 
     * 0x200
     * 
     * </td>
     * <td>
     * To set a file's sparse attribute, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function (<b>SetFileAttributesW</b>) and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>SetFileAttributesW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values 
     *        override <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that is an archive file or directory. Applications typically use this attribute to 
     *         mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is hidden. It is not included in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that does not have other attributes set. This attribute is valid only when used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></a><a id="file_attribute_not_content_indexed"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</b></dt>
     * <dt>8192 (0x2000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is not to be indexed by the content indexing service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not available immediately. This attribute indicates that the file data is 
     *         physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical 
     *         storage management software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is read-only. Applications can read the file, but cannot write to it or delete it. This 
     *         attribute is not honored on directories. For more information, see "You cannot view or change the Read-only or 
     *         the System attributes of folders in Windows Server 2003, in Windows XP, or in 
     *         Windows Vista.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file or directory that the operating system uses a part of, or uses exclusively.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file that is being used for temporary storage. File systems avoid writing data back to mass storage if 
     *         sufficient cache memory is available, because typically, an application deletes a temporary file after the 
     *         handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is 
     *         written after the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfileattributesw
     * @since windows5.1.2600
     */
    static SetFileAttributesW(lpFileName, dwFileAttributes) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesW", "ptr", lpFileName, "uint", dwFileAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the file information for the specified file.
     * @remarks
     * Certain file information classes behave slightly differently on different operating system releases. These 
     *     classes are supported by the underlying drivers, and any information they return is subject to change between 
     *     operating system releases.
     * 
     * The following table shows the valid file information classes and their corresponding data structure types for 
     *      use with this function.
     * 
     * <table>
     * <tr>
     * <th><i>FileInformationClass</i> value</th>
     * <th><i>lpFileInformation</i> type</th>
     * </tr>
     * <tr>
     * <td>
     * <b>FileBasicInfo</b>
     * 
     * 0
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_basic_info">FILE_BASIC_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FileRenameInfo</b>
     * 
     * 3
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_rename_info">FILE_RENAME_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FileDispositionInfo</b>
     * 
     * 4
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_disposition_info">FILE_DISPOSITION_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FileAllocationInfo</b>
     * 
     * 5
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_allocation_info">FILE_ALLOCATION_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FileEndOfFileInfo</b>
     * 
     * 6
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_end_of_file_info">FILE_END_OF_FILE_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>FileIoPriorityHintInfo</b>
     * 
     * 12
     * 
     * </td>
     * <td>
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_io_priority_hint_info">FILE_IO_PRIORITY_HINT_INFO</a>
     * 
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * You must specify appropriate access flags when creating the file handle for use with 
     *     <b>SetFileInformationByHandle</b>. For example, if 
     *     the application is using <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_disposition_info">FILE_DISPOSITION_INFO</a> with 
     *     the <b>DeleteFile</b> member set to <b>TRUE</b>, the file would need 
     *     <b>DELETE</b> access requested in the call to the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. To see an example of this, see the 
     *     Example Code section. For more information about file permissions, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * If there is a transaction bound to the handle, then the changes made will be transacted for the information 
     *     classes <b>FileBasicInfo</b>, <b>FileRenameInfo</b>, 
     *     <b>FileAllocationInfo</b>, <b>FileEndOfFileInfo</b>, and 
     *     <b>FileDispositionInfo</b>. If <b>FileDispositionInfo</b> is specified, 
     *     only the delete operation is transacted if a <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> 
     *     operation was requested. In this case, if the transaction is not committed before the handle is closed, the 
     *     deletion will not occur. For more information about TxF, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS (TxF)</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * See comment
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * See comment
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.
     * @param {Pointer<Void>} hFile A handle to the file for which to change information.
     * 
     * This handle must be opened with the appropriate permissions for the requested change. For more information, 
     *        see the Remarks and Example Code sections.
     * 
     * This handle should not be a pipe handle.
     * @param {Integer} FileInformationClass A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-file_info_by_handle_class">FILE_INFO_BY_HANDLE_CLASS</a> enumeration 
     *        value that specifies the type of information to be changed.
     * 
     * For a table of valid values, see the Remarks section.
     * @param {Pointer} lpFileInformation A pointer to the buffer that contains the information to change  for the specified file information class. 
     *        The structure that this parameter points to corresponds to the class that is specified by 
     *        <i>FileInformationClass</i>.
     * 
     * For a table of valid structure types, see the Remarks section.
     * @param {Integer} dwBufferSize The size of <i>lpFileInformation</i>, in bytes.
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfileinformationbyhandle
     * @since windows6.0.6000
     */
    static SetFileInformationByHandle(hFile, FileInformationClass, lpFileInformation, dwBufferSize) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileInformationByHandle", "ptr", hFile, "int", FileInformationClass, "ptr", lpFileInformation, "uint", dwBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves the file pointer of the specified file. (SetFilePointer)
     * @remarks
     * The file pointer that is identified by the value of the <i>hFile</i> parameter is not used 
     *     for overlapped read and write operations. 
     * 
     * The <i>hFile</i> parameter must refer to a file stored on a seeking device; for example, a disk volume. Calling the 
     *     <b>SetFilePointer</b> function with a handle to a non-seeking 
     *     device such as a pipe or a communications device is not supported, even though the 
     *     <b>SetFilePointer</b> function may not return an error. The behavior of the 
     *     <b>SetFilePointer</b> function in this case is undefined.
     * 
     * <p class="proch"><b>To specify the offset for overlapped operations</b>
     * 
     * <ul>
     * <li>Use the <b>Offset</b> and <b>OffsetHigh</b> members of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.</li>
     * </ul>
     * <p class="proch"><b>To determine the file type for <i>hFile</i></b>
     * 
     * <ul>
     * <li>Use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfiletype">GetFileType</a> function.</li>
     * </ul>
     * For information about how to determine the position of a file pointer, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/positioning-a-file-pointer">Positioning a File Pointer</a>.
     * 
     * Be careful when you set a file pointer in a multithreaded application. You must synchronize access to shared 
     *     resources. For example, an application with threads that share a file handle, update the file pointer, and read 
     *     from the file must protect this sequence by using a critical section object or mutex object. For more information, 
     *     see <a href="https://docs.microsoft.com/windows/desktop/Sync/critical-section-objects">Critical Section Objects</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/Sync/mutex-objects">Mutex Objects</a>.
     * 
     * If the <i>hFile</i> handle is opened with the 
     *     <b>FILE_FLAG_NO_BUFFERING</b> flag set, an application can move the file pointer only to 
     *     sector-aligned positions. A sector-aligned position is a position that is a whole number multiple of the volume 
     *     sector size. An application can obtain a volume sector size by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * If an application calls <b>SetFilePointer</b> with distance 
     *      to move values that result in a position not sector-aligned and a handle that is opened with 
     *      <b>FILE_FLAG_NO_BUFFERING</b>, the function fails, and 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_INVALID_PARAMETER</b>.
     * 
     * It is not an error to set a file pointer to a position beyond the end of the file. The size of the file does 
     *     not increase until you call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a>, or 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a> function. A write operation increases the size 
     *     of the file to the file pointer position plus the size of the buffer written, which results in the intervening 
     *     bytes uninitialized.
     * 
     * If the return value is <b>INVALID_SET_FILE_POINTER</b> and if 
     *     <i>lpDistanceToMoveHigh</i> is non-<b>NULL</b>, an application must call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether or not the function has 
     *     succeeded or failed. The following code example shows you that scenario.
     * 
     * 
     * ```cpp
     *   // Case One: calling the function with lpDistanceToMoveHigh == NULL 
     * 
     *   // Try to move hFile file pointer some distance  
     *   DWORD dwPtr = SetFilePointer( hFile, 
     *                                 lDistance, 
     *                                 NULL, 
     *                                 FILE_BEGIN ); 
     *    
     *   if (dwPtr == INVALID_SET_FILE_POINTER) // Test for failure
     *    { 
     *     // Obtain the error code. 
     *     DWORD dwError = GetLastError() ; 
     *    
     *     // Deal with failure 
     *     // . . . 
     *    
     *    } // End of error handler 
     * 
     * 
     *   //
     *   // Case Two: calling the function with lpDistanceToMoveHigh != NULL
     * 
     *   // Try to move hFile file pointer a huge distance 
     *   DWORD dwPtrLow = SetFilePointer( hFile, 
     *                                    lDistLow, 
     *                                    &lDistHigh, 
     *                                    FILE_BEGIN ); 
     *    
     *   // Test for failure
     *   if ( dwPtrLow == INVALID_SET_FILE_POINTER && 
     *        GetLastError() != NO_ERROR )
     *    {
     *     // Deal with failure
     *     // . . .
     * 
     *    } // End of error handler
     * 
     * ```
     * 
     * 
     * Although the parameter <i>lpDistanceToMoveHigh</i> is used to manipulate huge files, the 
     *     value of the parameter should be set when moving files of any size. If it is set to 
     *     <b>NULL</b>, then <i>lDistanceToMove</i> has a maximum value of 
     *     2^31–2, or 2 gigabytes less 2, because all file pointer values are signed values. Therefore, 
     *     if there is even a small chance for the file to increase to that size, it is best to treat the file as a huge file 
     *     and work with 64-bit file pointers. With 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-compression-and-decompression">file compression</a> on the NTFS file 
     *     system, and <a href="https://docs.microsoft.com/windows/desktop/FileIO/sparse-files">sparse files</a>, it is possible to have files that 
     *     are large even if the underlying volume is not very large.
     * 
     * If <i>lpDistanceToMoveHigh</i> is not <b>NULL</b>, then 
     *     <i>lpDistanceToMoveHigh</i> and <i>lDistanceToMove</i> form a single 64-bit 
     *     signed value. The <i>lDistanceToMove</i> parameter is treated as the low-order 32 bits of the 
     *     value, and <i>lpDistanceToMoveHigh</i> as the high-order 32 bits, which means that 
     *     <i>lpDistanceToMoveHigh</i> is a sign extension of 
     *     <i>lDistanceToMove</i>.
     * 
     * To move the file pointer from zero  to 2 gigabytes, <i>lpDistanceToMoveHigh</i> must be 
     *     set to either <b>NULL</b> or a sign extension of <i>lDistanceToMove</i>. To 
     *     move the pointer more than 2 gigabytes, use <i>lpDistanceToMoveHigh</i> and 
     *     <i>lDistanceToMove</i> as a single 64-bit quantity. For example, to move in the range from 2 
     *     gigabytes to 4 gigabytes set the contents of <i>lpDistanceToMoveHigh</i> to zero, or to 
     *     –1 for a negative sign extension of <i>lDistanceToMove</i>.
     * 
     * To work with 64-bit file pointers, you can declare a <b>LONG</b>, treat it as the upper 
     *     half of the 64-bit file pointer, and pass its address in <i>lpDistanceToMoveHigh</i>. This 
     *     means that you have to treat two different variables as a logical unit, which can cause an error. It is best to 
     *     use the <b>LARGE_INTEGER</b> structure to create a 64-bit value and pass the two 32-bit 
     *     values by using the appropriate elements of the union.
     * 
     * Also, it is best to use a function to hide the interface to 
     *     <b>SetFilePointer</b>. The following code example shows you that 
     *     scenario.
     * 
     * 
     * ```cpp
     * __int64 myFileSeek (HANDLE hf, __int64 distance, DWORD MoveMethod)
     * {
     *    LARGE_INTEGER li;
     * 
     *    li.QuadPart = distance;
     * 
     *    li.LowPart = SetFilePointer (hf, 
     *                                 li.LowPart, 
     *                                 &li.HighPart, 
     *                                 MoveMethod);
     * 
     *    if (li.LowPart == INVALID_SET_FILE_POINTER && GetLastError() 
     *        != NO_ERROR)
     *    {
     *       li.QuadPart = -1;
     *    }
     * 
     *    return li.QuadPart;
     * }
     * 
     * ```
     * 
     * 
     * You can use <b>SetFilePointer</b> to determine the length of 
     *     a file. To do this, use <b>FILE_END</b> for <i>dwMoveMethod</i> and seek to 
     *     location zero. The file offset returned is the length of the file. However, this practice can have unintended 
     *     side effects, for example, failure to save the current file pointer so that the program can return to that 
     *     location. It is best to use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesize">GetFileSize</a> instead.
     * 
     * You can also use the <b>SetFilePointer</b> function to query 
     *     the current file pointer position. To do this, specify a move method of <b>FILE_CURRENT</b> and 
     *     a distance of zero.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file.
     *       
     * 
     * The file handle must be created with the <b>GENERIC_READ</b> or 
     *        <b>GENERIC_WRITE</b> access right. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} lDistanceToMove The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.
     *       
     * 
     * If <i>lpDistanceToMoveHigh</i> is not <b>NULL</b>, 
     *        <i>lpDistanceToMoveHigh</i> and <i>lDistanceToMove</i> form a single 
     *        64-bit signed value that specifies the distance to move.
     * 
     * If <i>lpDistanceToMoveHigh</i> is <b>NULL</b>, 
     *        <i>lDistanceToMove</i> is a 32-bit signed value. A positive value for 
     *        <i>lDistanceToMove</i> moves the file pointer forward in the file, and a negative value 
     *        moves the file pointer back.
     * @param {Pointer<Int32>} lpDistanceToMoveHigh A pointer to the high order 32-bits of the signed 64-bit distance to move.
     *       
     * 
     * If you do not need the high order 32-bits, this pointer must be set to <b>NULL</b>.
     * 
     * When  not <b>NULL</b>, this parameter also receives the high order 
     *        <b>DWORD</b> of the new value of the file pointer. For more information, see the Remarks 
     *        section in this topic.
     * @param {Integer} dwMoveMethod The starting point for the file pointer move.
     * @returns {Integer} If the function succeeds and <i>lpDistanceToMoveHigh</i> is 
     *        <b>NULL</b>, the return value is the low-order <b>DWORD</b> of the new 
     *        file pointer.
     *        <b>Note</b>  If the function returns a value other than <b>INVALID_SET_FILE_POINTER</b>, the call 
     *          to <b>SetFilePointer</b> has succeeded. You do not need to 
     *          call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * 
     * If function succeeds and <i>lpDistanceToMoveHigh</i> is not 
     *        <b>NULL</b>, the return value is the low-order <b>DWORD</b> of the new 
     *        file pointer and <i>lpDistanceToMoveHigh</i> contains the high order 
     *        <b>DWORD</b> of the new file pointer.
     * 
     * If the function fails, the return value is <b>INVALID_SET_FILE_POINTER</b>. To get 
     *        extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If a new file pointer is a negative value, the function fails, the file pointer is not moved, and the code 
     *        returned by <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is 
     *        <b>ERROR_NEGATIVE_SEEK</b>.
     * 
     * If <i>lpDistanceToMoveHigh</i> is <b>NULL</b> and the new file position 
     *        does not fit in a 32-bit value, the function fails and returns 
     *        <b>INVALID_SET_FILE_POINTER</b>.
     * 
     * <div class="alert"><b>Note</b>  Because <b>INVALID_SET_FILE_POINTER</b> is a valid value for the 
     *        low-order <b>DWORD</b> of the new file pointer, you must check both the return value of 
     *        the function and the error code returned by 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether or not an error has 
     *        occurred. If an error has occurred, the return value of 
     *        <b>SetFilePointer</b> is 
     *        <b>INVALID_SET_FILE_POINTER</b> and 
     *        <b>GetLastError</b> returns a value other than 
     *        <b>NO_ERROR</b>. For a code example that demonstrates how to check for failure, see the 
     *        Remarks section in this topic.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfilepointer
     * @since windows5.1.2600
     */
    static SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFilePointer", "ptr", hFile, "int", lDistanceToMove, "int*", lpDistanceToMoveHigh, "uint", dwMoveMethod, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves the file pointer of the specified file. (SetFilePointerEx)
     * @remarks
     * The file pointer returned by this function is not used for overlapped read and write operations. To specify 
     *     the offset for overlapped operations, use the <b>Offset</b> and 
     *     <b>OffsetHigh</b> members of the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * You cannot use the <b>SetFilePointerEx</b> function with a handle to a nonseeking 
     *     device such as a pipe or a communications device. To determine the file type for <i>hFile</i>, 
     *     use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfiletype">GetFileType</a> function.
     * 
     * Use caution when setting the file pointer in a multithreaded application. You must synchronize access to 
     *     shared resources. For example, an application whose threads share a file handle, update the file pointer, and read 
     *     from the file must protect this sequence by using a critical section object or a mutex object. For more 
     *     information about these objects, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/Sync/critical-section-objects">Critical Section Objects</a> 
     *     and <a href="https://docs.microsoft.com/windows/desktop/Sync/mutex-objects">Mutex Objects</a>.
     * 
     * If the <i>hFile</i> handle was opened with the 
     *     <b>FILE_FLAG_NO_BUFFERING</b> flag set, an application can move the file pointer only to 
     *     sector-aligned positions. A sector-aligned position is a position that is a whole number multiple of the volume's 
     *     sector size. An application can obtain a volume's sector size by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function. If an application 
     *     calls <b>SetFilePointerEx</b> with distance-to-move values that result in a position 
     *     that is not sector-aligned and a handle that was opened with <b>FILE_FLAG_NO_BUFFERING</b>, the 
     *     function fails, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_INVALID_PARAMETER</b>. For additional information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * Note that it is not an error to set the file pointer to a position beyond the end of the file. The size of the 
     *     file does not increase until you call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a>, or 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefileex">WriteFileEx</a> function. A write operation increases the size 
     *     of the file to the file pointer position plus the size of the buffer written, leaving the intervening bytes 
     *     uninitialized.
     * 
     * You can use <b>SetFilePointerEx</b> to determine the length of a file. To do this, 
     *     use <b>FILE_END</b> for <i>dwMoveMethod</i> and seek to location zero. The 
     *     file offset returned is the length of the file. However, this practice can have unintended side effects, such as 
     *     failure to save the current file pointer so that the program can return to that location. It is simpler and safer 
     *     to use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesizeex">GetFileSizeEx</a> function instead.
     * 
     * You can also use <b>SetFilePointerEx</b> to query the current file pointer position. 
     *     To do this, specify a move method of <b>FILE_CURRENT</b> and a distance of zero.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file. The file handle must have been created with the 
     *       <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} liDistanceToMove The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a 
     *       negative value moves the file pointer backward.
     * @param {Pointer<Int64>} lpNewFilePointer A pointer to a variable to receive the new file pointer. If this parameter is 
     *       <b>NULL</b>, the new file pointer is not returned.
     * @param {Integer} dwMoveMethod 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfilepointerex
     * @since windows5.1.2600
     */
    static SetFilePointerEx(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFilePointerEx", "ptr", hFile, "int64", liDistanceToMove, "int64*", lpNewFilePointer, "uint", dwMoveMethod, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the date and time that the specified file or directory was created, last accessed, or last modified.
     * @remarks
     * Not all file systems can record creation and last access times and not all file systems record them in the same manner. For example, on  FAT, create time has a resolution of 10 milliseconds, write time has a resolution of 2 seconds, and access time has a resolution of 1 day (really, the access date). Therefore, the [GetFileTime](/windows/win32/api/fileapi/nf-fileapi-getfiletime) function may not return the same file time information set using **SetFileTime**. NTFS delays updates to the last access time for a file by up to one hour after the last access.
     * @param {Pointer<Void>} hFile A handle to the file or directory. The handle must have been created using the [CreateFile](/windows/win32/api/fileapi/nf-fileapi-createfilea) function  with the **FILE_WRITE_ATTRIBUTES** access right. For more information, see [File Security and Access Rights](/windows/win32/FileIO/file-security-and-access-rights).
     * @param {Pointer<FILETIME>} lpCreationTime A pointer to a [FILETIME](/windows/win32/api/minwinbase/ns-minwinbase-filetime) structure that contains the new creation date and time for the file or directory. If the application does not need to change this information, set this parameter either to `NULL` or to a pointer to a **FILETIME** structure that has both the **dwLowDateTime** and **dwHighDateTime** members set to `0`.
     * @param {Pointer<FILETIME>} lpLastAccessTime A pointer to a [FILETIME](/windows/win32/api/minwinbase/ns-minwinbase-filetime) structure that contains the new last access date and time for the file or directory. The last access time includes the last time the file or directory was written to, read from, or (in the case of executable files) run. If the application does not need to change this information, set this parameter either to `NULL` or to a pointer to a **FILETIME** structure that has both the **dwLowDateTime** and **dwHighDateTime** members set to `0`.
     * 
     * To prevent file operations using the given handle from modifying the last access time, call **SetFileTime** immediately after opening the file handle and pass a [FILETIME](/windows/win32/api/minwinbase/ns-minwinbase-filetime) structure that has both the **dwLowDateTime** and **dwHighDateTime** members set to `0xFFFFFFFF`.
     * @param {Pointer<FILETIME>} lpLastWriteTime A pointer to a [FILETIME](/windows/win32/api/minwinbase/ns-minwinbase-filetime) structure that contains the new last modified date and time for the file or directory.  If the application does not need to change this information, set this parameter either to `NULL` or to a pointer to a **FILETIME** structure that has both the **dwLowDateTime** and **dwHighDateTime** members set to `0`.
     * 
     * To prevent file operations using the given handle from modifying the last write time, call **SetFileTime** immediately after opening the file handle and pass a [FILETIME](/windows/win32/api/minwinbase/ns-minwinbase-filetime) structure that has both the **dwLowDateTime** and **dwHighDateTime** members set to `0xFFFFFFFF`.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfiletime
     * @since windows5.1.2600
     */
    static SetFileTime(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileTime", "ptr", hFile, "ptr", lpCreationTime, "ptr", lpLastAccessTime, "ptr", lpLastWriteTime, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the valid data length of the specified file. This function is useful in very limited scenarios. For more information, see the Remarks section.
     * @remarks
     * The <b>SetFileValidData</b> function sets the logical end of a file. To set the size of a file, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a> function. The physical file size is also referred to as the end of the file.
     * 
     * Each file stream has the following properties:
     * 
     * <ul>
     * <li>File size: the size of the data in a file, to the byte.</li>
     * <li>Allocation size: the size of the space that is allocated for a file on a disk, which is always an even multiple of the cluster size.</li>
     * <li>Valid data length: the length of the data in a file that is actually written, to the byte. This value is always less than or equal to the file size.</li>
     * </ul>
     * Typically, the 
     * <b>SetFileValidData</b> function is used by system-level applications on their own private data.   Not all file systems  use valid data length.  Some file systems can track multiple valid data ranges.
     * In general, most applications will never need to call this function.
     * 
     * The <b>SetFileValidData</b> function allows you to avoid filling data with zeros when writing nonsequentially to a file. The function makes the data in the file valid without writing to the file. As a result, although some performance gain may be realized, existing data on disk from previously existing files can inadvertently become available to unintended readers. The following paragraphs provide a more detailed description of this potential security and privacy issue.
     * 
     * A caller must have the <b>SE_MANAGE_VOLUME_NAME</b> privilege enabled when opening a file initially. Applications should call <b>SetFileValidData</b> only on files that restrict access to those entities that  have <b>SE_MANAGE_VOLUME_NAME</b> access. The application must ensure that the unwritten ranges of the file are never exposed, or security issues can result as follows.
     * 
     * If <b>SetFileValidData</b> is used on a file, the potential performance gain is obtained by not filling the allocated clusters for the file with zeros. Therefore, reading from the file will return whatever the allocated clusters contain, potentially content from other users.  This is not necessarily a security issue at this point, because the caller needs to have <b>SE_MANAGE_VOLUME_NAME</b> privilege for <b>SetFileValidData</b> to succeed,  and all  data on disk can be read by such users.  However, this caller can inadvertently expose this data to other users that cannot acquire the <b>SE_MANAGE_VOLUME_PRIVILEGE</b> privilege if the following holds: <ul>
     * <li>If the file was not opened with a sharing mode that denies other readers,  a nonprivileged user can open it and read the exposed data.</li>
     * <li>If the system stops responding before the caller finishes writing up the <i>ValidDataLength</i> supplied in the call, then, on a reboot, such a nonprivileged user can open the file and read exposed content.</li>
     * </ul>
     * 
     * 
     * If the caller of <b>SetFileValidData</b> opened the file with adequately restrictive access control, the previous conditions would not apply. However, for partially written files extended with <b>SetFileValidData</b> (that is, writing was not completed up to the <i>ValidDataLength</i> supplied in the call) there exists yet another potential privacy or security vulnerability. An administrator could copy the file to a target that is not properly controlled with restrictive ACL permissions, thus inadvertently exposing the extended area's data to unauthorized reading.
     * 
     * It is for these reasons that <b>SetFileValidData</b> is not recommended for general purpose use, in addition to performance considerations, as discussed below.
     * 
     * For more information about security and access privileges, see 
     * <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a> and <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * You can use the <b>SetFileValidData</b> function to  create large files in very specific circumstances so that the performance of subsequent file I/O can be better than other methods. Specifically, if the extended portion of the file is large and will be written to randomly, such as in a database type of application, the time it takes to extend and write to the file will be faster than using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a> and writing randomly. In most other situations, there is usually no performance gain to using <b>SetFileValidData</b>, and sometimes there can be a performance penalty.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file. The file must have been opened with the <b>GENERIC_WRITE</b> access right, and the <b>SE_MANAGE_VOLUME_NAME</b> privilege enabled. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * <div class="alert"><b>Note</b>  The file cannot be a network file, or be compressed, sparse, or transacted.</div>
     * <div> </div>
     * @param {Integer} ValidDataLength The new valid data length. 
     * 
     * This parameter must be a positive value that is greater than the current valid data length, but less than the current file size.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfilevaliddata
     * @since windows5.1.2600
     */
    static SetFileValidData(hFile, ValidDataLength) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileValidData", "ptr", hFile, "int64", ValidDataLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Unlocks a region in an open file.
     * @remarks
     * This function always operates synchronously, but may not queue a completion entry when a completion port is associated with the file handle.
     * 
     * Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must correspond exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and then unlocked using a single region that spans both locked regions.
     * 
     * If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it has locked when it terminates. If this is not done, access to these files may be denied if the operating system has not yet unlocked them.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file that contains a region locked with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-lockfile">LockFile</a>. The file handle must have been created with either the <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} dwFileOffsetLow The low-order word of the starting byte offset in the file where the locked region begins.
     * @param {Integer} dwFileOffsetHigh The high-order word of the starting byte offset in the file where the locked region begins.
     * @param {Integer} nNumberOfBytesToUnlockLow The low-order word of the length of the byte range to be unlocked.
     * @param {Integer} nNumberOfBytesToUnlockHigh The high-order word of the length of the byte range to be unlocked.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-unlockfile
     * @since windows5.1.2600
     */
    static UnlockFile(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\UnlockFile", "ptr", hFile, "uint", dwFileOffsetLow, "uint", dwFileOffsetHigh, "uint", nNumberOfBytesToUnlockLow, "uint", nNumberOfBytesToUnlockHigh, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Unlocks a region in the specified file. This function can operate either synchronously or asynchronously.
     * @remarks
     * Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must 
     *     correspond exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and 
     *     then unlocked using a single region that spans both locked regions.
     * 
     * Locks are released before the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function is 
     *     finished processing.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file. The handle must have been created with either the 
     *       <b>GENERIC_READ</b> or <b>GENERIC_WRITE</b> access right. For more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Integer} nNumberOfBytesToUnlockLow The low-order part of the length of the byte range to unlock.
     * @param {Integer} nNumberOfBytesToUnlockHigh The high-order part of the length of the byte range to unlock.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that the 
     *       function uses with the unlocking request. This structure contains the file offset of the beginning of the unlock 
     *       range. You must initialize the <b>hEvent</b> member to a valid handle or zero. For more 
     *       information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero or <b>NULL</b>. To get extended error 
     *        information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-unlockfileex
     * @since windows5.1.2600
     */
    static UnlockFileEx(hFile, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\UnlockFileEx", "ptr", hFile, "uint", dwReserved, "uint", nNumberOfBytesToUnlockLow, "uint", nNumberOfBytesToUnlockHigh, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes data to the specified file or input/output (I/O) device.
     * @remarks
     * The <b>WriteFile</b> function returns when one of the following 
     *      conditions occur:
     * 
     * <ul>
     * <li>The number of bytes requested is written.</li>
     * <li>A read operation releases buffer space on the read end of the pipe (if the write was blocked). For more 
     *       information, see the <a href="https://docs.microsoft.com/">Pipes</a> section.</li>
     * <li>An asynchronous handle is being used and the write is occurring asynchronously.</li>
     * <li>An error occurs.</li>
     * </ul>
     * The <b>WriteFile</b> function may fail with 
     *     <b>ERROR_INVALID_USER_BUFFER</b> or <b>ERROR_NOT_ENOUGH_MEMORY</b> whenever 
     *     there are too many outstanding asynchronous I/O requests.
     * 
     * To cancel all pending asynchronous I/O operations, use either:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelio">CancelIo</a>—this function cancels only 
     *       operations issued by the calling thread for the specified file handle.</li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a>—this function 
     *       cancels all operations issued by the threads for the specified file handle.</li>
     * </ul>
     * Use the <a href="https://docs.microsoft.com/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> function to 
     *      cancel pending synchronous I/O operations.
     * 
     * I/O operations that are canceled complete with the error <b>ERROR_OPERATION_ABORTED</b>.
     * 
     * The <b>WriteFile</b> function may fail with 
     *     <b>ERROR_NOT_ENOUGH_QUOTA</b>, which means the calling process's buffer could not be 
     *     page-locked. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsize">SetProcessWorkingSetSize</a>.
     * 
     * If part of the file is locked by another process and the write operation overlaps the locked portion, 
     *     <b>WriteFile</b> fails.
     * 
     * When writing to a file, the last write time is not fully updated until all handles used for writing have been 
     *     closed. Therefore, to ensure an accurate last write time, close the file handle immediately after writing to the 
     *     file.
     * 
     * Accessing the output buffer while a write operation is using the buffer may lead to corruption of the data 
     *     written from that buffer. Applications must not write to, reallocate, or free the output buffer that a write 
     *     operation is using until the write operation completes. This can be particularly problematic when using an 
     *     asynchronous file handle. Additional information regarding synchronous versus asynchronous file handles can be 
     *     found later in the <a href="#synchronization-and-file-position">Synchronization and File Position</a> 
     *     section and 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * Note that the time stamps may not be updated correctly for a remote file. To ensure consistent results, use 
     *     unbuffered I/O.
     * 
     * The system interprets zero bytes to write as specifying a null write operation and 
     *     <b>WriteFile</b> does not truncate or extend the file. To truncate or 
     *     extend a file, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setendoffile">SetEndOfFile</a> 
     *     function.
     * 
     * Characters can be written to the screen buffer using 
     *     <b>WriteFile</b> with a handle to console output. The exact behavior 
     *     of the function is determined by the console mode. The data is written to the current cursor position. The cursor 
     *     position is updated after the write operation. For more information about console handles, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * 
     * When writing to a communications device, the behavior of 
     *     <b>WriteFile</b> is determined by the current communication time-out 
     *     as set and retrieved by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getcommtimeouts">GetCommTimeouts</a> functions. Unpredictable results can 
     *     occur if you fail to set the time-out values. For more information about communication time-outs, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a>.
     * 
     * Although a single-sector write is atomic, a multi-sector write is not guaranteed to be atomic unless you are 
     *     using a transaction (that is, the handle created is a transacted handle; for example, a handle created using 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiletransacteda">CreateFileTransacted</a>). Multi-sector 
     *     writes that are cached may not always be written to the disk right away; therefore, specify 
     *     <b>FILE_FLAG_WRITE_THROUGH</b> in 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> to ensure that an entire multi-sector write is 
     *     written to the disk without potential caching delays.
     * 
     * If you write directly to a volume that has a mounted file system, you must first obtain exclusive access to 
     *     the volume. Otherwise, you risk causing data corruption or system instability, because your application's writes 
     *     may conflict with other changes coming from the file system and leave the contents of the volume in an 
     *     inconsistent state. To prevent these problems, the following changes have been made in Windows Vista 
     *     and later:
     * 
     * <ul>
     * <li>A write on a volume handle will succeed if the volume does not have a mounted file system, or if one of the 
     *       following conditions is true:
     *       <ul>
     * <li>The sectors to be written to are boot sectors.</li>
     * <li>The sectors to be written to reside outside of file system space.</li>
     * <li>You have explicitly locked or dismounted the volume by using 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_lock_volume">FSCTL_LOCK_VOLUME</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_dismount_volume">FSCTL_DISMOUNT_VOLUME</a>.</li>
     * <li>The volume has no actual file system. (In other words, it has a RAW file system mounted.)</li>
     * </ul>
     * </li>
     * <li>A write on a disk handle will succeed if one of the following conditions is true:
     *       <ul>
     * <li>The sectors to be written to do not fall within a volume's extents.</li>
     * <li>The sectors to be written to fall within a mounted volume, but you have explicitly locked or dismounted 
     *         the volume by using <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_lock_volume">FSCTL_LOCK_VOLUME</a> or 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_dismount_volume">FSCTL_DISMOUNT_VOLUME</a>.</li>
     * <li>The sectors to be written to fall within a volume that has no mounted file system other than RAW.</li>
     * </ul>
     * </li>
     * </ul>
     * There are strict requirements for successfully working with files opened with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> using 
     *     <b>FILE_FLAG_NO_BUFFERING</b>. For details see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-buffering">File Buffering</a>.
     * 
     * If <i>hFile</i> was opened with <b>FILE_FLAG_OVERLAPPED</b>, the 
     *      following conditions are in effect:
     * 
     * <ul>
     * <li>The <i>lpOverlapped</i> parameter must point to a valid and unique 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, otherwise the function can 
     *       incorrectly report that the write operation is complete.</li>
     * <li>The <i>lpNumberOfBytesWritten</i> parameter should be set to 
     *       <b>NULL</b>. To get the number of bytes written, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function. If the 
     *       <i>hFile</i> parameter is associated with an I/O completion port, you can also get the number 
     *       of bytes written by calling the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function.</li>
     * </ul>
     * In Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="synchronization_and_file_position"></a><a id="SYNCHRONIZATION_AND_FILE_POSITION"></a>Synchronization and File Position</h3>
     * If <i>hFile</i> is opened with <b>FILE_FLAG_OVERLAPPED</b>, it is an 
     *       asynchronous file handle; otherwise it is synchronous. The rules for using the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure are slightly different for each, 
     *       as previously noted.
     * 
     * <div class="alert"><b>Note</b>  If a  file or device is opened for asynchronous I/O, subsequent calls to functions such as 
     *       <b>WriteFile</b> using that handle generally return immediately, 
     *       but can also behave synchronously with respect to blocked execution. For more information, see 
     *       <a href="https://support.microsoft.com/kb/156932">http://support.microsoft.com/kb/156932</a>.</div>
     * <div> </div>
     * Considerations for working with asynchronous file handles:
     * 
     * <ul>
     * <li><b>WriteFile</b> may return before the write operation is 
     *        complete. In this scenario, <b>WriteFile</b> returns 
     *        <b>FALSE</b> and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        function returns <b>ERROR_IO_PENDING</b>, which allows the calling process to continue while 
     *        the system completes the write operation.</li>
     * <li>The <i>lpOverlapped</i> parameter must 
     *        not be <b>NULL</b> and should be used with the following facts in mind: 
     *        <ul>
     * <li>Although the event specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 
     *          structure is set and reset automatically by the system, the offset that is specified in the 
     *          <b>OVERLAPPED</b> structure is not automatically 
     *          updated.</li>
     * <li><b>WriteFile</b> resets the event to a nonsignaled state 
     *          when it begins the I/O operation.</li>
     * <li>The event specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure 
     *          is set to a signaled state when the write operation is complete; until that time, the write operation is 
     *          considered pending.</li>
     * <li>Because the write operation starts at the offset that is specified in the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, and 
     *          <b>WriteFile</b> may return before the system-level write 
     *          operation is complete (write pending), neither the offset nor any other part of the structure should be 
     *          modified, freed, or reused by the application until the event is signaled (that is, the write 
     *          completes).</li>
     * </ul>
     * </li>
     * </ul>
     * Considerations for working with synchronous file handles:
     * 
     * <ul>
     * <li>If <i>lpOverlapped</i> is <b>NULL</b>, the write operation starts at 
     *        the current file position and <b>WriteFile</b> does not return 
     *        until the operation is complete, and the system updates the file pointer before 
     *        <b>WriteFile</b> returns.</li>
     * <li>If <i>lpOverlapped</i> is not <b>NULL</b>, the write operation 
     *        starts at the offset that is specified in the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure and 
     *        <b>WriteFile</b> does not return until the write operation is 
     *        complete. The system updates the <b>OVERLAPPED</b> Internal and InternalHigh fields 
     *        and the file pointer before <b>WriteFile</b> returns.</li>
     * </ul>
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> and 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * <h3><a id="pipes"></a><a id="PIPES"></a>Pipes</h3>
     * If an anonymous pipe is being used and the read handle has been closed, when 
     *       <b>WriteFile</b> attempts to write using the pipe's corresponding 
     *       write handle, the function returns <b>FALSE</b> and 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_BROKEN_PIPE</b>.
     * 
     * If the pipe buffer is full when an application uses the 
     *       <b>WriteFile</b> function to write to a pipe, the write operation 
     *       may not finish immediately. The write operation will be completed when a read operation (using the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfile">ReadFile</a> function) makes more system buffer space available 
     *       for the pipe.
     * 
     * When writing to a non-blocking, byte-mode pipe handle with insufficient buffer space, 
     *       <b>WriteFile</b> returns <b>TRUE</b> with 
     *       *<i>lpNumberOfBytesWritten</i> &lt; <i>nNumberOfBytesToWrite</i>.
     * 
     * For more information about pipes, see <a href="https://docs.microsoft.com/windows/desktop/ipc/pipes">Pipes</a>.
     * 
     * <h3><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the file handle, then the file write is transacted. For more information, 
     *       see <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.
     * @param {Pointer<Void>} hFile A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, 
     *        tape drive, socket, communications resource, mailslot, or  pipe).
     * 
     * The <i>hFile</i> parameter must have been created with the write access. For more 
     *        information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * For asynchronous write operations, <i>hFile</i> can be any handle opened with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function using the 
     *        <b>FILE_FLAG_OVERLAPPED</b> flag or a socket handle returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.
     * @param {Pointer} lpBuffer A pointer to the buffer containing the data to be written to the file or device.
     * 
     * This buffer must remain valid for the duration of the write operation. The caller must not use this buffer 
     *         until the write operation is completed.
     * @param {Integer} nNumberOfBytesToWrite The number of bytes to be written to the file or device.
     * 
     * A value of zero specifies a null write operation. The behavior of a null write operation depends on the 
     *         underlying file system or communications technology.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>Pipe write operations across a network are limited in size per write. The amount varies per platform. 
     *          For x86 platforms it's 63.97 MB. For x64 platforms it's 31.97 MB. For Itanium it's 63.95 MB. For more 
     *          information regarding pipes, see the Remarks section.
     * @param {Pointer<UInt32>} lpNumberOfBytesWritten A pointer to the variable that receives the number of bytes written when using a synchronous 
     *         <i>hFile</i> parameter. <b>WriteFile</b> sets 
     *         this value to zero before doing any work or error checking. Use <b>NULL</b> for this 
     *         parameter if this is an asynchronous operation to avoid potentially erroneous results.
     * 
     * This parameter can be <b>NULL</b> only when the <i>lpOverlapped</i> 
     *         parameter is not <b>NULL</b>.
     *         
     * <b>Windows 7:  </b>This parameter can not be <b>NULL</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is 
     *        required if the <i>hFile</i> parameter was opened with 
     *        <b>FILE_FLAG_OVERLAPPED</b>, otherwise this parameter can be 
     *        <b>NULL</b>.
     * 
     * For an <i>hFile</i> that supports byte offsets, if you use this parameter you must specify 
     *        a byte offset at which to start writing to the file or device. This offset is specified by setting the 
     *        <b>Offset</b> and <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. For an 
     *        <i>hFile</i> that does not support byte offsets, <b>Offset</b> and 
     *        <b>OffsetHigh</b> are ignored.
     * 
     * To write to the end of file, specify both the <b>Offset</b> and 
     *        <b>OffsetHigh</b> members of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure as 0xFFFFFFFF. This is 
     *        functionally equivalent to previously calling the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to open 
     *        <i>hFile</i> using <b>FILE_APPEND_DATA</b> access.
     * 
     * For more information about different combinations of <i>lpOverlapped</i> and 
     *        <b>FILE_FLAG_OVERLAPPED</b>, see the Remarks section and the 
     *        <a href="https://docs.microsoft.com/">Synchronization and File Position</a> section.
     * @returns {Integer} If the function succeeds, the return value is nonzero (<b>TRUE</b>).
     * 
     * If the function fails, or is completing asynchronously, the return value is zero 
     *        (<b>FALSE</b>). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <div class="alert"><b>Note</b>  The <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> code 
     *        <b>ERROR_IO_PENDING</b> is not a failure; it designates the write operation is pending 
     *        completion asynchronously. For more information, see Remarks.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-writefile
     * @since windows5.1.2600
     */
    static WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\WriteFile", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToWrite, "uint*", lpNumberOfBytesWritten, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Writes data to the specified file or input/output (I/O) device. It reports its completion status asynchronously, calling the specified completion routine when writing is completed or canceled and the calling thread is in an alertable wait state.
     * @remarks
     * When using **WriteFileEx** you should check [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) even when the function returns "success" to check for conditions that are _successes_ but have some outcome you might want to know about. For example, a buffer overflow when calling **WriteFileEx** will return `TRUE`, but **GetLastError** will report the overflow with `ERROR_MORE_DATA`. If the function call is successful and there are no warning conditions, **GetLastError** will return `ERROR_SUCCESS`.
     * 
     * The **WriteFileEx** function will fail if the _hFile_ parameter is associated with an [I/O completion port](/windows/win32/FileIO/i-o-completion-ports). To perform writes using this type of handle, use the [WriteFile](/windows/win32/api/fileapi/nf-fileapi-writefile) function.
     * 
     * The **WriteFileEx** function may fail if there are too many outstanding asynchronous I/O requests. In the event of such a failure, [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) can return `ERROR_INVALID_USER_BUFFER` or `ERROR_NOT_ENOUGH_MEMORY`.
     * 
     * To cancel all pending asynchronous I/O operations, use either:
     * 
     * - [CancelIo](/windows/win32/FileIO/cancelio): This function only cancels operations issued by the calling thread for the specified file handle.
     * - [CancelIoEx](/windows/win32/FileIO/cancelioex-func): This function cancels all operations issued by the threads for the specified file handle.
     * 
     * Use [CancelSynchronousIo](/windows/win32/FileIO/cancelsynchronousio-func) to cancel pending synchronous I/O operations.
     * 
     * I/O operations that are canceled complete with the error **ERROR_OPERATION_ABORTED**.
     * 
     * If part of the file specified by _hFile_ is locked by another process, and the specified write operation overlaps the locked portion, **WriteFileEx** fails.
     * 
     * When writing to a file, the last write time is not fully updated until all handles used for writing have been closed. Therefore, to ensure an accurate last write time, close the file handle immediately after writing to the file.
     * 
     * Accessing the output buffer while a write operation is using the buffer may lead to corruption of the data written from that buffer. Applications must not write to, reallocate, or free the output buffer that a write operation is using until the write operation completes.
     * 
     * Note that the time stamps may not be updated correctly for a remote file. To ensure consistent results, use unbuffered I/O.
     * 
     * The system interprets zero bytes to write as specifying a null write operation and [WriteFile](/windows/win32/api/fileapi/nf-fileapi-writefile) does not truncate or extend the file. To truncate or extend a file, use the [SetEndOfFile](/windows/win32/api/fileapi/nf-fileapi-setendoffile) function.
     * 
     * An application uses the [WaitForSingleObjectEx](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex), [WaitForMultipleObjectsEx](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex), [MsgWaitForMultipleObjectsEx](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex), [SignalObjectAndWait](/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait), and [SleepEx](/windows/win32/api/synchapi/nf-synchapi-sleepex) functions to enter an alertable wait state. For more information about alertable wait states and overlapped I/O operations, see [About Synchronization](/windows/win32/Sync/about-synchronization).
     * 
     * If you write directly to a volume that has a mounted file system, you must first obtain exclusive access to the volume. Otherwise, you risk causing data corruption or system instability, because your application's writes may conflict with other changes coming from the file system and leave the contents of the volume in an inconsistent state. To prevent these problems, the following changes have been made in Windows Vista and later:
     * 
     * - A write on a volume handle will succeed if the volume does not have a mounted file system, or if one of the following conditions is true:
     *   - The sectors to be written to are boot sectors.
     *   - The sectors to be written to reside outside of file system space.
     *   - You have explicitly locked or dismounted the volume by using [FSCTL_LOCK_VOLUME](/windows/win32/api/winioctl/ni-winioctl-fsctl_lock_volume) or [FSCTL_DISMOUNT_VOLUME](/windows/win32/api/winioctl/ni-winioctl-fsctl_dismount_volume).
     *   - The volume has no actual file system. (In other words, it has a RAW file system mounted.)
     * - A write on a disk handle will succeed if one of the following conditions is true:
     *   - The sectors to be written to do not fall within a volume's extents.
     *   - The sectors to be written to fall within a mounted volume, but you have explicitly locked or dismounted the volume by using [FSCTL_LOCK_VOLUME](/windows/win32/api/winioctl/ni-winioctl-fsctl_lock_volume) or [FSCTL_DISMOUNT_VOLUME](/windows/win32/api/winioctl/ni-winioctl-fsctl_dismount_volume).
     *   - The sectors to be written to fall within a volume that has no mounted file system other than RAW.
     * 
     * There are strict requirements for successfully working with files opened with [CreateFile](/windows/win32/api/fileapi/nf-fileapi-createfilea) using **FILE_FLAG_NO_BUFFERING**. For details see [File Buffering](/windows/win32/FileIO/file-buffering).
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * | Technology | Supported |
     * |--------|--------|
     * | Server Message Block (SMB) 3.0 protocol | Yes |
     * | SMB 3.0 Transparent Failover (TFO) | Yes |
     * | SMB 3.0 with Scale-out File Shares (SO) | Yes |
     * | Cluster Shared Volume File System (CsvFS) | Yes |
     * | Resilient File System (ReFS) | Yes |
     * @param {Pointer<Void>} hFile A handle to the file or I/O device (for example, a file, file stream, physical disk, volume,  console buffer, tape drive, socket, communications resource, mailslot, or  pipe).
     * 
     * This parameter can be any handle opened with the **FILE_FLAG_OVERLAPPED** flag by the [CreateFile](/windows/win32/api/fileapi/nf-fileapi-createfilea) function, or a socket handle returned by the [socket](/windows/win32/api/winsock2/nf-winsock2-socket) or [accept](/windows/win32/api/winsock2/nf-winsock2-accept) function.
     * 
     * Do not associate an I/O completion port with this handle. For more information, see the Remarks section.
     * 
     * This handle also must have the **GENERIC_WRITE** access right. For more information on access rights, see [File Security and Access Rights](/windows/win32/FileIO/file-security-and-access-rights).
     * @param {Pointer} lpBuffer A pointer to the buffer containing the data to be written to the file or device.
     * 
     * This buffer must remain valid for the duration of the write operation. The caller must not use this buffer until the write operation is completed.
     * @param {Integer} nNumberOfBytesToWrite The number of bytes to be written to the file or device.
     * 
     * A value of zero specifies a null write operation. The behavior of a null write operation depends on the underlying file system.
     * 
     * Pipe write operations across a network are limited to 65,535 bytes per write. For more information regarding  pipes, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an [OVERLAPPED](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) data structure that supplies data to be used during the overlapped (asynchronous) write operation.
     * 
     * For files that support byte offsets, you must specify a byte offset at which to start writing to the file. You specify this offset by setting the **Offset** and **OffsetHigh** members of the [OVERLAPPED](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure. For files or devices that do not support byte offsets, **Offset** and **OffsetHigh** are ignored.
     * 
     * To write to the end of file, specify both the **Offset** and **OffsetHigh** members of the [OVERLAPPED](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure as `0xFFFFFFFF`. This is functionally equivalent to previously calling the [CreateFile](/windows/win32/api/fileapi/nf-fileapi-createfilea) function to open _hFile_ using **FILE_APPEND_DATA** access.
     * 
     * The **WriteFileEx** function ignores the [OVERLAPPED](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure's **hEvent** member. An application is free to use that member for its own purposes in the context of a **WriteFileEx** call. **WriteFileEx** signals completion of its writing operation by calling, or queuing a call to, the completion routine pointed to by _lpCompletionRoutine_, so it does not need an event handle.
     * 
     * The **WriteFileEx** function does use the **Internal** and **InternalHigh** members of the [OVERLAPPED](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) structure. You should not change the value of these members.
     * 
     * The [OVERLAPPED](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) data structure must remain valid for the duration of the write operation. It should not be a variable that can go out of scope while the write operation is pending completion.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to a completion routine to be called when the write operation has been completed and the calling thread is in an alertable wait state. For more information about this completion routine, see [FileIOCompletionRoutine](/windows/win32/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine).
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [GetLastError](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).
     * 
     * If the **WriteFileEx** function succeeds, the calling thread has an asynchronous I/O operation pending: the overlapped write operation to the file. When this I/O operation finishes, and the calling thread is blocked in an alertable wait state, the operating system calls the function pointed to by _lpCompletionRoutine_, and the wait completes with a return code of `WAIT_IO_COMPLETION`.
     * 
     * If the function succeeds and the file-writing operation finishes, but the calling thread is not in an alertable wait state, the system queues the call to *_lpCompletionRoutine_, holding the call until the calling thread enters an alertable wait state. For more information about alertable wait states and overlapped input/output operations, see [About Synchronization](/windows/win32/Sync/about-synchronization).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-writefileex
     * @since windows5.1.2600
     */
    static WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\WriteFileEx", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToWrite, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves data from an array of buffers and writes the data to a file.
     * @remarks
     * This function is not supported for 32-bit applications by WOW64 on the Itanium-based systems.
     * 
     * The [FILE_SEGMENT_ELEMENT structure](../winnt/ns-winnt-file_segment_element.md) is defined as follows:
     * 
     * ```cpp
     * typedef union _FILE_SEGMENT_ELEMENT {
     *     PVOID64   Buffer;
     *     ULONGLONG Alignment;
     * }FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
     * ```
     * 
     * Assigning a pointer to the **Buffer** member will sign-extend the value if the code is compiled as 32-bits; this can break large-address aware applications running on systems configured with <a href="https://docs.microsoft.com/windows/desktop/Memory/4-gigabyte-tuning">4-Gigabyte Tuning</a> or running under WOW64 on 64-bit Windows. Therefore, use the **PtrToPtr64** macro when assigning pointers to **Buffer**.
     * 
     * If part of the file specified by *hFile* is locked by another process, and the write operation overlaps the locked portion, the **WriteFileGather** function fails.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the file handle, then the operation is transacted.
     * @param {Pointer<Void>} hFile A handle to the file. The file handle must be created with the **GENERIC_WRITE** access right, and the **FILE_FLAG_OVERLAPPED** and **FILE_FLAG_NO_BUFFERING** flags. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<FILE_SEGMENT_ELEMENT>} aSegmentArray A pointer to an array of [FILE_SEGMENT_ELEMENT structure](../winnt/ns-winnt-file_segment_element.md) buffers that contain the data. For a description of this union, see Remarks.
     * 
     * Each element contains the address of one page of data.
     * 
     * > [!NOTE]
     * > To determine the size of a system page, use the <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo">GetSystemInfo</a> function.
     * 
     * The array must contain enough elements to store *nNumberOfBytesToWrite* bytes of data, and one element for the terminating **NULL**. For example, if there are 40 KB to be read and the page size is 4 KB, the array must have 11 elements that includes 10 elements for the data and one element for the **NULL**.
     * 
     * Each buffer must be at least the size of a system memory page and must be aligned on a system memory page size boundary. The system writes one system memory page of data from each buffer.
     * 
     * The function gathers the data from the buffers in a sequential order. For example, it writes data to the file from the first buffer, then the second buffer, and so on until there is no more data.
     * 
     * Due to the asynchronous operation of this function, precautions must be taken to ensure that this parameter always references valid memory for the lifetime of the asynchronous writes. For instance, a common programming error is to use local stack storage and then allow execution to run out of scope.
     * @param {Integer} nNumberOfBytesToWrite The total number of bytes to be written. Each element of *aSegmentArray* contains a one-page chunk of this total. Because the file must be opened with **FILE_FLAG_NO_BUFFERING**, the number of bytes must be a multiple of the sector size of the file system where the file is located.
     * 
     * If *nNumberOfBytesToWrite* is zero (0), the function performs a null write operation. The behavior of a null write operation depends on the underlying file system. If *nNumberOfBytesToWrite* is not zero (0) and the offset and length of the write place data beyond the current end of the file, the **WriteFileGather** function extends the file.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> data structure.
     * 
     * The **WriteFileGather** function requires a valid 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. The *lpOverlapped* parameter cannot be **NULL**.
     * 
     * The **WriteFileGather** function starts writing data to the file at a position that is specified by the **Offset** and **OffsetHigh** members of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * The **WriteFileGather** function may return before the write operation is complete. In that scenario, the **WriteFileGather** function returns the value zero (0), and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value **ERROR_IO_PENDING**. This asynchronous operation of the **WriteFileGather** function lets the calling process continue while the write operation completes. 
     * 
     * You can call the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-hasoverlappediocompleted">HasOverlappedIoCompleted</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function to obtain information about the completion of the write operation. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the function returns before the write operation is complete, the function returns zero (0), and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns **ERROR_IO_PENDING**.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-writefilegather
     * @since windows5.1.2600
     */
    static WriteFileGather(hFile, aSegmentArray, nNumberOfBytesToWrite, lpOverlapped) {
        static lpReserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("KERNEL32.dll\WriteFileGather", "ptr", hFile, "ptr", aSegmentArray, "uint", nNumberOfBytesToWrite, "uint*", lpReserved, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the path of the directory designated for temporary files. (Unicode)
     * @remarks
     * > [!NOTE]
     * > Apps should call [GetTempPath2](/windows/win32/api/fileapi/nf-fileapi-gettemppath2w) instead of **GetTempPath**. 
     * 
     * The <b>GetTempPath</b> function checks for the existence of 
     *     environment variables in the following order and uses the first path found:
     * 
     * <ol>
     * <li>The path specified by the TMP environment variable.</li>
     * <li>The path specified by the TEMP environment variable.</li>
     * <li>The path specified by the USERPROFILE environment variable.</li>
     * <li>The Windows directory.</li>
     * </ol>
     * Note that the function does not verify that the path exists, nor does it test to see if the current process has 
     *      any kind of access rights to the path. The <b>GetTempPath</b> 
     *      function returns the properly formatted string that specifies the fully qualified path based on the environment 
     *      variable search order as previously specified. The application should verify the existence of the path and 
     *      adequate access rights to the path prior to any use for file I/O operations.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the temp path name 
     *     maintains any symbolic links.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} nBufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Char>} lpBuffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppathw
     * @since windows5.1.2600
     */
    static GetTempPathW(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempPathW", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a volume GUID path for the volume that is associated with the specified volume mount point ( drive letter, volume GUID path, or mounted folder). (GetVolumeNameForVolumeMountPointW)
     * @remarks
     * Use 
     * <b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setvolumemountpointa">SetVolumeMountPoint</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * Mount points aren't supported by ReFS volumes.
     * @param {Pointer<Char>} lpszVolumeMountPoint A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\\") or a drive letter (for example, "X:\\"). The string must end with a trailing backslash ('\\').
     * @param {Pointer<Char>} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\\\?\Volume{<i>GUID</i>}\\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.
     * @param {Integer} cchBufferLength The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw
     * @since windows5.1.2600
     */
    static GetVolumeNameForVolumeMountPointW(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeNameForVolumeMountPointW", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a list of drive letters and mounted folder paths for the specified volume. (GetVolumePathNamesForVolumeNameW)
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Char>} lpszVolumeName A volume <b>GUID</b> path for the volume. A volume <b>GUID</b> 
     *       path is of the form 
     *       "\\\\?\\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\\".
     * @param {Pointer<Char>} lpszVolumePathNames A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an 
     *       array of null-terminated strings terminated by an additional <b>NULL</b> character. If the 
     *       buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.
     * @param {Integer} cchBufferLength The length of the <i>lpszVolumePathNames</i> buffer, in 
     *       <b>TCHARs</b>, including all <b>NULL</b> characters.
     * @param {Pointer<UInt32>} lpcchReturnLength If the call is successful, this parameter is the number of <b>TCHARs</b> copied to 
     *       the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer 
     *       required to hold the complete list, in <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the buffer is not large enough to 
     *        hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the 
     *        <i>lpcchReturnLength</i> parameter receives the required buffer size.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getvolumepathnamesforvolumenamew
     * @since windows5.1.2600
     */
    static GetVolumePathNamesForVolumeNameW(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength) {
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName
        lpszVolumePathNames := lpszVolumePathNames is String? StrPtr(lpszVolumePathNames) : lpszVolumePathNames

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNamesForVolumeNameW", "ptr", lpszVolumeName, "ptr", lpszVolumePathNames, "uint", cchBufferLength, "uint*", lpcchReturnLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file or I/O device.
     * @remarks
     * To compile an application that uses the <b>CreateFile2</b> 
     *     function, define the <b>_WIN32_WINNT</b> macro as 0x0602 or later. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.
     * 
     * <b>CreateFile2</b> supports file interaction and most other 
     *     types of I/O devices and mechanisms available to Windows developers. This section attempts to cover the varied 
     *     issues developers may experience when using <b>CreateFile2</b> in 
     *     different contexts and with different I/O types. The text attempts to use the word <i>file</i> 
     *     only when referring specifically to data stored in an actual file on a file system. However, some uses of 
     *     <i>file</i> may be referring more generally to an I/O object that supports file-like mechanisms. 
     *     This liberal use of the term <i>file</i> is particularly prevalent in constant names and 
     *     parameter names because of the previously mentioned historical reasons.
     * 
     * When an application is finished using the object handle returned by 
     *     <b>CreateFile2</b>, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close the handle. This not only 
     *     frees up system resources, but can have wider influence on things like sharing the file or device and committing 
     *     data to disk. Specifics are noted within this topic as appropriate.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *      directories. On volumes that have a mounted file system with this support, a new file inherits the compression 
     *      and encryption attributes of its directory.
     * 
     * You cannot use <b>CreateFile2</b> to control compression, 
     *      decompression, or decryption on a file or directory. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>, 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</a>, 
     *      and <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * If the <b>lpSecurityAttributes</b> member of the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-createfile2_extended_parameters">CREATEFILE2_EXTENDED_PARAMETERS</a> structure 
     *      passed in the <i>pCreateExParams</i> parameter is <b>NULL</b>, the handle 
     *      returned by <b>CreateFile2</b> cannot be inherited by any child 
     *      processes your application may create. The following information regarding this member also applies:
     * 
     * <ul>
     * <li>If the <b>bInheritHandle</b> member variable is not <b>FALSE</b>, 
     *       which is any nonzero value, then the handle can be inherited. Therefore it is critical this structure member be 
     *       properly initialized to <b>FALSE</b> if you do not intend the handle to be inheritable.</li>
     * <li>The access control lists (ACL) in the default security descriptor for a file or directory are inherited 
     *       from its parent directory.</li>
     * <li>The target file system must support security on files and directories for the 
     *       <b>lpSecurityDescriptor</b> member to have an effect on them, which can be determined by 
     *       using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>.</li>
     * </ul>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Symbolic_Link_Behavior"></a><a id="symbolic_link_behavior"></a><a id="SYMBOLIC_LINK_BEHAVIOR"></a>Symbolic Link Behavior</h3>
     * If the call to this function creates a file, there is no change in behavior. Also, consider the following 
     *       information regarding <b>FILE_FLAG_OPEN_REPARSE_POINT</b> flag for the 
     *       <b>dwFileFlags</b> member of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-createfile2_extended_parameters">CREATEFILE2_EXTENDED_PARAMETERS</a> 
     *       structure passed in the <i>pCreateExParams</i> parameter:
     * 
     * <ul>
     * <li>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *          symbolic link.</li>
     * <li>If <b>TRUNCATE_EXISTING</b> or <b>FILE_FLAG_DELETE_ON_CLOSE</b> 
     *          are specified, the file affected is a symbolic link.</li>
     * </ul>
     * </li>
     * <li>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is not specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *          target.</li>
     * <li>If <b>CREATE_ALWAYS</b>, <b>TRUNCATE_EXISTING</b>, or 
     *          <b>FILE_FLAG_DELETE_ON_CLOSE</b> are specified, the file affected is the target.</li>
     * </ul>
     * </li>
     * </ul>
     * <h3><a id="Files"></a><a id="files"></a><a id="FILES"></a>Files</h3>
     * If you rename or delete a file and then restore it shortly afterward, the system searches the cache for file 
     *       information to restore. Cached information includes its short/long name pair and creation time.
     * 
     * If you call <b>CreateFile2</b> on a file that is pending deletion 
     *       as a result of a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>, the function 
     *       fails. The operating system delays file deletion until all handles to the file are closed. 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The <i>dwDesiredAccess</i> parameter can be zero, allowing the application to query file 
     *       attributes without accessing the file if the application is running with adequate security settings. This is 
     *       useful to test for the existence of a file without opening it for read and/or write access, or to obtain other 
     *       statistics about the file or directory. See 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-and-setting-file-information">Obtaining and Setting File Information</a> 
     *       and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>.
     * 
     * When an application creates a file across a network, it is better to use 
     *       <c>GENERIC_READ | GENERIC_WRITE</c> for 
     *       <i>dwDesiredAccess</i> than to use <b>GENERIC_WRITE</b> alone. The 
     *       resulting code is faster, because the redirector can use the cache manager and send fewer SMBs with more data. 
     *       This combination also avoids an issue where writing to a file across a network can occasionally return 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * <h3><a id="File_Streams"></a><a id="file_streams"></a><a id="FILE_STREAMS"></a>File Streams</h3>
     * On NTFS file systems, you can use <b>CreateFile2</b> to create 
     *       separate streams within a file. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <h3><a id="Directories"></a><a id="directories"></a><a id="DIRECTORIES"></a>Directories</h3>
     * An application cannot create a directory by using 
     *       <b>CreateFile2</b>, therefore only the 
     *       <b>OPEN_EXISTING</b> value is valid for 
     *       <i>dwCreationDisposition</i> for this use case. To create a directory, the application must 
     *       call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>.
     * 
     * To open a directory using <b>CreateFile2</b>, specify the 
     *       <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag as part of <b>dwFileFlags</b> 
     *       member of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-createfile2_extended_parameters">CREATEFILE2_EXTENDED_PARAMETERS</a> 
     *       structure passed in the <i>pCreateExParams</i> parameter. Appropriate security checks still 
     *       apply when this flag is used without <b>SE_BACKUP_NAME</b> and 
     *       <b>SE_RESTORE_NAME</b> privileges.
     * 
     * When using <b>CreateFile2</b> to open a directory during 
     *       defragmentation of a FAT or FAT32 file system volume, do not specify the 
     *       <b>MAXIMUM_ALLOWED</b> access right. Access to the directory is denied if this is done. 
     *       Specify the <b>GENERIC_READ</b> access right instead.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-directory-management">About Directory Management</a>.
     * 
     * <h3><a id="Physical_Disks_and_Volumes"></a><a id="physical_disks_and_volumes"></a><a id="PHYSICAL_DISKS_AND_VOLUMES"></a>Physical Disks and Volumes</h3>
     * Direct access to the disk or to a volume is restricted.
     * 
     * You can use the <b>CreateFile2</b> function to open a physical 
     *       disk drive or a volume, which returns a direct access storage device (DASD) handle that can be used with the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function. This enables you to access 
     *       the disk or volume directly, for example such disk metadata as the partition table. However, this type of access 
     *       also exposes the disk drive or volume to potential data loss, because an incorrect write to a disk using this 
     *       mechanism could make its contents inaccessible to the operating system. To ensure data integrity, be sure to 
     *       become familiar with <b>DeviceIoControl</b> and how other 
     *       APIs behave differently with a direct access handle as opposed to a file system handle.
     * 
     * The following requirements must be met for such a call to succeed:
     * 
     * <ul>
     * <li>The caller must have administrative privileges. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.</li>
     * <li>The <i>dwCreationDisposition</i> parameter must have the 
     *       <b>OPEN_EXISTING</b> flag.</li>
     * <li>When opening a volume or floppy disk, the <i>dwShareMode</i> parameter must have the 
     *       <b>FILE_SHARE_WRITE</b> flag.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  The <i>dwDesiredAccess</i> parameter can be zero, allowing the application to query 
     *       device attributes without accessing a device. This is useful for an application to determine the size of a 
     *       floppy disk drive and the formats it supports without requiring a floppy disk in a drive, for instance. It can 
     *       also be used for reading statistics without requiring higher-level data read/write permission.</div>
     * <div> </div>
     * When opening a physical drive <i>x</i>:, the 
     *       <i>lpFileName</i> string should be the following form: 
     *       "\\.\PhysicalDrive<i>X</i>". Hard disk numbers 
     *       start at zero. The following table shows some examples of physical drive strings.
     * 
     * <table>
     * <tr>
     * <th>String</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>"\\.\PhysicalDrive0"</td>
     * <td>Opens the first physical drive.</td>
     * </tr>
     * <tr>
     * <td>"\\.\PhysicalDrive2"</td>
     * <td>Opens the third physical drive.</td>
     * </tr>
     * </table>
     *  
     * 
     * To obtain the physical drive identifier for a volume, open a handle to the volume and call the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a>. 
     *       This control code returns the disk number and offset for each of the volume's one or more extents; a volume can 
     *       span multiple physical disks.
     * 
     * For an example of opening a physical drive, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/DevIO/calling-deviceiocontrol">Calling DeviceIoControl</a>.
     * 
     * When opening a volume or removable media drive (for example, a floppy disk drive or flash memory thumb drive), 
     *       the <i>lpFileName</i> string should be the following form: 
     *       "\\.&#92;<i>X</i>:". Do not use a trailing backslash 
     *       (\\), which indicates the root directory of a drive. The following table shows some examples of drive strings.
     * 
     * <table>
     * <tr>
     * <th>String</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>"\\.\A:"</td>
     * <td>Opens floppy disk drive A.</td>
     * </tr>
     * <tr>
     * <td>"\\.\C:"</td>
     * <td>Opens the C: volume.</td>
     * </tr>
     * <tr>
     * <td>"\\.\C:\"</td>
     * <td>Opens the file system of the C: volume.</td>
     * </tr>
     * </table>
     *  
     * 
     * You can also open a volume by referring to its volume name. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * 
     * A volume contains one or more mounted file systems. Volume handles can be opened as noncached at the 
     *       discretion of the particular file system, even when the noncached option is not specified in 
     *       <b>CreateFile2</b>. You should assume that all Microsoft file 
     *       systems open volume handles as noncached. The restrictions on noncached I/O for files also apply to volumes.
     * 
     * A file system may or may not require buffer alignment even though the data is noncached. However, if the 
     *       noncached option is specified when opening a volume, buffer alignment is enforced regardless of the file system 
     *       on the volume. It is recommended on all file systems that you open volume handles as noncached, and follow the 
     *       noncached I/O restrictions.
     * 
     * <div class="alert"><b>Note</b>  To read or write to the last few sectors of the volume, you must call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> and specify 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>. This signals 
     *       the file system driver not to perform any I/O boundary checks on partition read or write calls. Instead, 
     *       boundary checks are performed by the device driver.</div>
     * <div> </div>
     * <h3><a id="Changer_Device"></a><a id="changer_device"></a><a id="CHANGER_DEVICE"></a>Changer Device</h3>
     * The <b>IOCTL_CHANGER_*</b> control codes for 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> accept a handle to a changer device. 
     *       To open a changer device, use a file name of the following form: 
     *       "\\.\Changer<i>x</i>" where 
     *       <i>x</i> is a number that indicates which device to open, starting with zero. To open 
     *       changer device zero in an application that is written in C or C++, use the following file name: 
     *       "\\\\.\\Changer0".
     * 
     * <h3><a id="Tape_Drives"></a><a id="tape_drives"></a><a id="TAPE_DRIVES"></a>Tape Drives</h3>
     * You can open tape drives by using a file name of the following form: 
     *       "\\.\TAPE<i>x</i>" where 
     *       <i>x</i> is a number that indicates which drive to open, starting with tape drive zero. To 
     *       open tape drive zero in an application that is written in C or C++, use the following file name: 
     *       "\\\\.\\TAPE0".
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/Backup/backup">Backup</a>.
     * 
     * <h3><a id="Communications_Resources"></a><a id="communications_resources"></a><a id="COMMUNICATIONS_RESOURCES"></a>Communications Resources</h3>
     * The <b>CreateFile2</b> function can create a handle to a 
     *       communications resource, such as the serial port COM1. For communications resources, 
     *       the <i>dwCreationDisposition</i> parameter must be 
     *       <b>OPEN_EXISTING</b>, the <i>dwShareMode</i> parameter must be zero 
     *       (exclusive access), and the <i>hTemplateFile</i> parameter must be 
     *       <b>NULL</b>. Read, write, or read/write access can be specified, and the handle can be opened 
     *       for overlapped I/O.
     * 
     * To specify a COM port number greater than 9, use the following syntax: 
     *       "\\.\COM10". This syntax works for all port numbers and hardware that 
     *       allows COM port numbers to be specified.
     * 
     * For more information about communications, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/DevIO/communications-resources">Communications</a>.
     * 
     * <h3><a id="Consoles"></a><a id="consoles"></a><a id="CONSOLES"></a>Consoles</h3>
     * The <b>CreateFile2</b> function can create a handle to console 
     *       input (CONIN$). If the process has an open handle to it as a result of inheritance or 
     *       duplication, it can also create a handle to the active screen buffer (CONOUT$). The 
     *       calling process must be attached to an inherited console or one allocated by the 
     *       <a href="https://docs.microsoft.com/windows/console/allocconsole">AllocConsole</a> function. For console handles, set the 
     *       <b>CreateFile2</b> parameters as follows.
     * 
     * <table>
     * <tr>
     * <th>Parameters</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td>
     * <i>lpFileName</i>
     * 
     * </td>
     * <td>
     * Use the CONIN$ value to specify console input.
     * 
     * Use the CONOUT$ value to specify console output.
     * 
     * CONIN$ gets a handle to the console input buffer, even if the 
     *          <a href="https://docs.microsoft.com/windows/console/setstdhandle">SetStdHandle</a> function redirects the standard input 
     *          handle. To get the standard input handle, use the 
     *          <a href="https://docs.microsoft.com/windows/console/getstdhandle">GetStdHandle</a> function.
     * 
     * CONOUT$ gets a handle to the active screen buffer, even if 
     *          <a href="https://docs.microsoft.com/windows/console/setstdhandle">SetStdHandle</a> redirects the standard output handle. To 
     *          get the standard output handle, use <a href="https://docs.microsoft.com/windows/console/getstdhandle">GetStdHandle</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwDesiredAccess</i>
     * 
     * </td>
     * <td>
     * <c>GENERIC_READ | GENERIC_WRITE</c> is preferred, but either one can 
     *          limit access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwShareMode</i>
     * 
     * </td>
     * <td>
     * When opening CONIN$, specify 
     *          <b>FILE_SHARE_READ</b>. When opening CONOUT$, specify 
     *          <b>FILE_SHARE_WRITE</b>.
     * 
     * If the calling process inherits the console, or if a child process should be able to access the console, 
     *          this parameter must be <c>FILE_SHARE_READ | FILE_SHARE_WRITE</c>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <i>dwCreationDisposition</i>
     * 
     * </td>
     * <td>
     * You should specify <b>OPEN_EXISTING</b> when using 
     *          <b>CreateFile2</b> to open the console.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Set the members of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-createfile2_extended_parameters">CREATEFILE2_EXTENDED_PARAMETERS</a> 
     *       structure passed in the <i>pCreateExParams</i> parameter as follows.
     * 
     * <table>
     * <tr>
     * <th>Members</th>
     * <th>Value</th>
     * </tr>
     * <tr>
     * <td>
     * <b>lpSecurityAttributes</b>
     * 
     * </td>
     * <td>
     * If you want the console to be inherited, the <b>bInheritHandle</b> member of the 
     *          <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure 
     *          must be <b>TRUE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * <b>dwFileAttributes</b>
     * 
     * <b>dwFileFlags</b>
     * 
     * <b>dwSecurityQosFlags</b>
     * 
     * <b>hTemplateFile</b>
     * 
     * </td>
     * <td>
     * Ignored.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following table shows various settings of <i>dwDesiredAccess</i> and 
     *       <i>lpFileName</i>.
     * 
     * <table>
     * <tr>
     * <th><i>lpFileName</i></th>
     * <th><i>dwDesiredAccess</i></th>
     * <th>Result</th>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><b>GENERIC_READ</b></td>
     * <td>Opens console for input.</td>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><b>GENERIC_WRITE</b></td>
     * <td>Opens console for output.</td>
     * </tr>
     * <tr>
     * <td>"CON"</td>
     * <td><c>GENERIC_READ | GENERIC_WRITE</c></td>
     * <td>Causes <b>CreateFile2</b> to fail; 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *         <b>ERROR_FILE_NOT_FOUND</b>.</td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Mailslots"></a><a id="mailslots"></a><a id="MAILSLOTS"></a>Mailslots</h3>
     * If <b>CreateFile2</b> opens the client end of a mailslot, the 
     *       function returns <b>INVALID_HANDLE_VALUE</b> if the mailslot client attempts to open a local 
     *       mailslot before the mailslot server has created it with the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot</a> function.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/ipc/mailslots">Mailslots</a>.
     * 
     * <h3><a id="Pipes"></a><a id="pipes"></a><a id="PIPES"></a>Pipes</h3>
     * If <b>CreateFile2</b> opens the client end of a named pipe, the 
     *       function uses any instance of the named pipe that is in the listening state. The opening process can duplicate 
     *       the handle as many times as required, but after it is opened, the named pipe instance cannot be opened by 
     *       another client. The access that is specified when a pipe is opened must be compatible with the access that is 
     *       specified in the <i>dwOpenMode</i> parameter of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function.
     * 
     * If the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> function was not 
     *       successfully called on the server prior to this operation, a pipe will not exist and 
     *       <b>CreateFile2</b> will fail with 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * 
     * If there is at least one active pipe instance but there are no available listener pipes on the server, which 
     *       means all pipe instances are currently connected, 
     *      <b>CreateFile2</b> fails with 
     *      <b>ERROR_PIPE_BUSY</b>.
     * 
     * For more information, see <a href="https://docs.microsoft.com/windows/desktop/ipc/pipes">Pipes</a>.
     * @param {Pointer<Char>} lpFileName The name of the file or device to be created or opened.
     * 
     * For information on special device names, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are <b>GENERIC_READ</b>, 
     *        <b>GENERIC_WRITE</b>, or both 
     *        (<c>GENERIC_READ | GENERIC_WRITE</c>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>, 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-access-rights-constants">File Access Rights Constants</a>, and 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-mask">ACCESS_MASK</a>.
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device 
     *        attributes without accessing that file or device, even if <b>GENERIC_READ</b> access would 
     *        have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the 
     *        <i>dwShareMode</i> parameter in an open request that already has an open handle.
     * 
     * For more information, see the Remarks section of this topic and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or 
     *        none (refer to the following table). Access requests to attributes or extended attributes are not affected by 
     *        this flag.
     * 
     * If this parameter is zero and <b>CreateFile2</b> succeeds, the 
     *        file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. 
     *        For more information, see the Remarks section.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an existing 
     *        request that has an open handle. <b>CreateFile2</b> would fail 
     *        and the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function would return 
     *        <b>ERROR_SHARING_VIOLATION</b>.
     * 
     * To enable a process to share a file or device while another process has the file or device open, use a
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     * 
     * For devices other than files, this parameter is usually set to <b>OPEN_EXISTING</b>.
     * 
     * For more information, see the Remarks section.
     * @param {Pointer<CREATEFILE2_EXTENDED_PARAMETERS>} pCreateExParams Pointer to an optional 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-createfile2_extended_parameters">CREATEFILE2_EXTENDED_PARAMETERS</a> 
     *       structure.
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-createfile2
     * @since windows8.0
     */
    static CreateFile2(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFile2", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "uint", dwCreationDisposition, "ptr", pCreateExParams)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates a virtual address range with the specified file handle.
     * @remarks
     * <b>SetFileIoOverlappedRange</b> can be used to 
     *      improve performance in an application that issues a high number of asynchronous unbuffered I/O and uses a defined 
     *      range of overlapped structures. Because this range of structures is locked in memory, the kernel can avoid 
     *      acquiring certain locks when updating the overlapped structures with the results of the I/O request.
     * 
     * <b>SetFileIoOverlappedRange</b> requires the 
     *      caller to have the <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeLockMemoryPrivilege</a> 
     *      access privilege.
     * 
     * This function has no effect on buffered and synchronous I/O.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} FileHandle A handle to the file.
     * 
     * This file handle must be opened with <b>FILE_READ_ATTRIBUTES</b> access rights.
     * @param {Pointer<Byte>} OverlappedRangeStart The starting address for the range.
     * @param {Integer} Length The length of the range, in bytes.
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfileiooverlappedrange
     * @since windows6.0.6000
     */
    static SetFileIoOverlappedRange(FileHandle, OverlappedRangeStart, Length) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileIoOverlappedRange", "ptr", FileHandle, "char*", OverlappedRangeStart, "uint", Length, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file. (ANSI)
     * @remarks
     * An application can determine whether a volume is compressed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.
     * 
     * If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesize">GetFileSize</a>.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<UInt32>} lpFileSizeHigh The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizea
     * @since windows5.1.2600
     */
    static GetCompressedFileSizeA(lpFileName, lpFileSizeHigh) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeA", "ptr", lpFileName, "uint*", lpFileSizeHigh, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file. (Unicode)
     * @remarks
     * An application can determine whether a volume is compressed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.
     * 
     * If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesize">GetFileSize</a>.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function returns the file size of the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetCompressedFileSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\\\?\\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>GetCompressedFileSizeW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<UInt32>} lpFileSizeHigh The high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizew
     * @since windows5.1.2600
     */
    static GetCompressedFileSizeW(lpFileName, lpFileSizeHigh) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeW", "ptr", lpFileName, "uint*", lpFileSizeHigh, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the first stream with a ::$DATA stream type in the specified file or directory.
     * @remarks
     * The <b>FindFirstStreamW</b> function opens a search handle and returns information about the first
     *     $DATA stream in the specified file or directory.
     *     For files, this is always the default, unnamed data stream, "::$DATA". Directories do not have $DATA streams by default
     *     and cannot have an unnamed data stream, but may have named data streams set after they have been created.
     *     After the search handle has been established, use it in calls to the
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a> function to 
     *     search for other streams in the specified file or directory. When the search handle is no longer needed, it should 
     *     be closed using the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 supports list of streams less than or equal to 64K.
     * @param {Pointer<Char>} lpFileName The fully qualified file name.
     * @param {Integer} InfoLevel The information level of the returned data. This parameter is one of the values in the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ne-fileapi-stream_info_levels">STREAM_INFO_LEVELS</a> enumeration type.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FindStreamInfoStandard"></a><a id="findstreaminfostandard"></a><a id="FINDSTREAMINFOSTANDARD"></a><dl>
     * <dt><b>FindStreamInfoStandard</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data is returned in a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_find_stream_data">WIN32_FIND_STREAM_DATA</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFindStreamData A pointer to a buffer that receives the file stream data. The format of this data depends on the value of 
     *       the <i>InfoLevel</i> parameter.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle that can be used in subsequent calls to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a> function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If no  streams can be found, the function fails and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *        <b>ERROR_HANDLE_EOF</b> (38).
     *        
     * If the filesystem does not support streams, the function fails and
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *        <b>ERROR_INVALID_PARAMETER</b> (87).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirststreamw
     * @since windows6.0.6000
     */
    static FindFirstStreamW(lpFileName, InfoLevel, lpFindStreamData) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstStreamW", "ptr", lpFileName, "int", InfoLevel, "ptr", lpFindStreamData, "uint", dwFlags)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a stream search started by a previous call to the FindFirstStreamW function.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFindStream The search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirststreamw">FindFirstStreamW</a> function.
     * @param {Pointer<Void>} lpFindStreamData A pointer to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_find_stream_data">WIN32_FIND_STREAM_DATA</a> structure that 
     *       receives information about the stream.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no  more streams can be found, 
     *        <b>GetLastError</b> returns 
     *        <b>ERROR_HANDLE_EOF</b> (38).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findnextstreamw
     * @since windows6.0.6000
     */
    static FindNextStreamW(hFindStream, lpFindStreamData) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextStreamW", "ptr", hFindStream, "ptr", lpFindStreamData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the file I/O functions are using the ANSI or OEM character set code page.
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> function causes a set of file 
     *     I/O functions to use the OEM code page. The 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> function causes the same set of file 
     *     I/O functions to use the ANSI code page. Use the <b>AreFileApisANSI</b> function to 
     *     determine which code page the set of file I/O functions is currently using. For a discussion of these functions' 
     *     usage, please see the Remarks sections of 
     *     <b>SetFileApisToOEM</b> and 
     *     <b>SetFileApisToANSI</b>.
     * 
     * The file I/O functions whose code page is ascertained by <b>AreFileApisANSI</b> are 
     *     those functions exported by KERNEL32.DLL that accept or return a file name.
     * 
     * The functions <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> set the code page for a process, so 
     *     <b>AreFileApisANSI</b> returns a value indicating the code page of an entire 
     *     process.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the set of file I/O functions is using the ANSI code page, the return value is nonzero.
     * 
     * If the set of file I/O functions is using the OEM code page, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-arefileapisansi
     * @since windows5.1.2600
     */
    static AreFileApisANSI() {
        result := DllCall("KERNEL32.dll\AreFileApisANSI", "int")
        return result
    }

    /**
     * Retrieves the path of the directory designated for temporary files. (ANSI)
     * @remarks
     * > [!NOTE]
     * > Apps should call [GetTempPath2](/windows/win32/api/fileapi/nf-fileapi-gettemppath2a) instead of **GetTempPath**. 
     * 
     * The <b>GetTempPath</b> function checks for the existence of 
     *     environment variables in the following order and uses the first path found:
     * 
     * <ol>
     * <li>The path specified by the TMP environment variable.</li>
     * <li>The path specified by the TEMP environment variable.</li>
     * <li>The path specified by the USERPROFILE environment variable.</li>
     * <li>The Windows directory.</li>
     * </ol>
     * Note that the function does not verify that the path exists, nor does it test to see if the current process has 
     *      any kind of access rights to the path. The <b>GetTempPath</b> 
     *      function returns the properly formatted string that specifies the fully qualified path based on the environment 
     *      variable search order as previously specified. The application should verify the existence of the path and 
     *      adequate access rights to the path prior to any use for file I/O operations.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the temp path name 
     *     maintains any symbolic links.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} nBufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Byte>} lpBuffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppatha
     * @since windows5.1.2600
     */
    static GetTempPathA(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempPathA", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an enumeration of all the hard links to the specified file. The FindFirstFileNameW function returns a handle to the enumeration that can be used on subsequent calls to the FindNextFileNameW function.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpFileName The name of the file.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags Reserved; specify zero (0).
     * @param {Pointer<UInt32>} StringLength The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If 
     *       this call fails and the error returned from the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function is 
     *       <b>ERROR_MORE_DATA</b> (234), the value that is returned by this parameter is the size that 
     *       the buffer pointed to by <i>LinkName</i>  must be to contain all the data.
     * @param {Pointer<Char>} LinkName A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle that can be used with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilenamew">FindNextFileNameW</a> function or closed with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To 
     *        get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstfilenamew
     * @since windows6.0.6000
     */
    static FindFirstFileNameW(lpFileName, dwFlags, StringLength, LinkName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        LinkName := LinkName is String? StrPtr(LinkName) : LinkName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileNameW", "ptr", lpFileName, "uint", dwFlags, "uint*", StringLength, "ptr", LinkName)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues enumerating the hard links to a file using the handle returned by a successful call to the FindFirstFileNameW function.
     * @remarks
     * If the function returns <b>TRUE</b>, there are more hard links to enumerate.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFindStream A handle to the enumeration that is returned by a successful call to 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilenamew">FindFirstFileNameW</a>.
     * @param {Pointer<UInt32>} StringLength The size of the <i>LinkName</i> parameter, in characters. If this call fails and the 
     *       error is <b>ERROR_MORE_DATA</b>, the value that is returned by this parameter is the size 
     *       that <i>LinkName</i>  must be to contain all the data.
     * @param {Pointer<Char>} LinkName A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If no matching files can be found, the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *        function returns <b>ERROR_HANDLE_EOF</b>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findnextfilenamew
     * @since windows6.0.6000
     */
    static FindNextFileNameW(hFindStream, StringLength, LinkName) {
        LinkName := LinkName is String? StrPtr(LinkName) : LinkName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextFileNameW", "ptr", hFindStream, "uint*", StringLength, "ptr", LinkName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about the file system and volume associated with the specified root directory. (ANSI)
     * @remarks
     * When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
     *      drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
     *      or a compact disc, respectively. To prevent the system from displaying this message box, call the
     *      <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function with
     *      <b>SEM_FAILCRITICALERRORS</b>.
     * 
     * The <b>FILE_VOL_IS_COMPRESSED</b> flag is the only indicator of volume-based compression. The
     *      file system name is not altered to indicate compression, for example, this flag is returned set on a DoubleSpace
     *      volume. When compression is volume-based, an entire volume is  compressed or not compressed.
     * 
     * The <b>FILE_FILE_COMPRESSION</b> flag indicates whether a file system supports file-based
     *      compression. When compression is file-based, individual files can be compressed or not compressed.
     * 
     * The <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> flags are
     *      mutually exclusive. Both bits cannot be returned set.
     * 
     * The maximum component length value that is stored in <i>lpMaximumComponentLength</i> is the
     *      only indicator that a volume supports longer-than-normal FAT file system (or other file system) file names. The
     *      file system name is not altered to indicate support for long file names.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize</a> function obtains the
     *      compressed size of a file. The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a>
     *      function can determine whether an individual file is compressed.
     * 
     * Symbolic link behavior—
     * 
     * If the path points to a symbolic link, the function returns volume information for the target.
     * 
     * Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If the volume supports file system transactions, the function returns
     *       <b>FILE_SUPPORTS_TRANSACTIONS</b> in <i>lpFileSystemFlags</i>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The fileapi.h header defines GetVolumeInformation as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpRootPathName A pointer to a string that contains the root directory of the volume to be described.
     * 
     * If this parameter is <b>NULL</b>, the root of the current directory is used. A trailing
     *        backslash is required. For example, you  specify \\\\MyServer\\MyShare as
     *        "\\\\MyServer\\MyShare\\", or the C drive as
     *        "C:\\".
     * @param {Pointer<Byte>} lpVolumeNameBuffer A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the
     *        <i>nVolumeNameSize</i> parameter.
     * @param {Integer} nVolumeNameSize The length of a volume name buffer, in <b>TCHARs</b>. The maximum buffer size is
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the volume name buffer is not supplied.
     * @param {Pointer<UInt32>} lpVolumeSerialNumber A pointer to a variable that receives the volume serial number.
     * 
     * This parameter can be <b>NULL</b> if the serial number is not required.
     * 
     * This function returns the volume serial number that the operating system assigns when a hard disk is
     *        formatted.  To programmatically obtain the hard disk's serial number that the manufacturer assigns, use the
     *        Windows Management Instrumentation (WMI)
     *        <a href="https://docs.microsoft.com/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a>  property
     *        <b>SerialNumber</b>.
     * @param {Pointer<UInt32>} lpMaximumComponentLength A pointer to a variable that receives the maximum length, in <b>TCHARs</b>, of a file
     *        name component  that a specified file system supports.
     * 
     * A file name component is the portion of a file name between backslashes.
     * 
     * The value that is stored in the variable  that  *<i>lpMaximumComponentLength</i> points to
     *        is used to indicate that a specified file system supports long names. For example, for a FAT file system that
     *        supports long names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can
     *        also be supported on systems that use the NTFS file system.
     * @param {Pointer<UInt32>} lpFileSystemFlags A pointer to a variable that receives flags associated with the specified file system.
     * 
     * This parameter can be one or more of the following flags. However,
     *        <b>FILE_FILE_COMPRESSION</b> and <b>FILE_VOL_IS_COMPRESSED</b> are mutually
     *        exclusive.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_SENSITIVE_SEARCH"></a><a id="file_case_sensitive_search"></a>
     * <b>FILE_CASE_SENSITIVE_SEARCH</b><br>0x00000001
     * </td>
     * <td width="60%">
     * The specified volume supports case-sensitive file names.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_CASE_PRESERVED_NAMES"></a><a id="file_case_preserved_names"></a>
     * <b>FILE_CASE_PRESERVED_NAMES</b><br>0x00000002
     * </td>
     * <td width="60%">
     * The specified volume supports preserved case of file names when it places a name on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNICODE_ON_DISK"></a><a id="file_unicode_on_disk"></a>
     * <b>FILE_UNICODE_ON_DISK</b><br>0x00000004
     * </td>
     * <td width="60%">
     * The specified volume supports Unicode in file names as they appear on disk.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_PERSISTENT_ACLS"></a><a id="file_persistent_acls"></a>
     * <b>FILE_PERSISTENT_ACLS</b><br>0x00000008
     * </td>
     * <td width="60%">
     * The specified volume preserves and enforces access control lists (ACL). For example, the NTFS file system
     *         preserves and enforces ACLs, and the FAT file system does not.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FILE_COMPRESSION"></a><a id="file_file_compression"></a>
     * <b>FILE_FILE_COMPRESSION</b><br>0x00000010
     * </td>
     * <td width="60%">
     * The specified volume supports file-based compression.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_QUOTAS"></a><a id="file_volume_quotas"></a>
     * <b>FILE_VOLUME_QUOTAS</b><br>0x00000020
     * </td>
     * <td width="60%">
     * The specified volume supports disk quotas.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_SPARSE_FILES"></a><a id="file_supports_sparse_files"></a>
     * <b>FILE_SUPPORTS_SPARSE_FILES</b><br>0x00000040
     * </td>
     * <td width="60%">
     * The specified volume supports sparse files.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_REPARSE_POINTS"></a><a id="file_supports_reparse_points"></a>
     * <b>FILE_SUPPORTS_REPARSE_POINTS</b><br>0x00000080
     * </td>
     * <td width="60%">
     * The specified volume supports reparse points.
     * 
     * <b>ReFS:  </b>ReFS supports reparse points but does not index them so
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> and
     *           <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> will not
     *           function as expected.
     * 
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_REMOTE_STORAGE"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_REMOTE_STORAGE</b><br>0x00000100
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_RETURNS_CLEANUP_RESULT_INFO"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_RETURNS_CLEANUP_RESULT_INFO</b><br>0x00000200
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_POSIX_UNLINK_RENAME"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_POSIX_UNLINK_RENAME</b><br>0x00000400
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     * <td width="40%"><a id="FILE_VOLUME_IS_COMPRESSED"></a><a id="file_volume_is_compressed"></a>
     * <b>FILE_VOLUME_IS_COMPRESSED</b><br>0x00008000
     * </td>
     * <td width="60%">
     * The specified volume is a compressed volume, for example, a DoubleSpace volume.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OBJECT_IDS"></a><a id="file_supports_object_ids"></a>
     * <b>FILE_SUPPORTS_OBJECT_IDS</b><br>0x00010000
     * </td>
     * <td width="60%">
     * The specified volume supports object identifiers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_ENCRYPTION"></a><a id="file_supports_encryption"></a>
     * <b>FILE_SUPPORTS_ENCRYPTION</b><br>0x00020000
     * </td>
     * <td width="60%">
     * The specified volume supports the Encrypted File System (EFS). For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_NAMED_STREAMS"></a><a id="file_named_streams"></a>
     * <b>FILE_NAMED_STREAMS</b><br>0x00040000
     * </td>
     * <td width="60%">
     * The specified volume supports named streams.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY_VOLUME"></a><a id="file_read_only_volume"></a>
     * <b>FILE_READ_ONLY_VOLUME</b><br>0x00080000
     * </td>
     * <td width="60%">
     * The specified volume is read-only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SEQUENTIAL_WRITE_ONCE"></a><a id="file_sequential_write_once"></a>
     * <b>FILE_SEQUENTIAL_WRITE_ONCE</b><br>0x00100000
     * </td>
     * <td width="60%">
     * The specified volume supports a single sequential write.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_TRANSACTIONS"></a><a id="file_supports_transactions"></a>
     * <b>FILE_SUPPORTS_TRANSACTIONS</b><br>0x00200000
     * </td>
     * <td width="60%">
     * The specified volume supports transactions. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/Ktm/about-ktm">About KTM</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_HARD_LINKS"></a><a id="file_supports_hard_links"></a>
     * <b>FILE_SUPPORTS_HARD_LINKS</b><br>0x00400000
     * </td>
     * <td width="60%">
     * The specified volume supports hard links. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/hard-links-and-junctions">Hard Links and Junctions</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_EXTENDED_ATTRIBUTES"></a><a id="file_supports_extended_attributes"></a>
     * <b>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</b><br>0x00800000
     * </td>
     * <td width="60%">
     * The specified volume supports extended attributes. An extended attribute is a piece of
     *         application-specific metadata that an application can associate with a file and is not part of the file's data.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_OPEN_BY_FILE_ID"></a><a id="file_supports_open_by_file_id"></a>
     * <b>FILE_SUPPORTS_OPEN_BY_FILE_ID</b><br>0x01000000
     * </td>
     * <td width="60%">
     * The file system supports open by FileID. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_USN_JOURNAL"></a><a id="file_supports_usn_journal"></a>
     * <b>FILE_SUPPORTS_USN_JOURNAL</b><br>0x02000000
     * </td>
     * <td width="60%">
     * The specified volume supports update sequence number (USN) journals. For more information, see
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/change-journal-records">Change Journal Records</a>.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This value is not supported until Windows Server 2008 R2 and Windows 7.
     * 
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_INTEGRITY_STREAMS"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_INTEGRITY_STREAMS</b><br>0x04000000
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     * <td width="40%"><a id="FILE_SUPPORTS_BLOCK_REFCOUNTING"></a><a id="file_supports_block_refcounting"></a>
     * <b>FILE_SUPPORTS_BLOCK_REFCOUNTING</b><br>0x08000000
     * </td>
     * <td width="60%">
     * The specified volume supports sharing logical clusters between files on the same volume. The file system reallocates on writes to shared clusters. Indicates that FSCTL_DUPLICATE_EXTENTS_TO_FILE is a supported operation.
     * 
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_SPARSE_VDL"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_SPARSE_VDL</b><br>0x10000000
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * <tr>
     * <td width="40%"><a id="FILE_DAX_VOLUME"></a><a id="file_dax_volume"></a>
     * <b>FILE_DAX_VOLUME</b><br>0x20000000
     * </td>
     * <td width="60%">
     * The specified volume is a direct access (DAX) volume.
     * 
     * <div class="alert"><b>Note</b>  This flag was introduced in Windows 10, version 1607.</div>
     * <div> </div>
     * </td>
     * </tr>
     * 
     * <tr>
     *   <td width="40%"><a id="FILE_SUPPORTS_GHOSTING"></a><a id="file_supports_remote_storage"></a>
     *     <b>FILE_SUPPORTS_GHOSTING</b><br>0x40000000
     *   </td>
     *   <td width="60%">
     *   </td>
     * </tr>
     * 
     * </table>
     * @param {Pointer<Byte>} lpFileSystemNameBuffer A pointer to a buffer that receives the name of the file system, for example, the FAT file system or the NTFS
     *        file system. The buffer size is specified by the <i>nFileSystemNameSize</i> parameter.
     * @param {Integer} nFileSystemNameSize The length of the file system name buffer, in <b>TCHARs</b>. The maximum buffer size is
     *        <b>MAX_PATH</b>+1.
     * 
     * This parameter is ignored if the file system name buffer is not supplied.
     * @returns {Integer} If all the requested information is retrieved, the return value is nonzero.
     * 
     * If not all the requested information is retrieved, the return value is zero. To get extended error
     *        information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationa
     * @since windows5.1.2600
     */
    static GetVolumeInformationA(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeNameBuffer := lpVolumeNameBuffer is String? StrPtr(lpVolumeNameBuffer) : lpVolumeNameBuffer
        lpFileSystemNameBuffer := lpFileSystemNameBuffer is String? StrPtr(lpFileSystemNameBuffer) : lpFileSystemNameBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeInformationA", "ptr", lpRootPathName, "ptr", lpVolumeNameBuffer, "uint", nVolumeNameSize, "uint*", lpVolumeSerialNumber, "uint*", lpMaximumComponentLength, "uint*", lpFileSystemFlags, "ptr", lpFileSystemNameBuffer, "uint", nFileSystemNameSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a name for a temporary file. If a unique file name is generated, an empty file is created and the handle to it is released; otherwise, only a file name is generated. (GetTempFileNameA)
     * @remarks
     * The <b>GetTempFileName</b> function creates a temporary 
     *     file name of the following form:
     * 
     * <i>&lt;path&gt;</i>&#92;<i>&lt;pre&gt;</i><i>&lt;uuuu&gt;</i>.TMP
     * 
     * The following table describes the file name syntax.
     * 
     * <table>
     * <tr>
     * <th>Component</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><i>&lt;path&gt;</i></td>
     * <td>Path specified by the <i>lpPathName</i> parameter</td>
     * </tr>
     * <tr>
     * <td><i>&lt;pre&gt;</i></td>
     * <td>First three letters of the <i>lpPrefixString</i> string</td>
     * </tr>
     * <tr>
     * <td><i>&lt;uuuu&gt;</i></td>
     * <td>Hexadecimal value of <i>uUnique</i></td>
     * </tr>
     * </table>
     *  
     * 
     * If <i>uUnique</i> is zero, 
     *     <b>GetTempFileName</b> creates an empty file and closes it. If 
     *     <i>uUnique</i> is not zero, you must create the file yourself. Only a file name is created, 
     *     because <b>GetTempFileName</b> is not able to guarantee that 
     *     the file name is unique.
     * 
     * Only the lower 16 bits of the <i>uUnique</i> parameter are used. This limits 
     *     <b>GetTempFileName</b> to a maximum of 65,535 unique file names 
     *     if the <i>lpPathName</i> and <i>lpPrefixString</i> parameters remain the 
     *     same.
     * 
     * Due to the algorithm used to generate file names, 
     *     <b>GetTempFileName</b> can perform poorly when creating a large 
     *     number of files with the same prefix. In such cases, it is recommended that you construct unique file names based 
     *     on <b>GUID</b>s.
     * 
     * Temporary files whose names have been created by this function are not automatically deleted. To delete these 
     *     files call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>.
     * 
     * To avoid problems resulting when converting an ANSI string, an application should call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function to create a temporary file.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpPathName The directory path for the file name. Applications typically specify a period (.) for the current directory 
     *        or the result of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-gettemppatha">GetTempPath</a> function. The string 
     *        cannot be longer than <b>MAX_PATH</b>–14 characters or
     *        <b>GetTempFileName</b> will fail. If this parameter is 
     *        <b>NULL</b>, the function fails.
     * @param {Pointer<Byte>} lpPrefixString The null-terminated prefix string. The function uses up to the first three characters of this string as the 
     *        prefix of the file name. This string must consist of characters in the OEM-defined character set.
     * @param {Integer} uUnique An unsigned integer to be used in creating the temporary file name. For more information, see Remarks.
     * 
     * If <i>uUnique</i> is zero, the function attempts to form a unique file name using the 
     *        current system time. If the file already exists, the number is increased by one and the functions tests if this 
     *        file already exists. This continues until a unique filename is found; the function creates a file by that name 
     *        and closes it.  Note that the function does not attempt  to verify the uniqueness of the file name when 
     *        <i>uUnique</i> is nonzero.
     * @param {Pointer<Byte>} lpTempFileName A pointer to the buffer that receives the temporary file name. This buffer should be 
     *        <b>MAX_PATH</b> characters to accommodate the path plus the terminating null character.
     * @returns {Integer} If the function succeeds, the return value specifies the unique numeric value used in the temporary file 
     *        name. If the <i>uUnique</i> parameter is nonzero, the return value specifies that same 
     *        number.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * 
     * The following is a possible return value.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUFFER_OVERFLOW</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The length of the string pointed to by the <i>lpPathName</i> parameter is more than 
     *          <b>MAX_PATH</b>–14 characters.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettempfilenamea
     * @since windows5.1.2600
     */
    static GetTempFileNameA(lpPathName, lpPrefixString, uUnique, lpTempFileName) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName
        lpPrefixString := lpPrefixString is String? StrPtr(lpPrefixString) : lpPrefixString
        lpTempFileName := lpTempFileName is String? StrPtr(lpTempFileName) : lpTempFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetTempFileNameA", "ptr", lpPathName, "ptr", lpPrefixString, "uint", uUnique, "ptr", lpTempFileName, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Causes the file I/O functions for the process to use the OEM character set code page.
     * @remarks
     * The file I/O functions whose code page is set by <b>SetFileApisToOEM</b> are those 
     *     functions exported by KERNEL32.DLL that accept or return a file name. 
     *     <b>SetFileApisToOEM</b> sets the code page per process, rather than per thread or per 
     *     computer.
     * 
     * The <b>SetFileApisToOEM</b> function is complemented by the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> function, which causes the same 
     *      set of file I/O functions to use the ANSI character set code page.
     * 
     * The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by 
     *     default. This means that strings returned by the console functions may not be processed correctly by other 
     *     functions, and vice versa. For example, if the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA</a> function returns a string that contains 
     *     certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the 
     *     <a href="https://docs.microsoft.com/windows/console/writeconsole">WriteConsoleA</a> function will not display the string 
     *     properly.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi">AreFileApisANSI</a> function to determine 
     *     which code page the set of file I/O functions is currently using. Use the 
     *     <a href="https://docs.microsoft.com/windows/console/setconsolecp">SetConsoleCP</a> and 
     *     <a href="https://docs.microsoft.com/windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page 
     *     for the 8-bit console functions.
     * 
     * To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console 
     *     applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that 
     *     solution, a console application can call the <b>SetFileApisToOEM</b> function to cause 
     *     the set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistoansi">SetFileApisToANSI</a> function to set those functions 
     *     back to the ANSI code page.
     * 
     * When dealing with command lines, a console application should obtain the command line in Unicode form and then 
     *     convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the 
     *     <i>argv</i> parameter of the command-line <b>main</b> function 
     *     contains ANSI character set strings in this case.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfileapistooem
     * @since windows5.1.2600
     */
    static SetFileApisToOEM() {
        DllCall("KERNEL32.dll\SetFileApisToOEM")
    }

    /**
     * Causes the file I/O functions to use the ANSI character set code page for the current process.
     * @remarks
     * The file I/O functions whose code page is set by <b>SetFileApisToANSI</b> are those 
     *     functions exported by KERNEL32.DLL that accept or return a file name. 
     *     <b>SetFileApisToANSI</b> sets the code page per process, rather than per thread or per 
     *     computer.
     * 
     * The <b>SetFileApisToANSI</b> function complements the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> function, which causes the same set 
     *     of file I/O functions to use the OEM character set code page.
     * 
     * The 8-bit console functions use the OEM code page by default. All other functions use the ANSI code page by 
     *     default. This means that strings returned by the console functions may not be processed correctly by other 
     *     functions, and vice versa. For example, if the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFileA</a> function returns a string that contains 
     *     certain extended ANSI characters, and the 8-bit console functions are set to use the OEM code page, then the 
     *     <a href="https://docs.microsoft.com/windows/console/writeconsole">WriteConsoleA</a> function does not display the string 
     *     properly.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-arefileapisansi">AreFileApisANSI</a> function to determine 
     *     which code page the set of file I/O functions is currently using. Use the 
     *     <a href="https://docs.microsoft.com/windows/console/setconsolecp">SetConsoleCP</a> and 
     *     <a href="https://docs.microsoft.com/windows/console/setconsoleoutputcp">SetConsoleOutputCP</a> functions to set the code page 
     *     for the 8-bit console functions.
     * 
     * To solve the problem of code page incompatibility, it is best to use Unicode for console applications. Console 
     *     applications that use Unicode are much more versatile than those that use 8-bit console functions. Barring that 
     *     solution, a console application can call the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileapistooem">SetFileApisToOEM</a> function to cause the 
     *     set of file I/O functions to use OEM character set strings rather than ANSI character set strings. Use the 
     *     <b>SetFileApisToANSI</b> function to set those functions back to the ANSI code 
     *     page.
     * 
     * When dealing with command lines, a console application should obtain the command line in Unicode form and then 
     *     convert it to OEM form using the relevant character-to-OEM functions. Note also that the array in the 
     *     <i>argv</i> parameter of the command-line <b>main</b> function 
     *     contains ANSI character set strings in this case.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-setfileapistoansi
     * @since windows5.1.2600
     */
    static SetFileApisToANSI() {
        DllCall("KERNEL32.dll\SetFileApisToANSI")
    }

    /**
     * Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process. (Unicode)
     * @remarks
     * When calling this function from a process running as SYSTEM it will return the path C:\Windows\SystemTemp, which is inaccessible to non-SYSTEM processes. For non-SYSTEM processes, **GetTempPath2** will behave the same as [GetTempPath](/windows/win32/api/fileapi/nf-fileapi-gettemppatha). 
     * 
     * The <b>GetTempPath2</b> function checks for the existence of 
     *     environment variables in the following order and uses the first path found:
     * 
     * <ol>
     * <li>The path specified by the TMP environment variable.</li>
     * <li>The path specified by the TEMP environment variable.</li>
     * <li>The path specified by the USERPROFILE environment variable.</li>
     * <li>The Windows directory.</li>
     * </ol>
     * Note that the function does not verify that the path exists, nor does it test to see if the current process has 
     *      any kind of access rights to the path. The <b>GetTempPath2</b> 
     *      function returns the properly formatted string that specifies the fully qualified path based on the environment 
     *      variable search order as previously specified. The application should verify the existence of the path and 
     *      adequate access rights to the path prior to any use for file I/O operations.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the temp path name 
     *     maintains any symbolic links.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} BufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Char>} Buffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppath2w
     */
    static GetTempPath2W(BufferLength, Buffer) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("KERNEL32.dll\GetTempPath2W", "uint", BufferLength, "ptr", Buffer, "uint")
        return result
    }

    /**
     * Retrieves the path of the directory designated for temporary files, based on the privileges of the calling process. (ANSI)
     * @remarks
     * When calling this function from a process running as SYSTEM it will return the path C:\Windows\SystemTemp, which is inaccessible to non-SYSTEM processes. For non-SYSTEM processes, **GetTempPath2** will behave the same as [GetTempPath](/windows/win32/api/fileapi/nf-fileapi-gettemppatha). 
     * 
     * The <b>GetTempPath2</b> function checks for the existence of 
     *     environment variables in the following order and uses the first path found:
     * 
     * <ol>
     * <li>The path specified by the TMP environment variable.</li>
     * <li>The path specified by the TEMP environment variable.</li>
     * <li>The path specified by the USERPROFILE environment variable.</li>
     * <li>The Windows directory.</li>
     * </ol>
     * Note that the function does not verify that the path exists, nor does it test to see if the current process has 
     *      any kind of access rights to the path. The <b>GetTempPath2</b> 
     *      function returns the properly formatted string that specifies the fully qualified path based on the environment 
     *      variable search order as previously specified. The application should verify the existence of the path and 
     *      adequate access rights to the path prior to any use for file I/O operations.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the temp path name 
     *     maintains any symbolic links.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} BufferLength The size of the string buffer identified by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Byte>} Buffer A pointer to a string buffer that receives the null-terminated string specifying the temporary file path. 
     *       The returned string ends with a backslash, for example, "C:\\TEMP\\".
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character. If the 
     *        return value is greater than <i>nBufferLength</i>, the return value is the length, in 
     *        <b>TCHARs</b>, of the buffer required to hold the path.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum possible return value is <b>MAX_PATH</b>+1 (261).
     * @see https://learn.microsoft.com/windows/win32/api/fileapi/nf-fileapi-gettemppath2a
     */
    static GetTempPath2A(BufferLength, Buffer) {
        Buffer := Buffer is String? StrPtr(Buffer) : Buffer

        result := DllCall("KERNEL32.dll\GetTempPath2A", "uint", BufferLength, "ptr", Buffer, "uint")
        return result
    }

    /**
     * Copies an existing file to a new file. The behavior of this function is identical to CopyFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpExistingFileName The name of an existing file.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * 
     * If *lpExistingFileName* does not exist, the function fails, and [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md) returns **ERROR\_FILE\_NOT\_FOUND**.
     * @param {Pointer<Char>} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to **MAX\_PATH** characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see [Naming a File](/windows/win32/FileIO/naming-a-file).
     * 
     * For the unicode version of this function (**CopyFileFromAppW**), you can opt-in to remove the **MAX\_PATH** limitation without prepending "\\\\?\\". See the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/FileIO/naming-a-file) for details.
     * @param {Integer} bFailIfExists If this parameter is **TRUE** and the new file specified by *lpNewFileName* already exists, the function fails. If this parameter is **FALSE** and the new file already exists, the function overwrites the existing file and succeeds.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-copyfilefromappw
     */
    static CopyFileFromAppW(lpExistingFileName, lpNewFileName, bFailIfExists) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CopyFileFromAppW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int", bFailIfExists, "int")
        return result
    }

    /**
     * Creates a new directory. The behavior of this function is identical to CreateDirector, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpPathName The path of the directory to be created.
     *      
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a [**SECURITY\_ATTRIBUTES**](../wtypesbase/ns-wtypesbase-security_attributes.md) structure. The **lpSecurityDescriptor** member of the structure specifies a security descriptor for the new directory. If *lpSecurityAttributes* is **NULL**, the directory gets a default security descriptor. The ACLs in the default security descriptor for a directory are inherited from its parent directory.
     *     
     * The target file system must support security on files and directories for this parameter to have an effect.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md). Possible errors include the following.
     * 
     * <table>
     * <colgroup>
     * <col />
     * <col />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><strong>ERROR_ALREADY_EXISTS</strong></td>
     * <td><p>The specified directory already exists.</p></td>
     * </tr>
     * <tr class="even">
     * <td><strong>ERROR_PATH_NOT_FOUND</strong></td>
     * <td><p>One or more intermediate directories do not exist; this function will only create the final directory in the path.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-createdirectoryfromappw
     */
    static CreateDirectoryFromAppW(lpPathName, lpSecurityAttributes) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CreateDirectoryFromAppW", "ptr", lpPathName, "ptr", lpSecurityAttributes, "int")
        return result
    }

    /**
     * Creates or opens a file or I/O device. The behavior of this function is identical to CreateFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpFileName The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\\) in this name.
     *     
     * In the ANSI version of this function, the name is limited to **MAX\_PATH** characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file).
     * 
     * For information on special device names, see [Defining an MS-DOS Device Name](/windows/win32/fileio/defining-an-ms-dos-device-name).
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see [File Streams](/windows/win32/fileio/file-streams).
     * 
     * For the unicode version of this function (**CreateFileFromAppW**), you can opt-in to remove the **MAX\_PATH** limitation without prepending "\\\\?\\". See the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are **GENERIC\_READ**, **GENERIC\_WRITE**, or both (`GENERIC_READ | GENERIC_WRITE`). For more information, see [Generic Access Rights](/windows/win32/secauthz/generic-access-rights), [File Security and Access Rights](/windows/win32/fileio/file-security-and-access-rights), [**File Access Rights Constants**](/windows/win32/fileio/file-access-rights-constants), and [**ACCESS\_MASK**](/windows/win32/secauthz/access-mask).
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if **GENERIC\_READ** access would have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the *dwShareMode* parameter in an open request that already has an open handle.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
     *     
     * <table>
     * <colgroup>
     * <col />
     * <col />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="0"></span>
     * <strong>0</strong>
     * 0x00000000</td>
     * <td><p>Prevents other processes from opening a file or device if they request delete, read, or write access.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_SHARE_DELETE"></span><span id="file_share_delete"></span>
     * <strong>FILE_SHARE_DELETE</strong>
     * 0x00000004</td>
     * <td><p>Enables subsequent open operations on a file or device to request delete access.</p>
     * <p>Otherwise, other processes cannot open the file or device if they request delete access.</p>
     * <p>If this flag is not specified, but the file or device has been opened for delete access, the function fails.</p>
     * <strong>Note</strong>  Delete access allows both delete and rename operations.
     * <div>
     *  
     * </div></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_SHARE_READ"></span><span id="file_share_read"></span>
     * <strong>FILE_SHARE_READ</strong>
     * 0x00000001</td>
     * <td><p>Enables subsequent open operations on a file or device to request read access.</p>
     * <p>Otherwise, other processes cannot open the file or device if they request read access.</p>
     * <p>If this flag is not specified, but the file or device has been opened for read access, the function fails.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_SHARE_WRITE"></span><span id="file_share_write"></span>
     * <strong>FILE_SHARE_WRITE</strong>
     * 0x00000002</td>
     * <td><p>Enables subsequent open operations on a file or device to request write access.</p>
     * <p>Otherwise, other processes cannot open the file or device if they request write access.</p>
     * <p>If this flag is not specified, but the file or device has been opened for write access or has a file mapping with write access, the function fails.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a [**SECURITY\_ATTRIBUTES**](https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
     *     
     * This parameter can be **NULL**.
     * 
     * If this parameter is **NULL**, the handle returned cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
     * 
     * The **lpSecurityDescriptor** member of the structure specifies a [**SECURITY\_DESCRIPTOR**](../winnt/ns-winnt-security_descriptor.md) for a file or device. If this member is **NULL**, the file or device associated with the returned handle is assigned a default security descriptor.
     * 
     * This function ignores the **lpSecurityDescriptor** member when opening an existing file or device, but continues to use the **bInheritHandle** member.
     * 
     * The **bInheritHandle** member of the structure specifies whether the returned handle can be inherited.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     *     
     * For devices other than files, this parameter is usually set to **OPEN\_EXISTING**.
     * 
     * For more information, see the Remarks section.
     * @param {Integer} dwFlagsAndAttributes The file or device attributes and flags, **FILE\_ATTRIBUTE\_NORMAL** being the most common default value for files.
     *     
     * This parameter can include any combination of the available file attributes (**FILE\_ATTRIBUTE\_\***). All other file attributes override **FILE\_ATTRIBUTE\_NORMAL**.
     * 
     * This parameter can also contain combinations of flags (**FILE\_FLAG\_\***) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any **FILE\_ATTRIBUTE\_\*** values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the **SECURITY\_SQOS\_PRESENT** flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
     * 
     * <table>
     * <colgroup>
     * <col />
     * <col />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_ARCHIVE"></span><span id="file_attribute_archive"></span>
     * <strong>FILE_ATTRIBUTE_ARCHIVE</strong>
     * 32 (0x20)</td>
     * <td><p>The file should be archived. Applications use this attribute to mark files for backup or removal.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_ENCRYPTED"></span><span id="file_attribute_encrypted"></span>
     * <strong>FILE_ATTRIBUTE_ENCRYPTED</strong>
     * 16384 (0x4000)</td>
     * <td><p>The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories. For more information, see <a href="https://docs.microsoft.com/windows/win32/fileio/file-encryption"><strong>File Encryption</strong></a>.</p>
     * <p>This flag has no effect if <strong>FILE_ATTRIBUTE_SYSTEM</strong> is also specified.</p>
     * <p>This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_HIDDEN"></span><span id="file_attribute_hidden"></span>
     * <strong>FILE_ATTRIBUTE_HIDDEN</strong>
     * 2 (0x2)</td>
     * <td><p>The file is hidden. Do not include it in an ordinary directory listing.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_NORMAL"></span><span id="file_attribute_normal"></span>
     * <strong>FILE_ATTRIBUTE_NORMAL</strong>
     * 128 (0x80)</td>
     * <td><p>The file does not have other attributes set. This attribute is valid only if used alone.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_OFFLINE"></span><span id="file_attribute_offline"></span>
     * <strong>FILE_ATTRIBUTE_OFFLINE</strong>
     * 4096 (0x1000)</td>
     * <td><p>The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_READONLY"></span><span id="file_attribute_readonly"></span>
     * <strong>FILE_ATTRIBUTE_READONLY</strong>
     * 1 (0x1)</td>
     * <td><p>The file is read only. Applications can read the file, but cannot write to or delete it.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_SYSTEM"></span><span id="file_attribute_system"></span>
     * <strong>FILE_ATTRIBUTE_SYSTEM</strong>
     * 4 (0x4)</td>
     * <td><p>The file is part of or used exclusively by an operating system.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_TEMPORARY"></span><span id="file_attribute_temporary"></span>
     * <strong>FILE_ATTRIBUTE_TEMPORARY</strong>
     * 256 (0x100)</td>
     * <td><p>The file is being used for temporary storage.</p>
     * <p>For more information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * 
     *  
     * 
     * <table>
     * <colgroup>
     * <col />
     * <col />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_BACKUP_SEMANTICS"></span><span id="file_flag_backup_semantics"></span>
     * <strong>FILE_FLAG_BACKUP_SEMANTICS</strong>
     * 0x02000000</td>
     * <td><p>The file is being opened or created for a backup or restore operation. The system ensures that the calling process overrides file security checks when the process has <strong>SE_BACKUP_NAME</strong> and <strong>SE_RESTORE_NAME</strong> privileges. For more information, see <a href="https://docs.microsoft.com/windows/win32/secbp/changing-privileges-in-a-token">Changing Privileges in a Token</a>.</p>
     * <p>You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks section.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_DELETE_ON_CLOSE"></span><span id="file_flag_delete_on_close"></span>
     * <strong>FILE_FLAG_DELETE_ON_CLOSE</strong>
     * 0x04000000</td>
     * <td><p>The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any other open or duplicated handles.</p>
     * <p>If there are existing open handles to a file, the call fails unless they were all opened with the <strong>FILE_SHARE_DELETE</strong> share mode.</p>
     * <p>Subsequent open requests for the file fail, unless the <strong>FILE_SHARE_DELETE</strong> share mode is specified.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_NO_BUFFERING"></span><span id="file_flag_no_buffering"></span>
     * <strong>FILE_FLAG_NO_BUFFERING</strong>
     * 0x20000000</td>
     * <td><p>The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard disk caching or memory mapped files.</p>
     * <p>There are strict requirements for successfully working with files opened with this function using the <strong>FILE_FLAG_NO_BUFFERING</strong> flag, for details see <a href="https://docs.microsoft.com/windows/win32/fileio/file-buffering">File Buffering</a>.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_OPEN_NO_RECALL"></span><span id="file_flag_open_no_recall"></span>
     * <strong>FILE_FLAG_OPEN_NO_RECALL</strong>
     * 0x00100000</td>
     * <td><p>The file data is requested, but it should continue to be located in remote storage. It should not be transported back to local storage. This flag is for use by remote storage systems.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_OPEN_REPARSE_POINT"></span><span id="file_flag_open_reparse_point"></span>
     * <strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>
     * 0x00200000</td>
     * <td><p>Normal <a href="https://docs.microsoft.com/windows/win32/fileio/reparse-points">reparse point</a> processing will not occur; this function will attempt to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.</p>
     * <p>This flag cannot be used with the <strong>CREATE_ALWAYS</strong> flag.</p>
     * <p>If the file is not a reparse point, then this flag is ignored.</p>
     * <p>For more information, see the Remarks section.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_OVERLAPPED"></span><span id="file_flag_overlapped"></span>
     * <strong>FILE_FLAG_OVERLAPPED</strong>
     * 0x40000000</td>
     * <td><p>The file or device is being opened or created for asynchronous I/O.</p>
     * <p>When subsequent I/O operations are completed on this handle, the event specified in the <a href="https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure will be set to the signaled state.</p>
     * <p>If this flag is specified, the file can be used for simultaneous read and write operations.</p>
     * <p>If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions specify an <a href="https://docs.microsoft.com/windows/win32/api/minwinbase/ns-minwinbase-overlapped"><strong>OVERLAPPED</strong></a> structure.</p>
     * <p>For information about considerations when using a file handle created with this flag, see the Synchronous and Asynchronous I/O Handles section of this topic.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_POSIX_SEMANTICS"></span><span id="file_flag_posix_semantics"></span>
     * <strong>FILE_FLAG_POSIX_SEMANTICS</strong>
     * 0x0100000</td>
     * <td><p>Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case, for file systems that support that naming. Use care when using this option, because files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_RANDOM_ACCESS"></span><span id="file_flag_random_access"></span>
     * <strong>FILE_FLAG_RANDOM_ACCESS</strong>
     * 0x10000000</td>
     * <td><p>Access is intended to be random. The system can use this as a hint to optimize file caching.</p>
     * <p>This flag has no effect if the file system does not support cached I/O and <strong>FILE_FLAG_NO_BUFFERING</strong>.</p>
     * <p>For more information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_SESSION_AWARE"></span><span id="file_flag_session_aware"></span>
     * <strong>FILE_FLAG_SESSION_AWARE</strong>
     * 0x00800000</td>
     * <td><p>The file or device is being opened with session awareness. If this flag is not specified, then per-session devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. This flag has no effect for callers not in session 0. This flag is supported only on server editions of Windows.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_FLAG_SEQUENTIAL_SCAN"></span><span id="file_flag_sequential_scan"></span>
     * <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong>
     * 0x08000000</td>
     * <td><p>Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.</p>
     * <p>This flag should not be used if read-behind (that is, reverse scans) will be used.</p>
     * <p>This flag has no effect if the file system does not support cached I/O and <strong>FILE_FLAG_NO_BUFFERING</strong>.</p>
     * <p>For more information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_FLAG_WRITE_THROUGH"></span><span id="file_flag_write_through"></span>
     * <strong>FILE_FLAG_WRITE_THROUGH</strong>
     * 0x80000000</td>
     * <td><p>Write operations will not go through any intermediate cache, they will go directly to disk.</p>
     * <p>For additional information, see the Caching Behavior section of this topic.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @param {Pointer<Void>} hTemplateFile A valid handle to a template file with the **GENERIC\_READ** access right. The template file supplies file attributes and extended attributes for the file that is being created.
     *     
     * This parameter can be **NULL**.
     * 
     * When opening an existing file, this parameter is ignored.
     * 
     * When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory. For more information, see [File Encryption](/windows/win32/fileio/file-encryption).
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
     * 
     * If the function fails, the return value is **INVALID\_HANDLE\_VALUE**. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-createfilefromappw
     */
    static CreateFileFromAppW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CreateFileFromAppW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile)
        return result
    }

    /**
     * Creates or opens a file or I/O device. The behavior of this function is identical to CreateFile2, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpFileName The name of the file or device to be created or opened.
     *     
     * For information on special device names, see [Defining an MS-DOS Device Name](/windows/win32/fileio/defining-an-ms-dos-device-name).
     *     
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more information, see [File Streams](/windows/win32/fileio/file-streams).
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwDesiredAccess The requested access to the file or device, which can be summarized as read, write, both or neither zero).
     * 
     * The most commonly used values are **GENERIC\_READ**, **GENERIC\_WRITE**, or both (`GENERIC_READ | GENERIC_WRITE`). For more information, see [Generic Access Rights](/windows/win32/secauthz/generic-access-rights), [File Security and Access Rights](/windows/win32/fileio/file-security-and-access-rights), [**File Access Rights Constants**](/windows/win32/fileio/file-access-rights-constants), and [**ACCESS\_MASK**](/windows/win32/secauthz/access-mask).
     * 
     * If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if **GENERIC\_READ** access would have been denied.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified by the *dwShareMode* parameter in an open request that already has an open handle.
     * @param {Integer} dwShareMode The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
     *     
     * If this parameter is zero and the function succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
     * 
     * You can't request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. This function would fail and the [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md) function would return **ERROR\_SHARING\_VIOLATION**.
     * @param {Integer} dwCreationDisposition An action to take on a file or device that exists or does not exist.
     *     
     * For devices other than files, this parameter is usually set to **OPEN\_EXISTING**.
     * @param {Pointer<CREATEFILE2_EXTENDED_PARAMETERS>} pCreateExParams Pointer to an optional [**CREATEFILE2\_EXTENDED\_PARAMETERS**](../fileapi/ns-fileapi-createfile2_extended_parameters.md) structure.
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
     * 
     * If the function fails, the return value is **INVALID\_HANDLE\_VALUE**. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-createfile2fromappw
     */
    static CreateFile2FromAppW(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\CreateFile2FromAppW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "uint", dwCreationDisposition, "ptr", pCreateExParams)
        return result
    }

    /**
     * Deletes an existing file. The behavior of this function is identical to DeleteFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpFileName The name of the file to be deleted.
     *     
     * In the ANSI version of this function, the name is limited to **MAX\_PATH** characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file).
     * 
     * For the unicode version of this function (**DeleteFileFromAppW**), you can opt-in to remove the **MAX\_PATH** character limitation without prepending "\\\\?\\". See the "Maximum Path Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-deletefilefromappw
     */
    static DeleteFileFromAppW(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\DeleteFileFromAppW", "ptr", lpFileName, "int")
        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name and attributes that match those specified.
     * @param {Pointer<Char>} lpFileName The directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (\*) or a question mark (?).
     *     
     * This parameter should not be **NULL**, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
     * 
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *     
     * This parameter is one of the [**FINDEX\_INFO\_LEVELS**](../minwinbase/ne-minwinbase-findex_info_levels.md) enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the buffer that receives the file data.
     *     
     * The pointer type is determined by the level of information that is specified in the *fInfoLevelId* parameter.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *     
     * This parameter is one of the [**FINDEX\_SEARCH\_OPS**](../minwinbase/ne-minwinbase-findex_search_ops.md) enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     *     
     * <table>
     * <colgroup>
     * <col />
     * <col />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="FIND_FIRST_EX_CASE_SENSITIVE"></span><span id="find_first_ex_case_sensitive"></span>
     * <strong>FIND_FIRST_EX_CASE_SENSITIVE</strong>
     * 1</td>
     * <td><p>Searches are case-sensitive.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FIND_FIRST_EX_LARGE_FETCH"></span><span id="find_first_ex_large_fetch"></span>
     * <strong>FIND_FIRST_EX_LARGE_FETCH</strong>
     * 2</td>
     * <td><p>Uses a larger buffer for directory queries, which can increase performance of the find operation.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY"></span><span id="find_first_ex_on_disk_entries_only"></span>
     * <strong>FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY</strong>
     * 4</td>
     * <td><p>Limits the results to files that are physically on disk. This flag is only relevant when a file virtualization filter is present.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to [**FindNextFile**](../fileapi/nf-fileapi-findnextfilew.md) or [**FindClose**](../fileapi/nf-fileapi-findclose.md), and the *lpFindFileData* parameter contains information about the first file or directory found.
     * 
     * If the function fails or fails to locate files from the search string in the *lpFileName* parameter, the return value is **INVALID\_HANDLE\_VALUE** and the contents of *lpFindFileData* are indeterminate. To get extended error information, call the [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md) function.
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-findfirstfileexfromappw
     */
    static FindFirstFileExFromAppW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\FindFirstFileExFromAppW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags)
        return result
    }

    /**
     * Retrieves attributes for a specified file or directory. The behavior of this function is identical to GetFileAttributesEx, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpFileName The name of the file or directory.
     * 
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} fInfoLevelId A class of attribute information to retrieve.
     * 
     * This parameter can be the following value from the [GET\_FILEEX\_INFO\_LEVELS](../minwinbase/ne-minwinbase-get_fileex_info_levels.md) enumeration.
     * 
     * | Value | Meaning |
     * |--------|--------|
     * | **GetFileExInfoStandard** | The _lpFileInformation_ parameter is a [WIN32_FILE_ATTRIBUTE_DATA](/windows/win32/api/fileapi/ns-fileapi-win32_file_attribute_data) structure. |
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of _fInfoLevelId_.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero (`0`). To get extended error information, call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-getfileattributesexfromappw
     */
    static GetFileAttributesExFromAppW(lpFileName, fInfoLevelId, lpFileInformation) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\GetFileAttributesExFromAppW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "int")
        return result
    }

    /**
     * Moves an existing file or a directory, including its children. The behavior of this function is identical to MoveFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpExistingFileName The current name of the file or directory on the local computer.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Pointer<Char>} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a different file system or drive. A new directory must be on the same drive.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-movefilefromappw
     */
    static MoveFileFromAppW(lpExistingFileName, lpNewFileName) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\MoveFileFromAppW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int")
        return result
    }

    /**
     * Deletes an existing empty directory. The behavior of this function is identical to RemoveDirectory, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpPathName The path of the directory to be removed. This path must specify an empty directory, and the calling process must have delete access to the directory.
     * 
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (`0`). To get extended error information, call [GetLastError](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-removedirectoryfromappw
     */
    static RemoveDirectoryFromAppW(lpPathName) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\RemoveDirectoryFromAppW", "ptr", lpPathName, "int")
        return result
    }

    /**
     * Replaces one file with another file, with the option of creating a backup copy of the original file. The behavior of this function is identical to ReplaceFile, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpReplacedFileName For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     *     
     * This file is opened with the **GENERIC\_READ**, **DELETE**, and **SYNCHRONIZE** access rights. The sharing mode is **FILE\_SHARE\_READ** | **FILE\_SHARE\_WRITE** | **FILE\_SHARE\_DELETE**.
     *     
     * The caller must have write access to the file to be replaced. For more information, see [File Security and Access Rights](/windows/win32/fileio/file-security-and-access-rights).
     * @param {Pointer<Char>} lpReplacementFileName The name of the file that will replace the *lpReplacedFileName* file.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * 
     *     
     * The function attempts to open this file with the **SYNCHRONIZE**, **GENERIC\_READ**, **GENERIC\_WRITE**, **DELETE**, and **WRITE\_DAC** access rights so that it can preserve all attributes and ACLs. If this fails, the function attempts to open the file with the **SYNCHRONIZE**, **GENERIC\_READ**, **DELETE**, and **WRITE\_DAC** access rights. No sharing mode is specified.
     * @param {Pointer<Char>} lpBackupFileName The name of the file that will serve as a backup copy of the *lpReplacedFileName* file. If this parameter is **NULL**, no backup file is created. See the Remarks section for implementation details on the backup file.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwReplaceFlags 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md). The following are possible error codes for this function.
     * 
     * <table>
     * <colgroup>
     * <col />
     * <col />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><strong>ERROR_UNABLE_TO_MOVE_REPLACEMENT</strong>
     * 1176 (0x498)</td>
     * <td><p>The replacement file could not be renamed. If <em>lpBackupFileName</em> was specified, the replaced and replacement files retain their original file names. Otherwise, the replaced file no longer exists and the replacement file exists under its original name.</p></td>
     * </tr>
     * <tr class="even">
     * <td><strong>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</strong>
     * 1177 (0x499)</td>
     * <td><p>The replacement file could not be moved. The replacement file still exists under its original name; however, it has inherited the file streams and attributes from the file it is replacing. The file to be replaced still exists with a different name. If <em>lpBackupFileName</em> is specified, it will be the name of the replaced file.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><strong>ERROR_UNABLE_TO_REMOVE_REPLACED</strong>
     * 1175 (0x497)</td>
     * <td><p>The replaced file could not be deleted. The replaced and replacement files retain their original file names.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * 
     *  
     * 
     * If any other error is returned, such as **ERROR\_INVALID\_PARAMETER**, the replaced and replacement files will retain their original file names. In this scenario, a backup file does not exist and it is not guaranteed that the replacement file will have inherited all of the attributes and streams of the replaced file.
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-replacefilefromappw
     */
    static ReplaceFileFromAppW(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags) {
        static lpExclude := 0, lpReserved := 0 ;Reserved parameters must always be NULL

        lpReplacedFileName := lpReplacedFileName is String? StrPtr(lpReplacedFileName) : lpReplacedFileName
        lpReplacementFileName := lpReplacementFileName is String? StrPtr(lpReplacementFileName) : lpReplacementFileName
        lpBackupFileName := lpBackupFileName is String? StrPtr(lpBackupFileName) : lpBackupFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\ReplaceFileFromAppW", "ptr", lpReplacedFileName, "ptr", lpReplacementFileName, "ptr", lpBackupFileName, "uint", dwReplaceFlags, "ptr", lpExclude, "ptr", lpReserved, "int")
        return result
    }

    /**
     * Sets the attributes for a file or directory. The behavior of this function is identical to SetFileAttributes, except that this function adheres to the Universal Windows Platform app security model.
     * @param {Pointer<Char>} lpFileName The name of the file whose attributes are to be set.
     *     
     * For information about opting out of the **MAX\_PATH** limitation without prepending "\\\\?\\", see the "Maximum Path Length Limitation" section of [Naming Files, Paths, and Namespaces](/windows/win32/fileio/naming-a-file) for details.
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     *     
     * This parameter can be one or more values, combined using the bitwise-OR operator. However, all other values override **FILE\_ATTRIBUTE\_NORMAL**.
     * 
     * Not all attributes are supported by this function.
     * 
     * The following is a list of supported attribute values.
     * 
     * <table>
     * <colgroup>
     * <col />
     * <col />
     * </colgroup>
     * <thead>
     * <tr class="header">
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_ARCHIVE"></span><span id="file_attribute_archive"></span>
     * <strong>FILE_ATTRIBUTE_ARCHIVE</strong>
     * 32 (0x20)</td>
     * <td><p>A file or directory that is an archive file or directory. Applications typically use this attribute to mark files for backup or removal.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_HIDDEN"></span><span id="file_attribute_hidden"></span>
     * <strong>FILE_ATTRIBUTE_HIDDEN</strong>
     * 2 (0x2)</td>
     * <td><p>The file or directory is hidden. It is not included in an ordinary directory listing.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_NORMAL"></span><span id="file_attribute_normal"></span>
     * <strong>FILE_ATTRIBUTE_NORMAL</strong>
     * 128 (0x80)</td>
     * <td><p>A file that does not have other attributes set. This attribute is valid only when used alone.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"></span><span id="file_attribute_not_content_indexed"></span>
     * <strong>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</strong>
     * 8192 (0x2000)</td>
     * <td><p>The file or directory is not to be indexed by the content indexing service.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_OFFLINE"></span><span id="file_attribute_offline"></span>
     * <strong>FILE_ATTRIBUTE_OFFLINE</strong>
     * 4096 (0x1000)</td>
     * <td><p>The data of a file is not available immediately. This attribute indicates that the file data is physically moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management software. Applications should not arbitrarily change this attribute.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_READONLY"></span><span id="file_attribute_readonly"></span>
     * <strong>FILE_ATTRIBUTE_READONLY</strong>
     * 1 (0x1)</td>
     * <td><p>A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute is not honored on directories.</p></td>
     * </tr>
     * <tr class="odd">
     * <td><span id="FILE_ATTRIBUTE_SYSTEM"></span><span id="file_attribute_system"></span>
     * <strong>FILE_ATTRIBUTE_SYSTEM</strong>
     * 4 (0x4)</td>
     * <td><p>A file or directory that the operating system uses a part of, or uses exclusively.</p></td>
     * </tr>
     * <tr class="even">
     * <td><span id="FILE_ATTRIBUTE_TEMPORARY"></span><span id="file_attribute_temporary"></span>
     * <strong>FILE_ATTRIBUTE_TEMPORARY</strong>
     * 256 (0x100)</td>
     * <td><p>A file that is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because typically, an application deletes a temporary file after the handle is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after the handle is closed.</p></td>
     * </tr>
     * </tbody>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call [**GetLastError**](../errhandlingapi/nf-errhandlingapi-getlasterror.md).
     * @see https://learn.microsoft.com/windows/win32/api/fileapifromapp/nf-fileapifromapp-setfileattributesfromappw
     */
    static SetFileAttributesFromAppW(lpFileName, dwFileAttributes) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("api-ms-win-core-file-fromapp-l1-1-0.dll\SetFileAttributesFromAppW", "ptr", lpFileName, "uint", dwFileAttributes, "int")
        return result
    }

    /**
     * Determines where to install a file based on whether it locates another version of the file in the system. The values VerFindFile returns in the specified buffers are used in a subsequent call to the VerInstallFile function. (ANSI)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * <b>VerFindFile</b> searches for a copy of the specified file by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfile">OpenFile</a>   function. However, it determines the system directory from the specified Windows directory, or searches the path. 
     * 
     * If the 
     * 				<i>dwFlags</i> parameter indicates that the file is private to this application (not <b>VFFF_ISSHAREDFILE</b>), <b>VerFindFile</b> recommends installing the file in the application's directory. Otherwise, if the system is running a shared copy of the system, the function recommends installing the file in the Windows directory. If the system is running a private copy of the system, the function recommends installing the file in the system directory. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines VerFindFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * 
     * This parameter can be the following value. All other bits are reserved. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="VFFF_ISSHAREDFILE"></a><a id="vfff_issharedfile"></a><dl>
     * <dt><b>VFFF_ISSHAREDFILE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file can be shared by multiple applications. An application can use this information to determine where the file should be copied.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} szFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. Include only the file name and extension, not a path.
     * @param {Pointer<Byte>} szWinDir Type: <b>LPCTSTR</b>
     * 
     * The directory in which Windows is running or will be run. This string is returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya">GetWindowsDirectory</a> function.
     * @param {Pointer<Byte>} szAppDir Type: <b>LPCTSTR</b>
     * 
     * The directory where the installation program is installing a set of related files. If the installation program is installing an application, this is the directory where the application will reside. This parameter also points to the application's current directory unless otherwise specified.
     * @param {Pointer<Byte>} szCurDir Type: <b>LPWSTR</b>
     * 
     * A buffer that receives the path to a current version of the file being installed. The path is a zero-terminated string. If a current version is not installed, the buffer will contain a zero-length string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puCurDirLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szCurDir</i>  buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuCurDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szCurDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuCurDirLen</i> will be the size of the buffer required to hold the path.
     * @param {Pointer<Byte>} szDestDir Type: <b>LPTSTR</b>
     * 
     * A buffer that receives the path to the installation location recommended by <b>VerFindFile</b>. The path is a zero-terminated string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puDestDirLen Type: <b>PUINT</b>
     * 
     * A pointer to a variable that specifies the length of the 
     * 					<i>szDestDir</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuDestDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szDestDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuDestDirLen</i> will be the size of the buffer needed to hold the path.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates the status of the file. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_CURNEDEST</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The currently installed version of the file is not in the recommended destination.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_FILEINUSE</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is using the currently installed version of the file; therefore, the file cannot be overwritten or deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_BUFFTOOSMALL</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * At least one of the buffers was too small to contain the corresponding string. An application should check the output buffers to determine which buffer was too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verfindfilea
     * @since windows5.0
     */
    static VerFindFileA(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen) {
        szFileName := szFileName is String? StrPtr(szFileName) : szFileName
        szWinDir := szWinDir is String? StrPtr(szWinDir) : szWinDir
        szAppDir := szAppDir is String? StrPtr(szAppDir) : szAppDir
        szCurDir := szCurDir is String? StrPtr(szCurDir) : szCurDir
        szDestDir := szDestDir is String? StrPtr(szDestDir) : szDestDir

        result := DllCall("VERSION.dll\VerFindFileA", "uint", uFlags, "ptr", szFileName, "ptr", szWinDir, "ptr", szAppDir, "ptr", szCurDir, "uint*", puCurDirLen, "ptr", szDestDir, "uint*", puDestDirLen, "uint")
        return result
    }

    /**
     * Determines where to install a file based on whether it locates another version of the file in the system. The values VerFindFile returns in the specified buffers are used in a subsequent call to the VerInstallFile function. (Unicode)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * <b>VerFindFile</b> searches for a copy of the specified file by using the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfile">OpenFile</a>   function. However, it determines the system directory from the specified Windows directory, or searches the path. 
     * 
     * If the 
     * 				<i>dwFlags</i> parameter indicates that the file is private to this application (not <b>VFFF_ISSHAREDFILE</b>), <b>VerFindFile</b> recommends installing the file in the application's directory. Otherwise, if the system is running a shared copy of the system, the function recommends installing the file in the Windows directory. If the system is running a private copy of the system, the function recommends installing the file in the system directory. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines VerFindFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * 
     * This parameter can be the following value. All other bits are reserved. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="VFFF_ISSHAREDFILE"></a><a id="vfff_issharedfile"></a><dl>
     * <dt><b>VFFF_ISSHAREDFILE</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file can be shared by multiple applications. An application can use this information to determine where the file should be copied.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} szFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. Include only the file name and extension, not a path.
     * @param {Pointer<Char>} szWinDir Type: <b>LPCTSTR</b>
     * 
     * The directory in which Windows is running or will be run. This string is returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya">GetWindowsDirectory</a> function.
     * @param {Pointer<Char>} szAppDir Type: <b>LPCTSTR</b>
     * 
     * The directory where the installation program is installing a set of related files. If the installation program is installing an application, this is the directory where the application will reside. This parameter also points to the application's current directory unless otherwise specified.
     * @param {Pointer<Char>} szCurDir Type: <b>LPWSTR</b>
     * 
     * A buffer that receives the path to a current version of the file being installed. The path is a zero-terminated string. If a current version is not installed, the buffer will contain a zero-length string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puCurDirLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szCurDir</i>  buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuCurDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szCurDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuCurDirLen</i> will be the size of the buffer required to hold the path.
     * @param {Pointer<Char>} szDestDir Type: <b>LPTSTR</b>
     * 
     * A buffer that receives the path to the installation location recommended by <b>VerFindFile</b>. The path is a zero-terminated string. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required.
     * @param {Pointer<UInt32>} puDestDirLen Type: <b>PUINT</b>
     * 
     * A pointer to a variable that specifies the length of the 
     * 					<i>szDestDir</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuDestDirLen</i> contains the size, in characters, of the data returned in 
     * 					<i>szDestDir</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuDestDirLen</i> will be the size of the buffer needed to hold the path.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates the status of the file. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_CURNEDEST</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The currently installed version of the file is not in the recommended destination.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_FILEINUSE</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is using the currently installed version of the file; therefore, the file cannot be overwritten or deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VFF_BUFFTOOSMALL</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * At least one of the buffers was too small to contain the corresponding string. An application should check the output buffers to determine which buffer was too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verfindfilew
     * @since windows5.0
     */
    static VerFindFileW(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen) {
        szFileName := szFileName is String? StrPtr(szFileName) : szFileName
        szWinDir := szWinDir is String? StrPtr(szWinDir) : szWinDir
        szAppDir := szAppDir is String? StrPtr(szAppDir) : szAppDir
        szCurDir := szCurDir is String? StrPtr(szCurDir) : szCurDir
        szDestDir := szDestDir is String? StrPtr(szDestDir) : szDestDir

        result := DllCall("VERSION.dll\VerFindFileW", "uint", uFlags, "ptr", szFileName, "ptr", szWinDir, "ptr", szAppDir, "ptr", szCurDir, "uint*", puCurDirLen, "ptr", szDestDir, "uint*", puDestDirLen, "uint")
        return result
    }

    /**
     * Installs the specified file based on information returned from the VerFindFile function. VerInstallFile decompresses the file, if necessary, assigns a unique filename, and checks for errors, such as outdated files. (ANSI)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * <b>VerInstallFile</b> copies the file from the source directory to the destination directory. If 
     * 				<i>szCurDir</i> indicates that a previous version of the file exists on the system, <b>VerInstallFile</b> compares the files' version stamp information. If the previously installed version of the file is more recent than the new version, or if the files' attributes are significantly different, for example, if they are in different languages, then <b>VerInstallFile</b> returns with one or more recoverable error codes. 
     * 
     * <b>VerInstallFile</b> leaves the temporary file in the destination directory. The application can either override the error or delete the temporary file. If the application overrides the error, <b>VerInstallFile</b> deletes the previously installed version and renames the temporary file with the original filename. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines VerInstallFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * @param {Pointer<Byte>} szSrcFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. This is the filename in the directory pointed to by the 
     * 					<i>szSrcDir</i> parameter; the filename can include only the filename and extension, not a path.
     * @param {Pointer<Byte>} szDestFileName Type: <b>LPCTSTR</b>
     * 
     * The name <b>VerInstallFile</b> will give the new file upon installation. This file name may be different from the filename in the 
     * 					<i>szSrcFileName</i> directory. The new name should include only the file name and extension, not a path.
     * @param {Pointer<Byte>} szSrcDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file can be found.
     * @param {Pointer<Byte>} szDestDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file should be installed. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szDestDir</i> parameter.
     * @param {Pointer<Byte>} szCurDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where a preexisting version of this file can be found. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szCurDir</i> parameter.
     * @param {Pointer<Byte>} szTmpFile Type: <b>LPTSTR</b>
     * 
     * The name of a temporary copy of the source file. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required, and should be empty on input.
     * @param {Pointer<UInt32>} puTmpFileLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szTmpFile</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuTmpFileLen</i> receives the size, in characters, of the data returned in 
     * 					<i>szTmpFile</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuTmpFileLen</i> will be the size of the buffer required to hold the data.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates exceptions. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_ACCESSVIOLATION</b></dt>
     * <dt>0x00000200L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to an access violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_BUFFTOOSMALL</b></dt>
     * <dt>0x00040000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>szTmpFile</i> buffer was too small to contain the name of the temporary source file. When the function returns, <i>lpuTmpFileLen</i> contains the size of the buffer required to hold the filename.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTCREATE</b></dt>
     * <dt>0x00000800L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file. The specific error may be described by another flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETE</b></dt>
     * <dt>0x00001000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot delete the destination file, or cannot delete the existing version of the file located in another directory. If the <b>VIF_TEMPFILE</b> bit is set, the installation failed, and the destination file probably cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETECUR</b></dt>
     * <dt>0x00004000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The existing version of the file could not be deleted and <b>VIFF_DONTDELETEOLD</b> was not specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADCABINET</b></dt>
     * <dt>0x00100000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the cabinet file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADLZ32</b></dt>
     * <dt>0x00080000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADDST</b></dt>
     * <dt>0x00020000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the destination (existing) files. This prevents the function from examining the file's attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADSRC</b></dt>
     * <dt>0x00010000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the source file. This could mean that the path was not specified properly.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTRENAME</b></dt>
     * <dt>0x00002000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot rename the temporary file, but already deleted the destination file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFCODEPG</b></dt>
     * <dt>0x00000010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file requires a code page that cannot be displayed by the version of the system currently running. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFLANG</b></dt>
     * <dt>0x00000008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files have different language or code-page values. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFTYPE</b></dt>
     * <dt>0x00000020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file has a different type, subtype, or operating system from the preexisting file. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_FILEINUSE</b></dt>
     * <dt>0x00000080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is in use by the system and cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_MISMATCH</b></dt>
     * <dt>0x00000002L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files differ in one or more attributes. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFMEMORY</b></dt>
     * <dt>0x00008000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot complete the requested operation due to insufficient memory. Generally, this means the application ran out of memory attempting to expand a compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFSPACE</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file due to insufficient disk space on the destination drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SHARINGVIOLATION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to a sharing violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SRCOLD</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file to install is older than the preexisting file. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_TEMPFILE</b></dt>
     * <dt>0x00000001L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The temporary copy of the new file is in the destination directory. The cause of failure is reflected in other flags.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_WRITEPROT</b></dt>
     * <dt>0x00000040L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is write-protected. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verinstallfilea
     * @since windows5.0
     */
    static VerInstallFileA(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen) {
        szSrcFileName := szSrcFileName is String? StrPtr(szSrcFileName) : szSrcFileName
        szDestFileName := szDestFileName is String? StrPtr(szDestFileName) : szDestFileName
        szSrcDir := szSrcDir is String? StrPtr(szSrcDir) : szSrcDir
        szDestDir := szDestDir is String? StrPtr(szDestDir) : szDestDir
        szCurDir := szCurDir is String? StrPtr(szCurDir) : szCurDir
        szTmpFile := szTmpFile is String? StrPtr(szTmpFile) : szTmpFile

        result := DllCall("VERSION.dll\VerInstallFileA", "uint", uFlags, "ptr", szSrcFileName, "ptr", szDestFileName, "ptr", szSrcDir, "ptr", szDestDir, "ptr", szCurDir, "ptr", szTmpFile, "uint*", puTmpFileLen, "uint")
        return result
    }

    /**
     * Installs the specified file based on information returned from the VerFindFile function. VerInstallFile decompresses the file, if necessary, assigns a unique filename, and checks for errors, such as outdated files. (Unicode)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * <b>VerInstallFile</b> copies the file from the source directory to the destination directory. If 
     * 				<i>szCurDir</i> indicates that a previous version of the file exists on the system, <b>VerInstallFile</b> compares the files' version stamp information. If the previously installed version of the file is more recent than the new version, or if the files' attributes are significantly different, for example, if they are in different languages, then <b>VerInstallFile</b> returns with one or more recoverable error codes. 
     * 
     * <b>VerInstallFile</b> leaves the temporary file in the destination directory. The application can either override the error or delete the temporary file. If the application overrides the error, <b>VerInstallFile</b> deletes the previously installed version and renames the temporary file with the original filename. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines VerInstallFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} uFlags Type: <b>DWORD</b>
     * @param {Pointer<Char>} szSrcFileName Type: <b>LPCTSTR</b>
     * 
     * The name of the file to be installed. This is the filename in the directory pointed to by the 
     * 					<i>szSrcDir</i> parameter; the filename can include only the filename and extension, not a path.
     * @param {Pointer<Char>} szDestFileName Type: <b>LPCTSTR</b>
     * 
     * The name <b>VerInstallFile</b> will give the new file upon installation. This file name may be different from the filename in the 
     * 					<i>szSrcFileName</i> directory. The new name should include only the file name and extension, not a path.
     * @param {Pointer<Char>} szSrcDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file can be found.
     * @param {Pointer<Char>} szDestDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where the file should be installed. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szDestDir</i> parameter.
     * @param {Pointer<Char>} szCurDir Type: <b>LPCTSTR</b>
     * 
     * The name of the directory where a preexisting version of this file can be found. <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verfindfilea">VerFindFile</a> returns this value in its 
     * 					<i>szCurDir</i> parameter.
     * @param {Pointer<Char>} szTmpFile Type: <b>LPTSTR</b>
     * 
     * The name of a temporary copy of the source file. The buffer should be at least <b>_MAX_PATH</b> characters long, although this is not required, and should be empty on input.
     * @param {Pointer<UInt32>} puTmpFileLen Type: <b>PUINT</b>
     * 
     * The length of the 
     * 					<i>szTmpFile</i> buffer. This pointer must not be <b>NULL</b>.
     * 
     * When the function returns, 
     * 					<i>lpuTmpFileLen</i> receives the size, in characters, of the data returned in 
     * 					<i>szTmpFile</i>, including the terminating null character. If the buffer is too small to contain all the data, 
     * 					<i>lpuTmpFileLen</i> will be the size of the buffer required to hold the data.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is a bitmask that indicates exceptions. It can be one or more of the following values. All other values are reserved.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_ACCESSVIOLATION</b></dt>
     * <dt>0x00000200L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to an access violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_BUFFTOOSMALL</b></dt>
     * <dt>0x00040000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>szTmpFile</i> buffer was too small to contain the name of the temporary source file. When the function returns, <i>lpuTmpFileLen</i> contains the size of the buffer required to hold the filename.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTCREATE</b></dt>
     * <dt>0x00000800L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file. The specific error may be described by another flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETE</b></dt>
     * <dt>0x00001000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot delete the destination file, or cannot delete the existing version of the file located in another directory. If the <b>VIF_TEMPFILE</b> bit is set, the installation failed, and the destination file probably cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTDELETECUR</b></dt>
     * <dt>0x00004000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The existing version of the file could not be deleted and <b>VIFF_DONTDELETEOLD</b> was not specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADCABINET</b></dt>
     * <dt>0x00100000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the cabinet file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTLOADLZ32</b></dt>
     * <dt>0x00080000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot load the compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADDST</b></dt>
     * <dt>0x00020000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the destination (existing) files. This prevents the function from examining the file's attributes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTREADSRC</b></dt>
     * <dt>0x00010000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot read the source file. This could mean that the path was not specified properly.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_CANNOTRENAME</b></dt>
     * <dt>0x00002000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot rename the temporary file, but already deleted the destination file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFCODEPG</b></dt>
     * <dt>0x00000010L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file requires a code page that cannot be displayed by the version of the system currently running. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFLANG</b></dt>
     * <dt>0x00000008L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files have different language or code-page values. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_DIFFTYPE</b></dt>
     * <dt>0x00000020L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new file has a different type, subtype, or operating system from the preexisting file. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_FILEINUSE</b></dt>
     * <dt>0x00000080L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is in use by the system and cannot be deleted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_MISMATCH</b></dt>
     * <dt>0x00000002L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The new and preexisting files differ in one or more attributes. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFMEMORY</b></dt>
     * <dt>0x00008000L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot complete the requested operation due to insufficient memory. Generally, this means the application ran out of memory attempting to expand a compressed file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_OUTOFSPACE</b></dt>
     * <dt>0x00000100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function cannot create the temporary file due to insufficient disk space on the destination drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SHARINGVIOLATION</b></dt>
     * <dt>0x00000400L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A read, create, delete, or rename operation failed due to a sharing violation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_SRCOLD</b></dt>
     * <dt>0x00000004L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file to install is older than the preexisting file. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_TEMPFILE</b></dt>
     * <dt>0x00000001L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The temporary copy of the new file is in the destination directory. The cause of failure is reflected in other flags.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>VIF_WRITEPROT</b></dt>
     * <dt>0x00000040L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The preexisting file is write-protected. This error can be overridden by calling <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verinstallfilea">VerInstallFile</a> again with the <b>VIFF_FORCEINSTALL</b> flag set.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verinstallfilew
     * @since windows5.0
     */
    static VerInstallFileW(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen) {
        szSrcFileName := szSrcFileName is String? StrPtr(szSrcFileName) : szSrcFileName
        szDestFileName := szDestFileName is String? StrPtr(szDestFileName) : szDestFileName
        szSrcDir := szSrcDir is String? StrPtr(szSrcDir) : szSrcDir
        szDestDir := szDestDir is String? StrPtr(szDestDir) : szDestDir
        szCurDir := szCurDir is String? StrPtr(szCurDir) : szCurDir
        szTmpFile := szTmpFile is String? StrPtr(szTmpFile) : szTmpFile

        result := DllCall("VERSION.dll\VerInstallFileW", "uint", uFlags, "ptr", szSrcFileName, "ptr", szDestFileName, "ptr", szSrcDir, "ptr", szDestDir, "ptr", szCurDir, "ptr", szTmpFile, "uint*", puTmpFileLen, "uint")
        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSize returns the size, in bytes, of that information. (ANSI)
     * @remarks
     * Call the 
     * 				<b>GetFileVersionInfoSize</b> function before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoa">GetFileVersionInfo</a> function. The size returned by <b>GetFileVersionInfoSize</b> indicates the buffer size required for the version information returned by <b>GetFileVersionInfo</b>. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfoSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * A pointer to a variable that the function sets to zero.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizea
     * @since windows5.0
     */
    static GetFileVersionInfoSizeA(lptstrFilename, lpdwHandle) {
        lptstrFilename := lptstrFilename is String? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeA", "ptr", lptstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSize returns the size, in bytes, of that information. (Unicode)
     * @remarks
     * Call the 
     * 				<b>GetFileVersionInfoSize</b> function before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoa">GetFileVersionInfo</a> function. The size returned by <b>GetFileVersionInfoSize</b> indicates the buffer size required for the version information returned by <b>GetFileVersionInfo</b>. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfoSize as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * A pointer to a variable that the function sets to zero.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizew
     * @since windows5.0
     */
    static GetFileVersionInfoSizeW(lptstrFilename, lpdwHandle) {
        lptstrFilename := lptstrFilename is String? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeW", "ptr", lptstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file. (GetFileVersionInfoA)
     * @remarks
     * File version info has fixed and non-fixed part. The fixed part contains information like version number. The non-fixed part contains things like strings. In the past <b>GetFileVersionInfo</b> was taking version information from the binary (exe/dll). Currently, it is querying fixed version from language neutral file (exe/dll) and the non-fixed part from mui file, merges them and returns to the user.
     * If the given binary does not have a mui file then behavior is as in previous version.
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizea">GetFileVersionInfoSize</a> function before calling the <b>GetFileVersionInfo</b> function. To retrieve information from the file-version information buffer, use the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the 
     * 					<i>lpData</i> parameter. 
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizea">GetFileVersionInfoSize</a> function first to determine the size, in bytes, of a file's version information. The 
     * 						<i>dwLen</i> member should be equal to or greater than that value. 
     * 
     * If the buffer pointed to by 
     * 						<i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * Pointer to a buffer that receives the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfoa
     * @since windows5.0
     */
    static GetFileVersionInfoA(lptstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lptstrFilename := lptstrFilename is String? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoA", "ptr", lptstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file. (GetFileVersionInfoW)
     * @remarks
     * File version info has fixed and non-fixed part. The fixed part contains information like version number. The non-fixed part contains things like strings. In the past <b>GetFileVersionInfo</b> was taking version information from the binary (exe/dll). Currently, it is querying fixed version from language neutral file (exe/dll) and the non-fixed part from mui file, merges them and returns to the user.
     * If the given binary does not have a mui file then behavior is as in previous version.
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizea">GetFileVersionInfoSize</a> function before calling the <b>GetFileVersionInfo</b> function. To retrieve information from the file-version information buffer, use the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lptstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the 
     * 					<i>lpData</i> parameter. 
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizea">GetFileVersionInfoSize</a> function first to determine the size, in bytes, of a file's version information. The 
     * 						<i>dwLen</i> member should be equal to or greater than that value. 
     * 
     * If the buffer pointed to by 
     * 						<i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * Pointer to a buffer that receives the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfow
     * @since windows5.0
     */
    static GetFileVersionInfoW(lptstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lptstrFilename := lptstrFilename is String? StrPtr(lptstrFilename) : lptstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoW", "ptr", lptstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSizeEx returns the size, in bytes, of that information. (ANSI)
     * @remarks
     * Call the <b>GetFileVersionInfoSizeEx</b> function before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoexa">GetFileVersionInfoEx</a> function. The size returned by <b>GetFileVersionInfoSizeEx</b> indicates the buffer size required for the version information returned by <b>GetFileVersionInfoEx</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfoSizeEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls which MUI DLLs (if any) from which the version resource is extracted. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * When this function returns, contains a pointer to a variable that is set to zero because this function sets it to zero. This parameter exists for historical reasons.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     *                     
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizeexa
     * @since windows6.0.6000
     */
    static GetFileVersionInfoSizeExA(dwFlags, lpwstrFilename, lpdwHandle) {
        lpwstrFilename := lpwstrFilename is String? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeExA", "uint", dwFlags, "ptr", lpwstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the operating system can retrieve version information for a specified file. If version information is available, GetFileVersionInfoSizeEx returns the size, in bytes, of that information. (Unicode)
     * @remarks
     * Call the <b>GetFileVersionInfoSizeEx</b> function before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoexa">GetFileVersionInfoEx</a> function. The size returned by <b>GetFileVersionInfoSizeEx</b> indicates the buffer size required for the version information returned by <b>GetFileVersionInfoEx</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfoSizeEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls which MUI DLLs (if any) from which the version resource is extracted. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file of interest. The function uses the search sequence specified by the  <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Pointer<UInt32>} lpdwHandle Type: <b>LPDWORD</b>
     * 
     * When this function returns, contains a pointer to a variable that is set to zero because this function sets it to zero. This parameter exists for historical reasons.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * If the function succeeds, the return value is the size, in bytes, of the file's version information.
     *                     
     *                     
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizeexw
     * @since windows6.0.6000
     */
    static GetFileVersionInfoSizeExW(dwFlags, lpwstrFilename, lpdwHandle) {
        lpwstrFilename := lpwstrFilename is String? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoSizeExW", "uint", dwFlags, "ptr", lpwstrFilename, "uint*", lpdwHandle, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file. (GetFileVersionInfoExA)
     * @remarks
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> function before calling the <b>GetFileVersionInfoEx</b> function. To retrieve information from the file-version information buffer, use the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function.
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls the MUI DLLs (if any) from which the version resource is extracted. The value of this flag must match the flags passed to the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> call, which was used to determine the buffer size that is passed in the <i>dwLen</i> parameter. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_PREFETCHED"></a><a id="file_ver_get_prefetched"></a><dl>
     * <dt><b>FILE_VER_GET_PREFETCHED</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates a preference for version.dll to attempt to preload the image outside of the loader lock to avoid contention.  This flag does not change the behavior or semantics of the function.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the <i>lpData</i> parameter. 
     * 
     *                     
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> function first to determine the size, in bytes, of a file's version information. The <i>dwLen</i> parameter should be equal to or greater than that value.
     * 
     * If the buffer pointed to by <i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * When this function returns, contains a pointer to a buffer that contains the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfoexa
     * @since windows6.0.6000
     */
    static GetFileVersionInfoExA(dwFlags, lpwstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lpwstrFilename := lpwstrFilename is String? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoExA", "uint", dwFlags, "ptr", lpwstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves version information for the specified file. (GetFileVersionInfoExW)
     * @remarks
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> function before calling the <b>GetFileVersionInfoEx</b> function. To retrieve information from the file-version information buffer, use the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function.
     *       
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines GetFileVersionInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwFlags Type: <b>DWORD</b>
     * 
     * Controls the MUI DLLs (if any) from which the version resource is extracted. The value of this flag must match the flags passed to the corresponding <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> call, which was used to determine the buffer size that is passed in the <i>dwLen</i> parameter. Zero or more of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_LOCALISED"></a><a id="file_ver_get_localised"></a><dl>
     * <dt><b>FILE_VER_GET_LOCALISED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the entire version resource (both strings and binary version information) from the corresponding MUI file, if available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_NEUTRAL"></a><a id="file_ver_get_neutral"></a><dl>
     * <dt><b>FILE_VER_GET_NEUTRAL</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Loads the version resource strings from the corresponding MUI file, if available, and loads the binary version information (<b>VS_FIXEDFILEINFO</b>) from the corresponding language-neutral file, if available. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_VER_GET_PREFETCHED"></a><a id="file_ver_get_prefetched"></a><dl>
     * <dt><b>FILE_VER_GET_PREFETCHED</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates a preference for version.dll to attempt to preload the image outside of the loader lock to avoid contention.  This flag does not change the behavior or semantics of the function.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpwstrFilename Type: <b>LPCTSTR</b>
     * 
     * The name of the file. If a full path is not specified, the function uses the search sequence specified by the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function.
     * @param {Integer} dwLen Type: <b>DWORD</b>
     * 
     * The size, in bytes, of the buffer pointed to by the <i>lpData</i> parameter. 
     * 
     *                     
     * 
     * Call the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfosizeexa">GetFileVersionInfoSizeEx</a> function first to determine the size, in bytes, of a file's version information. The <i>dwLen</i> parameter should be equal to or greater than that value.
     * 
     * If the buffer pointed to by <i>lpData</i> is not large enough, the function truncates the file's version information to the size of the buffer.
     * @param {Pointer} lpData Type: <b>LPVOID</b>
     * 
     * When this function returns, contains a pointer to a buffer that contains the file-version information.
     * 
     * You can use this value in a subsequent call to the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function to retrieve data from the buffer.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfoexw
     * @since windows6.0.6000
     */
    static GetFileVersionInfoExW(dwFlags, lpwstrFilename, dwLen, lpData) {
        static dwHandle := 0 ;Reserved parameters must always be NULL

        lpwstrFilename := lpwstrFilename is String? StrPtr(lpwstrFilename) : lpwstrFilename

        A_LastError := 0

        result := DllCall("VERSION.dll\GetFileVersionInfoExW", "uint", dwFlags, "ptr", lpwstrFilename, "uint", dwHandle, "uint", dwLen, "ptr", lpData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a description string for the language associated with a specified binary Microsoft language identifier. (ANSI)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * Typically, an installation program uses this function to translate a language identifier returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function. The text string may be used in a dialog box that asks the user how to proceed in the event of a language conflict. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines VerLanguageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} wLang Type: <b>DWORD</b>
     * 
     * The binary language identifier. For a complete list of the language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language Identifiers</a>.
     * 
     * For example, the description string associated with the language identifier 0x040A is "Spanish (Traditional Sort)". If the identifier is unknown, the <i>szLang</i> parameter points to a default string ("Language Neutral").
     * @param {Pointer<Byte>} szLang Type: <b>LPTSTR</b>
     * 
     * The language specified by the <i>wLang</i> parameter.
     * @param {Integer} cchLang Type: <b>DWORD</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>szLang</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the size, in characters, of the string returned in the buffer. This value does not include the terminating null character. If the description string is smaller than or equal to the buffer, the entire description string is in the buffer. If the description string is larger than the buffer, the description string is truncated to the length of the buffer.
     * 
     * If an error occurs, the return value is zero. Unknown language identifiers do not produce errors.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verlanguagenamea
     * @since windows5.0
     */
    static VerLanguageNameA(wLang, szLang, cchLang) {
        szLang := szLang is String? StrPtr(szLang) : szLang

        result := DllCall("KERNEL32.dll\VerLanguageNameA", "uint", wLang, "ptr", szLang, "uint", cchLang, "uint")
        return result
    }

    /**
     * Retrieves a description string for the language associated with a specified binary Microsoft language identifier. (Unicode)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * Typically, an installation program uses this function to translate a language identifier returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-verqueryvaluea">VerQueryValue</a> function. The text string may be used in a dialog box that asks the user how to proceed in the event of a language conflict. 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winver.h header defines VerLanguageName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} wLang Type: <b>DWORD</b>
     * 
     * The binary language identifier. For a complete list of the language identifiers, see <a href="https://docs.microsoft.com/windows/desktop/Intl/language-identifiers">Language Identifiers</a>.
     * 
     * For example, the description string associated with the language identifier 0x040A is "Spanish (Traditional Sort)". If the identifier is unknown, the <i>szLang</i> parameter points to a default string ("Language Neutral").
     * @param {Pointer<Char>} szLang Type: <b>LPTSTR</b>
     * 
     * The language specified by the <i>wLang</i> parameter.
     * @param {Integer} cchLang Type: <b>DWORD</b>
     * 
     * The size, in characters, of the buffer pointed to by <i>szLang</i>.
     * @returns {Integer} Type: <b>DWORD</b>
     * 
     * The return value is the size, in characters, of the string returned in the buffer. This value does not include the terminating null character. If the description string is smaller than or equal to the buffer, the entire description string is in the buffer. If the description string is larger than the buffer, the description string is truncated to the length of the buffer.
     * 
     * If an error occurs, the return value is zero. Unknown language identifiers do not produce errors.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verlanguagenamew
     * @since windows5.0
     */
    static VerLanguageNameW(wLang, szLang, cchLang) {
        szLang := szLang is String? StrPtr(szLang) : szLang

        result := DllCall("KERNEL32.dll\VerLanguageNameW", "uint", wLang, "ptr", szLang, "uint", cchLang, "uint")
        return result
    }

    /**
     * Retrieves specified version information from the specified version-information resource. (ANSI)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * The following are predefined version information Unicode strings.
     * 
     * <table class="clsStd">
     * <tr>
     * <td>Comments</td>
     * <td>InternalName</td>
     * <td>ProductName</td>
     * </tr>
     * <tr>
     * <td>CompanyName</td>
     * <td>LegalCopyright</td>
     * <td>ProductVersion</td>
     * </tr>
     * <tr>
     * <td>FileDescription</td>
     * <td>LegalTrademarks</td>
     * <td>PrivateBuild</td>
     * </tr>
     * <tr>
     * <td>FileVersion</td>
     * <td>OriginalFilename</td>
     * <td>SpecialBuild</td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pBlock Type: <b>LPCVOID</b>
     * 
     * The version-information resource returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoa">GetFileVersionInfo</a> function.
     * @param {Pointer<Byte>} lpSubBlock Type: <b>LPCTSTR</b>
     * 
     * The version-information value to be retrieved. The string must consist of names separated by backslashes (\\) and it must have one of the following forms.
     * @param {Pointer<Void>} lplpBuffer Type: <b>LPVOID*</b>
     * 
     * When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by <i>pBlock</i>. The memory pointed to by <i>lplpBuffer</i> is freed when the associated <i>pBlock</i> memory is freed.
     * @param {Pointer<UInt32>} puLen Type: <b>PUINT</b>
     * 
     * When this method returns, contains a pointer to the size of the requested data pointed to by <i>lplpBuffer</i>: for version information values, the length in characters of the string stored at <i>lplpBuffer</i>; for translation array values, the size in bytes of the array stored at <i>lplpBuffer</i>; and for root block, the size in bytes of the structure.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the specified version-information structure exists, and version information is available, the return value is nonzero. If the address of the length buffer is zero, no value is available for the specified version-information name.
     * 
     * If the specified name does not exist or the specified resource is not valid, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verqueryvaluea
     * @since windows5.0
     */
    static VerQueryValueA(pBlock, lpSubBlock, lplpBuffer, puLen) {
        lpSubBlock := lpSubBlock is String? StrPtr(lpSubBlock) : lpSubBlock

        result := DllCall("VERSION.dll\VerQueryValueA", "ptr", pBlock, "ptr", lpSubBlock, "ptr", lplpBuffer, "uint*", puLen, "int")
        return result
    }

    /**
     * Retrieves specified version information from the specified version-information resource. (Unicode)
     * @remarks
     * This function works on 16-, 32-, and 64-bit file images.
     * 
     * The following are predefined version information Unicode strings.
     * 
     * <table class="clsStd">
     * <tr>
     * <td>Comments</td>
     * <td>InternalName</td>
     * <td>ProductName</td>
     * </tr>
     * <tr>
     * <td>CompanyName</td>
     * <td>LegalCopyright</td>
     * <td>ProductVersion</td>
     * </tr>
     * <tr>
     * <td>FileDescription</td>
     * <td>LegalTrademarks</td>
     * <td>PrivateBuild</td>
     * </tr>
     * <tr>
     * <td>FileVersion</td>
     * <td>OriginalFilename</td>
     * <td>SpecialBuild</td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pBlock Type: <b>LPCVOID</b>
     * 
     * The version-information resource returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winver/nf-winver-getfileversioninfoa">GetFileVersionInfo</a> function.
     * @param {Pointer<Char>} lpSubBlock Type: <b>LPCTSTR</b>
     * 
     * The version-information value to be retrieved. The string must consist of names separated by backslashes (\\) and it must have one of the following forms.
     * @param {Pointer<Void>} lplpBuffer Type: <b>LPVOID*</b>
     * 
     * When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by <i>pBlock</i>. The memory pointed to by <i>lplpBuffer</i> is freed when the associated <i>pBlock</i> memory is freed.
     * @param {Pointer<UInt32>} puLen Type: <b>PUINT</b>
     * 
     * When this method returns, contains a pointer to the size of the requested data pointed to by <i>lplpBuffer</i>: for version information values, the length in characters of the string stored at <i>lplpBuffer</i>; for translation array values, the size in bytes of the array stored at <i>lplpBuffer</i>; and for root block, the size in bytes of the structure.
     * @returns {Integer} Type: <b>BOOL</b>
     * 
     * If the specified version-information structure exists, and version information is available, the return value is nonzero. If the address of the length buffer is zero, no value is available for the specified version-information name.
     * 
     * If the specified name does not exist or the specified resource is not valid, the return value is zero.
     * @see https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verqueryvaluew
     * @since windows5.0
     */
    static VerQueryValueW(pBlock, lpSubBlock, lplpBuffer, puLen) {
        lpSubBlock := lpSubBlock is String? StrPtr(lpSubBlock) : lpSubBlock

        result := DllCall("VERSION.dll\VerQueryValueW", "ptr", pBlock, "ptr", lpSubBlock, "ptr", lplpBuffer, "uint*", puLen, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt64>} plsn1 
     * @param {Pointer<UInt64>} plsn2 
     * @returns {Integer} 
     */
    static LsnEqual(plsn1, plsn2) {
        result := DllCall("clfsw32.dll\LsnEqual", "uint*", plsn1, "uint*", plsn2, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt64>} plsn1 
     * @param {Pointer<UInt64>} plsn2 
     * @returns {Integer} 
     */
    static LsnLess(plsn1, plsn2) {
        result := DllCall("clfsw32.dll\LsnLess", "uint*", plsn1, "uint*", plsn2, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt64>} plsn1 
     * @param {Pointer<UInt64>} plsn2 
     * @returns {Integer} 
     */
    static LsnGreater(plsn1, plsn2) {
        result := DllCall("clfsw32.dll\LsnGreater", "uint*", plsn1, "uint*", plsn2, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt64>} plsn 
     * @returns {Integer} 
     */
    static LsnNull(plsn) {
        result := DllCall("clfsw32.dll\LsnNull", "uint*", plsn, "char")
        return result
    }

    /**
     * Retrieves the logical container ID that is contained in a specified LSN.
     * @param {Pointer<UInt64>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure from which the container ID is to be retrieved.
     * @returns {Integer} This function returns the logical container ID that is contained in <i>plsn</i>. The logical container ID is not necessarily the same as the ID of the physical container on stable storage.
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-lsncontainer
     * @since windows6.0.6000
     */
    static LsnContainer(plsn) {
        result := DllCall("clfsw32.dll\LsnContainer", "uint*", plsn, "uint")
        return result
    }

    /**
     * Creates a log sequence number (LSN), given a container ID, a block offset, and a record sequence number.
     * @param {Integer} cidContainer The container ID. This value must be an integer between 0x0 and 0xFFFFFFFF.
     * @param {Integer} offBlock The block offset. This value must be a multiple of 512.
     * @param {Integer} cRecord The record sequence number. This value must be  an integer between  0 - 511.
     * @returns {Integer} Returns a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that represents the container ID, block offset, and record sequence number that is supplied by the caller.
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-lsncreate
     * @since windows6.0.6000
     */
    static LsnCreate(cidContainer, offBlock, cRecord) {
        result := DllCall("clfsw32.dll\LsnCreate", "uint", cidContainer, "uint", offBlock, "uint", cRecord, "uint")
        return result
    }

    /**
     * Returns the sector-aligned block offset that is contained in the specified LSN.
     * @remarks
     * The block offset that is returned by this function is a multiple of the sector size on the stable storage medium. For example, if the sector size is 1024 bytes, the block offset is a multiple of 1024.
     * @param {Pointer<UInt64>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure from which the block offset is to be retrieved.
     * @returns {Integer} <b>LsnBlockOffset</b> returns the block offset that is contained in <i>plsn</i>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-lsnblockoffset
     * @since windows6.0.6000
     */
    static LsnBlockOffset(plsn) {
        result := DllCall("clfsw32.dll\LsnBlockOffset", "uint*", plsn, "uint")
        return result
    }

    /**
     * Retrieves the record sequence number that is contained in a specified LSN.
     * @param {Pointer<UInt64>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure from which the record sequence number is to be retrieved.
     * @returns {Integer} The record sequence number that is contained in <i>plsn</i>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-lsnrecordsequence
     * @since windows6.0.6000
     */
    static LsnRecordSequence(plsn) {
        result := DllCall("clfsw32.dll\LsnRecordSequence", "uint*", plsn, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt64>} plsn 
     * @returns {Integer} 
     */
    static LsnInvalid(plsn) {
        result := DllCall("clfsw32.dll\LsnInvalid", "uint*", plsn, "char")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt64>} plsn 
     * @returns {Integer} 
     */
    static LsnIncrement(plsn) {
        result := DllCall("clfsw32.dll\LsnIncrement", "uint*", plsn, "uint")
        return result
    }

    /**
     * Creates or opens a log.
     * @param {Pointer<Char>} pszLogFileName The name of the log.
     * 
     * This  name is specified when creating the log  by using 
     *        <b>CreateLogFile</b>. The following example identifies the 
     *        format to use.
     * 
     * <b>log :&lt;</b><i>LogName</i><b>&gt;[::&lt;</b><i>LogStreamName</i><b>&gt;]</b>
     * 
     * For example: The path "LOG:c:\MyDirectory\MyLog" creates the file 
     *        "c:\MyDirectory\MyLog.blf". The path 
     *        "\??\LOG:\HarddiskVolume1\MyDirectory\MyLog" creates the file 
     *        "\\.\HarddiskVolume1\MyDirectory\MyLog.blf", as does the path 
     *        "\clfs\Device\HarddiskVolume1\MyDirectory\MyLog".
     * 
     * &lt;<i>LogName</i>&gt; corresponds to a valid file path in the file system, and 
     *        &lt;<i>LogStreamName</i>&gt; is the unique name of a log stream in the log. For more 
     *        information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/log-types">Log Types</a>.
     * @param {Integer} fDesiredAccess The type of access that the returned handle has to the log object.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GENERIC_READ"></a><a id="generic_read"></a><dl>
     * <dt><b>GENERIC_READ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies read access to the object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GENERIC_WRITE"></a><a id="generic_write"></a><dl>
     * <dt><b>GENERIC_WRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specifies write access to the object.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="DELETE"></a><a id="delete"></a><dl>
     * <dt><b>DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specify log deletion access
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * A bitwise <b>OR</b> of two or more of these flags allows combinations of read, write, and delete access to the object.
     *        <div class="alert"><b>Note</b>  You must specify <b>DELETE</b> access to be able to delete the log.</div>
     * <div> </div>
     * <b>Windows Server 2003 R2:  </b>This parameter must be set to <b>GENERIC_WRITE</b>.
     * @param {Integer} dwShareMode The sharing mode of a file.
     * 
     * A client cannot request a sharing mode that conflicts with any mode that is specified in any previous open 
     *        request that has an open handle.
     * 
     * If this parameter is zero and the function succeeds, the object cannot be shared and cannot be opened 
     *        again until the handle is closed.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psaLogFile A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *       structure that  specifies the security attributes of a log.
     * 
     * It determines whether the returned handle can be 
     *       inherited by child processes. If this parameter is <b>NULL</b>, the handle cannot be 
     *       inherited.
     * 
     * The <b>lpSecurityDescriptor</b> member of 
     *       <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> specifies a 
     *       <a href="https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">security descriptor</a> for the new log 
     *       handle. If <i>psaLogFile</i> is <b>NULL</b>, the object gets a default 
     *       security descriptor. The access control lists (ACL) in the default security descriptor for a log come from the 
     *       primary or impersonation token of the creator.
     * @param {Integer} fCreateDisposition An action to be taken.
     * @param {Integer} fFlagsAndAttributes The file attributes and flags for the file.
     * 
     * This parameter can take the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This non-ephemeral log should be archived.
     * 
     * If this flag is not supplied, the log does not need to be archived, and an archival tail is not maintained 
     *         for recycling log containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <b>FILE_FLAG_OVERLAPPED</b> flag is set, all other flag values are ignored.
     * 
     * Specifying <b>FILE_FLAG_OVERLAPPED</b> means that a file is opened for overlapped I/O, 
     *         which enables more than one I/O operation to be performed on the log handle. If this flag is set when creating 
     *         a log, all asynchronous I/O calls to that log must specify an overlapped structure and synchronize with the deferred completion of the call.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the log.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *       error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-createlogfile
     * @since windows6.0.6000
     */
    static CreateLogFile(pszLogFileName, fDesiredAccess, dwShareMode, psaLogFile, fCreateDisposition, fFlagsAndAttributes) {
        pszLogFileName := pszLogFileName is String? StrPtr(pszLogFileName) : pszLogFileName

        A_LastError := 0

        result := DllCall("clfsw32.dll\CreateLogFile", "ptr", pszLogFileName, "uint", fDesiredAccess, "uint", dwShareMode, "ptr", psaLogFile, "uint", fCreateDisposition, "uint", fFlagsAndAttributes)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Marks the specified log for deletion. The log is actually deleted when all handles, marshaling areas, and read contexts to the log are closed. If the log is a physical log, its underlying containers are deleted.
     * @param {Pointer<Void>} hLog A handle to an open log that is obtained by a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. The log must have been created with DELETE access or you cannot delete the log.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-deletelogbyhandle
     * @since windows6.0.6000
     */
    static DeleteLogByHandle(hLog) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\DeleteLogByHandle", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Marks a log for deletion. The log is actually deleted when all handles, marshaling areas, and read contexts to the log are closed. If the log is a physical log, its underlying containers are deleted.
     * @param {Pointer<Char>} pszLogFileName The name of the log. 
     * 
     * This  name is specified when creating the log  by using  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. The following example identifies the format  to use:
     * 
     * <b>log:&lt;</b><i>log name</i><b>&gt;[::&lt;</b><i>log stream name</i><b>&gt;]</b>
     * 
     * &lt;<i>log  name</i>&gt; corresponds to a valid file path in the  file system.
     * 
     * &lt;<i>log stream name</i>&gt; is the unique name of a log stream in the log.
     * 
     *   For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/log-types">Log Types</a>.
     * @param {Pointer<Void>} pvReserved This parameter is reserved and should be set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-deletelogfile
     * @since windows6.0.6000
     */
    static DeleteLogFile(pszLogFileName, pvReserved) {
        pszLogFileName := pszLogFileName is String? StrPtr(pszLogFileName) : pszLogFileName

        A_LastError := 0

        result := DllCall("clfsw32.dll\DeleteLogFile", "ptr", pszLogFileName, "ptr", pvReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds a container to the physical log that is associated with the log handle�if the calling process has write access to the .blf file and the ability to create files in the target directory of the container.
     * @param {Pointer<Void>} hLog The handle to an open log. 
     * 
     * The handle must  be   obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> with write access to the log. The client application must have  write access to the .blf file, and the ability to create files in the target directory of a container.
     * @param {Pointer<UInt64>} pcbContainer The optional parameter that specifies the size of the container, in bytes.  
     * 
     * The minimum size is  512 KB for normal logs and 1024 KB for multiplexed logs. The maximum size is approximately 4 gigabytes.
     * 
     * This parameter is required if the containers are being added to a newly created log.  If a container is already created, this parameter can  be <b>NULL</b>, or some value that is at least as large as the size of the first container. 
     * 
     * 
     * Log container sizes are multiples of the log region size  (512 KB).  When you add a container to a new file, the <b>AddLogContainer</b> function rounds the size of the container up to the next 512 KB boundary, and returns that size in the value pointed to by <i>pcbContainer</i>.  
     * 
     * Similarly,  if the log already has at least one container and the value of <i>*pcbContainer</i> is at least as large as the current container size, the function creates all containers with the current internal size and returns that size in <i>*pcbContainer</i>.
     * @param {Pointer<Char>} pwszContainerPath A pointer to a null-terminated string that contains a valid path for the new container on a log volume.
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>pReserved</i> to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-addlogcontainer
     * @since windows6.0.6000
     */
    static AddLogContainer(hLog, pcbContainer, pwszContainerPath, pReserved) {
        pwszContainerPath := pwszContainerPath is String? StrPtr(pwszContainerPath) : pwszContainerPath

        A_LastError := 0

        result := DllCall("clfsw32.dll\AddLogContainer", "ptr", hLog, "uint*", pcbContainer, "ptr", pwszContainerPath, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds multiple log containers to the physical log that is associated with the log handle�if the calling process has access to the log handle.
     * @remarks
     * The <b>AddLogContainerSet</b> function is not atomic.  If the operation 
     * 		is interrupted, for example, by an invalid path name, the call to 
     * 		<b>AddLogContainerSet</b> returns a failure, but some containers may 
     * 		have been created.  Your application must recover from this error, for example, by determining which containers were added.
     * 
     * Because <b>AddLogContainerSet</b> adds more than one container, it is  more
     *           efficient than making repeated calls to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainer">AddLogContainer</a>, which only adds one container.
     * 
     * Containers are created and opened in a noncompressed mode, and are initialized with 0 (zeros) when they are created.
     * @param {Pointer<Void>} hLog The handle to an open log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> with permissions to add a log container. 
     * 
     * The file can be dedicated or multiplexed.
     * @param {Integer} cContainer The number of containers  in the <i>rgwszContainerPath</i> array.  
     * 
     * This value must be nonzero.  A log must have at least two containers before any I/O can be performed on it.
     * @param {Pointer<UInt64>} pcbContainer The size of the container, in bytes.  
     * 
     * The minimum size is  512 KB for normal logs and 1024 KB for multiplexed logs. The maximum size is approximately 4 gigabytes (GB).
     * 
     * This parameter is required if the containers are being added to a newly created log.  If a container is already created, this parameter can  be <b>NULL</b>, or some value that is at least as large as the size of the first container. 
     * 
     * 
     * Log container sizes are multiples of the log region size  (512 KB).  When you add a container to a new file, the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainer">AddLogContainer</a> function rounds the size of the container up to the next 512 KB boundary, and returns that size in the value pointed to by <i>pcbContainer</i>.  
     * 
     * Similarly,  if the log already has at least one container and the value of <i>*pcbContainer</i> is at least as large as the current container size, the function creates all containers with the current internal size and returns that size in <i>*pcbContainer</i>.
     * @param {Pointer<Char>} rgwszContainerPath An array of   <i>cContainer</i> path names for containers.  
     * 
     * Each element in the array is a wide-character string that contains a valid path for the new container in the log volume.
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>Reserved</i> to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero, which indicates that all containers are added successfully to the log.
     * 
     * If the function fails, the return value is zero, which indicates that none of the containers are added.  To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-addlogcontainerset
     * @since windows6.0.6000
     */
    static AddLogContainerSet(hLog, cContainer, pcbContainer, rgwszContainerPath, pReserved) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\AddLogContainerSet", "ptr", hLog, "ushort", cContainer, "uint*", pcbContainer, "ptr", rgwszContainerPath, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes one container from a log that is associated with a dedicated or multiplexed log handle.
     * @remarks
     * By default, container deletion is lazy, which means that a container is deleted  only if it is not part of an active log.  If the container is part of the active log, it is marked for deletion. However,  deletion does not occur until the  end  of the log exceeds the last sector of the container, or the container has a logical identifier that is greater than the logical identifier of the head of the active log.  The log size reflects the container deletion only when the container is deleted physically.
     * 
     * A log client can request a forced deletion on a container by setting the deletion flag to <b>TRUE</b>. This has the same effect  as deleting a container  that  is  not part of the active log.  However, if the container is part of the active log, the call fails without marking the container for deletion.
     * @param {Pointer<Void>} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.
     * @param {Pointer<Char>} pwszContainerPath A pointer to a wide character string that contains a  path for a  log container that is created by either  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainer">AddLogContainer</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainerset">AddLogContainerSet</a>.
     * @param {Integer} fForce The deletion flag  that determines when and how a container is deleted.
     * 
     * If <i>fForce</i> is <b>TRUE</b>, and the container is part of the active log region, the container is not deleted and an error <b>ERROR_LOG_CANT_DELETE</b> is returned.
     * 
     * If <b>FALSE</b>, the container is deleted when the container is no longer a part of the active log region.
     * @param {Pointer<Void>} pReserved This parameter is reserved and should be  set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-removelogcontainer
     * @since windows6.0.6000
     */
    static RemoveLogContainer(hLog, pwszContainerPath, fForce, pReserved) {
        pwszContainerPath := pwszContainerPath is String? StrPtr(pwszContainerPath) : pwszContainerPath

        A_LastError := 0

        result := DllCall("clfsw32.dll\RemoveLogContainer", "ptr", hLog, "ptr", pwszContainerPath, "int", fForce, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes multiple containers from a log that is associated with a dedicated or multiplexed log handle.
     * @remarks
     * By default, container deletion is lazy, which means that a container is deleted  only if it is  not part of the active log.  If the container is part of the active log it is marked for deletion. This deletion is deferred until the tail of the log exceeds the last sector of the container, or the container has a logical identifier that is greater than the logical identifier of the head of the active log.  The log size reflects the container deletion only when the container is  deleted physically.
     * 
     * 
     * A log client can request a forced deletion on a container by setting the deletion flag to <b>TRUE</b>. This has the same effect  as  deleting a container that  is  not part of the active log.  However, if a container is part of the active log, the call fails without marking the container for deletion.
     * @param {Pointer<Void>} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle must have administrative permission to add a log container, and can refer to either a dedicated or multiplexed log.
     * @param {Integer} cContainer The number of container path names in an array that is pointed to by <i>rgwszContainerPath</i>.  
     * 
     * This value must be nonzero.
     * @param {Pointer<Char>} rgwszContainerPath An array of pointers to container path names that contain  <i>cContainers</i> pointers.  
     * 
     * Each path name is a wide character string that identifies  a container  created by either <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainer">AddLogContainer</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-addlogcontainerset">AddLogContainerSet</a>.
     * @param {Integer} fForce The deletion flag  that determines when and how a container is deleted.
     * 
     * If <i>fForce</i> is <b>TRUE</b>, and the container is part of the active log region, the container is not deleted and an error <b>ERROR_LOG_CANT_DELETE</b> is returned.
     * 
     * If <b>FALSE</b>, the container is deleted when the container is no longer a part of the active log region.
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>pReserved</i> to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-removelogcontainerset
     * @since windows6.0.6000
     */
    static RemoveLogContainerSet(hLog, cContainer, rgwszContainerPath, fForce, pReserved) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\RemoveLogContainerSet", "ptr", hLog, "ushort", cContainer, "ptr", rgwszContainerPath, "int", fForce, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the last archived log sequence number (LSN) or archive tail of an archivable log.
     * @remarks
     * If there are any archive contexts obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-preparelogarchive">PrepareLogArchive</a> that are not terminated with <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a>, the change does not take effect until all archives are complete. While there are outstanding archive contexts, only the greatest archive tail is applied.
     * @param {Pointer<Void>} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle can refer to a dedicated or multiplexed log.
     * @param {Pointer<UInt64>} plsnArchiveTail A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies a valid physical LSN in the log.
     * 
     * 
     * <div class="alert"><b>Note</b>  For handles to both a physical log or a log stream, <i>plsnArchiveTail</i> is a physical LSN, because it refers to a record address in the physical log.</div>
     * <div> </div>
     * @param {Pointer<Void>} pReserved This parameter is reserved and should be set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following  list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-setlogarchivetail
     * @since windows6.0.6000
     */
    static SetLogArchiveTail(hLog, plsnArchiveTail, pReserved) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\SetLogArchiveTail", "ptr", hLog, "uint*", plsnArchiveTail, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * This function has been deprecated. Use TruncateLog instead.
     * @remarks
     * The <b>SetEndOfLog</b> function  truncates the log by setting the end of the log to the specified value.   This operation only works on dedicated logs.
     * 
     * <b>SetEndOfLog</b> can only be used to truncate a log.
     * @param {Pointer<Void>} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle must refer to a dedicated log.
     * @param {Pointer<UInt64>} plsnEnd A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the new end of a log.  
     * 
     * The LSN must be between the base log sequence number (LSN) of the log and the last LSN of the log.
     * @param {Pointer<OVERLAPPED>} lpOverlapped Reserved.  Set <i>lpOverlapped</i> to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-setendoflog
     * @since windows6.0.6000
     */
    static SetEndOfLog(hLog, plsnEnd, lpOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\SetEndOfLog", "ptr", hLog, "uint*", plsnEnd, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Truncates the log. The function sets the end of the log to the specified value.
     * @remarks
     * If the volume sector size is greater than 512 bytes, <b>TruncateLog</b> returns ERROR_NOT_SUPPORTED.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context that is allocated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<UInt64>} plsnEnd A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the new end of a log.  
     * 
     * The LSN must be between the base log sequence number (LSN) of the log and the last LSN of the log.
     * @param {Pointer<OVERLAPPED>} lpOverlapped Reserved.  Set <i>Reserved</i> to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-truncatelog
     * @since windows6.0.6000
     */
    static TruncateLog(pvMarshal, plsnEnd, lpOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\TruncateLog", "ptr", pvMarshal, "uint*", plsnEnd, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a scan context to use with ScanLogContainers to enumerate all log containers that are associated with a log, and performs the first scan.
     * @remarks
     * After completing a scan, the client must call <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-scanlogcontainers">ScanLogContainers</a> again with the <i>eScanMode</i> parameter set to <b>CLFS_SCAN_CLOSE</b>  so that it can free the system-allocated array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_container_information">CLFS_CONTAINER_INFORMATION</a> structures; otherwise, memory leaks result.
     * @param {Pointer<Void>} hLog A  handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> with permissions  to scan the log containers.  
     * 
     * The file can be  a dedicated or multiplexed log.
     * @param {Integer} cFromContainer The container where  the scan is to be started.  
     * 
     * This parameter is an ordinal number relative to the number of containers in the log.
     * @param {Integer} cContainers The number of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_container_information">CLFS_CONTAINER_INFORMATION</a> structures for  <b>CreateLogContainerScanContext</b> to allocate. 
     * 
     * This number is the number of containers scanned with each scan call so the caller knows the scan is complete when the number of containers returned is less than this value.
     * 
     * On exit, a pointer to the system-allocated array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_container_information">CLFS_CONTAINER_INFORMATION</a> structures is placed in the <b>pinfoContainer</b> member of the client-allocated <a href="https://docs.microsoft.com/windows/win32/api/clfs/ns-clfs-cls_scan_context~r1">CLFS_SCAN_CONTEXT</a> structure. This member is   pointed to by the <i>pcxScan</i> parameter (that is, "pcxScan-&gt;pinfoContainer[]"), and the actual number of structures in the array is placed in "pcxScan-&gt;cContainersReturned".
     * 
     * The client must call <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-scanlogcontainers">ScanLogContainers</a> with the <i>eScanMode</i> parameter set to <b>CLFS_SCAN_CLOSE</b>  so that it can free this array; otherwise, memory leaks result.
     * @param {Integer} eScanMode The mode to scan containers.  
     * 
     * Containers can be scanned in any one of the following modes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_INIT__"></a><a id="clfs_scan_init__"></a><dl>
     * <dt><b>CLFS_SCAN_INIT  </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Initializes or reinitializes a scan from the first container in the container list.  
     * 
     * This mode initializes the container context and returns the first set of container descriptors  that  <i>cContainers</i> specifies.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_FORWARD"></a><a id="clfs_scan_forward"></a><dl>
     * <dt><b>CLFS_SCAN_FORWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Returns the first set of containers  that  <i>cContainers</i> specifies.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_BACKWARD"></a><a id="clfs_scan_backward"></a><dl>
     * <dt><b>CLFS_SCAN_BACKWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Returns the last set of containers  that <i>cContainers</i> specifies.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<CLS_SCAN_CONTEXT>} pcxScan A pointer to a client-allocated <a href="https://docs.microsoft.com/windows/win32/api/clfs/ns-clfs-cls_scan_context~r1">CLFS_SCAN_CONTEXT</a> structure that receives a scan context that can be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-scanlogcontainers">ScanLogContainers</a> function when a client scans the log containers of a dedicated log.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if an asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-createlogcontainerscancontext
     * @since windows6.0.6000
     */
    static CreateLogContainerScanContext(hLog, cFromContainer, cContainers, eScanMode, pcxScan, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\CreateLogContainerScanContext", "ptr", hLog, "uint", cFromContainer, "uint", cContainers, "char", eScanMode, "ptr", pcxScan, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates log containers. Call this function repeatedly to iterate over all log containers.
     * @remarks
     * The ID of a log container is  returned in: <b>pcxScan-&gt;pinfoContainer-&gt;LogicalContainerId</b>.
     * 
     * <div class="alert"><b>Note</b>  The Common Log File System (CLFS) scan contexts are not thread-safe. They should not be used by more than one thread at a time, or passed into more than one asynchronous scan at a time.</div>
     * <div> </div>
     * @param {Pointer<CLS_SCAN_CONTEXT>} pcxScan A pointer to a client-allocated <a href="https://docs.microsoft.com/windows/win32/api/clfs/ns-clfs-cls_scan_context~r1">CLFS_SCAN_CONTEXT</a> structure  that  the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogcontainerscancontext">CreateLogContainerScanContext</a> function initializes.
     * @param {Integer} eScanMode The mode  for  containers  to  be scanned.  
     * 
     * Containers can be scanned in any  of the following <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/clfs-scan-mode-constants">CLFS_SCAN_MODE</a> modes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_INIT"></a><a id="clfs_scan_init"></a><dl>
     * <dt><b>CLFS_SCAN_INIT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reinitializes the scan context, but does not allocate associated storage.  
     * 
     * The initialization is destructive, because all  data that is stored in the current scan context is lost.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_CLOSE"></a><a id="clfs_scan_close"></a><dl>
     * <dt><b>CLFS_SCAN_CLOSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Uninitializes the scan context, and deallocates  system storage that is associated with a scan context.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_FORWARD"></a><a id="clfs_scan_forward"></a><dl>
     * <dt><b>CLFS_SCAN_FORWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the next call to <b>ScanLogContainers</b> to proceed  in a forward direction. 
     * 
     * Cannot be used if <b>CLFS_SCAN_BACKWARD</b> is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CLFS_SCAN_BACKWARD"></a><a id="clfs_scan_backward"></a><dl>
     * <dt><b>CLFS_SCAN_BACKWARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Causes the next call to <b>ScanLogContainers</b> to proceed  in a backward direction. 
     * 
     * Cannot be used if <b>CLFS_SCAN_FORWARD</b> is specified.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pReserved Reserved.  Set <i>pReserved</i> to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  The following  list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-scanlogcontainers
     * @since windows6.0.6000
     */
    static ScanLogContainers(pcxScan, eScanMode, pReserved) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ScanLogContainers", "ptr", pcxScan, "char", eScanMode, "ptr", pReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Calculates the sector-aligned reservation size for a set of reserved records.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context that is allocated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Integer} cReservedRecords The number of reserved records that are associated with the reservation adjustment.
     * @param {Pointer<Int64>} rgcbReservation An array of space allocations  to reserve in the log that is associated with the current marshaling context, in bytes.  
     * 
     * The number of allocations corresponds to the number of records  that  <i>cReservedRecords</i> specifies.  Each allocation must be greater than zero (0) or  the function fails with <b>ERROR_INVALID_PARAMETER</b>.
     * @param {Pointer<Int64>} pcbAlignReservation A pointer to a variable in which the function returns the number of   sector-aligned byte space to be reserved in the log—after being given the number of records  that  <i>cRecords</i> specifies and the size of reservations specified in the <i>rgcbReservation</i> array.
     * 
     *   The value returned in <i>*pcbAlignReservation</i> is used as input to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-allocreservedlog">AllocReservedLog</a>. If  <b>AllocReservedLog</b> succeeds, this value is always greater than zero (0).  If <b>AllocReservedLog</b> fails, the value is zero (0).
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-alignreservedlog
     * @since windows6.0.6000
     */
    static AlignReservedLog(pvMarshal, cReservedRecords, rgcbReservation, pcbAlignReservation) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\AlignReservedLog", "ptr", pvMarshal, "uint", cReservedRecords, "int64*", rgcbReservation, "int64*", pcbAlignReservation, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Allocates sector-aligned space for a set of reserved records.
     * @param {Pointer<Void>} pvMarshal A pointer to the  marshaling context that is allocated by calling the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Integer} cReservedRecords The number of reserved records that are associated with the reservation adjustment.  
     * 
     * This value must be greater than zero (0).
     * @param {Pointer<Int64>} pcbAdjustment The size of the sector-aligned space reservation that is associated with the number of records specified in <i>cReservedRecords</i>, in bytes.  
     * 
     * This parameter must be the aligned reservation size  that  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-alignreservedlog">AlignReservedLog</a> returns in <i>*pcbAlignReservation</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible  error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-allocreservedlog
     * @since windows6.0.6000
     */
    static AllocReservedLog(pvMarshal, cReservedRecords, pcbAdjustment) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\AllocReservedLog", "ptr", pvMarshal, "uint", cReservedRecords, "int64*", pcbAdjustment, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reduces the number of reserved log records in a marshaling area made by calling ReserveAndAppendLog, ReserveAndAppendLogAligned, or AllocReservedLog.
     * @remarks
     * When you reserve records, you reserve a specific size.  When you free those records, you must free the same size.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Integer} cReservedRecords The number of reserved records to be freed.  
     * 
     * If the byte count of the adjustment in <i>pcbAdjustment</i> is positive,  <i>cReservedRecords</i> is the total  number of reserved records  that are remaining after the adjustment. Otherwise, this parameter specifies the number of records to be subtracted from the current number of reserved records, but can never exceed the reserved count.
     * @param {Pointer<Int64>} pcbAdjustment The number of bytes of reservation space affected by the adjustment.  
     * 
     * On input, if this number is positive,  it specifies the total remaining size of the reserved space after the adjustment. If this parameter  is negative,  its absolute value is  the number of bytes to be freed.
     * 
     * This value is usually an aggregate of the actual reserved space that is returned in a previous call to the following: 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-reserveandappendlog">ReserveAndAppendLog</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-reserveandappendlogaligned">ReserveAndAppendLogAligned</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-allocreservedlog">AllocReservedLog</a>
     * </li>
     * </ul>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-freereservedlog
     * @since windows6.0.6000
     */
    static FreeReservedLog(pvMarshal, cReservedRecords, pcbAdjustment) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\FreeReservedLog", "ptr", pvMarshal, "uint", cReservedRecords, "int64*", pcbAdjustment, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns a buffer that contains metadata about a specified log and its current state, which is defined by the CLFS_INFORMATION structure.
     * @param {Pointer<Void>} hLog A handle to an open log that is obtained from a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle can refer to a dedicated or multiplexed log.
     * @param {Pointer<CLS_INFORMATION>} pinfoBuffer A pointer to a user-allocated <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_information">CLFS_INFORMATION</a> structure that receives the log metadata.
     * @param {Pointer<UInt32>} cbBuffer A pointer to a variable that on input specifies the size, in bytes, of the metadata buffer pointed to by <i>pinfoBuffer</i>.
     * 
     *  On output, it specifies the number of bytes that are actually copied into <i>pinfoBuffer</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-getlogfileinformation
     * @since windows6.0.6000
     */
    static GetLogFileInformation(hLog, pinfoBuffer, cbBuffer) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\GetLogFileInformation", "ptr", hLog, "ptr", pinfoBuffer, "uint*", cbBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enables or disables log archive support for a specified log.
     * @param {Pointer<Void>} hLog A handle to the log that is obtained from 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.
     * @param {Integer} eMode 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-setlogarchivemode
     * @since windows6.0.6000
     */
    static SetLogArchiveMode(hLog, eMode) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\SetLogArchiveMode", "ptr", hLog, "int", eMode, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns the last restart area that is written successfully to the log associated with the marshaling area of WriteLogRestartArea.
     * @remarks
     * The error message ERROR_LOG_BLOCK_INCOMPLETE is returned if the log block size specified by <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> is not large enough to hold a complete log block.
     * 
     * Typically, <b>ReadLogRestartArea</b> is  used only  during client restart, either after a crash or after a   normal  shutdown.  
     * 
     * If there is no restart area in the log,  <b>ReadLogRestartArea</b> fails  with the  code <b>ERROR_LOG_NO_RESTART</b>.
     * 
     * If <b>ReadLogRestartArea</b>   fails with an error code of <b>ERROR_IO_PENDING</b>, a pointer to a valid read context  is placed in the variable pointed to by the <i>ppvReadContext</i> parameter. 
     * 
     * To complete the log-record copy, the client should first synchronize its execution with deferred completion of the overlapped I/O operation by  calling  <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, or one of the synchronization <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">Wait Functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</a>.
     * 
     * After <b>ReadLogRestartArea</b> completes asynchronously, the requested restart area  is  read from the disk, but a valid pointer to it is not   placed in <i>*ppvRestartBuffer</i>.  
     * 
     * To obtain a valid pointer, the client must call <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readpreviouslogrestartarea">ReadPreviousLogRestartArea</a>, which passes in the read-context pointer returned by <b>ReadLogRestartArea</b>.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time.<p class="note">CLFS read contexts should not be passed into more than one asynchronous read at a time, or the function fails with ERROR_BUSY.
     * 
     * </div>
     * <div> </div>
     * @param {Pointer<Void>} pvMarshal A pointer to a   marshaling context that is  allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<Void>} ppvRestartBuffer A pointer to a variable that receives a pointer to the restart data in the log I/O block.
     * @param {Pointer<UInt32>} pcbRestartBuffer A pointer to a variable that receives the amount of restart data.
     * @param {Pointer<UInt64>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the log sequence  number (LSN) of the restart area.
     * @param {Pointer<Void>} ppvContext A pointer to a variable that receives a pointer to a system-allocated read context  when a read is successful.  
     * 
     * If the function defers completion of an operation, it    returns a valid read-context pointer and an error status of <b>ERROR_IO_PENDING</b>.  On all other errors, the read-context pointer is <b>NULL</b>.  For more information about handling deferred completion of the function, see the Remarks section of this topic. 
     * 
     * After obtaining all requested log records, the client must pass  the read context to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatereadlog">TerminateReadLog</a> to free the associated memory. Failure to do so results in memory leakage.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time, or passed into more than one asynchronous read at a time.</div>
     * <div> </div>
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if an asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-readlogrestartarea
     * @since windows6.0.6000
     */
    static ReadLogRestartArea(pvMarshal, ppvRestartBuffer, pcbRestartBuffer, plsn, ppvContext, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogRestartArea", "ptr", pvMarshal, "ptr", ppvRestartBuffer, "uint*", pcbRestartBuffer, "uint*", plsn, "ptr", ppvContext, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads the previous log restart area that is relative to the current restart record specified in the read context, pvReadContext. This read context is the one previously created by a call to ReadLogRestartArea.
     * @remarks
     * The error message ERROR_LOG_BLOCK_INCOMPLETE is returned if the log block size specified by <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> is not large enough to hold a complete log block.
     * 
     * If <b>ReadPreviousLogRestartArea</b>  fails with an error code of <b>ERROR_IO_PENDING</b>, a pointer to a valid read context  is placed in the variable that is pointed to by the <i>ppvReadContext</i> parameter.
     * 
     * To complete the log-record copy, the client should first synchronize its execution with deferred completion of the overlapped I/O operation by using <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> or one of the synchronization <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">Wait Functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</a>.
     * 
     * After <b>ReadPreviousLogRestartArea</b> completes asynchronously, the requested restart area is read from the disk, but a valid pointer to it is not  placed in <i>*ppvRestartBuffer</i>.
     * 
     * To obtain a valid pointer,  the client must call <b>ReadPreviousLogRestartArea</b> a second time.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time.<p class="note">CLFS read contexts should not be passed into more than one asynchronous read at a time, or the function fails with ERROR_READ.
     * 
     * </div>
     * <div> </div>
     * @param {Pointer<Void>} pvReadContext A pointer to a system-allocated read context that <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrestartarea">ReadLogRestartArea</a> returns.
     * 
     *   Even when those functions return <b>ERROR_IO_PENDING</b>, they still return a pointer to a valid read context. For information about  asynchronous completion, see the Remarks section of this topic.
     * @param {Pointer<Void>} ppvRestartBuffer A pointer to a variable that receives a pointer to the restart data.
     * @param {Pointer<UInt32>} pcbRestartBuffer A pointer to a variable that receives the size of the restart data at <i>*ppvRestartBuffer</i>, in bytes.
     * @param {Pointer<UInt64>} plsnRestart A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the log sequence number (LSN) of the restart area  that   this function returns.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that  is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-readpreviouslogrestartarea
     * @since windows6.0.6000
     */
    static ReadPreviousLogRestartArea(pvReadContext, ppvRestartBuffer, pcbRestartBuffer, plsnRestart, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadPreviousLogRestartArea", "ptr", pvReadContext, "ptr", ppvRestartBuffer, "uint*", pcbRestartBuffer, "uint*", plsnRestart, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Appends a new client restart area to a log, and optionally advances the base log sequence number (LSN) of the log.
     * @remarks
     * The <b>WriteLogRestartArea</b> causes both a flush of all current buffered log records and a flush of the log metadata.
     * 
     * If a client calls <b>WriteLogRestartArea</b> on  a  log  that is created to support asynchronous operations (for example, if the <i>fFlagsAndAttributes</i> parameter of <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>  is set to <b>FILE_FLAG_OVERLAPPED</b> when the log is created), the client must supply a pointer to a valid <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure in the <i>pOverlapped</i> parameter of <b>WriteLogRestartArea</b>.
     * 
     * Then, if  <b>WriteLogRestartArea</b>   fails with an error of <b>ERROR_IO_PENDING</b>, a pointer to a valid read context is placed in the variable that is pointed to by the <i>ppvReadContext</i> parameter. 
     * 
     * To complete the call, the client should synchronize its execution with deferred completion of the overlapped I/O operation by using <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> or one of the synchronization <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">Wait Functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</a>.
     * @param {Pointer<Void>} pvMarshal A pointer to the   marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<Void>} pvRestartBuffer A pointer to a  buffer that contains restart data.
     * @param {Integer} cbRestartBuffer The size of <i>pvRestartBuffer</i>, in bytes.
     * @param {Pointer<UInt64>} plsnBase A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the new base LSN of the log after successfully writing the restart area.  
     * 
     * This value cannot be outside the range of the active log. It must be at least the value of the current base LSN, and not greater than the LSN that was returned in the <i>lastLSN</i> parameter from the latest call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-reserveandappendlog">ReserveAndAppendLog</a>.  If you omit this optional parameter, the base LSN  does not change.
     * @param {Integer} fFlags The flags that specify the behavior of this function.
     * @param {Pointer<UInt32>} pcbWritten A pointer to a variable that receives the number of bytes that are  written when an operation completes.
     * @param {Pointer<UInt64>} plsnNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the restart area that is written.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. 
     * 
     * This parameter can be <b>NULL</b> if an asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following  list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-writelogrestartarea
     * @since windows6.0.6000
     */
    static WriteLogRestartArea(pvMarshal, pvRestartBuffer, cbRestartBuffer, plsnBase, fFlags, pcbWritten, plsnNext, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\WriteLogRestartArea", "ptr", pvMarshal, "ptr", pvRestartBuffer, "uint", cbRestartBuffer, "uint*", plsnBase, "uint", fFlags, "uint*", pcbWritten, "uint*", plsnNext, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} pvMarshal 
     * @param {Pointer<UInt32>} pcbRecordNumber 
     * @param {Pointer<Int64>} pcbUserReservation 
     * @param {Pointer<Int64>} pcbCommitReservation 
     * @returns {Integer} 
     */
    static GetLogReservationInfo(pvMarshal, pcbRecordNumber, pcbUserReservation, pcbCommitReservation) {
        result := DllCall("clfsw32.dll\GetLogReservationInfo", "ptr", pvMarshal, "uint*", pcbRecordNumber, "int64*", pcbUserReservation, "int64*", pcbCommitReservation, "int")
        return result
    }

    /**
     * Advances the base log sequence number (LSN) of a log stream to the specified LSN.
     * @remarks
     * <b>AdvanceLogBase</b> might flush data and metadata when it is called.
     * @param {Pointer<Void>} pvMarshal A pointer to the marshaling context  that  a successful call to  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> returns.
     * @param {Pointer<UInt64>} plsnBase The new base LSN for the log that is specified in <i>pvMarshal</i>.  
     * 
     * This LSN must be in the range between the current base LSN and the last LSN of the log, inclusively.
     * @param {Integer} fFlags This parameter is not implemented at this time, and must be zero.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * If asynchronous operation is not used, this parameter can be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-advancelogbase
     * @since windows6.0.6000
     */
    static AdvanceLogBase(pvMarshal, plsnBase, fFlags, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\AdvanceLogBase", "ptr", pvMarshal, "uint*", plsnBase, "uint", fFlags, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Resets the log file and then shuts the log.
     * @param {Pointer<Void>} hLog A handle to a dedicated or multiplexed log. 
     * 
     * This handle is returned by a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  It is invalidated on successful completion of the call. No other operations that use this handle, or a derivative of this handle, can be called after this function has returned.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-closeandresetlogfile
     * @since windows6.0.6000
     */
    static CloseAndResetLogFile(hLog) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\CloseAndResetLogFile", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a marshaling area for a log, and when successful it returns a marshaling context. Before creating a marshaling area, the log must have at least one container.
     * @param {Pointer<Void>} hLog A handle to the log that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * The log handle  can  refer to a dedicated or multiplexed log.
     * @param {Pointer<CLFS_BLOCK_ALLOCATION>} pfnAllocBuffer The callback function that allocates memory for log blocks.  
     * 
     * If this parameter is <b>NULL</b>, the Common Log File System (CLFS) provides a default block allocation function.  This parameter cannot be <b>NULL</b> if a block-freeing callback is specified by using the <i>pfnFreeBuffer</i>  parameter.
     * 
     * The following example identifies the  syntax of the block allocation callback function:
     * 
     * <c>typedef PVOID (* CLFS_BLOCK_ALLOCATION) (ULONG cbBufferSize, PVOID pvUserContext);</c>
     * @param {Pointer<CLFS_BLOCK_DEALLOCATION>} pfnFreeBuffer The callback function that   frees log blocks allocated by <i>pfnAllocBuffer</i>.  
     * 
     * If this parameter is <b>NULL</b>, CLFS provides a default block deallocation function.  This parameter cannot be <b>NULL</b> if a block allocation callback is specified by using the <i>pfnAllocBuffer</i> parameter.
     * 
     * The following example identifies the syntax of the  block-freeing callback function:
     * 
     * <c>typedef void (* CLFS_BLOCK_DEALLOCATION) (PVOID pvBuffer, PVOID pvUserContext);</c>
     * 
     * The <i>buffer</i> parameter of "ClfsBlockDeallocProc" must point to a block that is allocated by using the callback pointed to by <i>pfnAllocBuffer</i>.
     * @param {Pointer<Void>} pvBlockAllocContext A pointer to a  buffer that is passed back as a user context to the block allocation and deallocation routines, if a buffer is specified.  
     * 
     * If <i>pfnAllocBuffer</i> is <b>NULL</b>, this parameter is ignored.
     * @param {Integer} cbMarshallingBuffer The size, in bytes, of the individual log I/O blocks that will be used by the new marshaling area.  This must be a multiple of the sector size on the stable storage medium.   The sector size is the value returned in the <i>lpBytesPerSector</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * Records cannot be appended or read if they are longer than this value.
     * @param {Integer} cMaxWriteBuffers The maximum number of blocks that can be allocated at any time for   write operations.  
     * 
     * This value can affect the frequency of data flushes. If you do not need to specify a limit to control the frequency of the  data flush cycle, specify  INFINITE.
     * @param {Integer} cMaxReadBuffers The maximum number of blocks that can be allocated at any time for read operations.  
     * 
     * Read contexts use at least one read block.
     * @param {Pointer<Void>} ppvMarshal A pointer to the  marshaling context  that CLFS  allocates when <b>CreateLogMarshallingArea</b> completes successfully.  
     * 
     * This context must be used with all read, append, write, and flush operations to log marshaling areas.  All operations that access marshaling areas by using a marshaling context are thread-safe. This parameter is <b>NULL</b> if the operation is not successful.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following  list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-createlogmarshallingarea
     * @since windows6.0.6000
     */
    static CreateLogMarshallingArea(hLog, pfnAllocBuffer, pfnFreeBuffer, pvBlockAllocContext, cbMarshallingBuffer, cMaxWriteBuffers, cMaxReadBuffers, ppvMarshal) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\CreateLogMarshallingArea", "ptr", hLog, "ptr", pfnAllocBuffer, "ptr", pfnFreeBuffer, "ptr", pvBlockAllocContext, "uint", cbMarshallingBuffer, "uint", cMaxWriteBuffers, "uint", cMaxReadBuffers, "ptr", ppvMarshal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes a marshaling area that is created by a successful call to CreateLogMarshallingArea.
     * @param {Pointer<Void>} pvMarshal A pointer to the opaque marshaling context allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible  error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-deletelogmarshallingarea
     * @since windows6.0.6000
     */
    static DeleteLogMarshallingArea(pvMarshal) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\DeleteLogMarshallingArea", "ptr", pvMarshal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reserves space for log buffers, or appends a log record to the log, or does both. The function is atomic.
     * @remarks
     * The LSN that is returned by the <b>ReserveAndAppendLog</b> function is not necessarily the next LSN that is used.  The LSN that is returned is an estimate of the next LSN, and it varies based on which flags are specified by the <i>fFlags</i> parameter.  The LSN that is returned can be used when moving the base tail.  This LSN is invalidated by the next call to this function.
     * 
     * If the <b>ReserveAndAppendLog</b> function returns <b>ERROR_LOG_FILE_FULL</b>, there is no more space in the log. This can be resolved in one of the following ways:<ul>
     * <li>Free any unneeded reservations.</li>
     * <li>Advance the base LSN or the log archive tail, or both, to recycle containers.</li>
     * <li>Add containers to the log.</li>
     * </ul>The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/common-log-file-system-management-api">CLFS Management API</a> also provides a way to handle scenarios involving  full logs.
     * 
     * If the <b>ReserveAndAppendLog</b>  function is called with a valid <i>pOverlapped</i> structure and the log handle is created with the overlapped option, then if a call to this function fails with an error code of <b>ERROR_IO_PENDING</b>, a pointer to a valid read context  is  placed in the variable that is pointed to by the <i>ppvReadContext</i> parameter.
     * 
     * To complete the log record copy, the client should first synchronize its execution with deferred completion of the overlapped I/O operation by using  the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function, or one of the synchronization <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">Wait Functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</a>.
     * @param {Pointer<Void>} pvMarshal A pointer to a  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<CLS_WRITE_ENTRY>} rgWriteEntries A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_write_entry">CLFS_WRITE_ENTRY</a> buffers to be marshaled into  one  record.
     * 
     * This parameter is ignored if the <i>cWriteEntries</i> parameter is zero.
     * @param {Integer} cWriteEntries The number of write entries  in the <i>rgWriteEntries</i>  array. 
     * 
     * If this value is nonzero, you must specify a buffer in the <i>rgWriteEntries</i> parameter.
     * @param {Pointer<UInt64>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the next record in the undo-chain.
     * @param {Pointer<UInt64>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the previous record in the previous-chain.
     * @param {Integer} cReserveRecords The number of record sizes in the <i>rgcbReservation</i> array.
     * @param {Pointer<Int64>} rgcbReservation A pointer to an array of reservation sizes for each record  that  the <i>cReserveRecords</i> parameter specifies.  
     * 
     *  This parameter is ignored if the <i>cReserveRecords</i> parameter is zero.    If a reservation size is negative, a reservation of that size is released.
     * 
     * The actual space that is reserved for each record, including required overhead, is returned in the individual array elements on successful completion. These values can  be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-freereservedlog">FreeReservedLog</a>  function to adjust space that is reserved in the marshaling area.
     * @param {Integer} fFlags The flags that specify the behavior of this function.
     * @param {Pointer<UInt64>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN  of the appended record.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-reserveandappendlog
     * @since windows6.0.6000
     */
    static ReserveAndAppendLog(pvMarshal, rgWriteEntries, cWriteEntries, plsnUndoNext, plsnPrevious, cReserveRecords, rgcbReservation, fFlags, plsn, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReserveAndAppendLog", "ptr", pvMarshal, "ptr", rgWriteEntries, "uint", cWriteEntries, "uint*", plsnUndoNext, "uint*", plsnPrevious, "uint", cReserveRecords, "int64*", rgcbReservation, "uint", fFlags, "uint*", plsn, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reserves space for log buffers, or appends a log record to the log, or both.
     * @remarks
     * The LSN that is returned by the <b>ReserveAndAppendLogAligned</b> function is not necessarily the next LSN that is used.  The LSN that is returned is an estimate of the next LSN, and it varies based on which flags are specified by the <i>fFlags</i> parameter.  The LSN that is returned can be used when moving the base tail.  This LSN is invalidated by the next call to this function.
     * 
     * If the <b>ReserveAndAppendLogAligned</b> function returns <b>ERROR_LOG_FILE_FULL</b>, there is no more space in the log. This can be resolved in one of the following ways:<ul>
     * <li>Free any unneeded reservations.</li>
     * <li>Advance the base LSN or the log archive tail, or both, to recycle containers.</li>
     * <li>Add containers to the log.</li>
     * </ul>The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/common-log-file-system-management-api">CLFS Management API</a> also provides a way to handle scenarios involving  full logs.
     * 
     * If the <b>ReserveAndAppendLogAligned</b>  function is called with a valid <i>overlapped</i> structure and the log handle is created with the overlapped option, then if a call to this function fails with an error code of <b>ERROR_IO_PENDING</b>, a pointer to a valid read context  is  placed in the variable that is pointed to by the <i>ppvReadContext</i> parameter.
     * 
     * To complete the log-record copy, the client should first synchronize its execution with deferred completion of the overlapped I/O operation by using  the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function or one of the synchronization <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">Wait Functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</a>.
     * @param {Pointer<Void>} pvMarshal A pointer to a   marshaling context that  is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<CLS_WRITE_ENTRY>} rgWriteEntries A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_write_entry">CLFS_WRITE_ENTRY</a> buffers to be marshaled into  one  record.  
     * 
     * This parameter is ignored if the <i>cWriteEntries</i> parameter is zero.
     * @param {Integer} cWriteEntries The number of write entries  in the <i>rgWriteEntries</i>  array. 
     * 
     * If this value is nonzero, you must specify a buffer in the <i>rgWriteEntries</i> parameter.
     * @param {Integer} cbEntryAlignment The byte alignment for each write entry in the <i>rgWriteEntries</i> parameter.
     * 
     * Specify 1 (one) for a simple concatenation. The <i>cbWriteEntryAlignment</i> parameter must be nonzero.
     * @param {Pointer<UInt64>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the next record in the undo-chain.
     * @param {Pointer<UInt64>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the previous record in the previous-chain.
     * @param {Integer} cReserveRecords The number of record sizes in the <i>rgcbReservation</i> array.
     * @param {Pointer<Int64>} rgcbReservation A pointer to an array of reservation sizes for each record  that  the <i>cReserveRecords</i> parameter specifies.  
     * 
     *  This parameter is ignored if the <i>cReserveRecords</i> parameter is zero.    If a reservation size is negative, a reservation of that size is released.
     * 
     * The actual space that is reserved for each record, including required overhead, is returned in the individual array elements on successful completion. These values can  be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-freereservedlog">FreeReservedLog</a>  function to adjust space that is reserved in the marshaling area.
     * @param {Integer} fFlags The flags that specify the behavior of this function.
     * @param {Pointer<UInt64>} plsn A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN  of the appended record.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-reserveandappendlogaligned
     * @since windows6.0.6000
     */
    static ReserveAndAppendLogAligned(pvMarshal, rgWriteEntries, cWriteEntries, cbEntryAlignment, plsnUndoNext, plsnPrevious, cReserveRecords, rgcbReservation, fFlags, plsn, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReserveAndAppendLogAligned", "ptr", pvMarshal, "ptr", rgWriteEntries, "uint", cWriteEntries, "uint", cbEntryAlignment, "uint*", plsnUndoNext, "uint*", plsnPrevious, "uint", cReserveRecords, "int64*", rgcbReservation, "uint", fFlags, "uint*", plsn, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Forces all records appended to this marshaling area to be flushed to disk.
     * @param {Pointer<Void>} pvMarshal A pointer to the  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that  is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-flushlogbuffers
     * @since windows6.0.6000
     */
    static FlushLogBuffers(pvMarshal, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\FlushLogBuffers", "ptr", pvMarshal, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Forces all records appended to this marshaling area up to the record with the specified log sequence number (LSN) to be flushed to the disk. More records than specified may be flushed during this operation.
     * @param {Pointer<Void>} pvMarshalContext A pointer to the  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<UInt64>} plsnFlush A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN that is used to determine which records to flush.   
     * 
     * Specify CLFS_LSN_NULL to flush all records in the marshaling area.
     * @param {Pointer<UInt64>} plsnLastFlushed A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure. 
     * 
     * The LSN returned is greater than the LSN of any record flushed.  If the function  succeeds, the value of the LSN is never less than <i>plsnFlush</i>.  This value  is meaningful only  when  the function succeeds.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that  is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b>  except for an asynchronous operation.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the   possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-flushlogtolsn
     * @since windows6.0.6000
     */
    static FlushLogToLsn(pvMarshalContext, plsnFlush, plsnLastFlushed, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\FlushLogToLsn", "ptr", pvMarshalContext, "uint*", plsnFlush, "uint*", plsnLastFlushed, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Initiates a sequence of reads from a specified log sequence number (LSN) in one of three modes, and returns the first of the specified log records and a read context.
     * @remarks
     * The error message ERROR_LOG_BLOCK_INCOMPLETE is returned if the log block size specified by <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> is not large enough to hold a complete log block.
     * 
     * If <b>ReadLogRecord</b>  is called with a valid <i>pOverlapped</i> structure and the log handle is created with the overlapped option, then if a call to this function fails with an error code of <b>ERROR_IO_PENDING</b>, a pointer to a valid read context  is  placed in the variable that is pointed to by the <i>ppvReadContext</i> parameter.
     * 
     * If you attempt to open more read contexts than the number buffers specified in a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a>,  ERROR_LOG_BLOCK_EXHAUSTED is returned.
     * 
     * To complete a log-record copy, the client should first synchronize its execution with deferred completion of the overlapped I/O operation by using  <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> or one of the synchronization <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">Wait Functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</a>.
     * 
     * After <b>ReadLogRecord</b> completes asynchronously, the requested record  is read from the disk, but is not  resolved to a pointer in <i>*ppvReadBuffer</i>.
     * 
     * To complete the requested read and obtain a valid pointer to the log record, the client must call <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readnextlogrecord">ReadNextLogRecord</a>, which passes in the read-context pointer  that  <b>ReadLogRecord</b> returns.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time.<p class="note">CLFS read contexts should not be passed into more than one asynchronous read at a time, or the function fails with ERROR_BUSY.
     * 
     * </div>
     * <div> </div>
     * @param {Pointer<Void>} pvMarshal A pointer to a  marshaling context that is allocated by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogmarshallingarea">CreateLogMarshallingArea</a> function.
     * @param {Pointer<UInt64>} plsnFirst A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the record  where  the read operation should start.  
     * 
     * This value must be an LSN of a valid record in the active range of the log.
     * @param {Integer} eContextMode The mode for the read context that is returned in <i>*ppvReadContext</i>.  
     * 
     * The following table identifies the three  mutually exclusive  read modes.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsContextPrevious"></a><a id="clfscontextprevious"></a><a id="CLFSCONTEXTPREVIOUS"></a><dl>
     * <dt><b>ClfsContextPrevious</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Reads the  record linked to by <i>plsnPrevious</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsContextUndoNext"></a><a id="clfscontextundonext"></a><a id="CLFSCONTEXTUNDONEXT"></a><dl>
     * <dt><b>ClfsContextUndoNext</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Reads the  record chain linked to by <i>plsnUndoNext</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsContextForward"></a><a id="clfscontextforward"></a><a id="CLFSCONTEXTFORWARD"></a><dl>
     * <dt><b>ClfsContextForward</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Reads the record  with the LSN that immediately follows the current LSN in the read context.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ppvReadBuffer A pointer to a variable that receives a pointer to the target record in the log I/O block.
     * @param {Pointer<UInt32>} pcbReadBuffer A pointer to  a variable that receives the size of the data that is returned in <i>*ppvReadBuffer</i>, in bytes.
     * @param {Pointer<Byte>} peRecordType A pointer to a variable that receives the  type of record read. 
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/clfs-record-type-constants">CLFS_RECORD_TYPE Constants</a>.
     * @param {Pointer<UInt64>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in the undo record chain.
     * @param {Pointer<UInt64>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in the previous record chain.
     * @param {Pointer<Void>} ppvReadContext A pointer to a variable that receives a pointer to a system-allocated read context  when a read is successful.  
     * 
     * If the function defers completion of an operation, it    returns a valid read-context pointer and an error status of <b>ERROR_IO_PENDING</b>.  On all other errors, the read-context pointer is <b>NULL</b>.  For more information about handling deferred completion of the function, see the Remarks section of this topic.
     * 
     * After obtaining all requested log records, the client must pass  the read context to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatereadlog">TerminateReadLog</a> to free the associated memory. Failure to do so results in memory leakage.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time, or passed into more than one asynchronous read at a time.</div>
     * <div> </div>
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, which is required for asynchronous operation.
     * 
     *  This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The following  list identifies the possible error codes.
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-readlogrecord
     * @since windows6.0.6000
     */
    static ReadLogRecord(pvMarshal, plsnFirst, eContextMode, ppvReadBuffer, pcbReadBuffer, peRecordType, plsnUndoNext, plsnPrevious, ppvReadContext, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogRecord", "ptr", pvMarshal, "uint*", plsnFirst, "int", eContextMode, "ptr", ppvReadBuffer, "uint*", pcbReadBuffer, "char*", peRecordType, "uint*", plsnUndoNext, "uint*", plsnPrevious, "ptr", ppvReadContext, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads the next record in a sequence that is initiated by a call to ReadLogRecord or ReadLogRestartArea.
     * @remarks
     * If <b>ReadNextLogRecord</b>  returns with a status code of <b>ERROR_IO_PENDING</b>, the client should synchronize its execution with deferred completion of the overlapped I/O operation by using <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a>, or one of the synchronization <a href="https://docs.microsoft.com/windows/desktop/Sync/wait-functions">Wait Functions</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</a>. 
     * 
     * After <b>ReadNextLogRecord</b> completes asynchronously, the requested record  is  read from the disk, but is not   resolved to a pointer in <i>*ppvReadBuffer</i>. To obtain a valid pointer to the record,  the client must call <b>ReadNextLogRecord</b> a second time.
     * 
     * <div class="alert"><b>Note</b>  Common Log File System (CLFS) read contexts are not thread-safe. They should not be used by more than one thread at a time.<p class="note">CLFS read contexts should not be passed into more than one asynchronous read at a time, or the function fails with ERROR_READ.
     * 
     * </div>
     * <div> </div>
     * @param {Pointer<Void>} pvReadContext A pointer to a  read context  that the system allocates and creates during a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrecord">ReadLogRecord</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrestartarea">ReadLogRestartArea</a>.  
     * 
     * If the function defers completion of an operation, it  returns a pointer to a valid read context and an error status of <b>ERROR_IO_PENDING</b>.  For information about handling asynchronous completion, see the Remarks section of this topic.
     * @param {Pointer<Void>} ppvBuffer A pointer to a variable that receives a pointer to the read data.
     * @param {Pointer<UInt32>} pcbBuffer A pointer to a variable that receives the size of the read data that is returned in <i>ppvReadBuffer</i>, in bytes.
     * @param {Pointer<Byte>} peRecordType A pointer that, on input, specifies   the record type filter of the next record read, and on output specifies the record type that is returned.    
     * 
     * Clients can specify any of the following record types.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsDataRecord"></a><a id="clfsdatarecord"></a><a id="CLFSDATARECORD"></a><dl>
     * <dt><b>ClfsDataRecord</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Only user-data records are read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsRestartRecord"></a><a id="clfsrestartrecord"></a><a id="CLFSRESTARTRECORD"></a><dl>
     * <dt><b>ClfsRestartRecord</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Only restart records are read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ClfsClientRecord"></a><a id="clfsclientrecord"></a><a id="CLFSCLIENTRECORD"></a><dl>
     * <dt><b>ClfsClientRecord</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  All restart and data records are read.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt64>} plsnUser A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies   the log client  to read this log sequence number (LSN) as the next LSN instead of  reading forward to the next record, reading the previous LSN, or reading the next undo LSN.  
     * 
     * This parameter gives log clients the ability to cursor through user-defined LSN chains in client buffers.  The relationship of this parameter to the current LSN held by the read context must be consistent with the context mode, <i>ecxMode</i>,  that is specified in the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrecord">ReadLogRecord</a>  entry points; otherwise, an error code of <b>ERROR_INVALID_PARAMETER</b> is returned.
     * @param {Pointer<UInt64>} plsnUndoNext A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in an undo record chain.
     * @param {Pointer<UInt64>} plsnPrevious A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the next record in the previous record chain.
     * @param {Pointer<UInt64>} plsnRecord A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that receives the LSN of the current record read into the read context.
     * @param {Pointer<OVERLAPPED>} pOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. 
     * 
     * This parameter can be <b>NULL</b> if asynchronous operation is not used.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following  list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-readnextlogrecord
     * @since windows6.0.6000
     */
    static ReadNextLogRecord(pvReadContext, ppvBuffer, pcbBuffer, peRecordType, plsnUser, plsnUndoNext, plsnPrevious, plsnRecord, pOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadNextLogRecord", "ptr", pvReadContext, "ptr", ppvBuffer, "uint*", pcbBuffer, "char*", peRecordType, "uint*", plsnUser, "uint*", plsnUndoNext, "uint*", plsnPrevious, "uint*", plsnRecord, "ptr", pOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Terminates a read context. This function frees system-allocated resources associated with the specified read context. Do not attempt to read log records after calling this function; you will receive indeterminate results.
     * @remarks
     * It is important to deallocate unused read contexts.  Failure to call this function causes resource leaks.
     * @param {Pointer<Void>} pvCursorContext A pointer to a  read context that is returned by <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrecord">ReadLogRecord</a> or <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-readlogrestartarea">ReadLogRestartArea</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-terminatereadlog
     * @since windows6.0.6000
     */
    static TerminateReadLog(pvCursorContext) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\TerminateReadLog", "ptr", pvCursorContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Prepares a physical log for archival.
     * @remarks
     * You must call <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a> to free the archive context, or memory leaks can occur.
     * 
     * Until you call <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a>, containers that are being archived cannot be recycled.
     * 
     * You can only perform one archive operation at a time per handle that  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> returns.
     * @param {Pointer<Void>} hLog A handle to the log that is  obtained by a successful call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>.  
     * 
     * This handle can be the handle to a dedicated or multiplexed log.
     * @param {Pointer<Char>} pszBaseLogFileName A pointer to a  user-allocated buffer to receive the fully qualified path of the base log.  
     * 
     * If the buffer is not large enough, it contains a truncated file path on exit, and the function fails with an <i>ERROR_BUFFER_OVERFLOW</i> status code. 
     * 
     * The  length of the file path is returned in the variable pointed to by <i>pcActualLength</i>.  The client can re-attempt  a failed call with a  name buffer that is large enough.
     * @param {Integer} cLen The size of the <i>pszBaseLogFileName</i> buffer, in wide characters.
     * @param {Pointer<UInt64>} plsnLow A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the log sequence number (LSN) of the low end of the range of the  active log where the log client needs log archival information. 
     * 
     * If this parameter is omitted, the low end of the range defaults to the LSN of the log archive tail.
     * @param {Pointer<UInt64>} plsnHigh A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure that specifies the LSN of the high end of the range of the  active log where the log client needs log archival information. 
     * 
     * If this parameter is omitted, the high end of the range defaults to the next LSN to be written to the log.
     * @param {Pointer<UInt32>} pcActualLength A pointer to a variable that receives the actual length of the name of the base log path, in characters.  
     * 
     * If this value is greater than <i>cLen</i>, the function returns an ERROR_BUFFER_OVERFLOW status with a truncated path that is stored in the <i>pszBaseLogFileName</i> buffer and all other out parameters that are not set to meaningful values.
     * @param {Pointer<UInt64>} poffBaseLogFileData A pointer to a variable that receives the offset  where  the metadata begins in the base log.
     * 
     * The contiguous extent in the base log   <i>pszBaseLogFileName</i> represents the full contents of the log metadata—that is, from <i>poffBaseLogFileData</i> to <i>pcbBaseLogFileLength</i>.
     * @param {Pointer<UInt64>} pcbBaseLogFileLength A pointer to a variable  that specifies the exact length  of the base log, in bytes.
     * @param {Pointer<UInt64>} plsnBase A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure to receive the base log sequence number (LSN) of the active log.
     * @param {Pointer<UInt64>} plsnLast A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure to receive the highest valid LSN in the active log.
     * @param {Pointer<UInt64>} plsnCurrentArchiveTail A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_lsn">CLFS_LSN</a> structure to receive the current LSN of the archive tail of the log.
     * @param {Pointer<Void>} ppvArchiveContext A pointer to the variable that receives a pointer to an  archive context that the system allocates.  
     * 
     * The archive context maintains the cursor state of the archival iterator and the log handle context.  The archival client is responsible for releasing the context by calling <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-preparelogarchive
     * @since windows6.0.6000
     */
    static PrepareLogArchive(hLog, pszBaseLogFileName, cLen, plsnLow, plsnHigh, pcActualLength, poffBaseLogFileData, pcbBaseLogFileLength, plsnBase, plsnLast, plsnCurrentArchiveTail, ppvArchiveContext) {
        pszBaseLogFileName := pszBaseLogFileName is String? StrPtr(pszBaseLogFileName) : pszBaseLogFileName

        A_LastError := 0

        result := DllCall("clfsw32.dll\PrepareLogArchive", "ptr", hLog, "ptr", pszBaseLogFileName, "uint", cLen, "uint*", plsnLow, "uint*", plsnHigh, "uint*", pcActualLength, "uint*", poffBaseLogFileData, "uint*", pcbBaseLogFileLength, "uint*", plsnBase, "uint*", plsnLast, "uint*", plsnCurrentArchiveTail, "ptr", ppvArchiveContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies a range of the archive view of the metadata to the specified buffer.
     * @param {Pointer<Void>} pvArchiveContext A pointer to an  archive context that is obtained by a call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-preparelogarchive">PrepareLogArchive</a>.
     * 
     *   The context maintains  the cursor state, which allows iteration through the set of file extents in the archive.  The archive client is responsible for deallocating the context by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a> function.
     * @param {Integer} cbOffset The offset in the metadata where data copying starts.  
     * 
     * On the first call to this function, specify zero (0). On subsequent calls, specify the value that is returned in <i>pcbBytesRead</i>.
     * @param {Integer} cbBytesToRead The number of bytes of the metadata snapshot should be copied into <i>pbReadBuffer</i>.  
     * 
     * This parameter cannot be zero (0).
     * @param {Pointer<Byte>} pbReadBuffer A pointer to the buffer  where the metadata snapshot is copied.
     * @param {Pointer<UInt32>} pcbBytesRead A pointer to a variable that receives the number of bytes  that are  copied to <i>pbReadBuffer</i>.  
     * 
     * The number of bytes is always between zero (0) and <i>cbBytesToRead</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies  the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-readlogarchivemetadata
     * @since windows6.0.6000
     */
    static ReadLogArchiveMetadata(pvArchiveContext, cbOffset, cbBytesToRead, pbReadBuffer, pcbBytesRead) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogArchiveMetadata", "ptr", pvArchiveContext, "uint", cbOffset, "uint", cbBytesToRead, "char*", pbReadBuffer, "uint*", pcbBytesRead, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the next set of archive extents in a log archive context.
     * @param {Pointer<Void>} pvArchiveContext A pointer to an  archive context that is obtained by a call to <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-preparelogarchive">PrepareLogArchive</a>.
     * 
     *   The context maintains  the cursor state, which allows iteration through the set of file extents in the archive.  The archive client is responsible for deallocating the context by using the <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-terminatelogarchive">TerminateLogArchive</a> function.
     * @param {Pointer<CLS_ARCHIVE_DESCRIPTOR>} rgadExtent A client-allocated array of <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_archive_descriptor">CLFS_ARCHIVE_DESCRIPTOR</a>  structures to be filled in by this function.
     * @param {Integer} cDescriptors The number of elements in  the <i>rgadExtent</i> array. 
     * 
     * This value is the maximum number of archive descriptors that can be retrieved by this function.
     * @param {Pointer<UInt32>} pcDescriptorsReturned The number of descriptors in the <i>rgadExtent</i> array that are  filled in by this function.  
     * 
     * If this value is less than <i>cDescriptors</i>,  the set of descriptors is exhausted and the archive client can terminate iteration through the ordered descriptor set.  Further calls to this function fail with ERROR_NO_MORE_ENTRIES.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-getnextlogarchiveextent
     * @since windows6.0.6000
     */
    static GetNextLogArchiveExtent(pvArchiveContext, rgadExtent, cDescriptors, pcDescriptorsReturned) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\GetNextLogArchiveExtent", "ptr", pvArchiveContext, "ptr", rgadExtent, "uint", cDescriptors, "uint*", pcDescriptorsReturned, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deallocates system resources that are allocated originally for a log archive context by PrepareLogArchive.
     * @remarks
     * Failure to call this function after archiving  completes  results in a resource leak.
     * @param {Pointer<Void>} pvArchiveContext The archive context that is obtained from <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-preparelogarchive">PrepareLogArchive</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following  error code is possible:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-terminatelogarchive
     * @since windows6.0.6000
     */
    static TerminateLogArchive(pvArchiveContext) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\TerminateLogArchive", "ptr", pvArchiveContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Validates the consistency of the log metadata and data before log archive and after log restore.
     * @param {Pointer<Char>} pszLogFileName The name of the log. 
     * 
     * The  name is specified when creating the log  by using  <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. The following example identifies the format  to use:
     * 
     * <i>Log</i><b>:&lt;</b><i>LogName</i><b>&gt;[::&lt;</b><i>LogStreamName</i><b>&gt;]</b>
     * 
     * <b>&lt;</b><i>LogName</i><b>&gt;</b> corresponds to a valid file path  in  the   file system.
     * 
     * <b>&lt;</b><i>LogStreamName</i><b>&gt;</b> is  the unique name of a log stream in the dedicated log.   
     * 
     * For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/log-types">Log Types</a>.
     * @param {Pointer<SECURITY_ATTRIBUTES>} psaLogFile A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that  specifies the security attributes of a log. 
     * 
     * This parameter can be <b>NULL</b>.
     * @param {Pointer<CLS_INFORMATION>} pinfoBuffer A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_information">CLFS_INFORMATION</a> structure that receives log metadata.
     * @param {Pointer<UInt32>} pcbBuffer A pointer to a variable that, on input, specifies the size of the <i>pinfoBuffer</i> metadata buffer, in bytes.  
     * 
     * On output, it receives the amount of information that is copied to the buffer, in bytes.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-validatelog
     * @since windows6.0.6000
     */
    static ValidateLog(pszLogFileName, psaLogFile, pinfoBuffer, pcbBuffer) {
        pszLogFileName := pszLogFileName is String? StrPtr(pszLogFileName) : pszLogFileName

        A_LastError := 0

        result := DllCall("clfsw32.dll\ValidateLog", "ptr", pszLogFileName, "ptr", psaLogFile, "ptr", pinfoBuffer, "uint*", pcbBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path name of the specified container.
     * @param {Pointer<Void>} hLog A handle to the log that is obtained from a successful call to 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a>. 
     * 
     * The log handle could refer to a 
     *       log stream or a physical log.
     * @param {Integer} cidLogicalContainer The unique  identifier that is associated with a container.
     * @param {Pointer<Char>} pwstrContainerName A pointer to a user-allocated buffer to receive the full path and name of the log container, in wide characters.
     * @param {Integer} cLenContainerName The size of the buffer pointed to by <i>pwstrContainerName</i>, in characters.
     * @param {Pointer<UInt32>} pcActualLenContainerName A pointer to a variable to receive the actual character count of the full container path name that is retrieved. 
     *       
     * 
     * If the function succeeds, the value of this parameter is less than or equal to 
     *       <i>cLenContainerName</i>. If the buffer is not large enough to store the whole container 
     *       path name, the function fails with <b>ERROR_MORE_DATA</b> and sets this parameter to the 
     *       size that is required for the full path name. For other failures the value is not defined.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-getlogcontainername
     * @since windows6.0.6000
     */
    static GetLogContainerName(hLog, cidLogicalContainer, pwstrContainerName, cLenContainerName, pcActualLenContainerName) {
        pwstrContainerName := pwstrContainerName is String? StrPtr(pwstrContainerName) : pwstrContainerName

        A_LastError := 0

        result := DllCall("clfsw32.dll\GetLogContainerName", "ptr", hLog, "uint", cidLogicalContainer, "ptr", pwstrContainerName, "uint", cLenContainerName, "uint*", pcActualLenContainerName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves log I/O statistics for a dedicated or multiplexed log that is associated with the specified handle.
     * @param {Pointer<Void>} hLog A handle to an open log file that <a href="https://docs.microsoft.com/windows/desktop/api/clfsw32/nf-clfsw32-createlogfile">CreateLogFile</a> gets.  The log handle can refer to either a dedicated or multiplexed log file.
     * @param {Pointer<Void>} pvStatsBuffer A pointer to a buffer to receive the I/O statistics.  
     * 
     * This buffer must be at least as large as an I/O statistics packet header. For more information, see  <a href="https://docs.microsoft.com/windows/desktop/api/clfs/ns-clfs-cls_io_statistics_header">CLFS_IO_STATISTICS_HEADER</a>.
     * @param {Integer} cbStatsBuffer The size of the I/O statistics buffer <i>pvStatsBuffer</i>, in bytes.   
     * 
     * If the buffer is not large enough for the statistics packet, the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} eStatsClass This parameter is not implemented at this time; it is reserved for future use.
     * @param {Pointer<UInt32>} pcbStatsWritten A pointer to a variable to receive the size of the I/O statistics packet that is written to  <i>pvStatsBuffer</i>.   
     * 
     * This value is less than or equal to <i>cbStatsBuffer</i>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/clfsw32/nf-clfsw32-getlogiostatistics
     * @since windows6.0.6000
     */
    static GetLogIoStatistics(hLog, pvStatsBuffer, cbStatsBuffer, eStatsClass, pcbStatsWritten) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\GetLogIoStatistics", "ptr", hLog, "ptr", pvStatsBuffer, "uint", cbStatsBuffer, "int", eStatsClass, "uint*", pcbStatsWritten, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Registers a client with the log manager. A client can specify whether to receive notifications by using callbacks, or have the notifications queued for retrieval by using ReadLogNotification.
     * @remarks
     * A client can deregister either by closing the log handle, or by calling <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmtw32/nf-clfsmgmtw32-deregistermanageablelogclient">DeregisterManageableLogClient</a>.
     * @param {Pointer<Void>} hLog The handle to the log to register. Only one registration per unique opening of the log is allowed.
     * @param {Pointer<LOG_MANAGEMENT_CALLBACKS>} pCallbacks Specifies the callbacks that the client is registering for.  Valid callbacks are enumerated by <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmtw32/ns-clfsmgmtw32-log_management_callbacks">LOG_MANAGEMENT_CALLBACKS</a>. Specify zero to queue notifications instead.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-registermanageablelogclient
     * @since windows6.0.6000
     */
    static RegisterManageableLogClient(hLog, pCallbacks) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\RegisterManageableLogClient", "ptr", hLog, "ptr", pCallbacks, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deregisters a client with the log manager.
     * @param {Pointer<Void>} hLog The handle to deregister.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. For extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-deregistermanageablelogclient
     * @since windows6.0.6000
     */
    static DeregisterManageableLogClient(hLog) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\DeregisterManageableLogClient", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves notifications from the log manager. It retrieves a queued notification from the log manager immediately if a notification is available; otherwise the request remains pending until a notification is generated.
     * @remarks
     * If the log handle is not created with the <b>FILE_FLAG_OVERLAPPED</b> file option, no operations can start on the log handle while the call to <b>ReadLogNotification</b>  is pending.
     * @param {Pointer<Void>} hLog The handle to the log.
     * @param {Pointer<CLFS_MGMT_NOTIFICATION>} pNotification Receives the notification type, and if the type has parameters associated with it, the parameters.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is required for asynchronous operation. If asynchronous operation is not used, this parameter can be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following is a possible error code:
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-readlognotification
     * @since windows6.0.6000
     */
    static ReadLogNotification(hLog, pNotification, lpOverlapped) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\ReadLogNotification", "ptr", hLog, "ptr", pNotification, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Installs (sets) a policy for a log.
     * @remarks
     * Installing a log policy does not trigger an immediate change in behavior.
     * @param {Pointer<Void>} hLog A handle to a log.
     * @param {Pointer<CLFS_MGMT_POLICY>} pPolicy A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmt/ns-clfsmgmt-clfs_mgmt_policy">CLFS_MGMT_POLICY</a> structure that represents the desired policy to install.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-installlogpolicy
     * @since windows6.0.6000
     */
    static InstallLogPolicy(hLog, pPolicy) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\InstallLogPolicy", "ptr", hLog, "ptr", pPolicy, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Resets the specified policy to its default behavior.
     * @param {Pointer<Void>} hLog Handle to the log to reset the policy for.
     * @param {Integer} ePolicyType Specifies the policy to reset. Policy types are enumerated in <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmt/ne-clfsmgmt-clfs_mgmt_policy_type">CLFS_MGMT_POLICY_TYPE</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-removelogpolicy
     * @since windows6.0.6000
     */
    static RemoveLogPolicy(hLog, ePolicyType) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\RemoveLogPolicy", "ptr", hLog, "int", ePolicyType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The QueryLogPolicy function allows you to obtain a policy that is installed for the specified log.
     * @param {Pointer<Void>} hLog The handle to the log to query.
     * @param {Integer} ePolicyType Specifies the type of policy to query for. Policy types are enumerated in <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmt/ne-clfsmgmt-clfs_mgmt_policy_type">CLFS_MGMT_POLICY_TYPE</a>.
     * @param {Pointer<CLFS_MGMT_POLICY>} pPolicyBuffer A pointer to a buffer to receive the returned policies.
     * @param {Pointer<UInt32>} pcbPolicyBuffer A pointer to the size of <i>pPolicyBuffer</i>. If the buffer is not large enough, <i>pcbPolicyBuffer</i> receives the size buffer required to successfully retrieve the specified policies.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-querylogpolicy
     * @since windows6.0.6000
     */
    static QueryLogPolicy(hLog, ePolicyType, pPolicyBuffer, pcbPolicyBuffer) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\QueryLogPolicy", "ptr", hLog, "int", ePolicyType, "ptr", pPolicyBuffer, "uint*", pcbPolicyBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Adds or deletes containers from a log based on the state of the installed policies.
     * @remarks
     * Containers are  created using the same security attributes as   the .blf file and are created within the context of the application, not the context of the owner of the .blf file. For more information about .blf files, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/clfs/log-types">Log Types</a>. If containers are deleted, they are deleted using the security context of the calling application.
     * @param {Pointer<Void>} hLog A handle to a log.
     * @param {Pointer<UInt64>} pDesiredSize 
     * @param {Pointer<UInt64>} pResultingSize A pointer to a valid ULONGLONG data variable, receives the number of containers in the resized log upon success.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-setlogfilesizewithpolicy
     * @since windows6.0.6000
     */
    static SetLogFileSizeWithPolicy(hLog, pDesiredSize, pResultingSize) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\SetLogFileSizeWithPolicy", "ptr", hLog, "uint*", pDesiredSize, "uint*", pResultingSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Called by a managed log client when an attempt to reserve or append to a log fails with a log full error message. The log manager attempts to resolve the log full condition for the client, and notifies the client when the outcome is known.
     * @remarks
     * If containers are created to resolve a log-full condition, they are created using the calling application's security context.
     * 
     * <b>HandleLogFull</b> always results in asynchronous behavior or an error; if it returns false and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_IO_PENDING</b>, the result is asynchronous behavior. If a request is asynchronous, a notification is sent to the client when the handler has either  resolved the log full condition or it fails.
     * @param {Pointer<Void>} hLog A handle to the log on which to resolve the log full condition. The handle must have been registered with <a href="https://docs.microsoft.com/windows/desktop/api/clfsmgmtw32/nf-clfsmgmtw32-registermanageablelogclient">RegisterManageableLogClient</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 						
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Valid values include the following:
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-handlelogfull
     * @since windows6.0.6000
     */
    static HandleLogFull(hLog) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\HandleLogFull", "ptr", hLog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The LogTailAdvanceFailure function is called by a log client to indicate that it cannot comply with a request from log management to advance its tail.
     * @param {Pointer<Void>} hLog A handle to the log on which to resolve the log full condition.
     * @param {Integer} dwReason Win32 error code with the reason for the failure For a list of possible values, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Valid values include the following:
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-logtailadvancefailure
     * @since windows6.0.6000
     */
    static LogTailAdvanceFailure(hLog, dwReason) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\LogTailAdvanceFailure", "ptr", hLog, "uint", dwReason, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The RegisterForLogWriteNotification function is called by a managed log client to enable or disable log write notifications.
     * @param {Pointer<Void>} hLog A handle to the log on which to resolve the log full condition.
     * @param {Integer} cbThreshold Number of bytes to be written to the log file before the notification is sent.
     * @param {Integer} fEnable If <b>TRUE</b>, the notification is enabled. If <b>FALSE</b>, the notification is disabled.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Valid values include the following:
     * @see https://learn.microsoft.com/windows/win32/api/clfsmgmtw32/nf-clfsmgmtw32-registerforlogwritenotification
     * @since windows6.0.6000
     */
    static RegisterForLogWriteNotification(hLog, cbThreshold, fEnable) {
        A_LastError := 0

        result := DllCall("clfsw32.dll\RegisterForLogWriteNotification", "ptr", hLog, "uint", cbThreshold, "int", fEnable, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a list of users for the specified file.
     * @remarks
     * When the list of users is no longer needed, call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/nf-winefs-freeencryptioncertificatehashlist">FreeEncryptionCertificateHashList</a> function to free the list.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<Char>} lpFileName The name of the file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pUsers A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a> structure that receives the list of users.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-queryusersonencryptedfile
     * @since windows5.1.2600
     */
    static QueryUsersOnEncryptedFile(lpFileName, pUsers) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\QueryUsersOnEncryptedFile", "ptr", lpFileName, "ptr", pUsers, "uint")
        return result
    }

    /**
     * Retrieves a list of recovery agents for the specified file.
     * @remarks
     * When the list of recovery agents is no longer needed, free it by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/nf-winefs-freeencryptioncertificatehashlist">FreeEncryptionCertificateHashList</a> function.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<Char>} lpFileName The name of the file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pRecoveryAgents A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a> structure that receives a list of recovery agents.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-queryrecoveryagentsonencryptedfile
     * @since windows5.1.2600
     */
    static QueryRecoveryAgentsOnEncryptedFile(lpFileName, pRecoveryAgents) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\QueryRecoveryAgentsOnEncryptedFile", "ptr", lpFileName, "ptr", pRecoveryAgents, "uint")
        return result
    }

    /**
     * Removes specified certificate hashes from a specified file.
     * @remarks
     * The 
     * <b>RemoveUsersFromEncryptedFile</b> function removes the specified certificate hashes if they exist in the specified file. If any of the certificate hashes are not found in the specified file, they are ignored and no error code is returned.
     * 
     * Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<Char>} lpFileName The name of the file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pHashes A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a> structure that contains a list of certificate hashes to be removed from the file.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-removeusersfromencryptedfile
     * @since windows5.1.2600
     */
    static RemoveUsersFromEncryptedFile(lpFileName, pHashes) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\RemoveUsersFromEncryptedFile", "ptr", lpFileName, "ptr", pHashes, "uint")
        return result
    }

    /**
     * Adds user keys to the specified encrypted file.
     * @remarks
     * Starting with Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<Char>} lpFileName The name of the encrypted file.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_LIST>} pEncryptionCertificates A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_list">ENCRYPTION_CERTIFICATE_LIST</a> structure that contains the list of new user keys to be added to the file.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-adduserstoencryptedfile
     * @since windows5.1.2600
     */
    static AddUsersToEncryptedFile(lpFileName, pEncryptionCertificates) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\AddUsersToEncryptedFile", "ptr", lpFileName, "ptr", pEncryptionCertificates, "uint")
        return result
    }

    /**
     * Sets the user's current key to the specified certificate.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<ENCRYPTION_CERTIFICATE>} pEncryptionCertificate A pointer to a certificate that will be the user's key. This parameter is a pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate">ENCRYPTION_CERTIFICATE</a> structure.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-setuserfileencryptionkey
     * @since windows5.1.2600
     */
    static SetUserFileEncryptionKey(pEncryptionCertificate) {
        result := DllCall("ADVAPI32.dll\SetUserFileEncryptionKey", "ptr", pEncryptionCertificate, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<ENCRYPTION_CERTIFICATE>} pEncryptionCertificate 
     * @param {Integer} dwCapabilities 
     * @param {Integer} dwFlags 
     * @returns {Integer} 
     */
    static SetUserFileEncryptionKeyEx(pEncryptionCertificate, dwCapabilities, dwFlags) {
        static pvReserved := 0 ;Reserved parameters must always be NULL

        result := DllCall("ADVAPI32.dll\SetUserFileEncryptionKeyEx", "ptr", pEncryptionCertificate, "uint", dwCapabilities, "uint", dwFlags, "ptr", pvReserved, "uint")
        return result
    }

    /**
     * Frees a certificate hash list.
     * @remarks
     * <b>ReFS:  </b>This function is not supported.
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pUsers A pointer to a certificate hash list structure, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/ns-winefs-encryption_certificate_hash_list">ENCRYPTION_CERTIFICATE_HASH_LIST</a>, which was returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/nf-winefs-queryusersonencryptedfile">QueryUsersOnEncryptedFile</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winefs/nf-winefs-queryrecoveryagentsonencryptedfile">QueryRecoveryAgentsOnEncryptedFile</a> function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-freeencryptioncertificatehashlist
     * @since windows5.1.2600
     */
    static FreeEncryptionCertificateHashList(pUsers) {
        DllCall("ADVAPI32.dll\FreeEncryptionCertificateHashList", "ptr", pUsers)
    }

    /**
     * Disables or enables encryption of the specified directory and the files in it.
     * @remarks
     * Under normal circumstances, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-encryptfilea">EncryptFile</a> will not encrypt 
     *     files and directories with the <b>FILE_ATTRIBUTE_SYSTEM</b> attribute set. It is possible to 
     *     override the <b>FILE_ATTRIBUTE_SYSTEM</b> attribute and encrypt files. Also, if a file or 
     *     directory is marked with the <b>FILE_ATTRIBUTE_SYSTEM</b> attribute, it will normally be
     *     invisible to the user in directory listings and Windows Explorer directory windows. 
     *     <b>EncryptionDisable</b> disables encryption of directories and files. It does not 
     *     affect the visibility of files with the <b>FILE_ATTRIBUTE_SYSTEM</b> attribute set.
     *    
     * 
     * If <b>TRUE</b> is passed in, 
     *     <b>EncryptionDisable</b> will write the following to the 
     *     Desktop.ini file in the directory (creating it if necessary):
     * 
     * 
     * ``` syntax
     * [Encryption]
     * Disable=1
     * ```
     * 
     * If the section already exists but <i>Disable</i> is set to 0, it will be set to 1.
     * 
     * Thereafter, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-encryptfilea">EncryptFile</a> will fail on the 
     *     directory and the files in it, and the code that 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns will be 
     *     <b>ERROR_DIR_EFS_DISALLOWED</b>. This function does not affect encryption of subdirectories 
     *     within the given directory.
     * 
     * The user can also manually add or edit the above lines in the Desktop.ini file and produce the 
     *     same effect.
     * 
     * <b>EncryptionDisable</b> affects only 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-fileencryptionstatusa">FileEncryptionStatus</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-encryptfilea">EncryptFile</a>. After the directory is 
     *     encrypted, any new files and new subdirectories created without the 
     *     <b>FILE_ATTRIBUTE_SYSTEM</b> attribute will be encrypted.
     * 
     * If <b>FALSE</b> is passed in, 
     *     <b>EncryptionDisable</b> will write the following to the 
     *     Desktop.ini file:
     * 
     * 
     * ``` syntax
     * [Encryption]
     * Disable=0
     * ```
     * 
     * This means that  file encryption is permitted on the files in that directory.
     * 
     * If you try to use <b>EncryptionDisable</b> to set the 
     *     directory to the state it is already in, the function succeeds but has no effect.
     * 
     * If you try to use <b>EncryptionDisable</b> to disable or 
     *     enable encryption on a file, the attempt will fail.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<Char>} DirPath The name of the directory for which to enable or 
     *       disable encryption.
     * @param {Integer} Disable Indicates whether to disable encryption (<b>TRUE</b>) or enable it 
     *       (<b>FALSE</b>).
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-encryptiondisable
     * @since windows5.1.2600
     */
    static EncryptionDisable(DirPath, Disable) {
        DirPath := DirPath is String? StrPtr(DirPath) : DirPath

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\EncryptionDisable", "ptr", DirPath, "int", Disable, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies the EFS metadata from one file or directory to another.
     * @remarks
     * Exclusive access to the destination file or directory is required by EFS for the call to this function. If this access is not provided, this function will fail.
     * 
     * The caller should have the EFS key for the source file or directory, and at least the <b>READ_ATTRIBUTE</b> ACL for the source file or directory.
     * 
     * The specified source and destination file or directories should reside on the same computer; otherwise, an error will be returned.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<Char>} SrcFileName The name of the file or directory from which the EFS metadata is to be copied. This source file or directory must be encrypted.
     * @param {Pointer<Char>} DstFileName The name of the file or directory to which the EFS metadata is to be copied. 
     * 
     * 
     * 
     * 
     * This destination file or directory does not have to be encrypted before the call to this function; however if this function completes successfully, it will be encrypted.
     * 
     * If the value of <i>SrcFileName</i> specifies a file, the value of this parameter must also specify a file, and likewise for directories. If a file or directory with the name specified by this parameter does not exist, a file or directory (depending on whether <i>SrcFileName</i> specifies a file or directory) will be created.
     * @param {Integer} dwCreationDistribution Describes how the destination file or directory identified by the <i>DstFileName</i> parameter value is to be opened. The following are the valid values of this parameter. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_ALWAYS"></a><a id="create_always"></a><dl>
     * <dt><b>CREATE_ALWAYS</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Always create the destination file or directory. Any value passed in this parameter other than <b>CREATE_NEW</b> will be processed as <b>CREATE_ALWAYS</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_NEW"></a><a id="create_new"></a><dl>
     * <dt><b>CREATE_NEW</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create the destination file or directory only if it does not already exist. If it does exist, and this value is specified, this function will fail.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwAttributes The file attributes of the destination file or directory. The <b>FILE_READ_ONLY</b> attribute is currently not processed by this function.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a 
     * <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that specifies the security attributes of the destination file or directory, if it does not already exist. If you specify <b>NULL</b>, the file or directory gets a default security descriptor. The ACLs in the default security descriptor for a file or directory are inherited from its parent directory.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, the return value is a system error code. For a complete list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a> or the header file WinError.h.
     * @see https://learn.microsoft.com/windows/win32/api/winefs/nf-winefs-duplicateencryptioninfofile
     * @since windows5.1.2600
     */
    static DuplicateEncryptionInfoFile(SrcFileName, DstFileName, dwCreationDistribution, dwAttributes, lpSecurityAttributes) {
        SrcFileName := SrcFileName is String? StrPtr(SrcFileName) : SrcFileName
        DstFileName := DstFileName is String? StrPtr(DstFileName) : DstFileName

        result := DllCall("ADVAPI32.dll\DuplicateEncryptionInfoFile", "ptr", SrcFileName, "ptr", DstFileName, "uint", dwCreationDistribution, "uint", dwAttributes, "ptr", lpSecurityAttributes, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} lpFileName 
     * @param {Pointer<UInt32>} pcbMetadata 
     * @param {Pointer<Byte>} ppbMetadata 
     * @returns {Integer} 
     * @deprecated
     */
    static GetEncryptedFileMetadata(lpFileName, pcbMetadata, ppbMetadata) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\GetEncryptedFileMetadata", "ptr", lpFileName, "uint*", pcbMetadata, "ptr", ppbMetadata, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} lpFileName 
     * @param {Pointer<Byte>} pbOldMetadata 
     * @param {Pointer<Byte>} pbNewMetadata 
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH>} pOwnerHash 
     * @param {Integer} dwOperation 
     * @param {Pointer<ENCRYPTION_CERTIFICATE_HASH_LIST>} pCertificatesAdded 
     * @returns {Integer} 
     * @deprecated
     */
    static SetEncryptedFileMetadata(lpFileName, pbOldMetadata, pbNewMetadata, pOwnerHash, dwOperation, pCertificatesAdded) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\SetEncryptedFileMetadata", "ptr", lpFileName, "char*", pbOldMetadata, "char*", pbNewMetadata, "ptr", pOwnerHash, "uint", dwOperation, "ptr", pCertificatesAdded, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} pbMetadata 
     * @returns {String} Nothing - always returns an empty string
     * @deprecated
     */
    static FreeEncryptedFileMetadata(pbMetadata) {
        DllCall("ADVAPI32.dll\FreeEncryptedFileMetadata", "char*", pbMetadata)
    }

    /**
     * 
     * @returns {Integer} 
     */
    static LZStart() {
        result := DllCall("KERNEL32.dll\LZStart", "int")
        return result
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static LZDone() {
        DllCall("KERNEL32.dll\LZDone")
    }

    /**
     * 
     * @param {Integer} hfSource 
     * @param {Integer} hfDest 
     * @returns {Integer} 
     */
    static CopyLZFile(hfSource, hfDest) {
        result := DllCall("KERNEL32.dll\CopyLZFile", "int", hfSource, "int", hfDest, "int")
        return result
    }

    /**
     * Copies a source file to a destination file.
     * @remarks
     * The handles identifying the source and destination files must be retrieved by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzinit">LZInit</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a> function. 
     * 
     * If the function succeeds, the file identified by the <i>hfDest</i> parameter is always uncompressed.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * @param {Integer} hfSource A handle to the source file.
     * @param {Integer} hfDest A handle to the destination file.
     * @returns {Integer} If the function succeeds, the return value specifies the size, in bytes, of the destination file.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZCopy</b> calls neither 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is a list of error codes that 
     * <b>LZCopy</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADOUTHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the destination file is not valid. The file cannot be written.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_READ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file format is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-lzcopy
     * @since windows5.1.2600
     */
    static LZCopy(hfSource, hfDest) {
        result := DllCall("KERNEL32.dll\LZCopy", "int", hfSource, "int", hfDest, "int")
        return result
    }

    /**
     * Allocates memory for the internal data structures required to decompress files, and then creates and initializes them.
     * @remarks
     * A maximum of 16 compressed files can be open at any given time. Similarly, a maximum of 16 uncompressed files can be open at any given time. An application should be careful to close the handle returned by 
     * <b>LZInit</b> when it is done using the file; otherwise, the application can inadvertently hit the 16-file limit.
     * 
     * The handle this function returns is compatible only with the functions in Lz32.dll; it should not be used for other file operations.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * @param {Integer} hfSource A handle to the file.
     * @returns {Integer} If the function succeeds, the return value is a new LZ file handle.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZInit</b> calls neither 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is the list of the error codes that 
     * <b>LZInit</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_UNKNOWNALG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is compressed with an unrecognized compression algorithm.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-lzinit
     * @since windows5.1.2600
     */
    static LZInit(hfSource) {
        result := DllCall("KERNEL32.dll\LZInit", "int", hfSource, "int")
        return result
    }

    /**
     * Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm. (ANSI)
     * @remarks
     * The contents of the buffer pointed to by the <i>lpszBuffer</i> parameter is the original file name if the file was compressed by using the <b>/r</b> option. If the <b>/r</b> option was not used, this function duplicates the name in the <i>lpszSource</i> parameter into the <i>lpszBuffer</i> buffer.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The lzexpand.h header defines GetExpandedName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszSource The name of the compressed file.
     * @param {Pointer<Byte>} lpszBuffer A pointer to a buffer that receives the original name of the compressed file.
     * @returns {Integer} If the function succeeds, the return value is 1.
     * 
     * If the function fails, the return value is LZERROR_BADVALUE. There is no extended error information for this function; do not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>GetExpandedName</b> calls neither 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-getexpandednamea
     * @since windows5.1.2600
     */
    static GetExpandedNameA(lpszSource, lpszBuffer) {
        lpszSource := lpszSource is String? StrPtr(lpszSource) : lpszSource
        lpszBuffer := lpszBuffer is String? StrPtr(lpszBuffer) : lpszBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetExpandedNameA", "ptr", lpszSource, "ptr", lpszBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the original name of a compressed file, if the file was compressed by the Lempel-Ziv algorithm. (Unicode)
     * @remarks
     * The contents of the buffer pointed to by the <i>lpszBuffer</i> parameter is the original file name if the file was compressed by using the <b>/r</b> option. If the <b>/r</b> option was not used, this function duplicates the name in the <i>lpszSource</i> parameter into the <i>lpszBuffer</i> buffer.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The lzexpand.h header defines GetExpandedName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpszSource The name of the compressed file.
     * @param {Pointer<Char>} lpszBuffer A pointer to a buffer that receives the original name of the compressed file.
     * @returns {Integer} If the function succeeds, the return value is 1.
     * 
     * If the function fails, the return value is LZERROR_BADVALUE. There is no extended error information for this function; do not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>GetExpandedName</b> calls neither 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-getexpandednamew
     * @since windows5.1.2600
     */
    static GetExpandedNameW(lpszSource, lpszBuffer) {
        lpszSource := lpszSource is String? StrPtr(lpszSource) : lpszSource
        lpszBuffer := lpszBuffer is String? StrPtr(lpszBuffer) : lpszBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetExpandedNameW", "ptr", lpszSource, "ptr", lpszBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates, opens, reopens, or deletes the specified file. (ANSI)
     * @remarks
     * If the <i>wStyle</i> parameter is the <b>OF_READ</b> flag (or 
     *     <b>OF_READ</b> and any of the <b>OF_SHARE_*</b> flags) and the file is 
     *     compressed, <b>LZOpenFile</b> calls the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzinit">LZInit</a> function, which performs the required initialization for 
     *     the decompression operations.
     * 
     * The handle this function returns is compatible only with the functions in Lz32.dll; it should not be used 
     *     for other file operations.
     * 
     * If <b>LZOpenFile</b> is unable to open the file specified by 
     *     <i>lpFileName</i>, on some versions of Windows it attempts to open a file with almost the same 
     *     file name, except the last character is replaced with an underscore ("_"). Thus, if an attempt to 
     *     open "MyProgram.exe" fails, <b>LZOpenFile</b> tries to open 
     *     "MyProgram.ex_". Installation packages often substitute the underscore for the last letter of a 
     *     file name extension to indicate that the file is compressed. For example, "MyProgram.exe" 
     *     compressed might be named "MyProgram.ex_". To determine the name of the file opened (if any), 
     *     examine the <b>szPathName</b> member of the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure in the 
     *     <i>lpReOpenBuf</i> parameter.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The lzexpand.h header defines LZOpenFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file.
     * @param {Pointer<OFSTRUCT>} lpReOpenBuf A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that is to receive 
     *        information about the file when the file is first opened. The structure can be used in subsequent calls to the 
     *        <b>LZOpenFile</b> function to see the open file.
     * 
     * The <b>szPathName</b> member of this structure contains characters from the original 
     *        equipment manufacturer (OEM) character set.
     * @param {Integer} wStyle 
     * @returns {Integer} If the function succeeds and the value specified by the <i>wStyle</i> parameter is not 
     *        <b>OF_READ</b>, the return value is a handle identifying the file. If the file is compressed 
     *        and opened with <i>wStyle</i> set to <b>OF_READ</b>, the return value is 
     *        a special file handle.
     * 
     * If the function fails, the return value is an <b>LZERROR_*</b> code. These codes have 
     *        values less than zero. There is no extended error information for this function; do not call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>LZOpenFile</b> calls neither 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a 
     *        thread's last-error code.</div>
     * <div> </div>
     * The following is the list of the error codes that <b>LZOpenFile</b> can return upon 
     *        failure.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * <dt>-1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * <dt>-5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-lzopenfilea
     * @since windows5.1.2600
     */
    static LZOpenFileA(lpFileName, lpReOpenBuf, wStyle) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("KERNEL32.dll\LZOpenFileA", "ptr", lpFileName, "ptr", lpReOpenBuf, "ushort", wStyle, "int")
        return result
    }

    /**
     * Creates, opens, reopens, or deletes the specified file. (Unicode)
     * @remarks
     * If the <i>wStyle</i> parameter is the <b>OF_READ</b> flag (or 
     *     <b>OF_READ</b> and any of the <b>OF_SHARE_*</b> flags) and the file is 
     *     compressed, <b>LZOpenFile</b> calls the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzinit">LZInit</a> function, which performs the required initialization for 
     *     the decompression operations.
     * 
     * The handle this function returns is compatible only with the functions in Lz32.dll; it should not be used 
     *     for other file operations.
     * 
     * If <b>LZOpenFile</b> is unable to open the file specified by 
     *     <i>lpFileName</i>, on some versions of Windows it attempts to open a file with almost the same 
     *     file name, except the last character is replaced with an underscore ("_"). Thus, if an attempt to 
     *     open "MyProgram.exe" fails, <b>LZOpenFile</b> tries to open 
     *     "MyProgram.ex_". Installation packages often substitute the underscore for the last letter of a 
     *     file name extension to indicate that the file is compressed. For example, "MyProgram.exe" 
     *     compressed might be named "MyProgram.ex_". To determine the name of the file opened (if any), 
     *     examine the <b>szPathName</b> member of the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure in the 
     *     <i>lpReOpenBuf</i> parameter.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The lzexpand.h header defines LZOpenFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file.
     * @param {Pointer<OFSTRUCT>} lpReOpenBuf A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that is to receive 
     *        information about the file when the file is first opened. The structure can be used in subsequent calls to the 
     *        <b>LZOpenFile</b> function to see the open file.
     * 
     * The <b>szPathName</b> member of this structure contains characters from the original 
     *        equipment manufacturer (OEM) character set.
     * @param {Integer} wStyle 
     * @returns {Integer} If the function succeeds and the value specified by the <i>wStyle</i> parameter is not 
     *        <b>OF_READ</b>, the return value is a handle identifying the file. If the file is compressed 
     *        and opened with <i>wStyle</i> set to <b>OF_READ</b>, the return value is 
     *        a special file handle.
     * 
     * If the function fails, the return value is an <b>LZERROR_*</b> code. These codes have 
     *        values less than zero. There is no extended error information for this function; do not call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>LZOpenFile</b> calls neither 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a 
     *        thread's last-error code.</div>
     * <div> </div>
     * The following is the list of the error codes that <b>LZOpenFile</b> can return upon 
     *        failure.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * <dt>-1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * <dt>-5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-lzopenfilew
     * @since windows5.1.2600
     */
    static LZOpenFileW(lpFileName, lpReOpenBuf, wStyle) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("KERNEL32.dll\LZOpenFileW", "ptr", lpFileName, "ptr", lpReOpenBuf, "ushort", wStyle, "int")
        return result
    }

    /**
     * Moves a file pointer the specified number of bytes from a starting position.
     * @remarks
     * The handle identified by the <i>hFile</i> parameter must be retrieved by calling either the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzinit">LZInit</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a> function.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * @param {Integer} hFile A handle to the file.
     * @param {Integer} lOffset The number of bytes by which to move the file pointer.
     * @param {Integer} iOrigin 
     * @returns {Integer} If the function succeeds, the return value specifies the offset from the beginning of the file to the new pointer position.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZSeek</b> calls neither <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is the list of error codes that 
     * <b>LZSeek</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADVALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters is outside the range of acceptable values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-lzseek
     * @since windows5.1.2600
     */
    static LZSeek(hFile, lOffset, iOrigin) {
        result := DllCall("KERNEL32.dll\LZSeek", "int", hFile, "int", lOffset, "int", iOrigin, "int")
        return result
    }

    /**
     * Reads (at most) the specified number of bytes from a file and copies them into a buffer.
     * @remarks
     * The handle identifying the file must be retrieved by calling either the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzinit">LZInit</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a> function.
     * 
     * If the file is compressed, 
     * <b>LZRead</b> operates on an expanded image of the file and copies the bytes of data into the specified buffer.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * @param {Integer} hFile A handle to the file.
     * @param {Pointer} lpBuffer A pointer to a buffer that receives the bytes read from the file. Ensure that this buffer is larger than <i>cbRead</i>.
     * @param {Integer} cbRead The count of bytes to be read.
     * @returns {Integer} If the function succeeds, the return value specifies the number of bytes read.
     * 
     * If the function fails, the return value is an LZERROR_* code. These codes have values less than zero. Note that 
     * <b>LZRead</b> calls neither <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror">SetLastError</a> nor <a href="https://docs.microsoft.com/windows/desktop/api/winuser/nf-winuser-setlasterrorex">SetLastErrorEx</a>; thus, its failure does not affect a thread's last-error code.
     * 
     * The following is the list of error codes that 
     * <b>LZRead</b> can return upon failure.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADINHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the source file is not valid. The file cannot be read.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADOUTHANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle identifying the destination file is not valid. The file cannot be written.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_BADVALUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the input parameters is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBALLOC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum number of open compressed files has been exceeded or local memory cannot be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_GLOBLOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The LZ file handle cannot be locked down.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_READ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The source file format is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>LZERROR_WRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is insufficient space for the output file.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * There is no extended error information for this function; do not call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-lzread
     * @since windows5.1.2600
     */
    static LZRead(hFile, lpBuffer, cbRead) {
        result := DllCall("KERNEL32.dll\LZRead", "int", hFile, "ptr", lpBuffer, "int", cbRead, "int")
        return result
    }

    /**
     * Closes a file that was opened by using the LZOpenFile function.
     * @remarks
     * The handle identifying the file must be retrieved by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a> function. If the handle is retrieved by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openfile">OpenFile</a> function, an error occurs.
     * 
     * If the file has been compressed by the Lempel-Ziv algorithm and opened by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lzexpand/nf-lzexpand-lzopenfilea">LZOpenFile</a>, 
     * <b>LZClose</b> frees any global heap space that was allocated to expand the file.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * @param {Integer} hFile A handle to the file to be closed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/lzexpand/nf-lzexpand-lzclose
     * @since windows5.1.2600
     */
    static LZClose(hFile) {
        DllCall("KERNEL32.dll\LZClose", "int", hFile)
    }

    /**
     * Indicates whether compression should be used on a particular volume, and if so, which compression algorithm should be used.
     * @param {Pointer<Char>} Volume Specifies the path to the volume whose compression state is desired.
     * @param {Pointer<UInt32>} Algorithm Points to a ULONG value. If the function returns TRUE, indicating compression is desired, this value will contain the algorithm that should be used for this volume.
     * @returns {Integer} If binaries on this volume should be compressed, the return value is TRUE; otherwise it is FALSE. This function will return FALSE if the system does not support compression on the specified volume.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofshouldcompressbinaries
     */
    static WofShouldCompressBinaries(Volume, Algorithm) {
        Volume := Volume is String? StrPtr(Volume) : Volume

        result := DllCall("WOFUTIL.dll\WofShouldCompressBinaries", "ptr", Volume, "uint*", Algorithm, "int")
        return result
    }

    /**
     * Used to query the version of the driver used to support a particular provider.
     * @remarks
     * On successful completion, the WofVersion value is updated to reflect the version of the WOF driver. This value includes the major and minor version numbers of the operating system in the high-order word, and the build number of the operating system in the low-order word. The major version can be extracted with HIBYTE(HIWORD(WofVersion)); the minor version can be extracted with LOBYTE(HIWORD(WofVersion)); the build number can be extracted with LOWORD(WofVersion). 
     * 
     * QuickInfo
     * @param {Pointer<Void>} FileOrVolumeHandle A handle to a file or volume opened with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or a similar API.
     * @param {Integer} Provider Indicates which provider the version query is intended for. Multiple versions of Wof may exist on the same volume at the same time for different providers.
     * @param {Pointer<UInt32>} WofVersion Pointer to a ULONG which will contain the version upon successful completion of this function.
     * @returns {HRESULT} This function returns an HRESULT indicating success or the reason for failure. If no driver is attached on the specified volume for the specified provider, the function will fail with HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION).
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofgetdriverversion
     */
    static WofGetDriverVersion(FileOrVolumeHandle, Provider, WofVersion) {
        result := DllCall("WOFUTIL.dll\WofGetDriverVersion", "ptr", FileOrVolumeHandle, "uint", Provider, "uint*", WofVersion, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Used to change a file from being backed by a physical file to one backed by a system data provider.
     * @remarks
     * When using WOF_PROVIDER_FILE, the operation may fail with ERROR_COMPRESSION_NOT_BENEFICIAL. This indicates that an attempt was made to compress the data, but no disk space was saved, so the file was not compressed. For most applications, this can be treated as a success condition.
     * @param {Pointer<Void>} FileHandle A handle to a file opened with <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or a similar API.
     * @param {Integer} Provider Indicates which provider is backing this file. Currently defined providers are: 
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>Indicates that the data for the file should be obtained from a WIM file.  On access, data is transparently extracted from the WIM file and provided to applications.  If the file contents are modified, data is transparently decompressed and the file is restored to the same physical form it had if this API were not used.</td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>Indicates that the data for the file should be compressed and stored with the file itself. On access, data is transparently decompressed and provided to applications. If the file contents are modified, data is transparently decompressed and the file is restored to the same physical form it had if this API were not used. This provider requires Windows 10.</td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ExternalFileInfo Provides data specific to the specified provider. Data structures for each defined provider are: 
     * 	  
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wim_external_file_info">WIM_EXTERNAL_FILE_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wof_file_compression_info_v1">WOF_FILE_COMPRESSION_INFO</a>
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Length Specifies the length of provider specific data, in bytes. This should correspond to the structures defined above: 
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>sizeof(WIM_EXTERNAL_FILE_INFO)</td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>sizeof(WOF_FILE_COMPRESSION_INFO)</td>
     * </tr>
     * </table>
     * @returns {HRESULT} This function returns an HRESULT indicating success or the reason for failure.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofsetfiledatalocation
     */
    static WofSetFileDataLocation(FileHandle, Provider, ExternalFileInfo, Length) {
        result := DllCall("WOFUTIL.dll\WofSetFileDataLocation", "ptr", FileHandle, "uint", Provider, "ptr", ExternalFileInfo, "uint", Length, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Used to determine if a file is being backed by a physical file or is backed by a system data provider, and optionally indicates which provider or additional data about the file.
     * @param {Pointer<Char>} FilePath Specifies the path to the file for which the backing state is desired.
     * @param {Pointer<Int32>} IsExternalFile Optionally points to a BOOL value. On successful return, this value will be TRUE if the object is externally backed, FALSE if it is a physical file.
     * @param {Pointer<UInt32>} Provider Optionally points to a ULONG value. On successful return, this value will be set to the provider that externally backs this object. Currently defined providers are: 
     * 	  		
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>Indicates that the data for the file resides in a separate WIM file.  On access, data is transparently extracted, decompressed and provided to applications.  If the file contents are modified, data is transparently decompressed and the file is restored to a regular file. </td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>Indicates that the data for the file should be compressed and stored with the file itself. On access, data is transparently decompressed and provided to applications. If the file contents are modified, data is transparently decompressed and the file is restored to a regular file. This provider requires Windows 10.</td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} ExternalFileInfo Optionally points to a caller allocated buffer. On successful return, this buffer will contain additional information about the state of the file. If this value is provided, <b>BufferLength</b> must also be specified. Data structures for each defined provider are:
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wim_external_file_info">WIM_EXTERNAL_FILE_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wof_file_compression_info_v1">WOF_FILE_COMPRESSION_INFO</a>
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} BufferLength Optionally points to a value that contains the length of the buffer specified in <b>ExternalFileInfo</b>. On return, this value will be set to the size of the buffer consumed, or the size of the buffer required. If the buffer is of insufficient length, this function will succeed indicating the required size and will not populate the buffer in <b>ExternalFileInfo</b>. This length should correspond to one of the structures defined above: 
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM</td>
     * <td>sizeof(WIM_EXTERNAL_FILE_INFO)</td>
     * </tr>
     * <tr>
     * <td>WOF_PROVIDER_FILE</td>
     * <td>sizeof(WOF_FILE_COMPRESSION_INFO)</td>
     * </tr>
     * </table>
     * @returns {HRESULT} This function returns an HRESULT indicating success or the reason for failure. If the buffer specified in <i>ExternalFileInfo</i> is not of the correct size, the function will return S_OK and indicate the required buffer size in <i>BufferLength</i>.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofisexternalfile
     */
    static WofIsExternalFile(FilePath, IsExternalFile, Provider, ExternalFileInfo, BufferLength) {
        FilePath := FilePath is String? StrPtr(FilePath) : FilePath

        result := DllCall("WOFUTIL.dll\WofIsExternalFile", "ptr", FilePath, "int*", IsExternalFile, "uint*", Provider, "ptr", ExternalFileInfo, "uint*", BufferLength, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enumerates all the data sources from a specified provider for a specified volume.
     * @param {Pointer<Char>} VolumeName The volume name hosting the files for which the backing data sources are requested.
     * @param {Integer} Provider Indicates which provider’s data sources are being requested.  Supported providers for this operation are: 
     * 	  	
     * 
     * <table>
     * <tr>
     * <td>WOF_PROVIDER_WIM </td>
     * <td>Indicates that the function should return the WIM files which are providing data for placeholder files on the specified volume.</td>
     * </tr>
     * </table>
     * @param {Pointer<WofEnumEntryProc>} EnumProc The callback function for each data source. The enumeration will stop          if <i>EnumProc</i> returns <b>FALSE</b>.
     * @param {Pointer<Void>} UserData User defined data passed to <i>EnumProc</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofenumentries
     */
    static WofEnumEntries(VolumeName, Provider, EnumProc, UserData) {
        VolumeName := VolumeName is String? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofEnumEntries", "ptr", VolumeName, "uint", Provider, "ptr", EnumProc, "ptr", UserData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Adds a single WIM data source to a volume such that files can be created on the volume which are stored within the WIM.
     * @param {Pointer<Char>} VolumeName The path to the volume upon which files residing in the WIM should be created.
     * @param {Pointer<Char>} WimPath The path to the WIM file which should be used to provide data to files.
     * @param {Integer} WimType The type of WIM. Can be <b>WIM_BOOT_OS_WIM</b> or <b>WIM_BOOT_NOT_OS_WIM</b>.
     * @param {Integer} WimIndex Index of the image in the WIM which is applied.
     * @param {Pointer<Int64>} DataSourceId On successful return, contains the data source used to identify the entry.  This data source can be used to create new files with <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/nf-wofapi-wofsetfiledatalocation">WofSetFileDataLocation</a>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofwimaddentry
     */
    static WofWimAddEntry(VolumeName, WimPath, WimType, WimIndex, DataSourceId) {
        VolumeName := VolumeName is String? StrPtr(VolumeName) : VolumeName
        WimPath := WimPath is String? StrPtr(WimPath) : WimPath

        result := DllCall("WOFUTIL.dll\WofWimAddEntry", "ptr", VolumeName, "ptr", WimPath, "uint", WimType, "uint", WimIndex, "int64*", DataSourceId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enumerates all of the files which are being backed by a specified WIM data source on a specified volume.
     * @param {Pointer<Char>} VolumeName The path to the volume which hosts WIM-backed files.
     * @param {Integer} DataSourceId Identifier used to identify the WIM entry.
     * @param {Pointer<WofEnumFilesProc>} EnumProc The callback function for file provided by the WIM entry.
     * @param {Pointer<Void>} UserData Optional user defined data passed to <i>EnumProc</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofwimenumfiles
     */
    static WofWimEnumFiles(VolumeName, DataSourceId, EnumProc, UserData) {
        VolumeName := VolumeName is String? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofWimEnumFiles", "ptr", VolumeName, "int64", DataSourceId, "ptr", EnumProc, "ptr", UserData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Temporarily removes a WIM data source from backing files on a volume until the volume is remounted or the data source is updated with WofWimUpdateEntry.
     * @remarks
     * If the volume currently has files whose data is derived from the WIM file, the data for those files will become temporarily inaccessible. This should not be performed on a WIM from which the system is currently operating.
     * @param {Pointer<Char>} VolumeName The volume name which contained files whose data was provided by the WIM.
     * @param {Integer} DataSourceId Identifies the WIM entry.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofwimsuspendentry
     */
    static WofWimSuspendEntry(VolumeName, DataSourceId) {
        VolumeName := VolumeName is String? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofWimSuspendEntry", "ptr", VolumeName, "int64", DataSourceId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Removes a single WIM data source from backing files on a volume.
     * @remarks
     * If the volume currently has files whose data is derived from the WIM file, the data for those files will become permanently inaccessible. It is good practice to remove any files referring to the WIM file prior to removing the data source from a volume.  Once all data sources for a WIM file have been removed, the WIM file itself can be renamed or deleted.
     * @param {Pointer<Char>} VolumeName The volume name which contained files whose data was provided by the WIM.
     * @param {Integer} DataSourceId Identifies the WIM entry.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofwimremoveentry
     */
    static WofWimRemoveEntry(VolumeName, DataSourceId) {
        VolumeName := VolumeName is String? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofWimRemoveEntry", "ptr", VolumeName, "int64", DataSourceId, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Updates a WIM entry to point to a different WIM file location.
     * @param {Pointer<Char>} VolumeName The volume name which contains files whose data is provided by the WIM.
     * @param {Integer} DataSourceId Identifies the WIM entry.
     * @param {Pointer<Char>} NewWimPath The new location of the WIM file.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-wofwimupdateentry
     */
    static WofWimUpdateEntry(VolumeName, DataSourceId, NewWimPath) {
        VolumeName := VolumeName is String? StrPtr(VolumeName) : VolumeName
        NewWimPath := NewWimPath is String? StrPtr(NewWimPath) : NewWimPath

        result := DllCall("WOFUTIL.dll\WofWimUpdateEntry", "ptr", VolumeName, "int64", DataSourceId, "ptr", NewWimPath, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enumerates all of the files which are compressed with a specified compression algorithm on a specified volume.
     * @param {Pointer<Char>} VolumeName A full path to the volume containing the files to enumerate.
     * @param {Integer} Algorithm The compression algorithm to enumerate.  For a list of valid compression algorithms, see <a href="https://docs.microsoft.com/windows/desktop/api/wofapi/ns-wofapi-wof_file_compression_info_v1">WOF_FILE_COMPRESSION_INFO_V1</a>.  If this value is MAX_ULONG, files compressed with any supported compression algorithm will be returned.
     * @param {Pointer<WofEnumFilesProc>} EnumProc The callback function for each data source. The enumeration will stop if <i>EnumProc</i> returns FALSE.
     * @param {Pointer<Void>} UserData User defined data passed to <i>EnumProc</i>.
     * @returns {HRESULT} If this function succeeds, it returns <b>S_OK</b>. Otherwise, it returns an <b>HRESULT</b> error code.
     * @see https://learn.microsoft.com/windows/win32/api/wofapi/nf-wofapi-woffileenumfiles
     */
    static WofFileEnumFiles(VolumeName, Algorithm, EnumProc, UserData) {
        VolumeName := VolumeName is String? StrPtr(VolumeName) : VolumeName

        result := DllCall("WOFUTIL.dll\WofFileEnumFiles", "ptr", VolumeName, "uint", Algorithm, "ptr", EnumProc, "ptr", UserData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Creates a context to be used to read replication records.
     * @param {Pointer<Char>} LogPath The path that identifies the Resource Manager's .blf file.
     * @param {Integer} BeginningLsn The first LSN in the range to be read.
     * @param {Integer} EndingLsn The last LSN in the range to be read.
     * @param {Pointer<TXF_ID>} TxfFileId The TxF identifier to search for in the LSN range. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/txfw32/ns-txfw32-txf_id">TXF_ID</a>.
     * @param {Pointer<Void>} TxfLogContext A pointer to the context created.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/txfw32/nf-txfw32-txflogcreatefilereadcontext
     * @since windows6.0.6000
     */
    static TxfLogCreateFileReadContext(LogPath, BeginningLsn, EndingLsn, TxfFileId, TxfLogContext) {
        LogPath := LogPath is String? StrPtr(LogPath) : LogPath

        A_LastError := 0

        result := DllCall("txfw32.dll\TxfLogCreateFileReadContext", "ptr", LogPath, "uint", BeginningLsn, "uint", EndingLsn, "ptr", TxfFileId, "ptr", TxfLogContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a context that is required to read any replication records.
     * @param {Pointer<Char>} LogPath Location of the RM's CLFS BLF.
     * @param {Integer} BeginningLsn Start of LSN range to search. (inclusive)
     * @param {Integer} EndingLsn End of LSN range to search. (inclusive)
     * @param {Pointer<Int64>} BeginningVirtualClock Start of the virtual clock.
     * @param {Pointer<Int64>} EndingVirtualClock End of the virtual clock.
     * @param {Integer} RecordTypeMask A mask value indicating the type of records.
     * @param {Pointer<Void>} TxfLogContext The returned context object.
     * @returns {Integer} Returns S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/txfw32/nf-txfw32-txflogcreaterangereadcontext
     */
    static TxfLogCreateRangeReadContext(LogPath, BeginningLsn, EndingLsn, BeginningVirtualClock, EndingVirtualClock, RecordTypeMask, TxfLogContext) {
        LogPath := LogPath is String? StrPtr(LogPath) : LogPath

        result := DllCall("txfw32.dll\TxfLogCreateRangeReadContext", "ptr", LogPath, "uint", BeginningLsn, "uint", EndingLsn, "int64*", BeginningVirtualClock, "int64*", EndingVirtualClock, "uint", RecordTypeMask, "ptr", TxfLogContext, "int")
        return result
    }

    /**
     * Closes a read context created by the TxfLogCreateFileReadContext function.
     * @param {Pointer<Void>} TxfLogContext A pointer to the context.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/txfw32/nf-txfw32-txflogdestroyreadcontext
     * @since windows6.0.6000
     */
    static TxfLogDestroyReadContext(TxfLogContext) {
        A_LastError := 0

        result := DllCall("txfw32.dll\TxfLogDestroyReadContext", "ptr", TxfLogContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reads the redo records from the log.
     * @param {Pointer<Void>} TxfLogContext A pointer to the context.
     * @param {Integer} BufferLength The size of the output buffer, in bytes.
     * @param {Pointer} Buffer A pointer to the buffer that receives the records. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/txfw32/ns-txfw32-txf_log_record_base">TXF_LOG_RECORD_BASE</a>.
     * @param {Pointer<UInt32>} BytesUsed The number of bytes written to the output buffer.
     * @param {Pointer<UInt32>} RecordCount The number of records written to the output buffer.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible error codes include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replication context is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Some of the available records were copied into the buffer. Call this function again to retrieve the rest 
     * 	       of the records.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer is not large enough to contain even one record. If <i>BytesUsed</i> is 
     * 	       nonzero, then there was enough space to copy the 
     * 	       <a href="https://docs.microsoft.com/windows/desktop/api/txfw32/ns-txfw32-txf_log_record_base">TXF_LOG_RECORD_BASE</a> structure, which indicates the 
     * 	       required buffer size to read the next complete record.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_CORRUPT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The format of the log file being processed is unrecognized.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/txfw32/nf-txfw32-txflogreadrecords
     * @since windows6.0.6000
     */
    static TxfLogReadRecords(TxfLogContext, BufferLength, Buffer, BytesUsed, RecordCount) {
        A_LastError := 0

        result := DllCall("txfw32.dll\TxfLogReadRecords", "ptr", TxfLogContext, "uint", BufferLength, "ptr", Buffer, "uint*", BytesUsed, "uint*", RecordCount, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} FileHandle 
     * @param {Pointer<TXF_ID>} TxfFileId 
     * @param {Pointer<UInt64>} LastLsn 
     * @param {Pointer<UInt32>} TransactionState 
     * @param {Pointer<Guid>} LockingTransaction 
     * @returns {Integer} 
     */
    static TxfReadMetadataInfo(FileHandle, TxfFileId, LastLsn, TransactionState, LockingTransaction) {
        result := DllCall("txfw32.dll\TxfReadMetadataInfo", "ptr", FileHandle, "ptr", TxfFileId, "uint*", LastLsn, "uint*", TransactionState, "ptr", LockingTransaction, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} RecordBuffer 
     * @param {Integer} RecordBufferLengthInBytes 
     * @param {Pointer} NameBuffer 
     * @param {Pointer<UInt32>} NameBufferLengthInBytes 
     * @param {Pointer<TXF_ID>} TxfId 
     * @returns {Integer} 
     */
    static TxfLogRecordGetFileName(RecordBuffer, RecordBufferLengthInBytes, NameBuffer, NameBufferLengthInBytes, TxfId) {
        result := DllCall("txfw32.dll\TxfLogRecordGetFileName", "ptr", RecordBuffer, "uint", RecordBufferLengthInBytes, "ptr", NameBuffer, "uint*", NameBufferLengthInBytes, "ptr", TxfId, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} RecordBuffer 
     * @param {Integer} RecordBufferLengthInBytes 
     * @param {Pointer<UInt32>} GenericType 
     * @param {Pointer<Int64>} VirtualClock 
     * @returns {Integer} 
     */
    static TxfLogRecordGetGenericType(RecordBuffer, RecordBufferLengthInBytes, GenericType, VirtualClock) {
        result := DllCall("txfw32.dll\TxfLogRecordGetGenericType", "ptr", RecordBuffer, "uint", RecordBufferLengthInBytes, "uint*", GenericType, "int64*", VirtualClock, "int")
        return result
    }

    /**
     * Sets the MiniVersion that a subsequent create should open.
     * @param {Integer} MiniVersion A USHORT identifying which version should be opened by create.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/txfw32/nf-txfw32-txfsetthreadminiversionforcreate
     */
    static TxfSetThreadMiniVersionForCreate(MiniVersion) {
        DllCall("txfw32.dll\TxfSetThreadMiniVersionForCreate", "ushort", MiniVersion)
    }

    /**
     * Returns the MiniVersion a subsequent create is set to open.
     * @param {Pointer<UInt16>} MiniVersion Pointer to a USHORT which will receive the result.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/txfw32/nf-txfw32-txfgetthreadminiversionforcreate
     */
    static TxfGetThreadMiniVersionForCreate(MiniVersion) {
        DllCall("txfw32.dll\TxfGetThreadMiniVersionForCreate", "ushort*", MiniVersion)
    }

    /**
     * Creates a new transaction object.
     * @remarks
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close the transaction 
     *     handle. If the last transaction handle is closed before a client  calls the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-committransaction">CommitTransaction</a> function with the transaction 
     *     handle, then  KTM rolls back the transaction.
     * 
     * If the transaction might need to be promotable to a distributed transaction, then you must grant the Distributed Transaction Coordinator (DTC)  access rights to enlist in the transaction.  To do this, the  <i>lpTransactionAttributes</i> parameter needs to contain an access control entry with the DTC’s SID (S-1-5-80-2818357584-3387065753-4000393942-342927828-138088443) and the TRANSACTION_ENLIST right. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)">Distributed Transaction Coordinator</a> and <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control-components">Access Control Components</a>.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpTransactionAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *       structure that determines whether the returned handle can be inherited by child processes. If this parameter is 
     *       <b>NULL</b>, the handle cannot be inherited.
     *       
     * 
     * The <b>lpSecurityDescriptor</b> member of the structure specifies a 
     *        <a href="https://docs.microsoft.com/windows/desktop/winstation/desktop-security-and-access-rights">security descriptor</a> for the new 
     *        event. If <i>lpTransactionAttributes</i> is <b>NULL</b>, the object gets 
     *        a default security descriptor. The access control lists (ACL) in the default security descriptor for a 
     *        transaction come from the primary or impersonation token of the creator.
     * @param {Pointer<Guid>} UOW Reserved. Must be zero (0).
     * @param {Integer} CreateOptions Any optional transaction instructions.  
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TRANSACTION_DO_NOT_PROMOTE"></a><a id="transaction_do_not_promote"></a><dl>
     * <dt><b>TRANSACTION_DO_NOT_PROMOTE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The transaction cannot be distributed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} IsolationLevel Reserved; specify zero (0).
     * @param {Integer} IsolationFlags Reserved; specify zero (0).
     * @param {Integer} Timeout The time-out interval, in milliseconds. If a nonzero value is specified, the transaction will be aborted when the interval elapses if it has not already reached the prepared state.
     * 
     * Specify zero (0) or INFINITE to provide an infinite time-out.
     * @param {Pointer<Char>} Description A user-readable description of the transaction.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the transaction.
     *       
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-createtransaction
     * @since windows6.0.6000
     */
    static CreateTransaction(lpTransactionAttributes, UOW, CreateOptions, IsolationLevel, IsolationFlags, Timeout, Description) {
        Description := Description is String? StrPtr(Description) : Description

        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateTransaction", "ptr", lpTransactionAttributes, "ptr", UOW, "uint", CreateOptions, "uint", IsolationLevel, "uint", IsolationFlags, "uint", Timeout, "ptr", Description)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens an existing transaction.
     * @remarks
     * Clients close the transaction handle by using the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function. If the last transaction handle is closed without anyone calling the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-committransaction">CommitTransaction</a> function on the transaction, then the KTM implicitly rolls back the transaction.
     * @param {Integer} dwDesiredAccess The access to the transaction object. You must have read and write access to work with a transaction. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/transaction-access-masks">Transaction Access Masks</a> for a list of valid values.
     * @param {Pointer<Guid>} TransactionId The GUID that identifies the transaction to be opened. This is commonly referred to as  a unit of work for the transaction.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the transaction.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-opentransaction
     * @since windows6.0.6000
     */
    static OpenTransaction(dwDesiredAccess, TransactionId) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenTransaction", "uint", dwDesiredAccess, "ptr", TransactionId)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified transaction be committed. (CommitTransaction)
     * @remarks
     * You can commit any transaction handle that has been opened or created using the TRANSACTION_COMMIT permission; any application can commit a transaction, not just the creator.
     * 
     * This function can only be called if the transaction is still active, not prepared, pre-prepared, or rolled back.
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction to be committed. 
     * 
     * This handle must have been opened with the TRANSACTION_COMMIT access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Ktm/ktm-security-and-access-rights">KTM Security and Access Rights</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-committransaction
     * @since windows6.0.6000
     */
    static CommitTransaction(TransactionHandle) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitTransaction", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified transaction be committed. (CommitTransactionAsync)
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction to be committed. 
     * 
     * This handle must have been opened with the TRANSACTION_COMMIT access right. For more information, see <a href="https://docs.microsoft.com/windows/desktop/Ktm/ktm-security-and-access-rights">KTM Security and Access Rights</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero. Success means that the function completed synchronously, and the calling application does not need to wait for pending results.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-committransactionasync
     * @since windows6.0.6000
     */
    static CommitTransactionAsync(TransactionHandle) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitTransactionAsync", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified transaction be rolled back.
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-rollbacktransaction
     * @since windows6.0.6000
     */
    static RollbackTransaction(TransactionHandle) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackTransaction", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified transaction be rolled back. This function returns asynchronously.
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero, and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns ERROR_IO_PENDING.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function. The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-rollbacktransactionasync
     * @since windows6.0.6000
     */
    static RollbackTransactionAsync(TransactionHandle) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackTransactionAsync", "ptr", TransactionHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains the identifier (ID) for the specified transaction.
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction.
     * @param {Pointer<Guid>} TransactionId A pointer to a variable that receives the ID of the transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-gettransactionid
     * @since windows6.0.6000
     */
    static GetTransactionId(TransactionHandle, TransactionId) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\GetTransactionId", "ptr", TransactionHandle, "ptr", TransactionId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns the requested information about the specified transaction.
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction. The handle must have  the TRANSACTION_QUERY_INFORMATION permission to retrieve the information.
     * @param {Pointer<UInt32>} Outcome A pointer to a buffer that receives the current outcome of the transaction. If the call to the <b>GetTransactionInformation</b> function is successful, this value will be one of the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ne-winnt-transaction_outcome">TRANSACTION_OUTCOME</a> enumeration values.
     * @param {Pointer<UInt32>} IsolationLevel Reserved.
     * @param {Pointer<UInt32>} IsolationFlags Reserved.
     * @param {Pointer<UInt32>} Timeout A pointer to a variable that receives the timeout value, in milliseconds, for this transaction.
     * @param {Integer} BufferLength The size of the <i>Description</i> parameter, in bytes. The buffer length value cannot be longer than the value of MAX_TRANSACTION_DESCRIPTION_LENGTH.
     * @param {Pointer<Char>} Description A pointer to a buffer that receives the user-defined description of the transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-gettransactioninformation
     * @since windows6.0.6000
     */
    static GetTransactionInformation(TransactionHandle, Outcome, IsolationLevel, IsolationFlags, Timeout, BufferLength, Description) {
        Description := Description is String? StrPtr(Description) : Description

        A_LastError := 0

        result := DllCall("ktmw32.dll\GetTransactionInformation", "ptr", TransactionHandle, "uint*", Outcome, "uint*", IsolationLevel, "uint*", IsolationFlags, "uint*", Timeout, "uint", BufferLength, "ptr", Description, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the transaction information for the specified transaction.
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction. The handle must have the TRANSACTION_SET_INFORMATION permission to set the transaction information.
     * @param {Integer} IsolationLevel Reserved; specify zero.
     * @param {Integer} IsolationFlags Reserved.
     * @param {Integer} Timeout The timeout value, in milliseconds, for this transaction.
     * @param {Pointer<Char>} Description The user-defined description of this transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-settransactioninformation
     * @since windows6.0.6000
     */
    static SetTransactionInformation(TransactionHandle, IsolationLevel, IsolationFlags, Timeout, Description) {
        Description := Description is String? StrPtr(Description) : Description

        A_LastError := 0

        result := DllCall("ktmw32.dll\SetTransactionInformation", "ptr", TransactionHandle, "uint", IsolationLevel, "uint", IsolationFlags, "uint", Timeout, "ptr", Description, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new transaction manager (TM) object and returns a handle with the specified access.
     * @remarks
     * Immediately after calling this function, you must call <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-recovertransactionmanager">RecoverTransactionManager</a>.
     * 
     * If your transaction manager is volatile, all your your resource managers must also be volatile.
     * 
     * You must call <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-recovertransactionmanager">RecoverTransactionManager</a> after creating a TM in order for the TM to function correctly.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpTransactionAttributes The transaction <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> (ACLs) for the TM object.
     * @param {Pointer<Char>} LogFileName The log file stream name.  If the stream does not exist in the log, it is created. To create a volatile TM, this parameter must be <b>NULL</b> and <i>CreateOptions</i> must specify TRANSACTION_MANAGER_VOLATILE, this transaction manager is considered volatile.
     * @param {Integer} CreateOptions Any optional attributes for the new TM.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TRANSACTION_MANAGER_VOLATILE"></a><a id="transaction_manager_volatile"></a><dl>
     * <dt><b>TRANSACTION_MANAGER_VOLATILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the TM is volatile, and does not perform recovery.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} CommitStrength Reserved; specify zero.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the transaction manager.  
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-createtransactionmanager
     * @since windows6.0.6000
     */
    static CreateTransactionManager(lpTransactionAttributes, LogFileName, CreateOptions, CommitStrength) {
        LogFileName := LogFileName is String? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateTransactionManager", "ptr", lpTransactionAttributes, "ptr", LogFileName, "uint", CreateOptions, "uint", CommitStrength)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens an existing transaction manager. (OpenTransactionManager)
     * @remarks
     * Immediately after calling this function, you must call <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-recovertransactionmanager">RecoverTransactionManager</a>.
     * 
     * The <i>LogFileName</i> must be specified using the NT file format. For example: <i>\??\&lt;drive&gt;:\&lt;path&gt;</i>. Do not use the .BLF extension.
     * @param {Pointer<Char>} LogFileName The name of the log stream.  This stream must exist within a CLFS log file.
     * @param {Integer} DesiredAccess The access requested. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/transaction-manager-access-masks">Transaction Manager Access Masks</a> for a list of valid values.
     * @param {Integer} OpenOptions Reserved; specify zero.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the transaction manager.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-opentransactionmanager
     * @since windows6.0.6000
     */
    static OpenTransactionManager(LogFileName, DesiredAccess, OpenOptions) {
        LogFileName := LogFileName is String? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenTransactionManager", "ptr", LogFileName, "uint", DesiredAccess, "uint", OpenOptions)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens an existing transaction manager. (OpenTransactionManagerById)
     * @remarks
     * Immediately after calling this function, you must call <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-recovertransactionmanager">RecoverTransactionManager</a>.
     * @param {Pointer<Guid>} TransactionManagerId The identifier of the transaction to open.
     * @param {Integer} DesiredAccess The access requested. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/transaction-manager-access-masks">Transaction Manager Access Masks</a> for a list of valid values.
     * @param {Integer} OpenOptions Reserved; specify zero.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the transaction manager.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-opentransactionmanagerbyid
     * @since windows6.0.6000
     */
    static OpenTransactionManagerById(TransactionManagerId, DesiredAccess, OpenOptions) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenTransactionManagerById", "ptr", TransactionManagerId, "uint", DesiredAccess, "uint", OpenOptions)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Renames a transaction manager (TM) object. This function can only be used on named TM handles.
     * @param {Pointer<Char>} LogFileName The name of the log stream.  This stream must exist within a CLFS log file.
     * @param {Pointer<Guid>} ExistingTransactionManagerGuid A value that specifies the current name of the TM.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-renametransactionmanager
     * @since windows6.0.6000
     */
    static RenameTransactionManager(LogFileName, ExistingTransactionManagerGuid) {
        LogFileName := LogFileName is String? StrPtr(LogFileName) : LogFileName

        A_LastError := 0

        result := DllCall("ktmw32.dll\RenameTransactionManager", "ptr", LogFileName, "ptr", ExistingTransactionManagerGuid, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Recovers information only to the specified virtual clock value.
     * @param {Pointer<Void>} TransactionManagerHandle A handle to the transaction manager.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-rollforwardtransactionmanager
     * @since windows6.0.6000
     */
    static RollforwardTransactionManager(TransactionManagerHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RollforwardTransactionManager", "ptr", TransactionManagerHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Recovers a transaction manager's state from its log file.
     * @remarks
     * This function must be called after you call <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransactionmanager">CreateTransactionManager</a>.
     * @param {Pointer<Void>} TransactionManagerHandle A handle to the transaction manager.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-recovertransactionmanager
     * @since windows6.0.6000
     */
    static RecoverTransactionManager(TransactionManagerHandle) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RecoverTransactionManager", "ptr", TransactionManagerHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains a virtual clock value from a transaction manager.
     * @param {Pointer<Void>} TransactionManagerHandle A handle to the transaction manager to obtain a virtual clock value for.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value for the transaction manager. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-getcurrentclocktransactionmanager
     * @since windows6.0.6000
     */
    static GetCurrentClockTransactionManager(TransactionManagerHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\GetCurrentClockTransactionManager", "ptr", TransactionManagerHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains an identifier for the specified transaction manager.
     * @param {Pointer<Void>} TransactionManagerHandle A handle to the transaction manager.
     * @param {Pointer<Guid>} TransactionManagerId A pointer to a variable that receives the identifier for the transaction manager.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-gettransactionmanagerid
     * @since windows6.0.6000
     */
    static GetTransactionManagerId(TransactionManagerHandle, TransactionManagerId) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\GetTransactionManagerId", "ptr", TransactionManagerHandle, "ptr", TransactionManagerId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new resource manager (RM) object, and associates the RM with a transaction manager (TM).
     * @remarks
     * Immediately after calling this function, you must call <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-recoverresourcemanager">RecoverResourceManager</a>.
     * 
     * An RM is an endpoint for TM notifications regarding transactions that the RM has enlisted in.
     * 
     * RMs are typically persistent, meaning that after a system failure, they must be reopened  to perform certain operations. Volatile, or transient, RMs can be created by calling the <b>CreateResourceManager</b> function and by specifying RESOURCE_MANAGER_VOLATILE.  Volatile RMs do not perform recovery operations, but do require notifications about a transaction.
     * 
     * You can create a volatile RM on a durable TM, but you cannot create a durable RM on a volatile TM.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpResourceManagerAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> structure that contains the security attributes for the resource manager.  Specify <b>NULL</b> to obtain the default attributes.
     * @param {Pointer<Guid>} ResourceManagerId A pointer the resource manager GUID. This parameter is required and must not be <b>NULL</b>.
     * @param {Integer} CreateOptions Any optional attributes for the new RM.  
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RESOURCE_MANAGER_VOLATILE"></a><a id="resource_manager_volatile"></a><dl>
     * <dt><b>RESOURCE_MANAGER_VOLATILE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the RM is volatile, and does not perform recovery.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} TmHandle A handle to the TM that will manage the transactions for this RM.
     * @param {Pointer<Char>} Description A description for this RM.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the RM.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-createresourcemanager
     * @since windows6.0.6000
     */
    static CreateResourceManager(lpResourceManagerAttributes, ResourceManagerId, CreateOptions, TmHandle, Description) {
        Description := Description is String? StrPtr(Description) : Description

        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateResourceManager", "ptr", lpResourceManagerAttributes, "ptr", ResourceManagerId, "uint", CreateOptions, "ptr", TmHandle, "ptr", Description)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens an existing resource manager (RM).
     * @remarks
     * Immediately after calling this function, you must call <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-recoverresourcemanager">RecoverResourceManager</a>.
     * @param {Integer} dwDesiredAccess The access requested for the RM. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/resource-manager-access-masks">Resource Manager Access Masks</a> for a list of valid values.
     * @param {Pointer<Void>} TmHandle A handle to the transaction manager.
     * @param {Pointer<Guid>} ResourceManagerId The identifier  for this resource manager.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the resource manager.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-openresourcemanager
     * @since windows6.0.6000
     */
    static OpenResourceManager(dwDesiredAccess, TmHandle, ResourceManagerId) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenResourceManager", "uint", dwDesiredAccess, "ptr", TmHandle, "ptr", ResourceManagerId)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Recovers a resource manager's state from its log file.
     * @param {Pointer<Void>} ResourceManagerHandle A handle to the resource manager.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-recoverresourcemanager
     * @since windows6.0.6000
     */
    static RecoverResourceManager(ResourceManagerHandle) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RecoverResourceManager", "ptr", ResourceManagerHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests and receives a notification for a resource manager (RM). This function is used by the RM register to receive notifications when a transaction changes state.
     * @remarks
     * All resource managers must register to receive <b>TRANSACTION_NOTIFY_PREPREPARE</b>, 
     *      <b>TRANSACTION_NOTIFY_PREPARE</b>, and <b>TRANSACTION_NOTIFY_COMMIT</b> 
     *      notifications, even if they subsequently call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-readonlyenlistment">ReadOnlyEnlistment</a> to mark an enlistment as 
     *      read-only. Resource managers can support <b>TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT</b>, but 
     *      they must also support the multi-phase pre-prepare, prepare, and commit notifications. For the list of all 
     *      notifications that resource managers can receive, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a>.
     * @param {Pointer<Void>} ResourceManagerHandle A handle  to the resource manager.
     * @param {Pointer<TRANSACTION_NOTIFICATION>} TransactionNotification A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a> 
     *       structure that receives the first available notification.
     * @param {Integer} NotificationLength The size of the <i>TransactionNotification</i> buffer, in bytes.
     * @param {Integer} dwMilliseconds The time, in milliseconds, for which the calling application is blocking while waiting for the notification 
     *       to become available. If no notifications are available when the timeout expires, 
     *       <b>ERROR_TIMEOUT</b> is returned.
     * @param {Pointer<UInt32>} ReturnLength A pointer to a variable that receives the actual size of the notification received by the 
     *       <i>TransactionNotification</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-getnotificationresourcemanager
     * @since windows6.0.6000
     */
    static GetNotificationResourceManager(ResourceManagerHandle, TransactionNotification, NotificationLength, dwMilliseconds, ReturnLength) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\GetNotificationResourceManager", "ptr", ResourceManagerHandle, "ptr", TransactionNotification, "uint", NotificationLength, "uint", dwMilliseconds, "uint*", ReturnLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests and receives asynchronous notification for a resource manager (RM). This function is used by the RM register to receive notifications when a transaction changes state.
     * @remarks
     * All resource managers must register to receive <b>TRANSACTION_NOTIFY_PREPREPARE</b>, 
     *      <b>TRANSACTION_NOTIFY_PREPARE</b>, and <b>TRANSACTION_NOTIFY_COMMIT</b> 
     *      notifications, even if they subsequently call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-readonlyenlistment">ReadOnlyEnlistment</a> to mark an enlistment as 
     *      read-only. Resource managers can support <b>TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT</b>, but 
     *      they must also support the multi-phase pre-prepare, prepare, and commit notifications. For the list of all 
     *      notifications that resource managers can receive, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a>.
     * 
     * Resource managers (RM) may want to call this function more than once to provide multiple buffers for KTM to 
     *     use when delivering notifications. The number of calls to this function depends on how much load your RM is 
     *     carrying.
     * 
     * This function must be called after the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-setresourcemanagercompletionport">SetResourceManagerCompletionPort</a> 
     *      function is called.
     * @param {Pointer<Void>} ResourceManagerHandle A handle  to the resource manager.
     * @param {Pointer<TRANSACTION_NOTIFICATION>} TransactionNotification A pointer to a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a> structure that 
     *       receives the first available notification.
     * @param {Integer} TransactionNotificationLength The size of the <i>TransactionNotification</i> buffer, in bytes.
     * @param {Pointer<UInt32>} ReturnLength A pointer to a variable that receives the actual size of the notification received by the 
     *       <i>TransactionNotification</i> parameter.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is 
     *       required for asynchronous operation.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-getnotificationresourcemanagerasync
     * @since windows6.0.6000
     */
    static GetNotificationResourceManagerAsync(ResourceManagerHandle, TransactionNotification, TransactionNotificationLength, ReturnLength, lpOverlapped) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\GetNotificationResourceManagerAsync", "ptr", ResourceManagerHandle, "ptr", TransactionNotification, "uint", TransactionNotificationLength, "uint*", ReturnLength, "ptr", lpOverlapped, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates the specified I/O completion port with the specified resource manager (RM). This port receives all notifications for the RM.
     * @remarks
     * This function must be used in conjunction with the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-getnotificationresourcemanagerasync">GetNotificationResourceManagerAsync</a> function, which provides the buffers that KTM uses to deliver notifications asynchronously. These functions provide a different way to receive notifications from KTM. You can use these two functions instead of the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-getnotificationresourcemanager">GetNotificationResourceManager</a> function.
     * 
     * This function must be called before calling <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-getnotificationresourcemanagerasync">GetNotificationResourceManagerAsync</a>.
     * @param {Pointer<Void>} ResourceManagerHandle A handle to the resource manager.
     * @param {Pointer<Void>} IoCompletionPortHandle A handle to the I/O completion port.
     * @param {Pointer} CompletionKey The user-defined identifier. Typically, it is used to associate the receive notification with a specific resource manager.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-setresourcemanagercompletionport
     * @since windows6.0.6000
     */
    static SetResourceManagerCompletionPort(ResourceManagerHandle, IoCompletionPortHandle, CompletionKey) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\SetResourceManagerCompletionPort", "ptr", ResourceManagerHandle, "ptr", IoCompletionPortHandle, "ptr", CompletionKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an enlistment, sets its initial state, and opens a handle to the enlistment with the specified access.
     * @remarks
     * <b>Windows Vista:  </b>Any attempt to enlist during the pre-prepare phase or later will fail.
     * 
     * If you do not specify within your notification mask that you accept a single-phase commit request, KTM always 
     *     performs a two-phase commit operation.
     * 
     * Keep the following notification rules in mind when enlisting in transactions:
     * 
     * <ul>
     * <li>The RM must always request rollback notification.</li>
     * <li>If the RM requests prepare notification, it must also request commit notification.</li>
     * <li>If the RM requests a single-phase commit operation, it must also specify prepare and commit 
     *       notifications.</li>
     * <li>The only time an RM is not required to request commit notifications is when it is requesting at least a 
     *       pair of prepare and rollback notifications.</li>
     * </ul>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpEnlistmentAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *       structure that contains the security attributes for the enlistment manager.  Specify 
     *       <b>NULL</b> to obtain the default attributes.
     * @param {Pointer<Void>} ResourceManagerHandle A handle to the resource manager (RM) to enlist.
     * @param {Pointer<Void>} TransactionHandle A handle to the transaction in which the RM is enlisting.
     * @param {Integer} NotificationMask The notifications this RM is requesting for the <i>TransactionHandle</i> parameter. For 
     *       a list of valid values, see <a href="https://docs.microsoft.com/windows/desktop/Ktm/notification-mask">NOTIFICATION_MASK</a>.
     * @param {Integer} CreateOptions Any optional enlistment instructions.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ENLISTMENT_SUPERIOR"></a><a id="enlistment_superior"></a><dl>
     * <dt><b>ENLISTMENT_SUPERIOR</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enlist as a superior transaction manager.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} EnlistmentKey A pointer to a user-defined structure used by the RM that is returned when a notification is sent in the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmtypes/ns-ktmtypes-transaction_notification">TRANSACTION_NOTIFICATION</a> structure. This is 
     *       typically used to associate a private structure  with this specific transaction.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the enlistment.
     *       
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-createenlistment
     * @since windows6.0.6000
     */
    static CreateEnlistment(lpEnlistmentAttributes, ResourceManagerHandle, TransactionHandle, NotificationMask, CreateOptions, EnlistmentKey) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\CreateEnlistment", "ptr", lpEnlistmentAttributes, "ptr", ResourceManagerHandle, "ptr", TransactionHandle, "uint", NotificationMask, "uint", CreateOptions, "ptr", EnlistmentKey)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens an existing enlistment object, and returns a handle to the enlistment.
     * @param {Integer} dwDesiredAccess The access requested for this enlistment. See <a href="https://docs.microsoft.com/windows/desktop/Ktm/enlistment-access-masks">Enlistment Access Masks</a> for a list of valid values.
     * @param {Pointer<Void>} ResourceManagerHandle A handle to the resource manager.
     * @param {Pointer<Guid>} EnlistmentId The enlistment identifier.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a handle to the enlistment.
     * 
     * If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the  possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-openenlistment
     * @since windows6.0.6000
     */
    static OpenEnlistment(dwDesiredAccess, ResourceManagerHandle, EnlistmentId) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\OpenEnlistment", "uint", dwDesiredAccess, "ptr", ResourceManagerHandle, "ptr", EnlistmentId)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Recovers an enlistment's state.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Void>} EnlistmentKey The key to the enlistment to be recovered.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-recoverenlistment
     * @since windows6.0.6000
     */
    static RecoverEnlistment(EnlistmentHandle, EnlistmentKey) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RecoverEnlistment", "ptr", EnlistmentHandle, "ptr", EnlistmentKey, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves an opaque structure of recovery data from KTM.
     * @remarks
     * This call cannot be used with volatile transaction managers.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Integer} BufferSize The size of the <i>Buffer</i> parameter, in bytes.
     * @param {Pointer<Void>} Buffer A pointer to a buffer that receives the enlistment recovery information.
     * @param {Pointer<UInt32>} BufferUsed A pointer to a variable that receives the actual number of bytes returned in the <i>Buffer</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-getenlistmentrecoveryinformation
     * @since windows6.0.6000
     */
    static GetEnlistmentRecoveryInformation(EnlistmentHandle, BufferSize, Buffer, BufferUsed) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\GetEnlistmentRecoveryInformation", "ptr", EnlistmentHandle, "uint", BufferSize, "ptr", Buffer, "uint*", BufferUsed, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Obtains the identifier (ID) for the specified enlistment.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Guid>} EnlistmentId A pointer to a variables that receives the ID of the enlistment.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-getenlistmentid
     * @since windows6.0.6000
     */
    static GetEnlistmentId(EnlistmentHandle, EnlistmentId) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\GetEnlistmentId", "ptr", EnlistmentHandle, "ptr", EnlistmentId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets an opaque, user-defined structure of recovery data from KTM.
     * @remarks
     * This call cannot be used with volatile transaction managers.
     * 
     * The information that is provided by the user may not be durably stored in the log at the completion of this operation, but it will be durably stored by the end of the next commit operation for this enlistment.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Integer} BufferSize The size of <i>Buffer</i>, in bytes.
     * @param {Pointer<Void>} Buffer The recovery information.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-setenlistmentrecoveryinformation
     * @since windows6.0.6000
     */
    static SetEnlistmentRecoveryInformation(EnlistmentHandle, BufferSize, Buffer) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\SetEnlistmentRecoveryInformation", "ptr", EnlistmentHandle, "uint", BufferSize, "ptr", Buffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Prepares the transaction associated with this enlistment handle. This function is used by communication resource managers (sometimes called superior transaction managers).
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment for which the prepare operation has completed.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-prepareenlistment
     * @since windows6.0.6000
     */
    static PrepareEnlistment(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\PrepareEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Pre-prepares the transaction associated with this enlistment handle. This function is used by communication resource managers (sometimes called superior transaction managers).
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment for which the prepare operation has completed.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this transaction.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     *       
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-preprepareenlistment
     * @since windows6.0.6000
     */
    static PrePrepareEnlistment(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\PrePrepareEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Commits the transaction associated with this enlistment handle. This function is used by communication resource managers (sometimes called superior transaction managers).
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment to commit.
     * @param {Pointer<Int64>} TmVirtualClock A pointer to the latest virtual clock value received for this enlistment. If you specify 
     *       <b>NULL</b>, the virtual clock value is not changed.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned by a 
     *       subordinate TM.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * 
     * The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-commitenlistment
     * @since windows6.0.6000
     */
    static CommitEnlistment(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Rolls back the specified transaction that is associated with an enlistment. This function cannot be called for read-only enlistments.
     * @remarks
     * This function is used by an RM to roll back a transaction in which it is enlisted. All work associated with the transaction is rolled back. 
     * 
     * Rollbacks are allowed by enlistments at any time before it issues a prepare complete notification.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this enlistment. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-rollbackenlistment
     * @since windows6.0.6000
     */
    static RollbackEnlistment(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Signals that this resource manager has completed its prepare work, so that other resource managers can now begin their prepare operations.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this prepare operation. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-prepreparecomplete
     * @since windows6.0.6000
     */
    static PrePrepareComplete(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\PrePrepareComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that the resource manager (RM) has completed all processing necessary to guarantee that a commit or abort operation will succeed for the specified transaction.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this prepare complete notification. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-preparecomplete
     * @since windows6.0.6000
     */
    static PrepareComplete(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\PrepareComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that the specified enlistment be converted to a read-only enlistment. A read-only enlistment cannot participate in the outcome of the transaction and is not durably recorded for recovery.
     * @remarks
     * If a resource manager no longer needs to participate in a transaction without rolling  back the transaction, it should call  <b>ReadOnlyEnlistment</b> prior to closing the enlistment handle.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this enlistment. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-readonlyenlistment
     * @since windows6.0.6000
     */
    static ReadOnlyEnlistment(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\ReadOnlyEnlistment", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that a resource manager (RM) has finished committing a transaction that was requested by the transaction manager (TM).
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment for which the commit operation is completed.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this transaction. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-commitcomplete
     * @since windows6.0.6000
     */
    static CommitComplete(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\CommitComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that the resource manager (RM) has successfully completed rolling back a transaction.
     * @remarks
     * If the RM was not able to successfully roll back a transaction, the RM should request a full rollback by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-rollbacktransaction">RollbackTransaction</a> function.
     * @param {Pointer<Void>} EnlistmentHandle A handle the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received for this transaction. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-rollbackcomplete
     * @since windows6.0.6000
     */
    static RollbackComplete(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\RollbackComplete", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates that the resource manager (RM) is refusing a single-phase request. When a transaction manager (TM) receives this call, it initiates a two-phase commit and sends a prepare request to all enlisted RMs.
     * @param {Pointer<Void>} EnlistmentHandle A handle to the enlistment.
     * @param {Pointer<Int64>} TmVirtualClock The latest virtual clock value received from the single-phase request notification. If you specify <b>NULL</b>, the virtual clock value is not changed. See <a href="https://docs.microsoft.com/windows/win32/api/winnt/ns-winnt-large_integer-r1">LARGE_INTEGER</a>.
     * 
     * To change the virtual clock value, this value must be greater than the current value returned in the COMMIT notification.
     * @returns {Integer} If the function succeeds, the return value is nonzero. 
     * 
     * 
     *   
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     *  The following list identifies the possible error codes:
     * @see https://learn.microsoft.com/windows/win32/api/ktmw32/nf-ktmw32-singlephasereject
     * @since windows6.0.6000
     */
    static SinglePhaseReject(EnlistmentHandle, TmVirtualClock) {
        A_LastError := 0

        result := DllCall("ktmw32.dll\SinglePhaseReject", "ptr", EnlistmentHandle, "int64*", TmVirtualClock, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Shares a server resource.
     * @remarks
     * This function applies only to Server Message Block (SMB) shares. For other types of shares, such as Distributed File System (DFS) or WebDAV shares, use <a href="https://docs.microsoft.com/windows/desktop/WNet/windows-networking-functions">Windows Networking (WNet) functions</a>, which support all types of shares.
     * 
     * Only members of the Administrators, System Operators, or Power Users local group can add file shares with a call to the 
     * <b>NetShareAdd</b> function. The Print Operator can add printer shares.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management share functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileshare">IADsFileShare</a>.
     * 
     * If 503 is specified for the <i>level</i> parameter, the remote server specified in the <b>shi503_servername</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_503">SHARE_INFO_503</a> structure must have been bound to a transport protocol using the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/nf-lmserver-netservertransportaddex">NetServerTransportAddEx</a> function. In the call to  <b>NetServerTransportAddEx</b>, either 2 or 3 must have been specified for the <i>level</i> parameter, and the <b>SVTI2_SCOPED_NAME</b> flag must have been specified in the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/ns-lmserver-server_transport_info_2">SERVER_TRANSPORT_INFO_2</a> structure for the transport protocol.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>.
     * @param {Pointer<UInt32>} parm_err Pointer to a value that receives the index of the first member of the share information structure that causes the <b>ERROR_INVALID_PARAMETER</b> error. If this parameter is <b>NULL</b>, the index is not returned on error. For more information, see the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsharesetinfo">NetShareSetInfo</a> function.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The character or file system name is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_DuplicateShare</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name is already in use on this server.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_RedirectedPath</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not valid for a redirected resource. The specified device name is assigned to a shared resource.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_UnknownDevDir</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device or directory does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netshareadd
     * @since windows5.1.2600
     */
    static NetShareAdd(servername, level, buf, parm_err) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareAdd", "ptr", servername, "uint", level, "char*", buf, "uint*", parm_err, "uint")
        return result
    }

    /**
     * Retrieves information about each shared resource on a server.
     * @remarks
     * This function applies only to Server Message Block (SMB) shares. For other types of shares, such as Distributed File System (DFS) or WebDAV shares, use <a href="https://docs.microsoft.com/windows/desktop/WNet/windows-networking-functions">Windows Networking (WNet) functions</a>, which support all types of shares.
     * 
     * For interactive users (users who are logged on locally to the machine), no special group membership is required to execute the <b>NetShareEnum</b> function. For non-interactive users, Administrator, Power User, Print Operator, or Server Operator group membership is required to successfully execute the 
     * <b>NetShareEnum</b> function at levels 2, 502, and 503. No special group membership is required for level 0 or level 1 calls.
     * 
     * <b>Windows Server 2022:  </b> For non-interactive users, Administrator, Access Control Assistance Operators, or Server Operator group membership is required to successfully execute the 
     * <b>NetShareEnum</b> function at levels 2, 502, and 503.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>For all users, Administrator, Power User, Print Operator, or Server Operator group membership is required to successfully execute the 
     * <b>NetShareEnum</b> function at levels 2 and 502.
     * 
     * To retrieve a value that indicates whether a share is the root volume in a DFS tree structure, you must call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsharegetinfo">NetShareGetInfo</a> function and specify information level 1005.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management share functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileshare">IADsFileShare</a>.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated. Note that applications should consider this value only as a hint.
     * @param {Pointer<UInt32>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing share search. The handle should be zero on the first call and left unchanged for subsequent calls. If <i>resume_handle</i> is <b>NULL</b>, then no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value is a system error code. For a list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netshareenum
     * @since windows5.1.2600
     */
    static NetShareEnum(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareEnum", "ptr", servername, "uint", level, "ptr", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr 
     * @param {Integer} prefmaxlen 
     * @param {Pointer<UInt32>} entriesread 
     * @param {Pointer<UInt32>} totalentries 
     * @param {Pointer<UInt32>} resume_handle 
     * @returns {Integer} 
     */
    static NetShareEnumSticky(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareEnumSticky", "ptr", servername, "uint", level, "ptr", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * Retrieves information about a particular shared resource on a server.
     * @remarks
     * This function applies only to Server Message Block (SMB) shares. For other types of shares, such as Distributed File System (DFS) or WebDAV shares, use <a href="https://docs.microsoft.com/windows/desktop/WNet/windows-networking-functions">Windows Networking (WNet) functions</a>, which support all types of shares.
     * 
     * For interactive users (users who are logged on locally to the machine), no special group membership is required to execute the <b>NetShareGetInfo</b> function. For non-interactive users, Administrator, Power User, Print Operator, or Server Operator group membership is required to successfully execute the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netshareenum">NetShareEnum</a> function at levels 2, 502, and 503. No special group membership is required for level 0 or level 1 calls.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>For all users, Administrator, Power User, Print Operator, or Server Operator group membership is required to successfully execute the 
     * <b>NetShareGetInfo</b> function at levels 2 and 502.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management share functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileshare">IADsFileShare</a>.
     * 
     * If 503 is specified for the <i>level</i> parameter, the remote server specified in the <b>shi503_servername</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_503">SHARE_INFO_503</a> structure must have been bound to a transport protocol using the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/nf-lmserver-netservertransportaddex">NetServerTransportAddEx</a> function. In the call to  <b>NetServerTransportAddEx</b>, either 2 or 3 must have been specified for the <i>level</i> parameter, and the <b>SVTI2_SCOPED_NAME</b> flag must have been specified in the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/ns-lmserver-server_transport_info_2">SERVER_TRANSPORT_INFO_2</a> structure for the transport protocol.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<Char>} netname Pointer to a string that specifies the name of the share for which to return information.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function.
     * @returns {Integer} If the function succeeds, the return value is NERR_Success.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_NetNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsharegetinfo
     * @since windows5.1.2600
     */
    static NetShareGetInfo(servername, netname, level, bufptr) {
        servername := servername is String? StrPtr(servername) : servername
        netname := netname is String? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareGetInfo", "ptr", servername, "ptr", netname, "uint", level, "ptr", bufptr, "uint")
        return result
    }

    /**
     * Sets the parameters of a shared resource.
     * @remarks
     * This function applies only to Server Message Block (SMB) shares. For other types of shares, such as Distributed File System (DFS) or WebDAV shares, use <a href="https://docs.microsoft.com/windows/desktop/WNet/windows-networking-functions">Windows Networking (WNet) functions</a>, which support all types of shares.
     * 
     * Only members of the Administrators or Power Users local group, or those with Print or Server Operator group membership, can successfully execute the 
     * <b>NetShareSetInfo</b> function. The Print Operator can set information only about Printer shares.
     * 
     * If the 
     * <b>NetShareSetInfo</b> function returns <b>ERROR_INVALID_PARAMETER</b>, you can use the <i>parm_err</i> parameter to indicate the first member of the share information structure that is not valid. (A share information structure begins with <b>SHARE_INFO_</b> and its format is specified by the <i>level</i> parameter.) The following table lists the values that can be returned in the <i>parm_err</i> parameter and the corresponding structure member that is in error. (The prefix <b>shi*_</b> indicates that the member can begin with multiple prefixes, for example, <i>shi2_</i> or <b>shi502_</b>.)
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Member</th>
     * </tr>
     * <tr>
     * <td>SHARE_NETNAME_PARMNUM</td>
     * <td><b>shi*_netname</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_TYPE_PARMNUM</td>
     * <td><b>shi*_type</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_REMARK_PARMNUM</td>
     * <td><b>shi*_remark</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_PERMISSIONS_PARMNUM</td>
     * <td><b>shi*_permissions</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_MAX_USES_PARMNUM</td>
     * <td><b>shi*_max_uses</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_CURRENT_USES_PARMNUM</td>
     * <td><b>shi*_current_uses</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_PATH_PARMNUM</td>
     * <td><b>shi*_path</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_PASSWD_PARMNUM</td>
     * <td><b>shi*_passwd</b></td>
     * </tr>
     * <tr>
     * <td>SHARE_FILE_SD_PARMNUM</td>
     * <td><b>shi*_security_descriptor</b></td>
     * </tr>
     * </table>
     *  
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management share functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileshare">IADsFileShare</a>.
     * 
     * If 503 is specified for the <i>level</i> parameter, the remote server specified in the <b>shi503_servername</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_503">SHARE_INFO_503</a> structure must have been bound to a transport protocol using the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/nf-lmserver-netservertransportaddex">NetServerTransportAddEx</a> function. In the call to  <b>NetServerTransportAddEx</b>, either 2 or 3 must have been specified for the <i>level</i> parameter, and the <b>SVTI2_SCOPED_NAME</b> flag must have been specified in the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/ns-lmserver-server_transport_info_2">SERVER_TRANSPORT_INFO_2</a> structure for the transport protocol.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<Char>} netname Pointer to a string that specifies the name of the share to set information on.
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>.
     * @param {Pointer<UInt32>} parm_err Pointer to a value that receives the index of the first member of the share information structure that causes the <b>ERROR_INVALID_PARAMETER</b> error. If this parameter is <b>NULL</b>, the index is not returned on error. For more information, see the following Remarks section.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid. For more information, see the following Remarks section.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_NetNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsharesetinfo
     * @since windows5.1.2600
     */
    static NetShareSetInfo(servername, netname, level, buf, parm_err) {
        servername := servername is String? StrPtr(servername) : servername
        netname := netname is String? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareSetInfo", "ptr", servername, "ptr", netname, "uint", level, "char*", buf, "uint*", parm_err, "uint")
        return result
    }

    /**
     * Deletes a share name from a server's list of shared resources, disconnecting all connections to the shared resource.
     * @remarks
     * This function applies only to Server Message Block (SMB) shares. For other types of shares, such as Distributed File System (DFS) or WebDAV shares, use <a href="https://docs.microsoft.com/windows/desktop/WNet/windows-networking-functions">Windows Networking (WNet) functions</a>, which support all types of shares.
     * 
     * Only members of the Administrators, Server Operators, or Power Users local group, or those with Server Operator group membership, can successfully delete file shares with a call to the 
     * <b>NetShareDel</b> function. The Print Operator can delete printer shares.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management share functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileshare">IADsFileShare</a>.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Pointer<Char>} netname Pointer to a string that specifies the name of the share to delete.
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @returns {Integer} If the function succeeds, the return value is NERR_Success.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_NetNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The share name does not exist.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsharedel
     * @since windows5.1.2600
     */
    static NetShareDel(servername, netname) {
        static reserved := 0 ;Reserved parameters must always be NULL

        servername := servername is String? StrPtr(servername) : servername
        netname := netname is String? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareDel", "ptr", servername, "ptr", netname, "uint", reserved, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} servername 
     * @param {Pointer<Char>} netname 
     * @returns {Integer} 
     */
    static NetShareDelSticky(servername, netname) {
        static reserved := 0 ;Reserved parameters must always be NULL

        servername := servername is String? StrPtr(servername) : servername
        netname := netname is String? StrPtr(netname) : netname

        result := DllCall("NETAPI32.dll\NetShareDelSticky", "ptr", servername, "ptr", netname, "uint", reserved, "uint")
        return result
    }

    /**
     * Checks whether or not a server is sharing a device.
     * @remarks
     * This function applies only to Server Message Block (SMB) shares. For other types of shares, such as Distributed File System (DFS) or WebDAV shares, use <a href="https://docs.microsoft.com/windows/desktop/WNet/windows-networking-functions">Windows Networking (WNet) functions</a>, which support all types of shares.
     * 
     * No special group membership is required to successfully execute the 
     * <b>NetShareCheck</b> function.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management share functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileshare">IADsFileShare</a>.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<Char>} device Pointer to a string that specifies the name of the device to check for shared access.
     * @param {Pointer<UInt32>} type Pointer to a variable that receives a bitmask of flags that specify the type of the shared device. This parameter is set only if the function returns successfully. 
     * 
     * One of the following flags may be specified.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_DISKTREE"></a><a id="stype_disktree"></a><dl>
     * <dt><b>STYPE_DISKTREE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disk drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_PRINTQ"></a><a id="stype_printq"></a><dl>
     * <dt><b>STYPE_PRINTQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Print queue.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_DEVICE"></a><a id="stype_device"></a><dl>
     * <dt><b>STYPE_DEVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Communication device.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_IPC"></a><a id="stype_ipc"></a><dl>
     * <dt><b>STYPE_IPC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Interprocess communication (IPC).
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * In addition, one or both of the following flags may be specified.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_SPECIAL"></a><a id="stype_special"></a><dl>
     * <dt><b>STYPE_SPECIAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Special share reserved for interprocess communication (IPC$) or remote administration of the server (ADMIN$). Can also refer to administrative shares such as C$, D$, E$, and so forth. For more information, see <a href="https://docs.microsoft.com/windows/desktop/NetShare/network-share-functions">Network Share Functions</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="STYPE_TEMPORARY"></a><a id="stype_temporary"></a><dl>
     * <dt><b>STYPE_TEMPORARY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A temporary share.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_DeviceNotShared</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The device is not shared.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsharecheck
     * @since windows5.1.2600
     */
    static NetShareCheck(servername, device, type) {
        servername := servername is String? StrPtr(servername) : servername
        device := device is String? StrPtr(device) : device

        result := DllCall("NETAPI32.dll\NetShareCheck", "ptr", servername, "ptr", device, "uint*", type, "uint")
        return result
    }

    /**
     * Deletes a share name from a server's list of shared resources, which disconnects all connections to that share.
     * @remarks
     * If 503 is specified for the <i>level</i> parameter, the <i>buf</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_503">SHARE_INFO_503</a> structure, and the <b>shi503_netname</b> and <b>shi503_servername</b> members of that structure are used to look up the shared resource on the server; the other members are ignored. The remote server specified in the <b>shi503_servername</b> member must have been bound to a transport protocol using the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/nf-lmserver-netservertransportaddex">NetServerTransportAddEx</a> function. In the call to  <b>NetServerTransportAddEx</b>, either 2 or 3 must have been specified for the <i>level</i> parameter, and the <b>SVTI2_SCOPED_NAME</b> flag must have been specified in the <a href="https://docs.microsoft.com/windows/desktop/api/lmserver/ns-lmserver-server_transport_info_2">SERVER_TRANSPORT_INFO_2</a> structure for the transport protocol.
     * 
     * If 0, 1, 2, or 502 is specified for the <i>level</i> parameter, the <i>buf</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_0">SHARE_INFO_0</a>, <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_1">SHARE_INFO_1</a>, <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_2">SHARE_INFO_2</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-share_info_502">SHARE_INFO_502</a> structure, and the <b>shi0_netname</b>, <b>shi1_netname</b>, <b>shi2_netname</b>, or <b>shi502_netname</b> member of that structure is used; the other members are ignored.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf Pointer to the buffer that specifies the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a>.
     * @returns {Integer} If the function succeeds, the return value is NERR_Success.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The request is not supported.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsharedelex
     * @since windows5.1.2600
     */
    static NetShareDelEx(servername, level, buf) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetShareDelEx", "ptr", servername, "uint", level, "char*", buf, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf 
     * @returns {Integer} 
     */
    static NetServerAliasAdd(servername, level, buf) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetServerAliasAdd", "ptr", servername, "uint", level, "char*", buf, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} buf 
     * @returns {Integer} 
     */
    static NetServerAliasDel(servername, level, buf) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetServerAliasDel", "ptr", servername, "uint", level, "char*", buf, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} servername 
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr 
     * @param {Integer} prefmaxlen 
     * @param {Pointer<UInt32>} entriesread 
     * @param {Pointer<UInt32>} totalentries 
     * @param {Pointer<UInt32>} resumehandle 
     * @returns {Integer} 
     */
    static NetServerAliasEnum(servername, level, bufptr, prefmaxlen, entriesread, totalentries, resumehandle) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetServerAliasEnum", "ptr", servername, "uint", level, "ptr", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resumehandle, "uint")
        return result
    }

    /**
     * Provides information about sessions established on a server.
     * @remarks
     * Only members of the Administrators or Server Operators local group can successfully execute the 
     * <b>NetSessionEnum</b> function at level 1 or level 2.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management session functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadssession">IADsSession</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileserviceoperations">IADsFileServiceOperations</a>.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<Char>} UncClientName Pointer to a string that specifies the name of the computer session for which information is to be returned. If this parameter is <b>NULL</b>, 
     * <b>NetSessionEnum</b> returns information for all computer sessions on the server.
     * @param {Pointer<Char>} username Pointer to a string that specifies the name of the user for which information is to be returned. If this parameter is <b>NULL</b>, 
     * <b>NetSessionEnum</b> returns information for all users.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter.
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated from the current resume position. Note that applications should consider this value only as a hint.
     * @param {Pointer<UInt32>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing session search. The handle should be zero on the first call and left unchanged for subsequent calls. If <i>resume_handle</i> is <b>NULL</b>, no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * More entries are available. Specify a large enough buffer to receive all entries.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_ClientNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session does not exist with the computer name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_InvalidComputer</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_UserNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user name could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsessionenum
     * @since windows5.1.2600
     */
    static NetSessionEnum(servername, UncClientName, username, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String? StrPtr(servername) : servername
        UncClientName := UncClientName is String? StrPtr(UncClientName) : UncClientName
        username := username is String? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetSessionEnum", "ptr", servername, "ptr", UncClientName, "ptr", username, "uint", level, "ptr", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * Ends a network session between a server and a workstation.
     * @remarks
     * Only members of the Administrators or Server Operators local group can successfully execute the 
     * <b>NetSessionDel</b> function.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management session functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadssession">IADsSession</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileserviceoperations">IADsFileServiceOperations</a>.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<Char>} UncClientName Pointer to a string that specifies the computer name of the client to disconnect. If the <i>UncClientName</i> parameter is <b>NULL</b>, then all the sessions of the user identified by the <i>username</i> parameter will be deleted on the server specified by the <i>servername</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsessionenum">NetSessionEnum</a>.
     * @param {Pointer<Char>} username Pointer to a string that specifies the name of the user whose session is to be terminated. If this parameter is <b>NULL</b>, all users' sessions from the client specified by the <i>UncClientName</i> parameter are to be terminated.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_ClientNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session does not exist with that computer name.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsessiondel
     * @since windows5.1.2600
     */
    static NetSessionDel(servername, UncClientName, username) {
        servername := servername is String? StrPtr(servername) : servername
        UncClientName := UncClientName is String? StrPtr(UncClientName) : UncClientName
        username := username is String? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetSessionDel", "ptr", servername, "ptr", UncClientName, "ptr", username, "uint")
        return result
    }

    /**
     * Retrieves information about a session established between a particular server and workstation.
     * @remarks
     * Only members of the Administrators or Server Operators local group can successfully execute the 
     * <b>NetSessionGetInfo</b> function at level 1 or level 2. No special group membership is required for level 0 or level 10 calls.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling the network management session functions. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadssession">IADsSession</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileserviceoperations">IADsFileServiceOperations</a>.
     * 
     * If you call this function at information level 1 or 2 on a member server or workstation, all authenticated users can view the information.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<Char>} UncClientName Pointer to a string that specifies the name of the computer session for which information is to be returned. This parameter is required and cannot be <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsessionenum">NetSessionEnum</a>.
     * @param {Pointer<Char>} username Pointer to a string that specifies the name of the user whose session information is to be returned. This parameter is required and cannot be <b>NULL</b>.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_ClientNameNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A session does not exist with the computer name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_InvalidComputer</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The computer name is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_UserNotFound</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user name could not be found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netsessiongetinfo
     * @since windows5.1.2600
     */
    static NetSessionGetInfo(servername, UncClientName, username, level, bufptr) {
        servername := servername is String? StrPtr(servername) : servername
        UncClientName := UncClientName is String? StrPtr(UncClientName) : UncClientName
        username := username is String? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetSessionGetInfo", "ptr", servername, "ptr", UncClientName, "ptr", username, "uint", level, "ptr", bufptr, "uint")
        return result
    }

    /**
     * Lists all connections made to a shared resource on the server or all connections established from a particular computer.
     * @remarks
     * Administrator, Server or Print Operator, or Power User group membership is required to successfully execute the 
     * <b>NetConnectionEnum</b> function.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Pointer<Char>} qualifier Pointer to a string that specifies a share name or computer name for the connections of interest. If it is a share name, then all the connections made to that share name are listed. If it is a computer name (for example, it starts with two backslash characters), then 
     * <b>NetConnectionEnum</b> lists all connections made from that computer to the server specified.
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the address of the buffer that receives the information. The format of this data depends on the value of the <i>level</i> parameter. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated from the current resume position. Note that applications should consider this value only as a hint.
     * @param {Pointer<UInt32>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing connection search. The handle should be zero on the first call and left unchanged for subsequent calls. If this parameter is <b>NULL</b>, then no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value is a system error code. For a list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netconnectionenum
     * @since windows5.1.2600
     */
    static NetConnectionEnum(servername, qualifier, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String? StrPtr(servername) : servername
        qualifier := qualifier is String? StrPtr(qualifier) : qualifier

        result := DllCall("NETAPI32.dll\NetConnectionEnum", "ptr", servername, "ptr", qualifier, "uint", level, "ptr", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "uint*", resume_handle, "uint")
        return result
    }

    /**
     * Forces a resource to close. This function can be used when an error prevents closure by any other means. You should use NetFileClose with caution because it does not write data cached on the client system to the file before closing the file.
     * @remarks
     * Only members of the Administrators or Server Operators local group can successfully execute the 
     * <b>NetFileClose</b> function.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} fileid Specifies the file identifier of the opened resource instance to close.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file was not found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netfileclose
     * @since windows5.1.2600
     */
    static NetFileClose(servername, fileid) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetFileClose", "ptr", servername, "uint", fileid, "uint")
        return result
    }

    /**
     * Returns information about some or all open files on a server, depending on the parameters specified.
     * @remarks
     * Only members of the Administrators or Server Operators local group can successfully execute the 
     * <b>NetFileEnum</b> function.
     * 
     * You can call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netfilegetinfo">NetFileGetInfo</a> function to retrieve information about a particular opening of a server resource.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling 
     * <b>NetFileEnum</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsresource">IADsResource</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileserviceoperations">IADsFileServiceOperations</a>.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Pointer<Char>} basepath Pointer to a string that specifies a qualifier for the returned information. If this parameter is <b>NULL</b>, all open resources are enumerated. If this parameter is not <b>NULL</b>, the function enumerates only resources that have the value of the <i>basepath</i> parameter as a prefix. (A prefix is the portion of a path that comes before a backslash.)
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Pointer<Char>} username Pointer to a string that specifies the name of the user or the name of the connection. If the string begins with two backslashes ("\\"), then it indicates the name of the connection, for example, "\\127.0.0.1" or "\\ClientName". The part of the connection name after the backslashes is the same as the client name in the session information structure returned by the <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netsessionenum">NetSessionEnum</a> function. If the string does not begin with two backslashes, then it indicates the name of the user. If this parameter is not <b>NULL</b>, its value serves as a qualifier for the enumeration. The files returned are limited to those that have user names or connection names that match the qualifier. If this parameter is <b>NULL</b>, no user-name qualifier is used.
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This parameter is a pointer to a string that specifies the name of the user. If this parameter is not <b>NULL</b>, its value serves as a qualifier for the enumeration. The files returned are limited to those that have user names matching the qualifier. If this parameter is <b>NULL</b>, no user-name qualifier is used.
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the address of the buffer that receives the information. The format of this data depends on the value of the <i>level</i> parameter. 
     * 
     * 
     * 
     * 
     * This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. Note that you must free the buffer even if the function fails with <b>ERROR_MORE_DATA</b>.
     * @param {Integer} prefmaxlen Specifies the preferred maximum length of returned data, in bytes. If you specify <b>MAX_PREFERRED_LENGTH</b>, the function allocates the amount of memory required for the data. If you specify another value in this parameter, it can restrict the number of bytes that the function returns. If the buffer size is insufficient to hold all entries, the function returns <b>ERROR_MORE_DATA</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @param {Pointer<UInt32>} entriesread Pointer to a value that receives the count of elements actually enumerated.
     * @param {Pointer<UInt32>} totalentries Pointer to a value that receives the total number of entries that could have been enumerated from the current resume position. Note that applications should consider this value only as a hint.
     * @param {Pointer<UIntPtr>} resume_handle Pointer to a value that contains a resume handle which is used to continue an existing file search. The handle should be zero on the first call and left unchanged for subsequent calls. If this parameter is <b>NULL</b>, no resume handle is stored.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MORE_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * More entries are available. Specify a large enough buffer to receive all entries.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_BufTooSmall</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The supplied buffer is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netfileenum
     * @since windows5.1.2600
     */
    static NetFileEnum(servername, basepath, username, level, bufptr, prefmaxlen, entriesread, totalentries, resume_handle) {
        servername := servername is String? StrPtr(servername) : servername
        basepath := basepath is String? StrPtr(basepath) : basepath
        username := username is String? StrPtr(username) : username

        result := DllCall("NETAPI32.dll\NetFileEnum", "ptr", servername, "ptr", basepath, "ptr", username, "uint", level, "ptr", bufptr, "uint", prefmaxlen, "uint*", entriesread, "uint*", totalentries, "ptr*", resume_handle, "uint")
        return result
    }

    /**
     * Retrieves information about a particular opening of a server resource.
     * @remarks
     * Only members of the Administrators or Server Operators local group can successfully execute the 
     * <b>NetFileGetInfo</b> function.
     * 
     * You can call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/nf-lmshare-netfileenum">NetFileEnum</a> function to retrieve information about multiple files open on a server.
     * 
     * If you are programming for Active Directory, you may be able to call certain Active Directory Service Interface (ADSI) methods to achieve the same functionality you can achieve by calling 
     * <b>NetFileGetInfo</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsresource">IADsResource</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/iads/nn-iads-iadsfileserviceoperations">IADsFileServiceOperations</a>.
     * @param {Pointer<Char>} servername Pointer to a string that specifies the DNS or NetBIOS name of the remote server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used. 
     * 
     * 
     * 
     * 
     * This string is Unicode if  <b>_WIN32_WINNT</b> or <b>FORCE_UNICODE</b> is defined.
     * @param {Integer} fileid Specifies the file identifier of the open resource for which to return information. The value of this parameter must have been returned in a previous enumeration call. For more information, see the following Remarks section.
     * @param {Integer} level 
     * @param {Pointer<Byte>} bufptr Pointer to the address of the buffer that receives the information. The format of this data depends on the value of the <i>level</i> parameter. This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value can be one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The user does not have access to the requested information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_LEVEL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The value specified for the <i>level</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_ENOUGH_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>NERR_BufTooSmall</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The supplied buffer is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/lmshare/nf-lmshare-netfilegetinfo
     * @since windows5.1.2600
     */
    static NetFileGetInfo(servername, fileid, level, bufptr) {
        servername := servername is String? StrPtr(servername) : servername

        result := DllCall("NETAPI32.dll\NetFileGetInfo", "ptr", servername, "uint", fileid, "uint", level, "ptr", bufptr, "uint")
        return result
    }

    /**
     * Retrieves operating statistics for a service. Currently, only the workstation and server services are supported.
     * @remarks
     * No special group membership is required to obtain workstation statistics. Only members of the Administrators or Server Operators local group can successfully execute the 
     * <b>NetStatisticsGet</b> function on a remote server.
     * @param {Pointer<SByte>} ServerName Pointer to a string that specifies the DNS or NetBIOS name of the server on which the function is to execute. If this parameter is <b>NULL</b>, the local computer is used.
     * @param {Pointer<SByte>} Service Pointer to a string that specifies the name of the service about which to get the statistics. Only the values <b>SERVICE_SERVER</b> and <b>SERVICE_WORKSTATION</b> are currently allowed.
     * @param {Integer} Level Specifies the information level of the data. This parameter can be the following value. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="0"></a><dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Return statistics about a workstation or a server. The <i>bufptr</i> parameter points to a 
     * <a href="https://docs.microsoft.com/windows/win32/api/lmstats/ns-lmstats-stat_workstation_0~r1">STAT_WORKSTATION_0</a> or a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmstats/ns-lmstats-stat_server_0">STAT_SERVER_0</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Options This parameter must be zero.
     * @param {Pointer<Byte>} Buffer Pointer to the buffer that receives the data. The format of this data depends on the value of the <i>level</i> parameter. This buffer is allocated by the system and must be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/lmapibuf/nf-lmapibuf-netapibufferfree">NetApiBufferFree</a> function. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffers">Network Management Function Buffers</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/NetMgmt/network-management-function-buffer-lengths">Network Management Function Buffer Lengths</a>.
     * @returns {Integer} If the function succeeds, the return value is <b>NERR_Success</b>.
     * 
     * If the function fails, the return value is a system error code. For a list of error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Debug/system-error-codes">System Error Codes</a>.
     * @see https://learn.microsoft.com/windows/win32/api/lmstats/nf-lmstats-netstatisticsget
     * @since windows5.1.2600
     */
    static NetStatisticsGet(ServerName, Service, Level, Options, Buffer) {
        result := DllCall("NETAPI32.dll\NetStatisticsGet", "char*", ServerName, "char*", Service, "uint", Level, "uint", Options, "ptr", Buffer, "uint")
        return result
    }

    /**
     * Queries the OS for the supported capabilities for IORINGs.
     * @remarks
     * The results of this call are internally cached per-process, so this is efficient to call multiple times as only the first will transition to the kernel to retrieve the data.Note that the results are not guaranteed to contain the same values between runs of the same process or even between processes on the same system.  So applications should not store this information beyond the lifetime of the process and should not assume that other processes have the same support.
     * @param {Pointer<IORING_CAPABILITIES>} capabilities Receives a pointer to an [IORING_CAPABILITIES](ns-ioringapi-ioring_capabilities.md) representing the I/O ring API capabilities.
     * @returns {HRESULT} S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-queryioringcapabilities
     */
    static QueryIoRingCapabilities(capabilities) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\QueryIoRingCapabilities", "ptr", capabilities, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Queries the support of the specified operation for the specified I/O ring.
     * @remarks
     * Unknown operation codes are treated as unsupported. Invalid **HIORING** handles are treated as not supporting any operations. So, this method will not throw errors due to these conditions.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring for which operation support is queried.
     * @param {Integer} op A value from the [IORING_OP_CODE](../ntioring_x/ne-ntioring_x-ioring_op_code.md) enumeration specifying the operation for which support is queried.
     * @returns {Integer} Returns an HRESULT including, but not limitted to the following:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK  | The operation is supported. |
     * | S_FALSE | The operation is unsupported. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-isioringopsupported
     */
    static IsIoRingOpSupported(ioRing, op) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\IsIoRingOpSupported", "ptr", ioRing, "int", op, "int")
        return result
    }

    /**
     * Creates a new instance of an I/O ring submission/completion queue pair and returns a handle for referencing the I/O ring.
     * @param {Integer} ioringVersion A UNIT32 representing the version of the I/O ring API the ring is created for. This value must be less than or equal to the value retrieved from a call to [QueryIoRingCapabilities](nf-ioringapi-queryioringcapabilities.md)
     * @param {Pointer} flags A value from the [IORING_CREATE_FLAGS](ns-ioringapi-ioring_create_flags.md) enumeration specifying creation flags.
     * @param {Integer} submissionQueueSize The requested minimum submission queue size. The system may round up the size as needed to ensure the actual size is a power of 2. You can get the actual allocated queue size by calling [GetIoRingInfo](nf-ioringapi-getioringinfo.md). You can get the maximum submission queue size on the current system by calling [QueryIoRingCapabilities](nf-ioringapi-queryioringcapabilities.md).
     * @param {Integer} completionQueueSize The requested minimum size of the completion queue. The system will round this size up to a power of two that is no less than two times the actual submission queue size to allow for submissions while some operations are still in progress. You can get the actual allocated queue size by calling [GetIoRingInfo](nf-ioringapi-getioringinfo.md).
     * @param {Pointer<Void>} h Receives the resulting **HIORING**  handle, if creation was successful. The returned **HIORING** ring must be closed by calling [CloseIoRing](nf-ioringapi-closeioring.md), not [CloseHandle](../handleapi/nf-handleapi-closehandle.md), to release the underlying resources for the IORING.
     * @returns {HRESULT} An HRESULT, including but not limited to the following:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK | Success. |
     * | IORING_E_UNKNOWN_VERSION | The version specified in *ioringVersion* is unknown. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-createioring
     */
    static CreateIoRing(ioringVersion, flags, submissionQueueSize, completionQueueSize, h) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\CreateIoRing", "int", ioringVersion, "ptr", flags, "uint", submissionQueueSize, "uint", completionQueueSize, "ptr", h, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Gets information about the API version and queue sizes of an I/O ring.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring for which information is being queried.
     * @param {Pointer<IORING_INFO>} info Receives a pointer to an [IORING_INFO](ns-ioringapi-ioring_info.md) structure specifying API version and queue sizes for the specified I/O ring.
     * @returns {HRESULT} S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-getioringinfo
     */
    static GetIoRingInfo(ioRing, info) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\GetIoRingInfo", "ptr", ioRing, "ptr", info, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Submits all constructed but not yet submitted entries to the kernel’s queue and optionally waits for a set of operations to complete.
     * @remarks
     * If this function returns an error other than IORING_E_WAIT_TIMEOUT, then all entries remain in the submission queue. Any errors processing a single submission queue entry results in a synchronous completion of that entry posted to the completion queue with an error status code for that operation.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring for which entries will be submitted.
     * @param {Integer} waitOperations The number of completion queue entries to wait for. Specifying 0 indicates that the call should not wait. This value must be less than the sum of the number of entries in the submission queue and the number of operations currently in progress.
     * @param {Integer} milliseconds The number of milliseconds to wait for the operations to complete. Specify **INFINITE** to wait indefinitely. This value is ignored if 0 is specified for *waitOperations*.
     * @param {Pointer<UInt32>} submittedEntries Optional. Receives a pointer to an array of **UINT_32** values representing the number of entries submitted.
     * @returns {HRESULT} Returns an HRESULT including, but not limited to, one of the following:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK  | All entries in the queue were submitted without error.         |
     * | IORING_E_WAIT_TIMEOUT | All operations were submitted without error and the subsequent wait timed out. |
     * | Any other error value | Failure to process the submission queue in its entirety. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-submitioring
     */
    static SubmitIoRing(ioRing, waitOperations, milliseconds, submittedEntries) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\SubmitIoRing", "ptr", ioRing, "uint", waitOperations, "uint", milliseconds, "uint*", submittedEntries, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Closes an **HIORING** handle that was previously opened with a call to CreateIoRing.
     * @remarks
     * Calling this function ensures that resources allocated for the I/O ring are released. The closed handle is no longer valid after the function returns. It is important to note that closing the handle abandons the operations that are queued but not submitted.  However, the operations that are in flight are **not** cancelled. 
     * 
     * It is possible that reads from or writes to memory buffers may still occur after **CloseIoRing** returns. If you want to ensure that no pending reads or writes occur, you must wait for the completions to appear in the completion queue for all the operations that are submitted. You may choose to cancel the previously submitted operations before waiting on their completions. As an alternative to submitting multiple cancel requests, you can call [CancelIoEx](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) with the file handle and NULL for the overlapped pointer to effectively cancel all pending operations on the handle.
     * @param {Pointer<Void>} ioRing The **HIORING** handle to close.
     * @returns {HRESULT} Returns S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-closeioring
     */
    static CloseIoRing(ioRing) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\CloseIoRing", "ptr", ioRing, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Pops a single entry from the completion queue, if one is available.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring from which an entry from the completion queue is popped.
     * @param {Pointer<IORING_CQE>} cqe Pointer to an [IORING_CQE](ns-ioringapi-ioring_cqe.md) structure that will recieve the data for the completed queue entry.
     * @returns {HRESULT} Returns an HRESULT including, but not limitted to the following:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK  | The entry was popped from the queue and the **IORING_CQE** pointed to by *cqe* contains the values from the entry. |
     * | S_FALSE | The completion queue is empty, and the data pointed to by the *cqe* parameter is unmodified. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-popioringcompletion
     */
    static PopIoRingCompletion(ioRing, cqe) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\PopIoRingCompletion", "ptr", ioRing, "ptr", cqe, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Registers a completion queue event with an IORING.
     * @remarks
     * The kernel will signal this event when it places the first entry into an empty completion queue, i.e. the kernel only sets the event to the signaled state when the completion queue transitions from the empty to non-empty state. Applications should call [PopIoRingCompletion](nf-ioringapi-popioringcompletion.md) until it indicates no more entries and then wait for any additional async completions to complete via the provided HANDLE. Otherwise, the event won’t enter the signaled state and the wait may block until a timeout occurs, or forever if an infinite timeout is used.
     * 
     * The kernel will internally duplicate the handle, so it is safe for the application to close the handle when waits are no longer needed. Providing an event handle value of NULL simply clears any existing value. Setting a value of INVALID_HANDLE_VALUE raises an error, as will any other invalid handle value, to aid in detecting code bugs early.
     * 
     * There is, at most, one event handle associated with an HIORING, attempting to set a second one will replace any that already exists.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring for which the completion event is registered.
     * @param {Pointer<Void>} hEvent A handle to the event object. The [CreateEvent](../synchapi/nf-synchapi-createeventa.md) or [OpenEvent](../synchapi/nf-synchapi-openeventa.md) function returns this handle.
     * @returns {HRESULT} Returns an HRESULT including the following values:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK  | Success     |
     * | E_INVALID_HANDLE | An invalid handle was passed in the *ioRing* parameter. |
     * | E_INVALIDARG | An invalid handle was passed in the *hEvent* parameter. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-setioringcompletionevent
     */
    static SetIoRingCompletionEvent(ioRing, hEvent) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\SetIoRingCompletionEvent", "ptr", ioRing, "ptr", hEvent, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Attempts to cancel a previously submitted I/O ring operation.
     * @remarks
     * Since I/O ring operations are performed asynchronously this function call is only a request for cancellation. The specified operation may complete before the cancellation is processed. The cancellation operation may complete after the operation it is canceling is completed. The completion of the cancel operation is not dependent on the actual completion of the I/O operations it cancels. Apps should look for the completion of the original operation in the completion queue by calling [PopIoRingCompletion](nf-ioringapi-popioringcompletion.md) to observe the final status of the operation. The operation may have completed successfully or with an error rather than being cancelled by the call to this function.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring for which a cancellation is requested.
     * @param {Pointer} file An [IORING_HANDLE_REF](ns-ioringapi-ioring_handle_ref.md) representing the file associated with the operation to cancel.
     * @param {Pointer} opToCancel A **UINT_PTR** specifying the operation to cancel. This value is the same value provided in the *userData* parameter when the operation was registered. To support cancellation, the *userData* value must be unique for each operation.
     * @param {Pointer} userData A UINT_PTR value identifying the cancellation operation. Specify this value when cancelling the operation with a call to [BuildIoRingCancelRequest](nf-ioringapi-buildioringcancelrequest.md). If an app implements cancellation behavior for the operation, the *userData* value must be unique. Otherwise, the value is treated as opaque by the system and can be anything, including 0.
     * @returns {HRESULT} | Value | Description |
     * |-------|-------------|
     * | S_OK  | Success |
     * | IORING_E_SUBMISSION_QUEUE_FULL | The submission queue is full, and no additional entries are available to build. The application must submit the existing entries and wait for some of them to complete before adding more operations to the queue. |
     * | IORING_E_UNKNOWN_REQUIRED_FLAG | The application provided a required flag that is not known to the implementation. Library code should check the *IoRingVersion* field of the [IORING_INFO](ns-ioringapi-ioring_info.md) obtained from a call to [GetIoRingInfo](nf-ioringapi-getioringinfo.md) to determine the API version of an I/O ring which determines the operations and flags that are supported. Applications should know the version they used to create the I/O ring and therefore should not provide unsupported flags at runtime. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-buildioringcancelrequest
     */
    static BuildIoRingCancelRequest(ioRing, file, opToCancel, userData) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingCancelRequest", "ptr", ioRing, "ptr", file, "ptr", opToCancel, "ptr", userData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Performs an asynchronous read from a file using an I/O ring.
     * @remarks
     * Check I/O ring support for read file operations by calling [IsIoRingOpSupported](nf-ioringapi-isioringopsupported.md) and specifying [IORING_OP_READ](../ntioring_x/ne-ntioring_x-ioring_op_code.md) for the *op* parameter.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring which will perform the read operation.
     * @param {Pointer} fileRef An [IORING_HANDLE_REF](ns-ioringapi-ioring_handle_ref.md) specifying the file to read.
     * @param {Pointer} dataRef An [IORING_BUFFER_REF](ns-ioringapi-ioring_buffer_ref.md) specifying the buffer into which the file is read. The provided buffer must have a size of at least *numberOfBytesToRead* bytes.
     * @param {Integer} numberOfBytesToRead The number of bytes to read.
     * @param {Integer} fileOffset The offset into the file to begin reading.
     * @param {Pointer} userData A UINT_PTR value identifying the file read operation. Specify this value when cancelling the operation with a call to [BuildIoRingCancelRequest](nf-ioringapi-buildioringcancelrequest.md). If an app implements cancellation behavior for the operation, the *userData* value must be unique. Otherwise, the value is treated as opaque by the system and can be anything, including 0.
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} Returns an HRESULT including, but not limited to the following:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK  | Success |
     * | IORING_E_SUBMISSION_QUEUE_FULL | The submission queue is full, and no additional entries are available to build. The application must submit the existing entries and wait for some of them to complete before adding more operations to the queue. |
     * | IORING_E_UNKNOWN_REQUIRED_FLAG | The application provided a required flag that is not known to the implementation. Library code should check the *IoRingVersion* field of the [IORING_INFO](ns-ioringapi-ioring_info.md) obtained from a call to [GetIoRingInfo](nf-ioringapi-getioringinfo.md) to determine the API version of an I/O ring which determines the operations and flags that are supported. Applications should know the version they used to create the I/O ring and therefore should not provide unsupported flags at runtime. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-buildioringreadfile
     */
    static BuildIoRingReadFile(ioRing, fileRef, dataRef, numberOfBytesToRead, fileOffset, userData, sqeFlags) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingReadFile", "ptr", ioRing, "ptr", fileRef, "ptr", dataRef, "uint", numberOfBytesToRead, "uint", fileOffset, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Registers an array of file handles with the system for future I/O ring operations.
     * @remarks
     * This function allows the kernel implementation to perform the validation and internal mapping just once avoiding the overhead on each I/O operation. Subsequent entries in the submission queue may refer to the handles registered with this function using an integer index into the array.  If a previous registration exists, this replaces the previous registration completely.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring for which file handles are registered.
     * @param {Integer} count A UINT32 specifying the number of handles provided in the *handles* parameter.
     * @param {Pointer<Void>} handles An array of HANDLE values to be registered.
     * @param {Pointer} userData A UINT_PTR value identifying the registration operation. Specify this value when cancelling the operation with a call to [BuildIoRingCancelRequest](nf-ioringapi-buildioringcancelrequest.md). If an app implements cancellation behavior for the operation, the *userData* value must be unique. Otherwise, the value is treated as opaque by the system and can be anything, including 0.
     * @returns {HRESULT} Returns an HRESULT including, but not limited to the following:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK  | Success |
     * | IORING_E_SUBMISSION_QUEUE_FULL | The submission queue is full, and no additional entries are available to build. The application must submit the existing entries and wait for some of them to complete before adding more operations to the queue. |
     * | IORING_E_UNKNOWN_REQUIRED_FLAG | The application provided a required flag that is not known to the implementation. Library code should check the *IoRingVersion* field of the [IORING_INFO](ns-ioringapi-ioring_info.md) obtained from a call to [GetIoRingInfo](nf-ioringapi-getioringinfo.md) to determine the API version of an I/O ring which determines the operations and flags that are supported. Applications should know the version they used to create the I/O ring and therefore should not provide unsupported flags at runtime. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-buildioringregisterfilehandles
     */
    static BuildIoRingRegisterFileHandles(ioRing, count, handles, userData) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingRegisterFileHandles", "ptr", ioRing, "uint", count, "ptr", handles, "ptr", userData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Registers an array of buffers with the system for future I/O ring operations.
     * @remarks
     * This function allows the kernel implementation to perform the validation and internal mapping just once avoiding the overhead on each I/O operation. Subsequent entries in the submission queue may refer to the buffers registered with this function using an integer index into the array.  If a previous registration exists, this replaces the previous registration completely. Any entries in the array with an *Address* of NULL and a *Length* of 0 are sparse entries, and not used. This allows you to release one or more of the previously registered buffers.
     * @param {Pointer<Void>} ioRing An **HIORING** representing a handle to the I/O ring for which buffers are registered.
     * @param {Integer} count A UINT32 specifying the number of buffers provided in the *buffers* parameter.
     * @param {Pointer<IORING_BUFFER_INFO>} buffers An array of [IORING_BUFFER_INFO](../ntioring_x/ns-ntioring_x-ioring_buffer_info.md) structures representing the buffers to be registered.
     * @param {Pointer} userData A UINT_PTR value identifying the registration operation. Specify this value when cancelling the operation with a call to [BuildIoRingCancelRequest](nf-ioringapi-buildioringcancelrequest.md). If an app implements cancellation behavior for the operation, the *userData* value must be unique. Otherwise, the value is treated as opaque by the system and can be anything, including 0.
     * @returns {HRESULT} Returns an HRESULT including, but not limited to the following:
     * 
     * | Value | Description |
     * |-------|-------------|
     * | S_OK  | Success |
     * | IORING_E_SUBMISSION_QUEUE_FULL | The submission queue is full, and no additional entries are available to build. The application must submit the existing entries and wait for some of them to complete before adding more operations to the queue. |
     * | IORING_E_UNKNOWN_REQUIRED_FLAG | The application provided a required flag that is not known to the implementation. Library code should check the *IoRingVersion* field of the [IORING_INFO](ns-ioringapi-ioring_info.md) obtained from a call to [GetIoRingInfo](nf-ioringapi-getioringinfo.md) to determine the API version of an I/O ring which determines the operations and flags that are supported. Applications should know the version they used to create the I/O ring and therefore should not provide unsupported flags at runtime. |
     * @see https://learn.microsoft.com/windows/win32/api/ioringapi/nf-ioringapi-buildioringregisterbuffers
     */
    static BuildIoRingRegisterBuffers(ioRing, count, buffers, userData) {
        result := DllCall("api-ms-win-core-ioring-l1-1-0.dll\BuildIoRingRegisterBuffers", "ptr", ioRing, "uint", count, "ptr", buffers, "ptr", userData, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} ioRing 
     * @param {Pointer} fileRef 
     * @param {Pointer} bufferRef 
     * @param {Integer} numberOfBytesToWrite 
     * @param {Integer} fileOffset 
     * @param {Integer} writeFlags 
     * @param {Pointer} userData 
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} 
     */
    static BuildIoRingWriteFile(ioRing, fileRef, bufferRef, numberOfBytesToWrite, fileOffset, writeFlags, userData, sqeFlags) {
        result := DllCall("KERNEL32.dll\BuildIoRingWriteFile", "ptr", ioRing, "ptr", fileRef, "ptr", bufferRef, "uint", numberOfBytesToWrite, "uint", fileOffset, "int", writeFlags, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * 
     * @param {Pointer<Void>} ioRing 
     * @param {Pointer} fileRef 
     * @param {Integer} flushMode 
     * @param {Pointer} userData 
     * @param {Integer} sqeFlags 
     * @returns {HRESULT} 
     */
    static BuildIoRingFlushFile(ioRing, fileRef, flushMode, userData, sqeFlags) {
        result := DllCall("KERNEL32.dll\BuildIoRingFlushFile", "ptr", ioRing, "ptr", fileRef, "int", flushMode, "ptr", userData, "int", sqeFlags, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Enables or disables file system redirection for the calling thread.
     * @remarks
     * This function is useful for 32-bit applications that want to gain access to the native system32 directory. By
     *     default, WOW64 file system redirection is enabled.
     * 
     * <div class="alert"><b>Note</b>  The
     *      <b>Wow64EnableWow64FsRedirection</b>
     *      function affects all file operations performed by the current thread, which can have unintended consequences if
     *      file system redirection is disabled for any length of time. For example, DLL loading depends on file system
     *      redirection, so disabling file system redirection will cause DLL loading to fail. Also, many feature
     *      implementations use delayed loading and will fail while redirection is disabled. The failure state of the initial
     *      delay-load operation is persisted, so any subsequent use of the delay-load function will fail even after file
     *      system redirection is re-enabled. To avoid these problems, disable file system redirection immediately before
     *      calls to specific file I/O functions (such as <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>)
     *      that must not be redirected, and re-enable file system redirection immediately afterward using
     *      <c>Wow64EnableWow64FsRedirection(TRUE)</c>.</div>
     * <div> </div>
     * File redirection is enabled or disabled only for the thread calling this function. This affects only
     *     operations made by the current thread. Some functions, such as
     *     <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a>, do their work on another
     *     thread, which is not affected by the state of file system redirection in the calling thread.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Wow64FsEnableRedirection Indicates the type of request for WOW64 system folder redirection. If
     *       <b>TRUE</b>, requests redirection be enabled; if <b>FALSE</b>, requests
     *       redirection be disabled.
     * @returns {Integer} Boolean value indicating whether the function succeeded. If <b>TRUE</b>, the function
     *       succeeded; if <b>FALSE</b>, the function failed.
     * @see https://learn.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64enablewow64fsredirection
     * @since windows6.0.6000
     */
    static Wow64EnableWow64FsRedirection(Wow64FsEnableRedirection) {
        result := DllCall("KERNEL32.dll\Wow64EnableWow64FsRedirection", "char", Wow64FsEnableRedirection, "char")
        return result
    }

    /**
     * Disables file system redirection for the calling thread. File system redirection is enabled by default.
     * @remarks
     * This function is useful for 32-bit applications that want to gain access to the native system32 directory. By 
     *     default, WOW64 file system redirection is enabled.
     * 
     * The 
     *     <b>Wow64DisableWow64FsRedirection</b>/<a href="https://docs.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> 
     *     function pairing is a replacement for the functionality of the 
     *     <a href="https://docs.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64enablewow64fsredirection">Wow64EnableWow64FsRedirection</a> 
     *     function.
     * 
     * To restore file system redirection, call the 
     *     <a href="https://docs.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> 
     *     function. Every successful call to the 
     *     <b>Wow64DisableWow64FsRedirection</b> function 
     *     must have a matching call to the 
     *     <b>Wow64RevertWow64FsRedirection</b> 
     *     function. This will ensure redirection is re-enabled and frees associated system resources.
     * 
     * <div class="alert"><b>Note</b>  The <b>Wow64DisableWow64FsRedirection</b> 
     *      function affects all file operations performed by the current thread, which can have unintended consequences if 
     *      file system redirection is disabled for any length of time. For example, DLL loading depends on file system 
     *      redirection, so disabling file system redirection will cause DLL loading to fail. Also, many feature 
     *      implementations use delayed loading and will fail while redirection is disabled. The failure state of the initial 
     *      delay-load operation is persisted, so any subsequent use of the delay-load function will fail even after file 
     *      system redirection is re-enabled. To avoid these problems, disable file system redirection immediately before 
     *      calls to specific file I/O functions (such as <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>) 
     *      that must not be redirected, and re-enable file system redirection immediately afterward using 
     *      <a href="https://docs.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a>.</div>
     * <div> </div>
     * Disabling file system redirection affects only operations made by the current thread. Some functions, such as 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessasusera">CreateProcessAsUser</a>, do their work on another 
     *     thread, which is not affected by the state of file system redirection in the calling thread.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} OldValue The WOW64 file system redirection value. The system uses this parameter to store information necessary to 
     *        revert (re-enable) file system redirection.
     * 
     * <div class="alert"><b>Note</b>  This value is for system use only. To avoid unpredictable behavior, do not modify this value in any 
     *        way.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection
     * @since windows6.0.6000
     */
    static Wow64DisableWow64FsRedirection(OldValue) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\Wow64DisableWow64FsRedirection", "ptr", OldValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Restores file system redirection for the calling thread.
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a>/<b>Wow64RevertWow64FsRedirection</b> function pair is a replacement for the functionality of the <a href="https://docs.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64enablewow64fsredirection">Wow64EnableWow64FsRedirection</a> function.
     * 
     * To disable file system redirection, call the [Wow64DisableWow64FsRedirection](/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection) function. Every call to the **Wow64DisableWow64FsRedirection** function must have a matching call to the  **Wow64RevertWow64FsRedirection** function. This will ensure redirection is re-enabled and frees associated system resources.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} OlValue The WOW64 file system redirection value. This value is obtained from the <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a> function.
     * @returns {Integer} If the function succeeds, the return value is a nonzero value.
     * 
     * If the function fails, the return value is <b>FALSE</b> (zero). To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection
     * @since windows6.0.6000
     */
    static Wow64RevertWow64FsRedirection(OlValue) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\Wow64RevertWow64FsRedirection", "ptr", OlValue, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file. (ANSI)
     * @remarks
     * As an alternative, you can obtain the same information by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shgetfileinfoa">SHGetFileInfo</a> function, passing the 
     *     <b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the target file is 
     *     used.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpApplicationName The full path of the file whose executable type is to be determined.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<UInt32>} lpBinaryType A pointer to a variable to receive information about the executable type of the file specified by 
     *       <i>lpApplicationName</i>. The following constants are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_32BIT_BINARY"></a><a id="scs_32bit_binary"></a><dl>
     * <dt><b>SCS_32BIT_BINARY</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 32-bit Windows-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_64BIT_BINARY"></a><a id="scs_64bit_binary"></a><dl>
     * <dt><b>SCS_64BIT_BINARY</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 64-bit Windows-based application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_DOS_BINARY"></a><a id="scs_dos_binary"></a><dl>
     * <dt><b>SCS_DOS_BINARY</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_OS216_BINARY"></a><a id="scs_os216_binary"></a><dl>
     * <dt><b>SCS_OS216_BINARY</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit OS/2-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_PIF_BINARY"></a><a id="scs_pif_binary"></a><dl>
     * <dt><b>SCS_PIF_BINARY</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A PIF file that executes an MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_POSIX_BINARY"></a><a id="scs_posix_binary"></a><dl>
     * <dt><b>SCS_POSIX_BINARY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A POSIX – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_WOW_BINARY"></a><a id="scs_wow_binary"></a><dl>
     * <dt><b>SCS_WOW_BINARY</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit Windows-based application
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the file is executable, the return value is nonzero. The function sets the variable pointed to by 
     *        <i>lpBinaryType</i> to indicate the file's executable type.
     * 
     * If the file is not executable, or if the function fails, the return value is zero. To get extended error 
     *        information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the file is a DLL, 
     *        the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getbinarytypea
     * @since windows5.1.2600
     */
    static GetBinaryTypeA(lpApplicationName, lpBinaryType) {
        lpApplicationName := lpApplicationName is String? StrPtr(lpApplicationName) : lpApplicationName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetBinaryTypeA", "ptr", lpApplicationName, "uint*", lpBinaryType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file. (Unicode)
     * @remarks
     * As an alternative, you can obtain the same information by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shgetfileinfoa">SHGetFileInfo</a> function, passing the 
     *     <b>SHGFI_EXETYPE</b> flag in the <i>uFlags</i> parameter.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the target file is 
     *     used.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetBinaryType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpApplicationName The full path of the file whose executable type is to be determined.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<UInt32>} lpBinaryType A pointer to a variable to receive information about the executable type of the file specified by 
     *       <i>lpApplicationName</i>. The following constants are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_32BIT_BINARY"></a><a id="scs_32bit_binary"></a><dl>
     * <dt><b>SCS_32BIT_BINARY</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 32-bit Windows-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_64BIT_BINARY"></a><a id="scs_64bit_binary"></a><dl>
     * <dt><b>SCS_64BIT_BINARY</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 64-bit Windows-based application.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_DOS_BINARY"></a><a id="scs_dos_binary"></a><dl>
     * <dt><b>SCS_DOS_BINARY</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_OS216_BINARY"></a><a id="scs_os216_binary"></a><dl>
     * <dt><b>SCS_OS216_BINARY</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit OS/2-based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_PIF_BINARY"></a><a id="scs_pif_binary"></a><dl>
     * <dt><b>SCS_PIF_BINARY</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A PIF file that executes an MS-DOS – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_POSIX_BINARY"></a><a id="scs_posix_binary"></a><dl>
     * <dt><b>SCS_POSIX_BINARY</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A POSIX – based application
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SCS_WOW_BINARY"></a><a id="scs_wow_binary"></a><dl>
     * <dt><b>SCS_WOW_BINARY</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 16-bit Windows-based application
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the file is executable, the return value is nonzero. The function sets the variable pointed to by 
     *        <i>lpBinaryType</i> to indicate the file's executable type.
     * 
     * If the file is not executable, or if the function fails, the return value is zero. To get extended error 
     *        information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the file is a DLL, 
     *        the last error code is <b>ERROR_BAD_EXE_FORMAT</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getbinarytypew
     * @since windows5.1.2600
     */
    static GetBinaryTypeW(lpApplicationName, lpBinaryType) {
        lpApplicationName := lpApplicationName is String? StrPtr(lpApplicationName) : lpApplicationName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetBinaryTypeW", "ptr", lpApplicationName, "uint*", lpBinaryType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the short path form of the specified path. (GetShortPathNameA)
     * @remarks
     * The path that the <i>lpszLongPath</i> parameter specifies does not have to be a full or 
     *     long path. The short form can be longer than the specified path.
     * 
     * If the return value is greater than the value specified in the <i>cchBuffer</i> parameter, 
     *     you can call the function again with a buffer that is large enough to hold the path. For an example of this case 
     *     in addition to using zero-length buffer for dynamic allocation, see the Example Code section.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * If the specified path is already in its short form  and conversion is not needed, the function simply copies 
     *     the specified path to the buffer specified by the <i>lpszShortPath</i> parameter.
     * 
     * You can set the <i>lpszShortPath</i> parameter to the same value as the 
     *     <i>lpszLongPath</i> parameter; in other words, you can set the output buffer for the short path 
     *     to the address of the input path string. Always ensure that the <i>cchBuffer</i> parameter 
     *     accurately represents the total size, in <b>TCHARs</b>, of this buffer.
     * 
     * You can obtain the long name of a file from the short name by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlongpathnamea">GetLongPathName</a> function. Alternatively, where 
     *     <b>GetLongPathName</b> is not available, you can call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea">FindFirstFile</a> on each component of the path to get the 
     *     corresponding long name.
     * 
     * It is possible to have access to a file or directory but not have access to some of the parent directories of 
     *     that file or directory. As a result, <b>GetShortPathName</b> 
     *     may fail when it is unable to query the parent directory of a path component  to determine the short name for that 
     *     component. This check can be skipped for directory components that already meet the requirements of a short name. 
     *     For more information, see the 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support short names on shares with continuous availability capability.
     * 
     * Resilient File System (ReFS) doesn't support short names. If you call <b>GetShortPathName</b> on a path that doesn't have any short names on-disk, the call will succeed, but will return the long-name path instead. This outcome is also possible with NTFS volumes because there's no guarantee that a short name will exist for a given long name.
     * @param {Pointer<Byte>} lpszLongPath The path string.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * @param {Pointer<Byte>} lpszShortPath A pointer to a buffer to receive the null-terminated short form of the path that 
     *        <i>lpszLongPath</i> specifies.
     * 
     * Passing <b>NULL</b> for this parameter and zero for <i>cchBuffer</i> 
     *        will always return the required buffer size for a specified <i>lpszLongPath</i>.
     * @param {Integer} cchBuffer The size of the buffer  that <i>lpszShortPath</i> points to, in 
     *        <b>TCHARs</b>.
     * 
     * Set this parameter to zero if <i>lpszShortPath</i> is set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string that is copied to <i>lpszShortPath</i>, not including the terminating null 
     *        character.
     * 
     * If the <i>lpszShortPath</i> buffer is too small to contain the path, the return value is 
     *        the size of the buffer, in <b>TCHARs</b>, that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getshortpathnamea
     * @since windows5.1.2600
     */
    static GetShortPathNameA(lpszLongPath, lpszShortPath, cchBuffer) {
        lpszLongPath := lpszLongPath is String? StrPtr(lpszLongPath) : lpszLongPath
        lpszShortPath := lpszShortPath is String? StrPtr(lpszShortPath) : lpszShortPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetShortPathNameA", "ptr", lpszLongPath, "ptr", lpszShortPath, "uint", cchBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form as a transacted operation. (ANSI)
     * @remarks
     * On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow 
     *     this convention. Therefore, do not assume that you can skip calling 
     *     <b>GetLongPathNameTransacted</b> if the path does not 
     *     contain a tilde (~) character.
     * 
     * If a long path is not found, this function returns the name specified in the 
     *     <i>lpszShortPath</i> parameter in the <i>lpszLongPath</i> parameter.
     * 
     * If the return value is greater than the value specified in <i>cchBuffer</i>, you can call 
     *     the function again with a buffer that is large enough to hold the path. For an example of this case, see the 
     *     Example Code section for <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a>.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * It is possible to have access to a file or directory but not have access to some of the parent directories of 
     *     that file or directory. As a result, 
     *     <b>GetLongPathNameTransacted</b> may fail when it is 
     *     unable to query the parent directory of a path component to determine the long name for that component. This check 
     *     can be skipped for directory components that have file extensions longer than 3 characters, or total lengths 
     *     longer than 12 characters. For more information, see the 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetLongPathNameTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> (260) 
     *        characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and 
     *        prepend "\\?\" to the path. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * The path must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Byte>} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHAR</b>s.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHAR</b>s, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHAR</b>s, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not exist, the return value is zero. To 
     *        get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getlongpathnametransacteda
     * @since windows6.0.6000
     */
    static GetLongPathNameTransactedA(lpszShortPath, lpszLongPath, cchBuffer, hTransaction) {
        lpszShortPath := lpszShortPath is String? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String? StrPtr(lpszLongPath) : lpszLongPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameTransactedA", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts the specified path to its long form as a transacted operation. (Unicode)
     * @remarks
     * On many file systems, a short file name contains a tilde (~) character. However, not all file systems follow 
     *     this convention. Therefore, do not assume that you can skip calling 
     *     <b>GetLongPathNameTransacted</b> if the path does not 
     *     contain a tilde (~) character.
     * 
     * If a long path is not found, this function returns the name specified in the 
     *     <i>lpszShortPath</i> parameter in the <i>lpszLongPath</i> parameter.
     * 
     * If the return value is greater than the value specified in <i>cchBuffer</i>, you can call 
     *     the function again with a buffer that is large enough to hold the path. For an example of this case, see the 
     *     Example Code section for <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a>.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * It is possible to have access to a file or directory but not have access to some of the parent directories of 
     *     that file or directory. As a result, 
     *     <b>GetLongPathNameTransacted</b> may fail when it is 
     *     unable to query the parent directory of a path component to determine the long name for that component. This check 
     *     can be skipped for directory components that have file extensions longer than 3 characters, or total lengths 
     *     longer than 12 characters. For more information, see the 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Short vs. Long Names</a> section of 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetLongPathNameTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpszShortPath The path to be converted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> (260) 
     *        characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and 
     *        prepend "\\?\" to the path. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * The path must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Char>} lpszLongPath A pointer to the buffer to receive the long path.
     * 
     * You can use the same buffer you used for the <i>lpszShortPath</i> parameter.
     * @param {Integer} cchBuffer The size of the buffer <i>lpszLongPath</i> points to, in 
     *       <b>TCHAR</b>s.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHAR</b>s, of the 
     *        string copied to <i>lpszLongPath</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHAR</b>s, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, such as if the file does not exist, the return value is zero. To 
     *        get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getlongpathnametransactedw
     * @since windows6.0.6000
     */
    static GetLongPathNameTransactedW(lpszShortPath, lpszLongPath, cchBuffer, hTransaction) {
        lpszShortPath := lpszShortPath is String? StrPtr(lpszShortPath) : lpszShortPath
        lpszLongPath := lpszLongPath is String? StrPtr(lpszLongPath) : lpszLongPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLongPathNameTransactedW", "ptr", lpszShortPath, "ptr", lpszLongPath, "uint", cchBuffer, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the notification modes for a file handle, allowing you to specify how completion notifications work for the specified file.
     * @remarks
     * To compile an application that uses this function, define the <b>_WIN32_WINNT</b> macro 
     *     as 0x0600 or later. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} FileHandle A handle to the file.
     * @param {Integer} Flags The modes to be set.  One or more modes can be set at the same time; however, after a mode has been set for 
     *       a file handle, it cannot be removed.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SKIP_COMPLETION_PORT_ON_SUCCESS"></a><a id="file_skip_completion_port_on_success"></a><dl>
     * <dt><b>FILE_SKIP_COMPLETION_PORT_ON_SUCCESS</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the following three conditions are true, the I/O Manager does not queue a completion entry to the port, 
     *          when it would ordinarily do so. The conditions are:
     *          <ul>
     * <li>A completion port is associated with the file handle.</li>
     * <li>The file is opened for asynchronous I/O.</li>
     * <li>A request returns success immediately without returning 
     *            <b>ERROR_PENDING</b>.</li>
     * </ul>
     * 
     * 
     * When the <i>FileHandle</i> parameter is a socket, this mode is only compatible with 
     *          Layered Service Providers (LSP) that return Installable File Systems (IFS) handles. To detect whether a 
     *          non-IFS LSP is installed, use the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function and examine the 
     *          <b>dwServiceFlag1</b> member in each returned 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. If the 
     *          <b>XP1_IFS_HANDLES</b> (0x20000) bit is cleared then the specified LSP is not an IFS LSP. 
     *          Vendors that have non-IFS LSPs are encouraged to migrate to the 
     *          <a href="https://docs.microsoft.com/windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a> 
     *          (WFP).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SKIP_SET_EVENT_ON_HANDLE"></a><a id="file_skip_set_event_on_handle"></a><dl>
     * <dt><b>FILE_SKIP_SET_EVENT_ON_HANDLE</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The I/O Manager does not set the event for the file object if a request returns with a success code, or the 
     *          error returned is <b>ERROR_PENDING</b> and the function that is called is not a 
     *          synchronous function.
     * 
     * If an explicit event is provided for the request, it is still signaled.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setfilecompletionnotificationmodes
     * @since windows6.0.6000
     */
    static SetFileCompletionNotificationModes(FileHandle, Flags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileCompletionNotificationModes", "ptr", FileHandle, "char", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the short name for the specified file. (ANSI)
     * @remarks
     * The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more 
     *     information, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hFile A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access 
     *        right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the 
     *        <b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.
     * @param {Pointer<Byte>} lpShortName A pointer to a string that specifies the short name for the file.
     * 
     *  Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.
     * 
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     *       <b>GetLastError</b> may return one of the following error 
     *        codes that are specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified short name is not unique.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setfileshortnamea
     * @since windows5.1.2600
     */
    static SetFileShortNameA(hFile, lpShortName) {
        lpShortName := lpShortName is String? StrPtr(lpShortName) : lpShortName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileShortNameA", "ptr", hFile, "ptr", lpShortName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the short name for the specified file. (Unicode)
     * @remarks
     * The caller of this function must have the <b>SE_RESTORE_NAME</b> privilege. For more 
     *     information, see <a href="https://docs.microsoft.com/windows/desktop/SecBP/running-with-special-privileges">Running with Special Privileges</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support short names on shares with continuous availability capability . Short names are not recommended on CsvFs.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines SetFileShortName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hFile A handle to the file. The file must be opened with either the <b>GENERIC_ALL</b> access 
     *        right or <b>GENERIC_WRITE</b>|<b>DELETE</b>, and with the 
     *        <b>FILE_FLAG_BACKUP_SEMANTICS</b> file attribute.
     * @param {Pointer<Char>} lpShortName A pointer to a string that specifies the short name for the file.
     * 
     *  Specifying  an empty (zero-length) string will remove the short file name, if it exists for the file specified by the <i>hFile</i> parameter. If  a short file name does not exist, the function will do nothing and return success.
     * 
     * 
     * <b>Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>This behavior is not supported. The parameter must contain a valid string of one or more characters.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. 
     *       <b>GetLastError</b> may return one of the following error 
     *        codes that are specific to this function.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified short name is not unique.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the specified file has been opened in case-sensitive mode or the specified short name is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setfileshortnamew
     * @since windows5.1.2600
     */
    static SetFileShortNameW(hFile, lpShortName) {
        lpShortName := lpShortName is String? StrPtr(lpShortName) : lpShortName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileShortNameW", "ptr", hFile, "ptr", lpShortName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the tape position on the specified device.
     * @remarks
     * If the offset specified by <i>dwOffsetLow</i> and <i>dwOffsetHigh</i> specifies the number of blocks, filemarks, or setmarks to move, a positive offset moves the tape forward to the end of the last block, filemark, or setmark. A negative offset moves the tape backward to the beginning of the last block, filemark, or setmark. If the offset is zero, the tape does not move.
     * 
     * To obtain information about the status, capabilities, and capacities of tape drives and media, call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-gettapeparameters">GetTapeParameters</a> function.
     * @param {Pointer<Void>} hDevice Handle to the device on which to set the tape position. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwPositionMethod 
     * @param {Integer} dwPartition Partition to position within. If <i>dwPartition</i> is zero, the current partition is used. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last.
     * @param {Integer} dwOffsetLow Low-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter.
     * @param {Integer} dwOffsetHigh High-order bits of the block address or count for the position operation specified by the <i>dwPositionMethod</i> parameter. If the high-order bits are not required, this parameter should be zero.
     * @param {Integer} bImmediate Indicates whether to return as soon as the move operation begins. If this parameter is <b>TRUE</b>, the function returns immediately; if <b>FALSE</b>, the function does not return until the move operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-settapeposition
     * @since windows5.1.2600
     */
    static SetTapePosition(hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate) {
        result := DllCall("KERNEL32.dll\SetTapePosition", "ptr", hDevice, "uint", dwPositionMethod, "uint", dwPartition, "uint", dwOffsetLow, "uint", dwOffsetHigh, "int", bImmediate, "uint")
        return result
    }

    /**
     * Retrieves the current address of the tape, in logical or absolute blocks.
     * @remarks
     * A logical block address is relative to a partition. The first logical block address on each partition is zero.
     * 
     * Call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-gettapeparameters">GetTapeParameters</a> function to obtain information about the status, capabilities, and capacities of tape drives and media.
     * @param {Pointer<Void>} hDevice Handle to the device on which to get the tape position. This handle is created by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>.
     * @param {Integer} dwPositionType 
     * @param {Pointer<UInt32>} lpdwPartition Pointer to a variable that receives the number of the current tape partition. Partitions are numbered logically from 1 through n, where 1 is the first partition on the tape and n is the last. When a device-specific block address is retrieved, or if the device supports only one partition, this parameter receives zero.
     * @param {Pointer<UInt32>} lpdwOffsetLow Pointer to a variable that receives the low-order bits of the current tape position.
     * @param {Pointer<UInt32>} lpdwOffsetHigh Pointer to a variable that receives the high-order bits of the current tape position. This parameter can be <b>NULL</b> if the high-order bits are not required.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-gettapeposition
     * @since windows5.1.2600
     */
    static GetTapePosition(hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh) {
        result := DllCall("KERNEL32.dll\GetTapePosition", "ptr", hDevice, "uint", dwPositionType, "uint*", lpdwPartition, "uint*", lpdwOffsetLow, "uint*", lpdwOffsetHigh, "uint")
        return result
    }

    /**
     * Prepares the tape to be accessed or removed.
     * @remarks
     * Some tape devices do not support certain tape operations. See your tape device documentation and use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-gettapeparameters">GetTapeParameters</a> function to determine your tape device's capabilities.
     * @param {Pointer<Void>} hDevice Handle to the device preparing the tape. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwOperation 
     * @param {Integer} bImmediate If this parameter is <b>TRUE</b>, the function returns immediately. If it is <b>FALSE</b>, the function does not return until the operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-preparetape
     * @since windows5.1.2600
     */
    static PrepareTape(hDevice, dwOperation, bImmediate) {
        result := DllCall("KERNEL32.dll\PrepareTape", "ptr", hDevice, "uint", dwOperation, "int", bImmediate, "uint")
        return result
    }

    /**
     * Erases all or part of a tape.
     * @remarks
     * Some tape devices do not support certain tape operations. To determine your tape device's capabilities, see your tape device documentation and use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-gettapeparameters">GetTapeParameters</a> function.
     * @param {Pointer<Void>} hDevice Handle to the device where the tape is to be erased. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwEraseType 
     * @param {Integer} bImmediate If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the erase operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-erasetape
     * @since windows5.1.2600
     */
    static EraseTape(hDevice, dwEraseType, bImmediate) {
        result := DllCall("KERNEL32.dll\EraseTape", "ptr", hDevice, "uint", dwEraseType, "int", bImmediate, "uint")
        return result
    }

    /**
     * Reformats a tape.
     * @remarks
     * Creating partitions reformats the tape. All previous information recorded on the tape is destroyed.
     * @param {Pointer<Void>} hDevice Handle to the device where the new partition is to be created. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwPartitionMethod 
     * @param {Integer} dwCount Number of partitions to create. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-gettapeparameters">GetTapeParameters</a> function provides the maximum number of partitions a tape can support.
     * @param {Integer} dwSize Size of each partition, in megabytes. This value is ignored if the <i>dwPartitionMethod</i> parameter is <b>TAPE_SELECT_PARTITIONS</b>.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createtapepartition
     * @since windows5.1.2600
     */
    static CreateTapePartition(hDevice, dwPartitionMethod, dwCount, dwSize) {
        result := DllCall("KERNEL32.dll\CreateTapePartition", "ptr", hDevice, "uint", dwPartitionMethod, "uint", dwCount, "uint", dwSize, "uint")
        return result
    }

    /**
     * Writes a specified number of filemarks, setmarks, short filemarks, or long filemarks to a tape device.
     * @remarks
     * Filemarks, setmarks, short filemarks, and long filemarks are special recorded elements that denote the linear organization of the tape. None of these marks contain user data. Filemarks are the most general marks; setmarks provide a hierarchy not available with filemarks.
     * 
     * A short filemark contains a short erase gap that cannot be overwritten unless the write operation is performed from the beginning of the partition or from an earlier long filemark.
     * 
     * A long filemark contains a long erase gap that allows an application to position the tape at the beginning of the filemark and to overwrite the filemark and the erase gap.
     * @param {Pointer<Void>} hDevice Handle to the device on which to write tapemarks. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwTapemarkType 
     * @param {Integer} dwTapemarkCount Number of tapemarks to write.
     * @param {Integer} bImmediate If this parameter is <b>TRUE</b>, the function returns immediately; if it is <b>FALSE</b>, the function does not return until the operation has been completed.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-writetapemark
     * @since windows5.1.2600
     */
    static WriteTapemark(hDevice, dwTapemarkType, dwTapemarkCount, bImmediate) {
        result := DllCall("KERNEL32.dll\WriteTapemark", "ptr", hDevice, "uint", dwTapemarkType, "uint", dwTapemarkCount, "int", bImmediate, "uint")
        return result
    }

    /**
     * Determines whether the tape device is ready to process tape commands.
     * @param {Pointer<Void>} hDevice Handle to the device for which to get the device status. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @returns {Integer} If the tape device is ready to accept appropriate tape-access commands without returning errors, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_REQUIRES_CLEANING</b></dt>
     * <dt>1165L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape drive is capable of reporting that it requires cleaning, and reports that it does require cleaning.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-gettapestatus
     * @since windows5.1.2600
     */
    static GetTapeStatus(hDevice) {
        result := DllCall("KERNEL32.dll\GetTapeStatus", "ptr", hDevice, "uint")
        return result
    }

    /**
     * Retrieves information that describes the tape or the tape drive.
     * @remarks
     * The block size range values (maximum and minimum) returned by the 
     * <b>GetTapeParameters</b> function called with the <i>dwOperation</i> parameter set to the <b>GET_TAPE_DRIVE_INFORMATION</b> value will indicate system limits, not drive limits. However, it is the tape drive device and the media present in the drive that determine the true block size limits. Thus, an application may not be able to set all the block sizes mentioned in the range obtained by specifying <b>GET_TAPE_DRIVE_INFORMATION</b> in <i>dwOperation</i>.
     * @param {Pointer<Void>} hDevice Handle to the device about which information is sought. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwOperation 
     * @param {Pointer<UInt32>} lpdwSize Pointer to a variable that receives the size, in bytes, of the buffer specified by the <i>lpTapeInformation</i> parameter. If the buffer is too small, this parameter receives the required size.
     * @param {Pointer} lpTapeInformation Pointer to a structure that contains the requested information. If the <i>dwOperation</i> parameter is <b>GET_TAPE_MEDIA_INFORMATION</b>, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_get_media_parameters">TAPE_GET_MEDIA_PARAMETERS</a> structure.
     * 
     * If <i>dwOperation</i> is <b>GET_TAPE_DRIVE_INFORMATION</b>, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_get_drive_parameters">TAPE_GET_DRIVE_PARAMETERS</a> structure.
     * @returns {Integer} If the function succeeds, the return value is <b>NO_ERROR</b>.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-gettapeparameters
     * @since windows5.1.2600
     */
    static GetTapeParameters(hDevice, dwOperation, lpdwSize, lpTapeInformation) {
        result := DllCall("KERNEL32.dll\GetTapeParameters", "ptr", hDevice, "uint", dwOperation, "uint*", lpdwSize, "ptr", lpTapeInformation, "uint")
        return result
    }

    /**
     * Specifies the block size of a tape or configures the tape device.
     * @param {Pointer<Void>} hDevice Handle to the device for which to set configuration information. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwOperation 
     * @param {Pointer<Void>} lpTapeInformation Pointer to a structure that contains the information to set. If the <i>dwOperation</i> parameter is SET_TAPE_MEDIA_INFORMATION, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_set_media_parameters">TAPE_SET_MEDIA_PARAMETERS</a> structure. 
     * 
     * 
     * 
     * 
     * If <i>dwOperation</i> is SET_TAPE_DRIVE_INFORMATION, <i>lpTapeInformation</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-tape_set_drive_parameters">TAPE_SET_DRIVE_PARAMETERS</a> structure.
     * @returns {Integer} If the function succeeds, the return value is NO_ERROR.
     * 
     * If the function fails, it can return one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BEGINNING_OF_MEDIA</b></dt>
     * <dt>1102L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to access data before the beginning-of-medium marker failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_BUS_RESET</b></dt>
     * <dt>1111L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reset condition was detected on the bus.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_DEVICE_NOT_PARTITIONED</b></dt>
     * <dt>1107L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The partition information could not be found when a tape was being loaded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_END_OF_MEDIA</b></dt>
     * <dt>1100L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-tape marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_FILEMARK_DETECTED</b></dt>
     * <dt>1101L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A filemark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_BLOCK_LENGTH</b></dt>
     * <dt>1106L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The block size is incorrect on a new tape in a multivolume partition.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_MEDIA_CHANGED</b></dt>
     * <dt>1110L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape that was in the drive has been replaced or removed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_DATA_DETECTED</b></dt>
     * <dt>1104L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The end-of-data marker was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NO_MEDIA_IN_DRIVE</b></dt>
     * <dt>1112L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no media in the drive.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_NOT_SUPPORTED</b></dt>
     * <dt>50L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape driver does not support a requested function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PARTITION_FAILURE</b></dt>
     * <dt>1105L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The tape could not be partitioned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SETMARK_DETECTED</b></dt>
     * <dt>1103L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A setmark was reached during an operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_LOCK_MEDIA</b></dt>
     * <dt>1108L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to lock the ejection mechanism failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_UNLOAD_MEDIA</b></dt>
     * <dt>1109L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to unload the tape failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_WRITE_PROTECT</b></dt>
     * <dt>19L</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The media is write protected.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-settapeparameters
     * @since windows5.1.2600
     */
    static SetTapeParameters(hDevice, dwOperation, lpTapeInformation) {
        result := DllCall("KERNEL32.dll\SetTapeParameters", "ptr", hDevice, "uint", dwOperation, "ptr", lpTapeInformation, "uint")
        return result
    }

    /**
     * Encrypts a file or directory. (ANSI)
     * @remarks
     * The <b>EncryptFile</b> function requires exclusive access to 
     *     the file being encrypted, and will fail if another process is using the file.
     * 
     * If the file is already encrypted, <b>EncryptFile</b> simply 
     *     returns a nonzero value, which indicates success. If the file is compressed, 
     *     <b>EncryptFile</b> will decompress the file before encrypting 
     *     it.
     * 
     * If <i>lpFileName</i> specifies a read-only file, the function fails and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that 
     *     contains a read-only file, the functions succeeds but the directory is not encrypted.
     * 
     * To decrypt an encrypted file, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-decryptfilea">DecryptFile</a> function.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file or directory to be encrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, 
     *        <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-encryptfilea
     * @since windows5.1.2600
     */
    static EncryptFileA(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\EncryptFileA", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Encrypts a file or directory. (Unicode)
     * @remarks
     * The <b>EncryptFile</b> function requires exclusive access to 
     *     the file being encrypted, and will fail if another process is using the file.
     * 
     * If the file is already encrypted, <b>EncryptFile</b> simply 
     *     returns a nonzero value, which indicates success. If the file is compressed, 
     *     <b>EncryptFile</b> will decompress the file before encrypting 
     *     it.
     * 
     * If <i>lpFileName</i> specifies a read-only file, the function fails and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that 
     *     contains a read-only file, the functions succeeds but the directory is not encrypted.
     * 
     * To decrypt an encrypted file, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-decryptfilea">DecryptFile</a> function.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines EncryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file or directory to be encrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, 
     *        <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-encryptfilew
     * @since windows5.1.2600
     */
    static EncryptFileW(lpFileName) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\EncryptFileW", "ptr", lpFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decrypts an encrypted file or directory. (ANSI)
     * @remarks
     * The 
     * <b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted, 
     * <b>DecryptFile</b> simply returns a nonzero value, which indicates success.
     * 
     * If <i>lpFileName</i> specifies a read-only file, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file or directory to be decrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-decryptfilea
     * @since windows5.1.2600
     */
    static DecryptFileA(lpFileName) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\DecryptFileA", "ptr", lpFileName, "uint", dwReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Decrypts an encrypted file or directory. (Unicode)
     * @remarks
     * The 
     * <b>DecryptFile</b> function requires exclusive access to the file being decrypted, and will fail if another process is using the file. If the file is not encrypted, 
     * <b>DecryptFile</b> simply returns a nonzero value, which indicates success.
     * 
     * If <i>lpFileName</i> specifies a read-only file, the function fails and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_FILE_READ_ONLY</b>. If <i>lpFileName</i> specifies a directory that contains a read-only file, the functions succeeds but the directory is not decrypted.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines DecryptFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file or directory to be decrypted.
     * 
     * The caller must have the <b>FILE_READ_DATA</b>, <b>FILE_WRITE_DATA</b>, <b>FILE_READ_ATTRIBUTES</b>, <b>FILE_WRITE_ATTRIBUTES</b>, and <b>SYNCHRONIZE</b> access rights. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-decryptfilew
     * @since windows5.1.2600
     */
    static DecryptFileW(lpFileName) {
        static dwReserved := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\DecryptFileW", "ptr", lpFileName, "uint", dwReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the encryption status of the specified file. (ANSI)
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file.
     * @param {Pointer<UInt32>} lpStatus A pointer to a variable that receives the encryption status of the file. This parameter can be one of the 
     *       following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ENCRYPTABLE"></a><a id="file_encryptable"></a><dl>
     * <dt><b>FILE_ENCRYPTABLE</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file can be encrypted.
     *         
     * 
     * <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on 
     *           these editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_IS_ENCRYPTED"></a><a id="file_is_encrypted"></a><dl>
     * <dt><b>FILE_IS_ENCRYPTED</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY"></a><a id="file_read_only"></a><dl>
     * <dt><b>FILE_READ_ONLY</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a read-only file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ROOT_DIR"></a><a id="file_root_dir"></a><dl>
     * <dt><b>FILE_ROOT_DIR</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a root directory. Root directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_ATTR"></a><a id="file_system_attr"></a><dl>
     * <dt><b>FILE_SYSTEM_ATTR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system file. System files cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_DIR"></a><a id="file_system_dir"></a><dl>
     * <dt><b>FILE_SYSTEM_DIR</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system directory. System directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_NOT_SUPPORT"></a><a id="file_system_not_support"></a><dl>
     * <dt><b>FILE_SYSTEM_NOT_SUPPORT</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system does not support file encryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNKNOWN"></a><a id="file_unknown"></a><dl>
     * <dt><b>FILE_UNKNOWN</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The encryption status is unknown. The file may be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_USER_DISALLOWED"></a><a id="file_user_disallowed"></a><dl>
     * <dt><b>FILE_USER_DISALLOWED</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reserved for future use.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-fileencryptionstatusa
     * @since windows5.1.2600
     */
    static FileEncryptionStatusA(lpFileName, lpStatus) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\FileEncryptionStatusA", "ptr", lpFileName, "uint*", lpStatus, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the encryption status of the specified file. (Unicode)
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FileEncryptionStatus as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file.
     * @param {Pointer<UInt32>} lpStatus A pointer to a variable that receives the encryption status of the file. This parameter can be one of the 
     *       following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ENCRYPTABLE"></a><a id="file_encryptable"></a><dl>
     * <dt><b>FILE_ENCRYPTABLE</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file can be encrypted.
     *         
     * 
     * <b>Home, Home Premium, Starter, and ARM Editions of Windows:  </b><b>FILE_ENCRYPTABLE</b> may be returned but EFS does not support encrypting files on 
     *           these editions of Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_IS_ENCRYPTED"></a><a id="file_is_encrypted"></a><dl>
     * <dt><b>FILE_IS_ENCRYPTED</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_READ_ONLY"></a><a id="file_read_only"></a><dl>
     * <dt><b>FILE_READ_ONLY</b></dt>
     * <dt>8</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a read-only file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ROOT_DIR"></a><a id="file_root_dir"></a><dl>
     * <dt><b>FILE_ROOT_DIR</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a root directory. Root directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_ATTR"></a><a id="file_system_attr"></a><dl>
     * <dt><b>FILE_SYSTEM_ATTR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system file. System files cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_DIR"></a><a id="file_system_dir"></a><dl>
     * <dt><b>FILE_SYSTEM_DIR</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is a system directory. System directories cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_SYSTEM_NOT_SUPPORT"></a><a id="file_system_not_support"></a><dl>
     * <dt><b>FILE_SYSTEM_NOT_SUPPORT</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file system does not support file encryption.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_UNKNOWN"></a><a id="file_unknown"></a><dl>
     * <dt><b>FILE_UNKNOWN</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The encryption status is unknown. The file may be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_USER_DISALLOWED"></a><a id="file_user_disallowed"></a><dl>
     * <dt><b>FILE_USER_DISALLOWED</b></dt>
     * <dt>7</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reserved for future use.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-fileencryptionstatusw
     * @since windows5.1.2600
     */
    static FileEncryptionStatusW(lpFileName, lpStatus) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("ADVAPI32.dll\FileEncryptionStatusW", "ptr", lpFileName, "uint*", lpStatus, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens an encrypted file in order to backup (export) or restore (import) the file. (ANSI)
     * @remarks
     * The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.
     * 
     * To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
     *       file and then call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a>. When the backup is
     *       complete, call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.
     * 
     * To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
     *       <b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a> once. When the operation is completed, call
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.
     * 
     * <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.
     * 
     *  If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.
     * 
     * 
     * The  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> functions handle backup and restore of unencrypted files.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file to be opened. The string must consist of characters from the Windows character set.
     * @param {Integer} ulFlags The operation to be performed. This parameter may be one of the
     *          following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Open the file for export
     *                                      (backup).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_IMPORT"></a><a id="create_for_import"></a><dl>
     * <dt><b>CREATE_FOR_IMPORT</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened for import
     *                                      (restore).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_DIR"></a><a id="create_for_dir"></a><dl>
     * <dt><b>CREATE_FOR_DIR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OVERWRITE_HIDDEN"></a><a id="overwrite_hidden"></a><dl>
     * <dt><b>OVERWRITE_HIDDEN</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Overwrite a hidden file on import.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvContext The address of a  context
     *          block that must be presented in subsequent calls to 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a>, or 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.  Do not modify it.
     * @returns {Integer} If the function succeeds, it returns <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in
     *       WinError.h. You can use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the
     *       <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
     *       the error.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-openencryptedfilerawa
     * @since windows5.1.2600
     */
    static OpenEncryptedFileRawA(lpFileName, ulFlags, pvContext) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\OpenEncryptedFileRawA", "ptr", lpFileName, "uint", ulFlags, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Opens an encrypted file in order to backup (export) or restore (import) the file. (Unicode)
     * @remarks
     * The caller must either have read or write access to the file, or it must have backup privilege <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> on the machine on which the files reside in order for the call to succeed.
     * 
     * To back up an encrypted file, call <b>OpenEncryptedFileRaw</b> to open the
     *       file and then call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a>. When the backup is
     *       complete, call <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.
     * 
     * To restore an encrypted file, call <b>OpenEncryptedFileRaw</b>, specifying
     *       <b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter, and then call
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a> once. When the operation is completed, call
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.
     * 
     * <b>OpenEncryptedFileRaw</b> fails if <i>lpFileName</i> exceeds <b>MAX_PATH</b> characters when opening an encrypted file on a remote machine.
     * 
     *  If the caller does not have access to the key for the file, the caller needs <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/authorization-constants">SeBackupPrivilege</a> to export encrypted files or SeRestorePrivilege to import encrypted files.
     * 
     * 
     * The  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> functions handle backup and restore of unencrypted files.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines OpenEncryptedFileRaw as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file to be opened. The string must consist of characters from the Windows character set.
     * @param {Integer} ulFlags The operation to be performed. This parameter may be one of the
     *          following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Open the file for export
     *                                      (backup).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_IMPORT"></a><a id="create_for_import"></a><dl>
     * <dt><b>CREATE_FOR_IMPORT</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened for import
     *                                      (restore).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="CREATE_FOR_DIR"></a><a id="create_for_dir"></a><dl>
     * <dt><b>CREATE_FOR_DIR</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Import (restore) a directory containing encrypted files.  This must be combined with one of the previous two flags to indicate the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="OVERWRITE_HIDDEN"></a><a id="overwrite_hidden"></a><dl>
     * <dt><b>OVERWRITE_HIDDEN</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Overwrite a hidden file on import.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pvContext The address of a  context
     *          block that must be presented in subsequent calls to 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a>, or 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a>.  Do not modify it.
     * @returns {Integer} If the function succeeds, it returns <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in
     *       WinError.h. You can use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the
     *       <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of
     *       the error.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-openencryptedfileraww
     * @since windows5.1.2600
     */
    static OpenEncryptedFileRawW(lpFileName, ulFlags, pvContext) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        result := DllCall("ADVAPI32.dll\OpenEncryptedFileRawW", "ptr", lpFileName, "uint", ulFlags, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Backs up (export) encrypted files.
     * @remarks
     * The file being backed up is not decrypted;  it is backed up in its encrypted state.
     * 
     * To back up an encrypted file, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> to open the file. Then call 
     *      <b>ReadEncryptedFileRaw</b>, passing it the address of an 
     *      application-defined export callback function. The system calls this callback function multiple times until the 
     *      entire file's contents have been read and backed up.  When the backup is complete, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a> to free resources and close 
     *      the file. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a> for details about how to 
     *      declare the export callback function.
     * 
     * To restore an encrypted file, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a>, specifying 
     *      <b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter. Then call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a>, passing it the address of 
     *      an application-defined import callback function. The system calls this callback function multiple times until the 
     *      entire file's contents have been read and restored. When the restore is complete, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a> to free resources and close 
     *      the file. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a> for details about how to 
     *      declare the import callback function.
     * 
     * This function is intended for the backup of only encrypted files; see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> for backup of unencrypted files.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<PFE_EXPORT_FUNC>} pfExportCallback A pointer to the export callback function. The system calls the callback function multiple times, each time 
     *       passing a block of the file's data to the callback function until the entire file has been read. For more 
     *       information, see <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a>.
     * @param {Pointer<Void>} pvCallbackContext A pointer to an application-defined and allocated context block. The system passes this pointer to the 
     *       callback function as a parameter so that the callback function can have access to application-specific data. 
     *       This can be a structure and can contain any data the application needs, such as the handle to the file that will 
     *       contain the backup copy of the encrypted file.
     * @param {Pointer<Void>} pvContext A pointer to a system-defined context block. The context block is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> function. Do not modify 
     *       it.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in WinError.h. You can use 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the 
     *        <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-readencryptedfileraw
     * @since windows5.1.2600
     */
    static ReadEncryptedFileRaw(pfExportCallback, pvCallbackContext, pvContext) {
        result := DllCall("ADVAPI32.dll\ReadEncryptedFileRaw", "ptr", pfExportCallback, "ptr", pvCallbackContext, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Restores (import) encrypted files.
     * @remarks
     * The file being restored is not decrypted;  it is restored in its encrypted state.
     * 
     * To back up an encrypted file, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> to open the file. Then call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a>, passing it the address of an 
     *      application-defined export callback function. The system calls this callback function multiple times until the 
     *      entire file's contents have been read and backed up.  When the backup is complete, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a> to free resources and close 
     *      the file. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_export_func">ExportCallback</a> for details about how to 
     *      declare the export callback function.
     * 
     * To restore an encrypted file, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a>, specifying 
     *      <b>CREATE_FOR_IMPORT</b> in the <i>ulFlags</i> parameter. Then call 
     *      <b>WriteEncryptedFileRaw</b>, passing it the address of 
     *      an application-defined import callback function. The system calls this callback function multiple times until the 
     *      entire file's contents have been read and restored. When the restore is complete, call 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-closeencryptedfileraw">CloseEncryptedFileRaw</a> to free resources and close 
     *      the file. See <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a> for details about how to 
     *      declare the export callback function.
     * 
     * If the file is a sparse file that was backed up from a volume with a smaller sparse allocation unit size than 
     *     the volume it is being restored to, the sparse blocks in the middle of the file may not properly align with the 
     *     larger blocks and the function call would fail and set an <b>ERROR_INVALID_PARAMETER</b> last 
     *     error code. The sparse allocation unit size is either 16 clusters or 64 KB, whichever is smaller.
     * 
     * This function is intended for restoring only encrypted files; see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> for restoring unencrypted files.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<PFE_IMPORT_FUNC>} pfImportCallback A pointer to the import callback function. The system calls the callback function multiple times, each time 
     *       passing a buffer that will be filled by the callback function with a portion of backed-up file's data. When the 
     *       callback function signals that the entire file has been processed, it tells the system that the restore 
     *       operation is finished. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pfe_import_func">ImportCallback</a>.
     * @param {Pointer<Void>} pvCallbackContext A pointer to an application-defined and allocated context block. The system passes this pointer to the 
     *       callback function as a parameter so that the callback function can have access to application-specific data. 
     *       This can be a structure and can contain any data the application needs, such as the handle to the file that will 
     *       contain the backup copy of the encrypted file.
     * @param {Pointer<Void>} pvContext A pointer to a system-defined context block. The context block is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> function. Do not modify 
     *       it.
     * @returns {Integer} If the function succeeds, the return value is <b>ERROR_SUCCESS</b>.
     * 
     * If the function fails, it returns a nonzero error code defined in WinError.h. You can use 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> with the 
     *        <b>FORMAT_MESSAGE_FROM_SYSTEM</b> flag to get a generic text description of the error.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-writeencryptedfileraw
     * @since windows5.1.2600
     */
    static WriteEncryptedFileRaw(pfImportCallback, pvCallbackContext, pvContext) {
        result := DllCall("ADVAPI32.dll\WriteEncryptedFileRaw", "ptr", pfImportCallback, "ptr", pvCallbackContext, "ptr", pvContext, "uint")
        return result
    }

    /**
     * Closes an encrypted file after a backup or restore operation, and frees associated system resources.
     * @remarks
     * The <b>CloseEncryptedFileRaw</b> function frees allocated system resources
     *       such as the system-defined context block and closes the file.
     * 
     * The  <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> functions handle backup and restore of unencrypted files.
     * 
     * In Windows 8, Windows Server 2012, and later, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support EFS on shares with continuous availability capability.
     * @param {Pointer<Void>} pvContext A pointer to a system-defined context block. The
     *          <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-openencryptedfilerawa">OpenEncryptedFileRaw</a> function returns the context block.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-closeencryptedfileraw
     * @since windows5.1.2600
     */
    static CloseEncryptedFileRaw(pvContext) {
        DllCall("ADVAPI32.dll\CloseEncryptedFileRaw", "ptr", pvContext)
    }

    /**
     * Creates, opens, reopens, or deletes a file.
     * @remarks
     * If the <i>lpFileName</i> parameter specifies a file name and extension only, this function 
     *     searches for a matching file in the following directories and the order shown:
     * 
     * <ol>
     * <li>
     * The directory where an application is loaded.
     * 
     * </li>
     * <li>
     * The current directory.
     * 
     * </li>
     * <li>
     * The Windows system directory.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemdirectorya">GetSystemDirectory</a> function to get the 
     *        path of this directory.
     * 
     * </li>
     * <li>
     * The 16-bit Windows system directory.
     * 
     * There is not a function that retrieves the path of this directory, but it is searched.
     * 
     * </li>
     * <li>
     * The Windows directory.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya">GetWindowsDirectory</a> function to get 
     *        the path of this directory.
     * 
     * </li>
     * <li>
     * The directories that are listed in the PATH environment variable.
     * 
     * </li>
     * </ol>
     * The <i>lpFileName</i> parameter cannot contain wildcard characters.
     * 
     * The <b>OpenFile</b> function does not support the 
     *     <b>OF_SEARCH</b> flag that the 16-bit Windows 
     *     <b>OpenFile</b> function supports. The 
     *     <b>OF_SEARCH</b> flag directs the system to search for a matching file even when a file name 
     *     includes a full path. Use the <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-searchpathw">SearchPath</a> function to search 
     *     for a file.
     * 
     * A sharing violation occurs if an attempt is made to open a file or directory for deletion on a remote machine 
     *     when the value of the <i>uStyle</i> parameter is the <b>OF_DELETE</b> access 
     *     flag OR'ed with any other access flag, and the remote file or directory has not been opened with 
     *     <b>FILE_SHARE_DELETE</b> share access. To avoid the sharing violation in this scenario, open 
     *     the remote file or directory with <b>OF_DELETE</b> access only, or call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> without first opening the file or directory for 
     *     deletion.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * @param {Pointer<Byte>} lpFileName The name of the file.
     * 
     * The string must consist of characters from the 8-bit Windows character set. The 
     *        <b>OpenFile</b> function does not support Unicode file names or 
     *        opening named pipes.
     * @param {Pointer<OFSTRUCT>} lpReOpenBuff A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure that receives 
     *        information about a file when it is first opened.
     * 
     * The structure can be used in subsequent calls to the 
     *        <b>OpenFile</b> function to see an open file.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-ofstruct">OFSTRUCT</a> structure contains a path string 
     *        member with a length that is limited to <b>OFS_MAXPATHNAME</b> characters, which is 128 
     *        characters. Because of this, you cannot use the <b>OpenFile</b> 
     *        function to open a file with a path length that exceeds 128 characters. The 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function does not have this path 
     *        length limitation.
     * @param {Integer} uStyle The action to be taken.
     * @returns {Integer} If the function succeeds, the return value specifies a file handle to use when performing file I/O. To close the file, call the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function using this handle.
     * 
     * If the function fails, the return value is <b>HFILE_ERROR</b>. To get extended error 
     *        information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-openfile
     * @since windows5.1.2600
     */
    static OpenFile(lpFileName, lpReOpenBuff, uStyle) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\OpenFile", "ptr", lpFileName, "ptr", lpReOpenBuff, "uint", uStyle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Back up a file or directory, including the security information.
     * @remarks
     * This function is not intended for use in backing up files encrypted under the 
     *     Encrypted File System. Use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-readencryptedfileraw">ReadEncryptedFileRaw</a> for that purpose.
     * 
     * If an error occurs while <b>BackupRead</b> is reading data, 
     *     the calling process can skip the bad data by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupseek">BackupSeek</a> function.
     * 
     * The file or directory should be restored using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> function.
     * @param {Pointer<Void>} hFile Handle to the file or directory to be backed up. To obtain the handle, call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. The SACLs are not read unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. For more information, see [File security and access rights](/windows/win32/fileio/file-security-and-access-rights).
     * 
     * The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.
     * 
     * The <b>BackupRead</b> function may fail if 
     *       <b>CreateFile</b> was called with the flag 
     *       <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value 
     *       <b>ERROR_INVALID_PARAMETER</b>.
     * @param {Pointer} lpBuffer Pointer to a buffer that receives the data.
     * @param {Integer} nNumberOfBytesToRead Length of the buffer, in bytes. The buffer size must be greater than the size of a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-win32_stream_id">WIN32_STREAM_ID</a> structure.
     * @param {Pointer<UInt32>} lpNumberOfBytesRead Pointer to a variable that receives the number of bytes read.
     * 
     * If the function returns a nonzero value, and the variable pointed to by 
     *       <i>lpNumberOfBytesRead</i> is zero, then all the data associated with the file handle has 
     *       been read.
     * @param {Integer} bAbort Indicates whether you have finished using <b>BackupRead</b> 
     *       on the handle. While you are backing up the file, specify this parameter as <b>FALSE</b>. 
     *       Once you are done using <b>BackupRead</b>, you must call 
     *       <b>BackupRead</b> one more time specifying 
     *       <b>TRUE</b> for this parameter and passing the appropriate 
     *       <i>lpContext</i>. <i>lpContext</i> must be passed when 
     *       <i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.
     * @param {Integer} bProcessSecurity Indicates whether the function will restore the access-control list (ACL) data for the file or directory.
     * 
     * If <i>bProcessSecurity</i> is <b>TRUE</b>, the ACL data will be backed 
     *       up.
     * @param {Pointer<Void>} lpContext Pointer to a variable that receives a pointer to an internal data structure used by 
     *       <b>BackupRead</b> to maintain context information during a 
     *       backup operation.
     * 
     * You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b> 
     *       before the first call to <b>BackupRead</b> for the specified 
     *       file or directory. The function allocates memory for the data structure, and then sets the variable to point to 
     *       that structure. You must not change <i>lpContext</i> or the variable that it points to 
     *       between calls to <b>BackupRead</b>.
     * 
     * To release the memory used by the data structure, call 
     *       <b>BackupRead</b> with the 
     *       <i>bAbort</i> parameter set to <b>TRUE</b> when the backup operation is complete.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-backupread
     * @since windows5.1.2600
     */
    static BackupRead(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\BackupRead", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToRead, "uint*", lpNumberOfBytesRead, "int", bAbort, "int", bProcessSecurity, "ptr", lpContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Seeks forward in a data stream initially accessed by using the BackupRead or BackupWrite function.
     * @remarks
     * Applications use the <b>BackupSeek</b> function to skip portions of a data stream that cause errors. This function does not seek across stream headers. For example, this function cannot be used to skip the stream name. If an application attempts to seek past the end of a substream, the function fails, the <i>lpdwLowByteSeeked</i> and <i>lpdwHighByteSeeked</i> parameters indicate the actual number of bytes the function seeks, and the file position is placed at the start of the next stream header.
     * @param {Pointer<Void>} hFile Handle to the file or directory. This handle is created by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * 
     * The handle must be synchronous (nonoverlapped). This means that the FILE_FLAG_OVERLAPPED flag must not be set when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.
     * @param {Integer} dwLowBytesToSeek Low-order part of the number of bytes to seek.
     * @param {Integer} dwHighBytesToSeek High-order part of the number of bytes to seek.
     * @param {Pointer<UInt32>} lpdwLowByteSeeked Pointer to a variable that receives the low-order bits of the number of bytes the function actually seeks.
     * @param {Pointer<UInt32>} lpdwHighByteSeeked Pointer to a variable that receives the high-order bits of the number of bytes the function actually seeks.
     * @param {Pointer<Void>} lpContext Pointer to an internal data structure used by the function. This structure must be the same structure that was initialized by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupread">BackupRead</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-backupwrite">BackupWrite</a> function. An application must not touch the contents of this structure.
     * @returns {Integer} If the function could seek the requested amount, the function returns a nonzero value.
     * 
     * If the function could not seek the requested amount, the function returns zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-backupseek
     * @since windows5.1.2600
     */
    static BackupSeek(hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\BackupSeek", "ptr", hFile, "uint", dwLowBytesToSeek, "uint", dwHighBytesToSeek, "uint*", lpdwLowByteSeeked, "uint*", lpdwHighByteSeeked, "ptr", lpContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Restore a file or directory that was backed up using BackupRead.
     * @remarks
     * This function is not intended for use in restoring files encrypted under the 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">Encrypted File System</a>. Use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-writeencryptedfileraw">WriteEncryptedFileRaw</a> for that purpose.
     * 
     * The data read from the backup medium must be substreams separated by 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-win32_stream_id">WIN32_STREAM_ID</a> structures.
     * 
     * The <b>BACKUP_LINK</b> stream type lets you restore files with hard links.
     * @param {Pointer<Void>} hFile Handle to the file or directory to be restored. To obtain the handle, call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function. The SACLs are not restored unless the file handle was created with the <b>ACCESS_SYSTEM_SECURITY</b> access right. To ensure that the integrity ACEs are restored correctly, the file handle must also have been created with the <b>WRITE_OWNER</b> access right. For more information, see [File security and access rights](/windows/win32/fileio/file-security-and-access-rights).
     * 
     * The handle must be synchronous (nonoverlapped). This means that the <b>FILE_FLAG_OVERLAPPED</b> flag must not be set when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> is called. This function does not validate that the handle it receives is synchronous, so it does not return an error code for a synchronous handle, but calling it with an asynchronous (overlapped) handle can result in subtle errors that are very difficult to debug.
     * 
     * The <b>BackupWrite</b> function may fail if 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> was called with the flag 
     *       <b>FILE_FLAG_NO_BUFFERING</b>. In this case, the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns the value
     *       <b>ERROR_INVALID_PARAMETER</b>.
     * @param {Pointer} lpBuffer Pointer to a buffer that the function writes data from.
     * @param {Integer} nNumberOfBytesToWrite Size of the buffer, in bytes. The buffer size must be greater than the size of a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-win32_stream_id">WIN32_STREAM_ID</a> structure.
     * @param {Pointer<UInt32>} lpNumberOfBytesWritten Pointer to a variable that receives the number of bytes written.
     * @param {Integer} bAbort Indicates whether you have finished using <b>BackupWrite</b> on the handle. 
     *       While you are restoring the file, specify this parameter as <b>FALSE</b>. After you are done 
     *       using <b>BackupWrite</b>, you must call <b>BackupWrite</b> 
     *       one more time specifying <b>TRUE</b> for this parameter and passing the appropriate 
     *       <i>lpContext</i>. <i>lpContext</i> must be passed when 
     *       <i>bAbort</i> is <b>TRUE</b>; all other parameters are ignored.
     * @param {Integer} bProcessSecurity Specifies whether the function will restore the access-control list (ACL) data for the file or directory.
     * 
     * If <i>bProcessSecurity</i> is <b>TRUE</b>, you need to specify 
     *       <b>WRITE_OWNER</b> and <b>WRITE_DAC</b> access when opening the file or 
     *       directory handle. If the handle does not have those access rights, the operating system denies access to the 
     *       ACL data, and ACL data restoration will not occur.
     * @param {Pointer<Void>} lpContext Pointer to a variable that receives a pointer to an internal data structure used by 
     *       <b>BackupWrite</b> to maintain context information during a restore operation.
     * 
     * You must set the variable pointed to by <i>lpContext</i> to <b>NULL</b> 
     *       before the first call to <b>BackupWrite</b> for the specified file or directory. The 
     *       function allocates memory for the data structure, and then sets the variable to point to that structure. You 
     *       must not change <i>lpContext</i> or the variable that it points to between calls to 
     *       <b>BackupWrite</b>.
     * 
     * To release the memory used by the data structure, call <b>BackupWrite</b> with the 
     *       <i>bAbort</i> parameter set to <b>TRUE</b> when the restore operation is 
     *       complete.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero, indicating that an I/O error occurred. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-backupwrite
     * @since windows5.1.2600
     */
    static BackupWrite(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\BackupWrite", "ptr", hFile, "ptr", lpBuffer, "uint", nNumberOfBytesToWrite, "uint*", lpNumberOfBytesWritten, "int", bAbort, "int", bProcessSecurity, "ptr", lpContext, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Fills a buffer with strings that specify valid drives in the system. (GetLogicalDriveStringsA)
     * @remarks
     * Each string in the buffer may be used wherever a root directory is required, such as for the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdrivetypea">GetDriveType</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> functions.
     * 
     * This function returns a concatenation of the drives in the Global and Local MS-DOS Device namespaces. If a 
     *     drive exists in both namespaces, this function will return the entry in the Local MS-DOS Device namespace. For 
     *     more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Integer} nBufferLength The maximum size of the buffer pointed to by <i>lpBuffer</i>, in 
     *       <b>TCHARs</b>. This size does not include the terminating null character. If this 
     *       parameter is zero, <i>lpBuffer</i> is not used.
     * @param {Pointer<Byte>} lpBuffer A pointer to a buffer that receives a series of null-terminated strings, one for each valid drive in the 
     *       system, plus with an additional null character. Each string is a device name.
     * @returns {Integer} If the function succeeds, the return value is the length, in characters, of the strings copied to the buffer, 
     *        not including the terminating null character. Note that an ANSI-ASCII null character uses one byte, but a 
     *        Unicode (UTF-16) null character uses two bytes.
     * 
     * If the buffer is not large enough, the return value is greater than <i>nBufferLength</i>. 
     *        It is the size of the buffer required to hold the drive strings.
     * 
     * If the function fails, the return value is zero. To get extended error information, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getlogicaldrivestringsa
     * @since windows5.1.2600
     */
    static GetLogicalDriveStringsA(nBufferLength, lpBuffer) {
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetLogicalDriveStringsA", "uint", nBufferLength, "ptr", lpBuffer, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the per-process mode that the SearchPath function uses when locating files.
     * @remarks
     * If the <b>SetSearchPathMode</b> function has not been 
     *     successfully called for the current process, the search mode used by the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-searchpathw">SearchPath</a> function is obtained from the system registry. For 
     *     more information, see <a href="https://docs.microsoft.com/windows/desktop/api/processenv/nf-processenv-searchpathw">SearchPath</a>.
     * 
     * After the <b>SetSearchPathMode</b> function has been 
     *     successfully called for the current process, the setting in the system registry is ignored in favor of the mode 
     *     most recently set successfully.
     * 
     * If the <b>SetSearchPathMode</b> function has been 
     *      successfully called for the current process with <i>Flags</i> set to 
     *      <c>(BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT)</c>, 
     *      safe mode is set permanently for the calling process. Any subsequent calls to the 
     *      <b>SetSearchPathMode</b> function from within that process 
     *      that attempt to change the search mode will fail with <b>ERROR_ACCESS_DENIED</b> from the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * <div class="alert"><b>Note</b>  Because setting safe search mode permanently cannot be disabled for the life of the process for which is was 
     *      set, it should be used with careful consideration. This is particularly true for DLL development, where the user 
     *      of the DLL will be affected by this process-wide setting.</div>
     * <div> </div>
     * It is not possible to permanently disable safe search mode.
     * 
     * This function does not modify the system registry.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} Flags The search mode to use.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE"></a><a id="base_search_path_enable_safe_searchmode"></a><dl>
     * <dt><b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Enable safe process search mode for the process.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE"></a><a id="base_search_path_disable_safe_searchmode"></a><dl>
     * <dt><b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b></dt>
     * <dt>0x00010000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Disable safe process search mode for the process.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BASE_SEARCH_PATH_PERMANENT"></a><a id="base_search_path_permanent"></a><dl>
     * <dt><b>BASE_SEARCH_PATH_PERMANENT</b></dt>
     * <dt>0x00008000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Optional flag to use in combination with 
     *          <b>BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE</b> to make this mode permanent for this 
     *          process. This is done by bitwise <b>OR</b> operation:
     * 
     * <c>(BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE | BASE_SEARCH_PATH_PERMANENT)</c>
     * 
     * This flag cannot be combined with the <b>BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE</b> 
     *         flag.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the operation completes successfully, the 
     *        <b>SetSearchPathMode</b> function returns a nonzero 
     *        value.
     * 
     * If the operation fails, the <b>SetSearchPathMode</b> 
     *        function returns zero. To get extended error information, call the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * 
     * If the <b>SetSearchPathMode</b> function fails because a 
     *        parameter value is not valid, the value returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will be 
     *        <b>ERROR_INVALID_PARAMETER</b>.
     * 
     * If the <b>SetSearchPathMode</b> function fails because 
     *        the combination of current state and parameter value is not valid, the value returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function will be 
     *        <b>ERROR_ACCESS_DENIED</b>. For more information, see the Remarks section.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setsearchpathmode
     * @since windows6.1
     */
    static SetSearchPathMode(Flags) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetSearchPathMode", "uint", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory with the attributes of a specified template directory. (ANSI)
     * @remarks
     * The <b>CreateDirectoryEx</b> function allows you to 
     *     create directories that inherit stream information from other directories. This function is useful, for example, 
     *     when you are using Macintosh directories, which have a resource stream that is needed to properly identify 
     *     directory contents as an attribute.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *     directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption 
     *     attributes of its parent directory.
     * 
     * You can obtain a handle to a directory by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the 
     *     <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see 
     *     <b>CreateFile</b>.
     * 
     * To support inheritance functions that query the security descriptor of this 
     *      object can heuristically determine and report that inheritance is in effect. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Byte>} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path. To create all intermediate directories on the path, use the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedirectoryexa">SHCreateDirectoryEx</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createdirectoryexa
     * @since windows5.1.2600
     */
    static CreateDirectoryExA(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes) {
        lpTemplateDirectory := lpTemplateDirectory is String? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String? StrPtr(lpNewDirectory) : lpNewDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryExA", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory with the attributes of a specified template directory. (Unicode)
     * @remarks
     * The <b>CreateDirectoryEx</b> function allows you to 
     *     create directories that inherit stream information from other directories. This function is useful, for example, 
     *     when you are using Macintosh directories, which have a resource stream that is needed to properly identify 
     *     directory contents as an attribute.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *     directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption 
     *     attributes of its parent directory.
     * 
     * You can obtain a handle to a directory by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with the 
     *     <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set. For a code example, see 
     *     <b>CreateFile</b>.
     * 
     * To support inheritance functions that query the security descriptor of this 
     *      object can heuristically determine and report that inheritance is in effect. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">Automatic Propagation of Inheritable ACEs</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateDirectoryEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Char>} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateDirectoryExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". The 255 character limit per path segment still applies. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path. To create all intermediate directories on the path, use the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedirectoryexa">SHCreateDirectoryEx</a> function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createdirectoryexw
     * @since windows5.1.2600
     */
    static CreateDirectoryExW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes) {
        lpTemplateDirectory := lpTemplateDirectory is String? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String? StrPtr(lpNewDirectory) : lpNewDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryExW", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory as a transacted operation, with the attributes of a specified template directory. (ANSI)
     * @remarks
     * The <b>CreateDirectoryTransacted</b> function 
     *     allows you to create directories that inherit stream information from other directories. This function is useful, 
     *     for example, when you are using Macintosh directories, which have a resource stream that is needed to properly 
     *     identify directory contents as an attribute.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *     directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption 
     *     attributes of its parent directory.
     * 
     * This function fails with <b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b> if you try to create a 
     *     child directory with a parent directory that has encryption disabled.
     * 
     * You can obtain a handle to a directory by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiletransacteda">CreateFileTransacted</a> function with the 
     *      <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateDirectoryTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.  This parameter can be 
     *        <b>NULL</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Byte>} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * You cannot create a child directory with a parent directory that has encryption disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createdirectorytransacteda
     * @since windows6.0.6000
     */
    static CreateDirectoryTransactedA(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction) {
        lpTemplateDirectory := lpTemplateDirectory is String? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String? StrPtr(lpNewDirectory) : lpNewDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryTransactedA", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a new directory as a transacted operation, with the attributes of a specified template directory. (Unicode)
     * @remarks
     * The <b>CreateDirectoryTransacted</b> function 
     *     allows you to create directories that inherit stream information from other directories. This function is useful, 
     *     for example, when you are using Macintosh directories, which have a resource stream that is needed to properly 
     *     identify directory contents as an attribute.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *     directories. On volumes formatted for such a file system, a new directory inherits the compression and encryption 
     *     attributes of its parent directory.
     * 
     * This function fails with <b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b> if you try to create a 
     *     child directory with a parent directory that has encryption disabled.
     * 
     * You can obtain a handle to a directory by calling the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiletransacteda">CreateFileTransacted</a> function with the 
     *      <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag set.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateDirectoryTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpTemplateDirectory The path of the directory to use as a template when creating the new directory.  This parameter can be 
     *        <b>NULL</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Char>} lpNewDirectory The path of the directory to be created.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure. The <b>lpSecurityDescriptor</b> member of the structure specifies a security 
     *        descriptor for the new directory.
     * 
     * If <i>lpSecurityAttributes</i> is <b>NULL</b>, the directory gets a 
     *        default security descriptor. The access control lists (ACL) in the default security descriptor for a directory 
     *        are inherited from its parent directory.
     * 
     * The target file system must support security on files and directories for this parameter to have an effect. 
     *        This is indicated when <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a> 
     *        returns <b>FS_PERSISTENT_ACLS</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. Possible errors include the 
     *        following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified directory already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * You cannot create a child directory with a parent directory that has encryption disabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_PATH_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more intermediate directories do not exist. This function only creates the final directory in the 
     *         path.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createdirectorytransactedw
     * @since windows6.0.6000
     */
    static CreateDirectoryTransactedW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction) {
        lpTemplateDirectory := lpTemplateDirectory is String? StrPtr(lpTemplateDirectory) : lpTemplateDirectory
        lpNewDirectory := lpNewDirectory is String? StrPtr(lpNewDirectory) : lpNewDirectory

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateDirectoryTransactedW", "ptr", lpTemplateDirectory, "ptr", lpNewDirectory, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory as a transacted operation. (ANSI)
     * @remarks
     * The <b>RemoveDirectoryTransacted</b> function 
     *     marks a directory for deletion on close. Therefore, the directory is not removed until the last handle to the 
     *     directory is closed.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> removes a directory junction, even 
     *     if the contents of the target are not empty; the function removes directory junctions regardless of the state of 
     *     the target object.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF
     * .
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines RemoveDirectoryTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpPathName The path of the directory to be removed. The path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-removedirectorytransacteda
     * @since windows6.0.6000
     */
    static RemoveDirectoryTransactedA(lpPathName, hTransaction) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryTransactedA", "ptr", lpPathName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing empty directory as a transacted operation. (Unicode)
     * @remarks
     * The <b>RemoveDirectoryTransacted</b> function 
     *     marks a directory for deletion on close. Therefore, the directory is not removed until the last handle to the 
     *     directory is closed.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> removes a directory junction, even 
     *     if the contents of the target are not empty; the function removes directory junctions regardless of the state of 
     *     the target object.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF
     * .
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines RemoveDirectoryTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpPathName The path of the directory to be removed. The path must specify an empty directory, and the calling process 
     *        must have delete access to the directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The directory must reside on the local computer; otherwise, the function fails and the last error code is set 
     *        to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-removedirectorytransactedw
     * @since windows6.0.6000
     */
    static RemoveDirectoryTransactedW(lpPathName, hTransaction) {
        lpPathName := lpPathName is String? StrPtr(lpPathName) : lpPathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\RemoveDirectoryTransactedW", "ptr", lpPathName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file as a transacted operation. (ANSI)
     * @remarks
     * <b>GetFullPathNameTransacted</b> merges the name 
     *     of the current drive and directory with a specified file name to determine the full path and file name of a 
     *     specified file. It also calculates the address of the file name portion of the full path and file name. This 
     *     function does not verify that the resulting path and file name are valid, or that they see an existing file on the 
     *     associated volume.
     * 
     * Share and volume names are valid input for <i>lpFileName</i>. For example, the following 
     *     list identities the returned path and file names if test-2 is a remote computer and U: is a network mapped drive:
     * 
     * <ul>
     * <li>If you specify "\\test-2\q$\lh" the path returned is 
     *       "\\test-2\q$\lh"</li>
     * <li>If you specify "\\?\UNC\test-2\q$\lh" the path returned is 
     *       "\\?\UNC\test-2\q$\lh"</li>
     * <li>If you specify "U:" the path returned is "U:\"</li>
     * </ul>
     * <b>GetFullPathNameTransacted</b> does not convert 
     *     the specified file name, <i>lpFileName</i>. If the specified file name exists, you can use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getlongpathnametransacteda">GetLongPathNameTransacted</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlongpathnamea">GetLongPathName</a>, or 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getshortpathnamew">GetShortPathName</a> to convert to long or short path 
     *     names, respectively.
     * 
     * If the return value is greater than the value specified in <i>nBufferLength</i>, you can 
     *     call the function again with a buffer that is large enough to hold the path. For an example of this case as well 
     *     as using zero length buffer for dynamic allocation, see the Example Code section.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetFullPathNameTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file.
     * 
     * This string can use short (the 8.3 form) or long file names. This string can be a share or volume name.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string  for the drive and path,  in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Byte>} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<Byte>} lpFilePart A pointer to a buffer that receives the address (in <i>lpBuffer</i>) of the final file 
     *        name component in the path. Specify <b>NULL</b> if you do not need to receive this 
     *        information.
     * 
     * If <i>lpBuffer</i> points to a directory and not a file, 
     *        <i>lpFilePart</i> receives 0 (zero).
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getfullpathnametransacteda
     * @since windows6.0.6000
     */
    static GetFullPathNameTransactedA(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameTransactedA", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the full path and file name of the specified file as a transacted operation. (Unicode)
     * @remarks
     * <b>GetFullPathNameTransacted</b> merges the name 
     *     of the current drive and directory with a specified file name to determine the full path and file name of a 
     *     specified file. It also calculates the address of the file name portion of the full path and file name. This 
     *     function does not verify that the resulting path and file name are valid, or that they see an existing file on the 
     *     associated volume.
     * 
     * Share and volume names are valid input for <i>lpFileName</i>. For example, the following 
     *     list identities the returned path and file names if test-2 is a remote computer and U: is a network mapped drive:
     * 
     * <ul>
     * <li>If you specify "\\test-2\q$\lh" the path returned is 
     *       "\\test-2\q$\lh"</li>
     * <li>If you specify "\\?\UNC\test-2\q$\lh" the path returned is 
     *       "\\?\UNC\test-2\q$\lh"</li>
     * <li>If you specify "U:" the path returned is "U:\"</li>
     * </ul>
     * <b>GetFullPathNameTransacted</b> does not convert 
     *     the specified file name, <i>lpFileName</i>. If the specified file name exists, you can use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getlongpathnametransacteda">GetLongPathNameTransacted</a>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getlongpathnamea">GetLongPathName</a>, or 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getshortpathnamew">GetShortPathName</a> to convert to long or short path 
     *     names, respectively.
     * 
     * If the return value is greater than the value specified in <i>nBufferLength</i>, you can 
     *     call the function again with a buffer that is large enough to hold the path. For an example of this case as well 
     *     as using zero length buffer for dynamic allocation, see the Example Code section.
     * 
     * <div class="alert"><b>Note</b>  Although the return value in this case is a length that includes the terminating null character, the return 
     *      value on success does not include the terminating null character in the count.</div>
     * <div> </div>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetFullPathNameTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file.
     * 
     * This string can use short (the 8.3 form) or long file names. This string can be a share or volume name.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} nBufferLength The size of the buffer to receive the null-terminated string  for the drive and path,  in 
     *       <b>TCHARs</b>.
     * @param {Pointer<Char>} lpBuffer A pointer to a buffer that receives the null-terminated string for the  drive and path.
     * @param {Pointer<Char>} lpFilePart A pointer to a buffer that receives the address (in <i>lpBuffer</i>) of the final file 
     *        name component in the path. Specify <b>NULL</b> if you do not need to receive this 
     *        information.
     * 
     * If <i>lpBuffer</i> points to a directory and not a file, 
     *        <i>lpFilePart</i> receives 0 (zero).
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the length, in <b>TCHARs</b>, of the 
     *        string copied to <i>lpBuffer</i>, not including the terminating null character.
     * 
     * If the <i>lpBuffer</i> buffer is too small to contain the path, the return value is the 
     *        size, in <b>TCHARs</b>, of the buffer that is required to hold the path and the 
     *        terminating null character.
     * 
     * If the function fails for any other reason, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getfullpathnametransactedw
     * @since windows6.0.6000
     */
    static GetFullPathNameTransactedW(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpBuffer := lpBuffer is String? StrPtr(lpBuffer) : lpBuffer

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFullPathNameTransactedW", "ptr", lpFileName, "uint", nBufferLength, "ptr", lpBuffer, "ptr", lpFilePart, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Defines, redefines, or deletes MS-DOS device names. (DefineDosDeviceA)
     * @remarks
     * MS-DOS device names are stored as junctions in the object namespace. The code that converts an MS-DOS path 
     *     into a corresponding path uses these junctions to map MS-DOS devices and drive letters. The 
     *     <b>DefineDosDevice</b> function enables an application to modify the junctions used to 
     *     implement the MS-DOS device namespace.
     * 
     * To retrieve the current mapping for a particular MS-DOS device name or to obtain a list of all MS-DOS devices 
     *     known to the system, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-querydosdevicew">QueryDosDevice</a> 
     *     function.
     * 
     * To define a drive letter assignment that is persistent across boots and not a network share, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setvolumemountpointa">SetVolumeMountPoint</a> function. If the volume to 
     *     be mounted already has a drive letter assigned to it, use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletevolumemountpointw">DeleteVolumeMountPoint</a> function to remove the 
     *     assignment.
     * 
     * Drive letters and device names defined at system boot time are protected from redefinition and deletion unless 
     *     the user is an administrator.
     * 
     * Starting with Windows XP, this function creates a device name for a caller that is not running in 
     *     the "LocalSystem" context in its own Local MS-DOS device namespace. If the caller  is running in 
     *     the "LocalSystem" context, the function creates the device name in the Global MS-DOS device 
     *     namespace. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a> and 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. For CsvFs, a new name will not be replicated to the other nodes on the cluster.
     * @param {Integer} dwFlags The controllable aspects of the <b>DefineDosDevice</b> function. This parameter
     * @param {Pointer<Byte>} lpDeviceName A pointer to an MS-DOS device name string specifying the device the function is defining, redefining, or 
     *       deleting. The device name string must not have a colon as the last character, unless a drive letter is being 
     *       defined, redefined, or deleted. For example, drive C  would be the string "C:". In no case is a 
     *       trailing backslash ("\") allowed.
     * @param {Pointer<Byte>} lpTargetPath A pointer to a path string that will implement this device. The string is an MS-DOS path string unless the 
     *       <b>DDD_RAW_TARGET_PATH</b> flag is specified, in which case this string is a path 
     *       string.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-definedosdevicea
     * @since windows5.1.2600
     */
    static DefineDosDeviceA(dwFlags, lpDeviceName, lpTargetPath) {
        lpDeviceName := lpDeviceName is String? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DefineDosDeviceA", "uint", dwFlags, "ptr", lpDeviceName, "ptr", lpTargetPath, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information about MS-DOS device names. (QueryDosDeviceA)
     * @remarks
     * The <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-definedosdevicew">DefineDosDevice</a> function enables an application 
     *     to create and modify the junctions used to implement the MS-DOS device namespace.
     * 
     * <b>Windows Server 2003 and Windows XP:  </b><b>QueryDosDevice</b> first searches the Local MS-DOS 
     *      Device namespace for the specified device name. If the device name is not found, the function will then search 
     *      the Global MS-DOS Device namespace.
     * 
     * When all existing MS-DOS device names are queried, the list of device names that are returned is dependent on 
     *      whether it is running in the "LocalSystem" context. If so, only the device names included in the Global MS-DOS 
     *      Device namespace will be returned. If not, a concatenation of the device names in the Global and Local MS-DOS 
     *      Device namespaces will be returned. If a device name exists in both namespaces, 
     *      <b>QueryDosDevice</b> will return the entry in the Local MS-DOS 
     *      Device namespace.
     * 
     * For more information on the Global and Local MS-DOS Device namespaces and changes to the accessibility of 
     *      MS-DOS device names, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS DOS Device Name</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Byte>} lpDeviceName An MS-DOS device name string specifying the target of the query. The device name cannot have a trailing 
     *        backslash; for example, use "C:", not "C:\\".
     * 
     * This parameter can be <b>NULL</b>. In that case, the 
     *        <b>QueryDosDevice</b> function will store a list of all 
     *        existing MS-DOS device names into the buffer pointed to by <i>lpTargetPath</i>.
     * @param {Pointer<Byte>} lpTargetPath A pointer to a buffer that will receive the result of the query. The function fills this buffer with one or 
     *        more null-terminated strings. The final null-terminated string is followed by an additional 
     *        <b>NULL</b>.
     * 
     * If <i>lpDeviceName</i> is non-<b>NULL</b>, the function retrieves 
     *        information about the particular MS-DOS device specified by <i>lpDeviceName</i>. The first 
     *        null-terminated string stored into the buffer is the current mapping for the device. The other null-terminated 
     *        strings represent undeleted prior mappings for the device.
     * 
     * If <i>lpDeviceName</i> is <b>NULL</b>, the function retrieves a list of 
     *        all existing MS-DOS device names. Each null-terminated string stored into the buffer is the name of an existing 
     *        MS-DOS device, for example, \Device\HarddiskVolume1 or \Device\Floppy0.
     * @param {Integer} ucchMax The maximum number of <b>TCHARs</b> that can be stored into the buffer pointed to by 
     *       <i>lpTargetPath</i>.
     * @returns {Integer} If the function succeeds, the return value is the number of <b>TCHARs</b> stored into 
     *        the buffer pointed to by <i>lpTargetPath</i>.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the buffer is too small, the function fails and the last error code is 
     *        <b>ERROR_INSUFFICIENT_BUFFER</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-querydosdevicea
     * @since windows5.1.2600
     */
    static QueryDosDeviceA(lpDeviceName, lpTargetPath, ucchMax) {
        lpDeviceName := lpDeviceName is String? StrPtr(lpDeviceName) : lpDeviceName
        lpTargetPath := lpTargetPath is String? StrPtr(lpTargetPath) : lpTargetPath

        A_LastError := 0

        result := DllCall("KERNEL32.dll\QueryDosDeviceA", "ptr", lpDeviceName, "ptr", lpTargetPath, "uint", ucchMax, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file, file stream, or directory as a transacted operation. (ANSI)
     * @remarks
     * When using the handle returned by 
     *      <b>CreateFileTransacted</b>, use the transacted version 
     *      of file I/O functions instead of the standard file I/O functions where appropriate. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/programming-considerations-for-transacted-fileio-">Programming Considerations for 
     *      Transactional NTFS</a>.
     * 
     * When opening a transacted handle to a directory, that handle must have 
     *      <b>FILE_WRITE_DATA</b> (<b>FILE_ADD_FILE</b>) and 
     *      <b>FILE_APPEND_DATA</b> (<b>FILE_ADD_SUBDIRECTORY</b>) permissions. These 
     *      are included in <b>FILE_GENERIC_WRITE</b> permissions. You should open directories with fewer 
     *      permissions if you are just using the handle to create files or subdirectories; otherwise, sharing violations can 
     *      occur.
     * 
     * You cannot open a file with <b>FILE_EXECUTE</b> access level when that file is a part of 
     *      another transaction (that is, another application opened it by calling 
     *      <b>CreateFileTransacted</b>).  This means that 
     *      <b>CreateFileTransacted</b> fails if the access level 
     *      <b>FILE_EXECUTE</b> or <b>FILE_ALL_ACCESS</b> is specified
     * 
     * When a non-transacted application calls 
     *      <b>CreateFileTransacted</b> with 
     *      <b>MAXIMUM_ALLOWED</b> specified for <i>lpSecurityAttributes</i>, a handle 
     *      is opened with the same access level every time.  When a transacted application calls 
     *      <b>CreateFileTransacted</b> with 
     *      <b>MAXIMUM_ALLOWED</b> specified for <i>lpSecurityAttributes</i>, a handle 
     *      is opened with a differing amount of access based on whether the file is locked by a transaction. For example, 
     *      if the calling application has <b>FILE_EXECUTE</b> access level for a file, the application 
     *      only obtains this access if the file that is being opened is either not locked by a transaction, or is locked by 
     *      a transaction and the application is already a transacted reader for that file.
     * 
     * See <a href="https://docs.microsoft.com/windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</a> for a complete 
     *      description of transacted operations.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close an object handle 
     *      returned by <b>CreateFileTransacted</b> when the handle 
     *      is no longer needed, and prior to committing or rolling back the transaction.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *      directories. On volumes that are formatted for that kind of file system, a new file inherits the compression and 
     *      encryption attributes of its directory.
     * 
     * You cannot use <b>CreateFileTransacted</b> to control 
     *      compression on a file or directory. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</a>, and 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * Symbolic link behavior—If the call to this function creates a new file, there is no change 
     *      in behavior.
     * 
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the symbolic 
     *        link.</li>
     * <li>If <b>TRUNCATE_EXISTING</b> or <b>FILE_FLAG_DELETE_ON_CLOSE</b> are 
     *        specified, the file affected is a symbolic link.</li>
     * </ul>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is not specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *        target.</li>
     * <li>If <b>CREATE_ALWAYS</b>, <b>TRUNCATE_EXISTING</b>, or 
     *        <b>FILE_FLAG_DELETE_ON_CLOSE</b> are specified, the file affected is the target.</li>
     * </ul>
     * A multi-sector write is not guaranteed to be atomic unless you are using a transaction (that is, the handle 
     *     created is a transacted handle).  A single-sector write is atomic. Multi-sector writes that are cached may not 
     *     always be written to the disk; therefore, specify <b>FILE_FLAG_WRITE_THROUGH</b> to ensure that 
     *     an entire multi-sector write is written to the disk without caching.
     * 
     * As stated previously, if the <i>lpSecurityAttributes</i> parameter is 
     *      <b>NULL</b>, the handle returned by 
     *      <b>CreateFileTransacted</b> cannot be inherited by any 
     *      child processes your application may create. The following information regarding this parameter also applies:
     * 
     * <ul>
     * <li>If <b>bInheritHandle</b> is not <b>FALSE</b>, which is any nonzero 
     *       value, then the handle can be inherited. Therefore it is critical this structure member be properly initialized 
     *       to <b>FALSE</b> if you do not intend the handle to be inheritable.</li>
     * <li>The access control lists (ACL) in the default security descriptor for a file or directory are inherited 
     *       from its parent directory.</li>
     * <li>The target file system must support security on files and directories for the 
     *       <b>lpSecurityDescriptor</b>  to have an effect on them, which can be determined by using 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>
     * </li>
     * </ul>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support TxF.
     * 
     * <h3><a id="Files"></a><a id="files"></a><a id="FILES"></a>Files</h3>
     * If you try to create a file on a floppy drive that does not have a floppy disk or a CD-ROM drive that does not 
     *       have a CD, the system displays a message for the user to insert a disk or a CD. To prevent the system from 
     *       displaying this message, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function 
     *       with <b>SEM_FAILCRITICALERRORS</b>.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * If you rename or delete a file and then restore it shortly afterward, the system searches the cache for file 
     *       information to restore. Cached information includes its short/long name pair and creation time.
     * 
     * If you call <b>CreateFileTransacted</b> on a file that 
     *       is pending deletion as a result of a previous call to 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>, the function fails. The operating system 
     *       delays file deletion until all handles to the file are closed.
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The <i>dwDesiredAccess</i> parameter can 
     *       be zero, allowing the application to query  file attributes without accessing the file if the application is 
     *       running with adequate security settings. This is useful to test for the existence of a file without opening it 
     *       for read and/or write access, or to obtain other statistics about the file or directory. See 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-and-setting-file-information">Obtaining and Setting File Information</a> 
     *       and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>.
     * 
     * When an application creates a file across a network, it is better to use 
     *       <b>GENERIC_READ</b> | <b>GENERIC_WRITE</b> than to use 
     *       <b>GENERIC_WRITE</b> alone. The resulting code is faster, because the redirector can use the 
     *       cache manager and send fewer SMBs with more data. This combination also avoids an issue where writing to a file 
     *       across a network can occasionally return <b>ERROR_ACCESS_DENIED</b>.
     * 
     * <h3><a id="File_Streams"></a><a id="file_streams"></a><a id="FILE_STREAMS"></a>File Streams</h3>
     * On NTFS file systems, you can use 
     *       <b>CreateFileTransacted</b> to create separate streams 
     *       within a file.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <h3><a id="Directories"></a><a id="directories"></a><a id="DIRECTORIES"></a>Directories</h3>
     * An application cannot create a directory by using 
     *       <b>CreateFileTransacted</b>, therefore only the 
     *       <b>OPEN_EXISTING</b> value is valid for <i>dwCreationDisposition</i> for 
     *       this use case. To create a directory, the application must call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectorytransacteda">CreateDirectoryTransacted</a>, 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>.
     * 
     * To open a directory using <b>CreateFileTransacted</b>, 
     *       specify the <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag as part of 
     *       <i>dwFlagsAndAttributes</i>. Appropriate security checks still apply when this flag is used 
     *       without <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges.
     * 
     * When using <b>CreateFileTransacted</b> to open a 
     *       directory during defragmentation of a FAT or FAT32 file system volume, do not specify the 
     *       <b>MAXIMUM_ALLOWED</b> access right. Access to the directory is denied if this is done. 
     *       Specify the <b>GENERIC_READ</b> access right instead.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-directory-management">About Directory Management</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of an object to be created or opened.
     * 
     * The object must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. For information on special device names, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * @param {Integer} dwDesiredAccess The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly 
     *        used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both 
     *        (<b>GENERIC_READ</b> | <b>GENERIC_WRITE</b>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * If this parameter is zero, the application can query  file, directory, or device attributes without accessing 
     *        that file or device. For more information, see the Remarks section of this topic.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified in an open request 
     *        that has an open handle. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the 
     *        following table).
     * 
     * If this parameter is zero and 
     *        <b>CreateFileTransacted</b> succeeds, the object cannot 
     *        be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section 
     *        of this topic.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an open request 
     *        that has an open handle, because that would result in the following sharing violation: 
     *        <b>ERROR_SHARING_VIOLATION</b>. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * To enable a process to share an object while another process has the object open, use a combination of one or
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains an optional 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> and also determines whether 
     *        or not the returned handle can be inherited by child processes. The parameter can be 
     *        <b>NULL</b>.
     * 
     * If the <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle 
     *        returned by <b>CreateFileTransacted</b> cannot be 
     *        inherited by any child processes your application may create and the object associated with the returned handle 
     *        gets a default security descriptor.
     * 
     * The <b>bInheritHandle</b> member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * The  <b>lpSecurityDescriptor</b> member of the structure specifies 
     *        a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> for an object, but may 
     *        also be <b>NULL</b>.
     * 
     * If <b>lpSecurityDescriptor</b> member is <b>NULL</b>, the object 
     *        associated with the returned handle is assigned a default security descriptor.
     * 
     * <b>CreateFileTransacted</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file, but continues to use the 
     *        <b>bInheritHandle</b> member.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwCreationDisposition An action to take on files that exist and  do not exist.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwFlagsAndAttributes The file attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default 
     *        value.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of 
     *        buffering behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  <p class="note">When <b>CreateFileTransacted</b> opens an existing 
     *         file, it generally combines the file flags with the file attributes of the existing file, and ignores any file 
     *         attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * </div>
     * <div> </div>
     * The following file attributes and flags are used only for file objects, not other types of objects that 
     *        <b>CreateFileTransacted</b> opens (additional 
     *        information can be found in the Remarks section of this topic). For more advanced access to file attributes, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all 
     *        file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.  File systems avoid writing data back to mass storage 
     *          if sufficient cache memory is available, because an application deletes a temporary file after a handle is 
     *          closed. In that case, the system can entirely avoid writing the data.  Otherwise, the data is written after 
     *          the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the 
     *          calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> 
     *          and <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after the last transacted writer handle to the file is closed, 
     *          provided that the transaction is still active. If a file has been marked for deletion and a transacted writer 
     *          handle is still open after the transaction completes, the file will not be deleted.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened with no system caching. This flag does not affect hard disk caching or memory 
     *          mapped files. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum 
     *          asynchronous performance, because the I/O does not rely on the synchronous operations of the memory manager. 
     *          However, some I/O operations take more time, because data is not being held in the cache. Also, the file 
     *          metadata may still be cached. To flush the metadata to disk, use the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function.
     * 
     * An application must meet certain requirements when working with files that are opened with 
     *          <b>FILE_FLAG_NO_BUFFERING</b>:
     * 
     * <ul>
     * <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector 
     *           size.</li>
     * <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For 
     *           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, 
     *           or 2048 bytes, but not of 335, 981, or 7171 bytes.</li>
     * <li>Buffer addresses for read and write operations should be sector aligned, which means aligned on 
     *           addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this 
     *           requirement may not be enforced.</li>
     * </ul>
     * One way to align buffers on integer multiples of the volume sector size is to use 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> to allocate the buffers. It allocates 
     *          memory that is aligned on addresses that are integer multiples of the operating system's memory page size. 
     *          Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses 
     *          that are integer multiples of a volume sector size. Memory pages are 4 or 8 KB in size; sectors are 512 bytes 
     *          (hard disks), 2048 bytes (CD), or 4096 bytes (hard disks), and therefore, volume sectors can never be larger 
     *          than memory pages.
     * 
     * An application can determine a volume sector size by calling the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not occur; 
     *          <b>CreateFileTransacted</b> will attempt to open the 
     *          reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the 
     *          reparse point is operational. This flag cannot be used with the <b>CREATE_ALWAYS</b> 
     *          flag. If the file is not a reparse point, then this flag is ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for asynchronous I/O. When the operation is complete, the event 
     *          specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is set to the 
     *          signaled state. Operations that take a significant amount of time to process return 
     *          <b>ERROR_IO_PENDING</b>.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations. The system does 
     *          not maintain the file pointer, therefore you must pass the file position to the read and write functions in 
     *          the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure or update the file 
     *          pointer.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed according to POSIX rules. This includes allowing multiple files with names, 
     *          differing only in case, for file systems that support that naming. Use care when using this option, because 
     *          files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed randomly. The system can use this as a hint to optimize file caching.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed sequentially from beginning to end. The system can use this as a hint to 
     *          optimize file caching. If an application moves the file pointer for random access, optimum caching may not 
     *          occur. However, correct operation is still guaranteed.
     * 
     * Specifying this flag can increase performance for applications that read large files using sequential 
     *          access. Performance gains can be even more noticeable for applications that read large files mostly 
     *          sequentially, but occasionally skip over small ranges of bytes.
     * 
     * This flag  has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in 
     *          effect, then the data is written to the system cache, but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in 
     *          effect, then the data is immediately flushed to disk without going through the system cache. The operating 
     *          system also requests a write-through the hard disk cache to persistent media. However, not all hardware 
     *          supports this write-through capability.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i> parameter can also specify Security Quality of Service 
     *        information. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling 
     *        application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {Pointer<Void>} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created. This parameter can be 
     *        <b>NULL</b>.
     * 
     * When opening an existing file, 
     *        <b>CreateFileTransacted</b> ignores the template 
     *        file.
     * 
     * When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @param {Pointer<UInt32>} pusMiniVersion The miniversion to be opened. If the transaction specified in <i>hTransaction</i> is not 
     *        the transaction that is modifying the file, this parameter should be <b>NULL</b>. Otherwise, 
     *        this parameter can be a miniversion identifier returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_txfs_create_miniversion">FSCTL_TXFS_CREATE_MINIVERSION</a> control
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createfiletransacteda
     * @since windows6.0.6000
     */
    static CreateFileTransactedA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion) {
        static lpExtendedParameter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileTransactedA", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile, "ptr", hTransaction, "uint*", pusMiniVersion, "ptr", lpExtendedParameter)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates or opens a file, file stream, or directory as a transacted operation. (Unicode)
     * @remarks
     * When using the handle returned by 
     *      <b>CreateFileTransacted</b>, use the transacted version 
     *      of file I/O functions instead of the standard file I/O functions where appropriate. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/programming-considerations-for-transacted-fileio-">Programming Considerations for 
     *      Transactional NTFS</a>.
     * 
     * When opening a transacted handle to a directory, that handle must have 
     *      <b>FILE_WRITE_DATA</b> (<b>FILE_ADD_FILE</b>) and 
     *      <b>FILE_APPEND_DATA</b> (<b>FILE_ADD_SUBDIRECTORY</b>) permissions. These 
     *      are included in <b>FILE_GENERIC_WRITE</b> permissions. You should open directories with fewer 
     *      permissions if you are just using the handle to create files or subdirectories; otherwise, sharing violations can 
     *      occur.
     * 
     * You cannot open a file with <b>FILE_EXECUTE</b> access level when that file is a part of 
     *      another transaction (that is, another application opened it by calling 
     *      <b>CreateFileTransacted</b>).  This means that 
     *      <b>CreateFileTransacted</b> fails if the access level 
     *      <b>FILE_EXECUTE</b> or <b>FILE_ALL_ACCESS</b> is specified
     * 
     * When a non-transacted application calls 
     *      <b>CreateFileTransacted</b> with 
     *      <b>MAXIMUM_ALLOWED</b> specified for <i>lpSecurityAttributes</i>, a handle 
     *      is opened with the same access level every time.  When a transacted application calls 
     *      <b>CreateFileTransacted</b> with 
     *      <b>MAXIMUM_ALLOWED</b> specified for <i>lpSecurityAttributes</i>, a handle 
     *      is opened with a differing amount of access based on whether the file is locked by a transaction. For example, 
     *      if the calling application has <b>FILE_EXECUTE</b> access level for a file, the application 
     *      only obtains this access if the file that is being opened is either not locked by a transaction, or is locked by 
     *      a transaction and the application is already a transacted reader for that file.
     * 
     * See <a href="https://docs.microsoft.com/windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</a> for a complete 
     *      description of transacted operations.
     * 
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close an object handle 
     *      returned by <b>CreateFileTransacted</b> when the handle 
     *      is no longer needed, and prior to committing or rolling back the transaction.
     * 
     * Some file systems, such as the NTFS file system, support compression or encryption for individual files and 
     *      directories. On volumes that are formatted for that kind of file system, a new file inherits the compression and 
     *      encryption attributes of its directory.
     * 
     * You cannot use <b>CreateFileTransacted</b> to control 
     *      compression on a file or directory. For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-compression-and-decompression">File Compression and Decompression</a>, and 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * Symbolic link behavior—If the call to this function creates a new file, there is no change 
     *      in behavior.
     * 
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the symbolic 
     *        link.</li>
     * <li>If <b>TRUNCATE_EXISTING</b> or <b>FILE_FLAG_DELETE_ON_CLOSE</b> are 
     *        specified, the file affected is a symbolic link.</li>
     * </ul>
     * If <b>FILE_FLAG_OPEN_REPARSE_POINT</b> is not specified:
     * 
     * <ul>
     * <li>If an existing file is opened and it is a symbolic link, the handle returned is a handle to the 
     *        target.</li>
     * <li>If <b>CREATE_ALWAYS</b>, <b>TRUNCATE_EXISTING</b>, or 
     *        <b>FILE_FLAG_DELETE_ON_CLOSE</b> are specified, the file affected is the target.</li>
     * </ul>
     * A multi-sector write is not guaranteed to be atomic unless you are using a transaction (that is, the handle 
     *     created is a transacted handle).  A single-sector write is atomic. Multi-sector writes that are cached may not 
     *     always be written to the disk; therefore, specify <b>FILE_FLAG_WRITE_THROUGH</b> to ensure that 
     *     an entire multi-sector write is written to the disk without caching.
     * 
     * As stated previously, if the <i>lpSecurityAttributes</i> parameter is 
     *      <b>NULL</b>, the handle returned by 
     *      <b>CreateFileTransacted</b> cannot be inherited by any 
     *      child processes your application may create. The following information regarding this parameter also applies:
     * 
     * <ul>
     * <li>If <b>bInheritHandle</b> is not <b>FALSE</b>, which is any nonzero 
     *       value, then the handle can be inherited. Therefore it is critical this structure member be properly initialized 
     *       to <b>FALSE</b> if you do not intend the handle to be inheritable.</li>
     * <li>The access control lists (ACL) in the default security descriptor for a file or directory are inherited 
     *       from its parent directory.</li>
     * <li>The target file system must support security on files and directories for the 
     *       <b>lpSecurityDescriptor</b>  to have an effect on them, which can be determined by using 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>
     * </li>
     * </ul>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support TxF.
     * 
     * <h3><a id="Files"></a><a id="files"></a><a id="FILES"></a>Files</h3>
     * If you try to create a file on a floppy drive that does not have a floppy disk or a CD-ROM drive that does not 
     *       have a CD, the system displays a message for the user to insert a disk or a CD. To prevent the system from 
     *       displaying this message, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> function 
     *       with <b>SEM_FAILCRITICALERRORS</b>.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * If you rename or delete a file and then restore it shortly afterward, the system searches the cache for file 
     *       information to restore. Cached information includes its short/long name pair and creation time.
     * 
     * If you call <b>CreateFileTransacted</b> on a file that 
     *       is pending deletion as a result of a previous call to 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>, the function fails. The operating system 
     *       delays file deletion until all handles to the file are closed.
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The <i>dwDesiredAccess</i> parameter can 
     *       be zero, allowing the application to query  file attributes without accessing the file if the application is 
     *       running with adequate security settings. This is useful to test for the existence of a file without opening it 
     *       for read and/or write access, or to obtain other statistics about the file or directory. See 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-and-setting-file-information">Obtaining and Setting File Information</a> 
     *       and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>.
     * 
     * When an application creates a file across a network, it is better to use 
     *       <b>GENERIC_READ</b> | <b>GENERIC_WRITE</b> than to use 
     *       <b>GENERIC_WRITE</b> alone. The resulting code is faster, because the redirector can use the 
     *       cache manager and send fewer SMBs with more data. This combination also avoids an issue where writing to a file 
     *       across a network can occasionally return <b>ERROR_ACCESS_DENIED</b>.
     * 
     * <h3><a id="File_Streams"></a><a id="file_streams"></a><a id="FILE_STREAMS"></a>File Streams</h3>
     * On NTFS file systems, you can use 
     *       <b>CreateFileTransacted</b> to create separate streams 
     *       within a file.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * 
     * <h3><a id="Directories"></a><a id="directories"></a><a id="DIRECTORIES"></a>Directories</h3>
     * An application cannot create a directory by using 
     *       <b>CreateFileTransacted</b>, therefore only the 
     *       <b>OPEN_EXISTING</b> value is valid for <i>dwCreationDisposition</i> for 
     *       this use case. To create a directory, the application must call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectorytransacteda">CreateDirectoryTransacted</a>, 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>.
     * 
     * To open a directory using <b>CreateFileTransacted</b>, 
     *       specify the <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag as part of 
     *       <i>dwFlagsAndAttributes</i>. Appropriate security checks still apply when this flag is used 
     *       without <b>SE_BACKUP_NAME</b> and <b>SE_RESTORE_NAME</b> privileges.
     * 
     * When using <b>CreateFileTransacted</b> to open a 
     *       directory during defragmentation of a FAT or FAT32 file system volume, do not specify the 
     *       <b>MAXIMUM_ALLOWED</b> access right. Access to the directory is denied if this is done. 
     *       Specify the <b>GENERIC_READ</b> access right instead.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-directory-management">About Directory Management</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of an object to be created or opened.
     * 
     * The object must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. For information on special device names, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/FileIO/defining-an-ms-dos-device-name">Defining an MS-DOS Device Name</a>.
     * 
     * To create a file stream, specify the name of the file, a colon, and then the name of the stream. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-streams">File Streams</a>.
     * @param {Integer} dwDesiredAccess The access to the object, which can be  summarized as read, write, both or neither (zero). The most commonly 
     *        used values are <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, or both 
     *        (<b>GENERIC_READ</b> | <b>GENERIC_WRITE</b>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/generic-access-rights">Generic Access Rights</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * If this parameter is zero, the application can query  file, directory, or device attributes without accessing 
     *        that file or device. For more information, see the Remarks section of this topic.
     * 
     * You cannot request an access mode that conflicts with the sharing mode that is specified in an open request 
     *        that has an open handle. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * @param {Integer} dwShareMode The sharing mode of an object, which can be read, write, both, delete, all of these, or none (refer to the 
     *        following table).
     * 
     * If this parameter is zero and 
     *        <b>CreateFileTransacted</b> succeeds, the object cannot 
     *        be shared and cannot be opened again until the handle is closed. For more information, see the Remarks section 
     *        of this topic.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an open request 
     *        that has an open handle, because that would result in the following sharing violation: 
     *        <b>ERROR_SHARING_VIOLATION</b>. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * To enable a process to share an object while another process has the object open, use a combination of one or
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a> 
     *        structure that contains an optional 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> and also determines whether 
     *        or not the returned handle can be inherited by child processes. The parameter can be 
     *        <b>NULL</b>.
     * 
     * If the <i>lpSecurityAttributes</i> parameter is <b>NULL</b>, the handle 
     *        returned by <b>CreateFileTransacted</b> cannot be 
     *        inherited by any child processes your application may create and the object associated with the returned handle 
     *        gets a default security descriptor.
     * 
     * The <b>bInheritHandle</b> member of the structure specifies whether the returned handle 
     *        can be inherited.
     * 
     * The  <b>lpSecurityDescriptor</b> member of the structure specifies 
     *        a <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-security_descriptor">security descriptor</a> for an object, but may 
     *        also be <b>NULL</b>.
     * 
     * If <b>lpSecurityDescriptor</b> member is <b>NULL</b>, the object 
     *        associated with the returned handle is assigned a default security descriptor.
     * 
     * <b>CreateFileTransacted</b> ignores the 
     *        <b>lpSecurityDescriptor</b> member when opening an existing file, but continues to use the 
     *        <b>bInheritHandle</b> member.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwCreationDisposition An action to take on files that exist and  do not exist.
     * 
     * For more information, see the Remarks section of this topic.
     * @param {Integer} dwFlagsAndAttributes The file attributes and flags, <b>FILE_ATTRIBUTE_NORMAL</b> being the most common default 
     *        value.
     * 
     * This parameter can include any combination of the available file attributes 
     *        (<b>FILE_ATTRIBUTE_*</b>). All other file attributes override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * This parameter can also contain combinations of flags (<b>FILE_FLAG_*</b>) for control of 
     *        buffering behavior, access modes, and other special-purpose flags. These combine with any 
     *        <b>FILE_ATTRIBUTE_*</b> values.
     * 
     * This parameter can also contain Security Quality of Service (SQOS) information by specifying the 
     *        <b>SECURITY_SQOS_PRESENT</b> flag. Additional SQOS-related flags information is presented in 
     *        the table following the attributes and flags tables.
     * 
     * <div class="alert"><b>Note</b>  <p class="note">When <b>CreateFileTransacted</b> opens an existing 
     *         file, it generally combines the file flags with the file attributes of the existing file, and ignores any file 
     *         attributes supplied as part of <i>dwFlagsAndAttributes</i>. Special cases are detailed in 
     *         <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * </div>
     * <div> </div>
     * The following file attributes and flags are used only for file objects, not other types of objects that 
     *        <b>CreateFileTransacted</b> opens (additional 
     *        information can be found in the Remarks section of this topic). For more advanced access to file attributes, 
     *        see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>. For a complete list of all 
     *        file attributes with their values and descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ARCHIVE"></a><a id="file_attribute_archive"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ARCHIVE</b></dt>
     * <dt>32 (0x20)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file should be archived. Applications use this attribute to mark files for backup or removal.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_ENCRYPTED"></a><a id="file_attribute_encrypted"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_ENCRYPTED</b></dt>
     * <dt>16384 (0x4000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a 
     *          directory, this means that encryption is the default for newly created files and subdirectories. For more 
     *          information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-encryption">File Encryption</a>.
     * 
     * This flag has no effect if <b>FILE_ATTRIBUTE_SYSTEM</b> is also specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_HIDDEN"></a><a id="file_attribute_hidden"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_HIDDEN</b></dt>
     * <dt>2 (0x2)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is hidden. Do not include it in an ordinary directory listing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_NORMAL"></a><a id="file_attribute_normal"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_NORMAL</b></dt>
     * <dt>128 (0x80)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file does not have other attributes set. This attribute is valid only if used alone.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_OFFLINE"></a><a id="file_attribute_offline"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_OFFLINE</b></dt>
     * <dt>4096 (0x1000)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data of a file is not immediately available. This attribute indicates that file data is physically 
     *          moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management 
     *          software. Applications should not arbitrarily change this attribute.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_READONLY"></a><a id="file_attribute_readonly"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_READONLY</b></dt>
     * <dt>1 (0x1)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is read only. Applications can read the file, but cannot write to or delete it.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_SYSTEM"></a><a id="file_attribute_system"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_SYSTEM</b></dt>
     * <dt>4 (0x4)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is part of or used exclusively by an operating system.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_ATTRIBUTE_TEMPORARY"></a><a id="file_attribute_temporary"></a><dl>
     * <dt><b>FILE_ATTRIBUTE_TEMPORARY</b></dt>
     * <dt>256 (0x100)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being used for temporary storage.  File systems avoid writing data back to mass storage 
     *          if sufficient cache memory is available, because an application deletes a temporary file after a handle is 
     *          closed. In that case, the system can entirely avoid writing the data.  Otherwise, the data is written after 
     *          the handle is closed.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for a backup or restore operation. The system ensures that the 
     *          calling process overrides file security checks when the process has <b>SE_BACKUP_NAME</b> 
     *          and <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions instead of a file handle. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_DELETE_ON_CLOSE"></a><a id="file_flag_delete_on_close"></a><dl>
     * <dt><b>FILE_FLAG_DELETE_ON_CLOSE</b></dt>
     * <dt>0x04000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be deleted immediately after the last transacted writer handle to the file is closed, 
     *          provided that the transaction is still active. If a file has been marked for deletion and a transacted writer 
     *          handle is still open after the transaction completes, the file will not be deleted.
     * 
     * If there are existing open handles to a file, the call fails unless they were all opened with the 
     *          <b>FILE_SHARE_DELETE</b> share mode.
     * 
     * Subsequent open requests for the file fail, unless the <b>FILE_SHARE_DELETE</b> share 
     *          mode is specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened with no system caching. This flag does not affect hard disk caching or memory 
     *          mapped files. When combined with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum 
     *          asynchronous performance, because the I/O does not rely on the synchronous operations of the memory manager. 
     *          However, some I/O operations take more time, because data is not being held in the cache. Also, the file 
     *          metadata may still be cached. To flush the metadata to disk, use the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> function.
     * 
     * An application must meet certain requirements when working with files that are opened with 
     *          <b>FILE_FLAG_NO_BUFFERING</b>:
     * 
     * <ul>
     * <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector 
     *           size.</li>
     * <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For 
     *           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, 
     *           or 2048 bytes, but not of 335, 981, or 7171 bytes.</li>
     * <li>Buffer addresses for read and write operations should be sector aligned, which means aligned on 
     *           addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this 
     *           requirement may not be enforced.</li>
     * </ul>
     * One way to align buffers on integer multiples of the volume sector size is to use 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> to allocate the buffers. It allocates 
     *          memory that is aligned on addresses that are integer multiples of the operating system's memory page size. 
     *          Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses 
     *          that are integer multiples of a volume sector size. Memory pages are 4 or 8 KB in size; sectors are 512 bytes 
     *          (hard disks), 2048 bytes (CD), or 4096 bytes (hard disks), and therefore, volume sectors can never be larger 
     *          than memory pages.
     * 
     * An application can determine a volume sector size by calling the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> processing will not occur; 
     *          <b>CreateFileTransacted</b> will attempt to open the 
     *          reparse point. When a file is opened, a file handle is returned, whether or not the filter that controls the 
     *          reparse point is operational. This flag cannot be used with the <b>CREATE_ALWAYS</b> 
     *          flag. If the file is not a reparse point, then this flag is ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for asynchronous I/O. When the operation is complete, the event 
     *          specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is set to the 
     *          signaled state. Operations that take a significant amount of time to process return 
     *          <b>ERROR_IO_PENDING</b>.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations. The system does 
     *          not maintain the file pointer, therefore you must pass the file position to the read and write functions in 
     *          the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure or update the file 
     *          pointer.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_POSIX_SEMANTICS"></a><a id="file_flag_posix_semantics"></a><dl>
     * <dt><b>FILE_FLAG_POSIX_SEMANTICS</b></dt>
     * <dt>0x01000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed according to POSIX rules. This includes allowing multiple files with names, 
     *          differing only in case, for file systems that support that naming. Use care when using this option, because 
     *          files created with this flag may not be accessible by applications that are written for MS-DOS or 16-bit 
     *          Windows.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed randomly. The system can use this as a hint to optimize file caching.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SESSION_AWARE"></a><a id="file_flag_session_aware"></a><dl>
     * <dt><b>FILE_FLAG_SESSION_AWARE</b></dt>
     * <dt>0x00800000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file or device is being opened with session awareness. If this flag is not specified, then per-session 
     *          devices (such as a device using RemoteFX USB Redirection) cannot be opened by processes running in session 0. 
     *          This flag has no effect for callers not in session 0. This flag is supported only on server editions of 
     *          Windows.
     * 
     * <b>Windows Server 2008 R2 and Windows Server 2008:  </b>This flag is not supported before Windows Server 2012.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is to be accessed sequentially from beginning to end. The system can use this as a hint to 
     *          optimize file caching. If an application moves the file pointer for random access, optimum caching may not 
     *          occur. However, correct operation is still guaranteed.
     * 
     * Specifying this flag can increase performance for applications that read large files using sequential 
     *          access. Performance gains can be even more noticeable for applications that read large files mostly 
     *          sequentially, but occasionally skip over small ranges of bytes.
     * 
     * This flag  has no effect if the file system does not support cached I/O and 
     *          <b>FILE_FLAG_NO_BUFFERING</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Write operations will not go through any intermediate cache, they will go directly to disk.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in 
     *          effect, then the data is written to the system cache, but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in 
     *          effect, then the data is immediately flushed to disk without going through the system cache. The operating 
     *          system also requests a write-through the hard disk cache to persistent media. However, not all hardware 
     *          supports this write-through capability.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The <i>dwFlagsAndAttributes</i> parameter can also specify Security Quality of Service 
     *        information. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/impersonation-levels">Impersonation Levels</a>. When the calling 
     *        application specifies the <b>SECURITY_SQOS_PRESENT</b> flag as part of
     * @param {Pointer<Void>} hTemplateFile A valid handle to a template file with the <b>GENERIC_READ</b> access right. The template 
     *        file supplies file attributes and extended attributes for the file that is being created. This parameter can be 
     *        <b>NULL</b>.
     * 
     * When opening an existing file, 
     *        <b>CreateFileTransacted</b> ignores the template 
     *        file.
     * 
     * When opening a new EFS-encrypted file, the file inherits the DACL from its parent directory.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @param {Pointer<UInt32>} pusMiniVersion The miniversion to be opened. If the transaction specified in <i>hTransaction</i> is not 
     *        the transaction that is modifying the file, this parameter should be <b>NULL</b>. Otherwise, 
     *        this parameter can be a miniversion identifier returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_txfs_create_miniversion">FSCTL_TXFS_CREATE_MINIVERSION</a> control
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or 
     *        mail slot.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createfiletransactedw
     * @since windows6.0.6000
     */
    static CreateFileTransactedW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion) {
        static lpExtendedParameter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateFileTransactedW", "ptr", lpFileName, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwCreationDisposition, "uint", dwFlagsAndAttributes, "ptr", hTemplateFile, "ptr", hTransaction, "uint*", pusMiniVersion, "ptr", lpExtendedParameter)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Reopens the specified file system object with different access rights, sharing mode, and flags.
     * @remarks
     * The <i>dwFlags</i> parameter cannot contain any of the file attribute flags 
     *     (<b>FILE_ATTRIBUTE_*</b>). These can only be specified when the file is created.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hOriginalFile A handle to the object to be reopened. The object must have been created by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function.
     * @param {Integer} dwDesiredAccess The required access to the object. For a list of values, see 
     * 	      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>. You 
     * 	      cannot request an access mode that conflicts with the sharing mode specified in a previous open request whose 
     * 	      handle is still open.
     * 
     * If this parameter is zero (0), the application can query device attributes without accessing the device. This 
     *        is useful if an application wants to determine the size of a floppy disk drive and the formats it supports 
     *        without requiring a floppy in the drive.
     * @param {Integer} dwShareMode The sharing mode of the object. You cannot request a sharing mode that conflicts with the access mode 
     *        specified in a previous open request whose handle is still open.
     * 
     * If this parameter is zero (0) and <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> succeeds, 
     *        the object cannot be shared and cannot be opened again until the handle is closed.
     * 
     * To enable other processes to share the object while your process has it open, use a combination of one or
     * @param {Integer} dwFlagsAndAttributes 
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to the specified file.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-reopenfile
     * @since windows6.0.6000
     */
    static ReOpenFile(hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReOpenFile", "ptr", hOriginalFile, "uint", dwDesiredAccess, "uint", dwShareMode, "uint", dwFlagsAndAttributes)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the attributes for a file or directory as a transacted operation. (ANSI)
     * @remarks
     * The following table describes how to set the attributes that cannot be set using 
     *     <b>SetFileAttributesTransacted</b>. Note that these 
     *     are not transacted operations.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>How to Set</th>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_COMPRESSED</b>
     * 
     * 0x800
     * 
     * </td>
     * <td>To set a file's compression state, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DEVICE</b>
     * 
     * 0x40
     * 
     * </td>
     * <td>Reserved; do not use.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DIRECTORY</b>
     * 
     * 0x10
     * 
     * </td>
     * <td>Files cannot be converted into directories. To create a directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a> function.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_ENCRYPTED</b>
     * 
     * 0x4000
     * 
     * </td>
     * <td>To create an encrypted file, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 
     *        function with the <b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file 
     *        into an encrypted file, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-encryptfilea">EncryptFile</a> 
     *        function.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
     * 
     * 0x400
     * 
     * </td>
     * <td>To associate a reparse point with a file or directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
     * 
     * 0x200
     * 
     * </td>
     * <td>To set a file's sparse attribute, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</td>
     * </tr>
     * </table>
     *  
     * 
     * If a file is open for modification in a transaction, no other thread can successfully open the file for 
     *     modification until the transaction is committed. If a transacted thread opens the file first, any subsequent 
     *     threads that attempt to open the file for modification before the transaction is committed will receive a sharing 
     *     violation. If a non-transacted thread opens the file for modification before the transacted thread does, and it is 
     *     still open when the transacted thread attempts to open it, the transaction will receive the 
     *     <b>ERROR_TRANSACTIONAL_CONFLICT</b> error.
     * 
     * For more information on transactions, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines SetFileAttributesTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * For a list of file attribute value and their descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. This parameter can be 
     *        one or more values, combined using the bitwise-OR operator. However, all other values override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setfileattributestransacteda
     * @since windows6.0.6000
     */
    static SetFileAttributesTransactedA(lpFileName, dwFileAttributes, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesTransactedA", "ptr", lpFileName, "uint", dwFileAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the attributes for a file or directory as a transacted operation. (Unicode)
     * @remarks
     * The following table describes how to set the attributes that cannot be set using 
     *     <b>SetFileAttributesTransacted</b>. Note that these 
     *     are not transacted operations.
     * 
     * <table>
     * <tr>
     * <th>Attribute</th>
     * <th>How to Set</th>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_COMPRESSED</b>
     * 
     * 0x800
     * 
     * </td>
     * <td>To set a file's compression state, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_compression">FSCTL_SET_COMPRESSION</a> operation.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DEVICE</b>
     * 
     * 0x40
     * 
     * </td>
     * <td>Reserved; do not use.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_DIRECTORY</b>
     * 
     * 0x10
     * 
     * </td>
     * <td>Files cannot be converted into directories. To create a directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a> function.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_ENCRYPTED</b>
     * 
     * 0x4000
     * 
     * </td>
     * <td>To create an encrypted file, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 
     *        function with the <b>FILE_ATTRIBUTE_ENCRYPTED</b> attribute. To convert an existing file 
     *        into an encrypted file, use the <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-encryptfilea">EncryptFile</a> 
     *        function.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_REPARSE_POINT</b>
     * 
     * 0x400
     * 
     * </td>
     * <td>To associate a reparse point with a file or directory, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_reparse_point">FSCTL_SET_REPARSE_POINT</a> operation.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>FILE_ATTRIBUTE_SPARSE_FILE</b>
     * 
     * 0x200
     * 
     * </td>
     * <td>To set a file's sparse attribute, use the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> function with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winioctl/ni-winioctl-fsctl_set_sparse">FSCTL_SET_SPARSE</a> operation.</td>
     * </tr>
     * </table>
     *  
     * 
     * If a file is open for modification in a transaction, no other thread can successfully open the file for 
     *     modification until the transaction is committed. If a transacted thread opens the file first, any subsequent 
     *     threads that attempt to open the file for modification before the transaction is committed will receive a sharing 
     *     violation. If a non-transacted thread opens the file for modification before the transacted thread does, and it is 
     *     still open when the transacted thread attempts to open it, the transaction will receive the 
     *     <b>ERROR_TRANSACTIONAL_CONFLICT</b> error.
     * 
     * For more information on transactions, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/transactional-ntfs-portal">Transactional NTFS</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. So if a transacted thread opens the file first, any subsequent threads that try 
     *       modifying the file before the transaction is committed receives a sharing violation. If a non-transacted thread 
     *       modifies the file before the transacted thread does, and the file is still open when the transaction attempts to 
     *       open it, the transaction receives the error <b>ERROR_TRANSACTIONAL_CONFLICT</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines SetFileAttributesTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file whose attributes are to be set.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">File Names, Paths, and Namespaces</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *       <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} dwFileAttributes The file attributes to set for the file.
     * 
     * For a list of file attribute value and their descriptions, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-attribute-constants">File Attribute Constants</a>. This parameter can be 
     *        one or more values, combined using the bitwise-OR operator. However, all other values override 
     *        <b>FILE_ATTRIBUTE_NORMAL</b>.
     * 
     * Not all attributes are supported by this function. For more information, see the Remarks section.
     * 
     * The following is a list of supported attribute values.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setfileattributestransactedw
     * @since windows6.0.6000
     */
    static SetFileAttributesTransactedW(lpFileName, dwFileAttributes, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileAttributesTransactedW", "ptr", lpFileName, "uint", dwFileAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory as a transacted operation. (ANSI)
     * @remarks
     * When <b>GetFileAttributesTransacted</b> is 
     *     called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root directory in the volume that the mounted folder associates with the directory. To obtain the 
     *     file attributes of the associated volume, call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw">GetVolumeNameForVolumeMountPoint</a> to 
     *     obtain the name of the associated volume. Then use the resulting name in a call to 
     *     <b>GetFileAttributesTransacted</b>. The results are 
     *     the attributes of the root directory on the associated volume.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the function returns attributes for the symbolic link.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. Conversely, if a file is open for modification outside of a transaction, no 
     *       transacted thread can open the file for modification until the non-transacted handle is closed. If a 
     *       non-transacted thread has a handle opened to modify a file, a call to 
     *       <b>GetFileAttributesTransacted</b> for that file 
     *       will fail with an <b>ERROR_TRANSACTIONAL_CONFLICT</b> error.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetFileAttributesTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file or directory.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The level of attribute information to retrieve.
     *       
     * 
     * This parameter can be the following value from the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     *       
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>. If the <i>fInfoLevelId</i> parameter is 
     *        <b>GetFileExInfoStandard</b> then this parameter points to a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getfileattributestransacteda
     * @since windows6.0.6000
     */
    static GetFileAttributesTransactedA(lpFileName, fInfoLevelId, lpFileInformation, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesTransactedA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file system attributes for a specified file or directory as a transacted operation. (Unicode)
     * @remarks
     * When <b>GetFileAttributesTransacted</b> is 
     *     called on a directory that is a mounted folder, it returns the attributes of the directory, not those of the root directory in the volume that the mounted folder associates with the directory. To obtain the 
     *     file attributes of the associated volume, call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumenameforvolumemountpointw">GetVolumeNameForVolumeMountPoint</a> to 
     *     obtain the name of the associated volume. Then use the resulting name in a call to 
     *     <b>GetFileAttributesTransacted</b>. The results are 
     *     the attributes of the root directory on the associated volume.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the function returns attributes for the symbolic link.
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If a file is open for modification in a transaction, no other thread can open the file for modification until 
     *       the transaction is committed. Conversely, if a file is open for modification outside of a transaction, no 
     *       transacted thread can open the file for modification until the non-transacted handle is closed. If a 
     *       non-transacted thread has a handle opened to modify a file, a call to 
     *       <b>GetFileAttributesTransacted</b> for that file 
     *       will fail with an <b>ERROR_TRANSACTIONAL_CONFLICT</b> error.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetFileAttributesTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file or directory.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file or directory must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The level of attribute information to retrieve.
     *       
     * 
     * This parameter can be the following value from the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> enumeration.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="GetFileExInfoStandard"></a><a id="getfileexinfostandard"></a><a id="GETFILEEXINFOSTANDARD"></a><dl>
     * <dt><b>GetFileExInfoStandard</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpFileInformation</i> parameter is a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFileInformation A pointer to a buffer that receives the attribute information.
     *       
     * 
     * The type of attribute information that is stored into this buffer is determined by the value of 
     *        <i>fInfoLevelId</i>. If the <i>fInfoLevelId</i> parameter is 
     *        <b>GetFileExInfoStandard</b> then this parameter points to a 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">WIN32_FILE_ATTRIBUTE_DATA</a> 
     *         structure
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getfileattributestransactedw
     * @since windows6.0.6000
     */
    static GetFileAttributesTransactedW(lpFileName, fInfoLevelId, lpFileInformation, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileAttributesTransactedW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFileInformation, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file as a transacted operation. (ANSI)
     * @remarks
     * An application can determine whether a volume is compressed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.
     * 
     * If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesize">GetFileSize</a>.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the function returns the file size of the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetCompressedFileSizeTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<UInt32>} lpFileSizeHigh A pointer to a variable that receives the high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getcompressedfilesizetransacteda
     * @since windows6.0.6000
     */
    static GetCompressedFileSizeTransactedA(lpFileName, lpFileSizeHigh, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeTransactedA", "ptr", lpFileName, "uint*", lpFileSizeHigh, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the actual number of bytes of disk storage used to store a specified file as a transacted operation. (Unicode)
     * @remarks
     * An application can determine whether a volume is compressed by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">GetVolumeInformation</a>, then checking the status of the <b>FS_VOL_IS_COMPRESSED</b> flag in the <b>DWORD</b> value pointed to by that function's <i>lpFileSystemFlags</i> parameter.
     * 
     * If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed or a sparse file, the value obtained is the actual file size, the same as the value returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfilesize">GetFileSize</a>.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the function returns the file size of the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines GetCompressedFileSizeTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file. 
     * 
     * 
     * 
     * 
     * Do not specify the name of a file on a nonseeking device, such as a pipe or a communications device, as its file size has no meaning.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<UInt32>} lpFileSizeHigh A pointer to a variable that receives the high-order <b>DWORD</b> of the compressed file size. The function's return value is the low-order <b>DWORD</b> of the compressed file size. 
     * 
     * 
     * 
     * 
     * This parameter can be <b>NULL</b> if the high-order <b>DWORD</b> of the compressed file size is not needed. Files less than 4 gigabytes in size do not need the high-order <b>DWORD</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is the low-order <b>DWORD</b> of the actual number of bytes of disk storage used to store the specified file, and if <i>lpFileSizeHigh</i> is non-<b>NULL</b>, the function puts the high-order <b>DWORD</b> of that actual value into the <b>DWORD</b> pointed to by that parameter. This is the compressed file size for compressed files, the actual file size for noncompressed files.
     * 
     * If the function fails, and <i>lpFileSizeHigh</i> is <b>NULL</b>, the return value is <b>INVALID_FILE_SIZE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the return value is <b>INVALID_FILE_SIZE</b> and <i>lpFileSizeHigh</i> is non-<b>NULL</b>, an application must call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> to determine whether the function has succeeded (value is <b>NO_ERROR</b>) or failed (value is other than <b>NO_ERROR</b>).
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getcompressedfilesizetransactedw
     * @since windows6.0.6000
     */
    static GetCompressedFileSizeTransactedW(lpFileName, lpFileSizeHigh, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetCompressedFileSizeTransactedW", "ptr", lpFileName, "uint*", lpFileSizeHigh, "ptr", hTransaction, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file as a transacted operation. (ANSI)
     * @remarks
     * If an application attempts to delete a file that does not exist, the 
     *     <b>DeleteFileTransacted</b> function fails with 
     *     <b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with 
     *     <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The following list identifies some tips for deleting, removing, or closing files:
     * 
     * <ul>
     * <li>To delete a read-only file, first you must remove the read-only attribute.</li>
     * <li>To delete or rename a file, you must have either delete permission on the file, or delete child permission 
     *       in the parent directory.</li>
     * <li>To recursively delete the files in a directory, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> function.</li>
     * <li>To remove an empty directory, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-removedirectorytransacteda">RemoveDirectoryTransacted</a> function.</li>
     * <li>To close an open file, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function.</li>
     * </ul>
     * If you set up a directory with all access except delete and delete child, and the access control lists (ACL) 
     *       of new files are inherited, then you can create a file without being able to delete it. However, then you can 
     *       create a file, and then get all the access you request on the handle that is returned to you at the time you 
     *       create the file.
     * 
     * If you request delete permission at the time you create a file, you can delete or rename the file with that 
     *       handle, but not with any other handle. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * The <b>DeleteFileTransacted</b> function fails if an 
     *     application attempts to delete a file that has other handles open for normal I/O or as a memory-mapped file 
     *     (<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).
     * 
     * The <b>DeleteFileTransacted</b> function marks a file 
     *     for deletion on close. The file is deleted after the last transacted writer handle to the file is closed, provided 
     *     that the transaction is still active. If a file has been marked for deletion and a transacted writer handle is 
     *     still open after the transaction completes, the file will not be deleted.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you 
     *       must call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> and specify 
     *       <b>FILE_FLAG_DELETE_ON_CLOSE</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines DeleteFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-deletefiletransacteda
     * @since windows6.0.6000
     */
    static DeleteFileTransactedA(lpFileName, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileTransactedA", "ptr", lpFileName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes an existing file as a transacted operation. (Unicode)
     * @remarks
     * If an application attempts to delete a file that does not exist, the 
     *     <b>DeleteFileTransacted</b> function fails with 
     *     <b>ERROR_FILE_NOT_FOUND</b>. If the file is a read-only file, the function fails with 
     *     <b>ERROR_ACCESS_DENIED</b>.
     * 
     * The following list identifies some tips for deleting, removing, or closing files:
     * 
     * <ul>
     * <li>To delete a read-only file, first you must remove the read-only attribute.</li>
     * <li>To delete or rename a file, you must have either delete permission on the file, or delete child permission 
     *       in the parent directory.</li>
     * <li>To recursively delete the files in a directory, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> function.</li>
     * <li>To remove an empty directory, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-removedirectorytransacteda">RemoveDirectoryTransacted</a> function.</li>
     * <li>To close an open file, use the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function.</li>
     * </ul>
     * If you set up a directory with all access except delete and delete child, and the access control lists (ACL) 
     *       of new files are inherited, then you can create a file without being able to delete it. However, then you can 
     *       create a file, and then get all the access you request on the handle that is returned to you at the time you 
     *       create the file.
     * 
     * If you request delete permission at the time you create a file, you can delete or rename the file with that 
     *       handle, but not with any other handle. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * The <b>DeleteFileTransacted</b> function fails if an 
     *     application attempts to delete a file that has other handles open for normal I/O or as a memory-mapped file 
     *     (<b>FILE_SHARE_DELETE</b> must have been specified when other handles were opened).
     * 
     * The <b>DeleteFileTransacted</b> function marks a file 
     *     for deletion on close. The file is deleted after the last transacted writer handle to the file is closed, provided 
     *     that the transaction is still active. If a file has been marked for deletion and a transacted writer handle is 
     *     still open after the transaction completes, the file will not be deleted.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the symbolic link is deleted, not the target. To delete a target, you 
     *       must call <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> and specify 
     *       <b>FILE_FLAG_DELETE_ON_CLOSE</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines DeleteFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the file to be deleted.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-deletefiletransactedw
     * @since windows6.0.6000
     */
    static DeleteFileTransactedW(lpFileName, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteFileTransactedW", "ptr", lpFileName, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the specified name can be used to create a file on a FAT file system. (ANSI)
     * @remarks
     * This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based 
     *     application or an MS-DOS-based application.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpName The file name, in 8.3 format.
     * @param {Pointer<Byte>} lpOemName A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} OemNameSize The size of the <i>lpOemName</i> buffer, in characters. If 
     *       <i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).
     * @param {Pointer<Int32>} pbNameContainsSpaces Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If 
     *       the name is not a valid 8.3 FAT file system name, this parameter is undefined.
     * @param {Pointer<Int32>} pbNameLegal If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when 
     *       the current OEM code page is applied to the file name.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-checknamelegaldos8dot3a
     * @since windows6.0.6000
     */
    static CheckNameLegalDOS8Dot3A(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal) {
        lpName := lpName is String? StrPtr(lpName) : lpName
        lpOemName := lpOemName is String? StrPtr(lpOemName) : lpOemName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CheckNameLegalDOS8Dot3A", "ptr", lpName, "ptr", lpOemName, "uint", OemNameSize, "int*", pbNameContainsSpaces, "int*", pbNameLegal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Determines whether the specified name can be used to create a file on a FAT file system. (Unicode)
     * @remarks
     * This function can be used to determine whether or not a file name can be passed to a 16-bit Windows-based 
     *     application or an MS-DOS-based application.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * See remarks
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support short names on shares with continuous availability capability, so function will always return zero (fail).
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CheckNameLegalDOS8Dot3 as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpName The file name, in 8.3 format.
     * @param {Pointer<Byte>} lpOemName A pointer to a buffer that receives the OEM string that corresponds to <i>Name</i>. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} OemNameSize The size of the <i>lpOemName</i> buffer, in characters. If 
     *       <i>lpOemName</i> is <b>NULL</b>, this parameter must be 0 (zero).
     * @param {Pointer<Int32>} pbNameContainsSpaces Indicates whether or not a name contains spaces. This parameter can be <b>NULL</b>. If 
     *       the name is not a valid 8.3 FAT file system name, this parameter is undefined.
     * @param {Pointer<Int32>} pbNameLegal If the function succeeds, this parameter indicates whether a file name is a valid 8.3 FAT file name when 
     *       the current OEM code page is applied to the file name.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is 0 (zero). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-checknamelegaldos8dot3w
     * @since windows6.0.6000
     */
    static CheckNameLegalDOS8Dot3W(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal) {
        lpName := lpName is String? StrPtr(lpName) : lpName
        lpOemName := lpOemName is String? StrPtr(lpOemName) : lpOemName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CheckNameLegalDOS8Dot3W", "ptr", lpName, "ptr", lpOemName, "uint", OemNameSize, "int*", pbNameContainsSpaces, "int*", pbNameLegal, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name as a transacted operation. (ANSI)
     * @remarks
     * The <b>FindFirstFileTransacted</b> function opens a search handle and 
     *     returns information about the first file that the file system finds with a name that matches the specified pattern. This may or may not be the first file or directory that appears in a directory-listing application (such as the dir command) when given the same file name string pattern. This is because <b>FindFirstFileTransacted</b> does no sorting of the search results. For additional information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.
     * 
     * The following list 
     *     identifies some other search characteristics:
     * 
     * <ul>
     * <li>The search is performed strictly on the name of the file, not on any attributes such as a date or a file 
     *       type.</li>
     * <li>The search includes the long and short file names.</li>
     * <li>An attempt to open 
     *     a search with a trailing backslash always fails.</li>
     * <li>Passing an invalid string, <b>NULL</b>, or empty string for the <i>lpFileName</i> parameter is not a valid use of this function. Results in this case are undefined.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  In rare cases, file information on NTFS file systems may not be current at the time you call this 
     *     function. To be assured of getting the current file information, call  the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * If the underlying file system does not support the specified type of filtering, other than directory 
     *     filtering, <b>FindFirstFileTransacted</b> fails with the error 
     *     <b>ERROR_NOT_SUPPORTED</b>. The application must use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> type 
     *     <b>FileExSearchNameMatch</b> and perform its own filtering.
     * 
     * After the search handle is established, use it in the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> function to search for other 
     *     files that match the same pattern with the same filtering that is being performed. When the search handle is not 
     *     needed, it should be closed by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * As stated previously, you cannot use a trailing backslash (\\) in the <i>lpFileName</i> input string for 
     *     <b>FindFirstFileTransacted</b>, therefore it may not be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the following options would apply:
     * 
     * <ul>
     * <li>To examine files in a root directory, you can use "C:\*" and step through the directory by 
     *       using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.</li>
     * <li>To get the attributes of a root directory, use 
     *       the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.</div>
     * <div> </div>
     * 
     * On network shares, you can use an <i>lpFileName</i> in the form of the following: 
     *     "\\\\server\\service\*". However, you cannot use an <i>lpFileName</i> that points to 
     *     the share itself; for example, "\\\\server\\service" is not valid.
     * 
     * To examine a directory that is not a root directory, use the path to that directory, without a trailing 
     *     backslash. For example, an argument of "C:\\Windows" returns information about the directory 
     *     "C:\\Windows", not about a directory or file in "C:\\Windows". To examine the files and directories in "C:\\Windows", use an <i>lpFileName</i> of "C:\\Windows\\*".
     * 
     * Be aware that some other thread or process could create or delete a file with this name between the time you query for the result 
     *     and the time you act on the information. If this is a potential concern for your application,  one possible solution is to use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with 
     *     <b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b> (which fails 
     *     if the file does not exist).
     * 
     * If you are writing a 32-bit application to list all the files in a directory and the application may be run on 
     *     a 64-bit computer, you should call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a> before 
     *     calling <b>FindFirstFileTransacted</b> and call <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> after the last call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> buffer contains information about 
     *     the symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FindFirstFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and 
     *        all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 
     *        32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the 
     *        path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *        receives information about a found file or subdirectory.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
     * 
     * If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended 
     *        error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findfirstfiletransacteda
     * @since windows6.0.6000
     */
    static FindFirstFileTransactedA(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags, hTransaction) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileTransactedA", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags, "ptr", hTransaction)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Searches a directory for a file or subdirectory with a name that matches a specific name as a transacted operation. (Unicode)
     * @remarks
     * The <b>FindFirstFileTransacted</b> function opens a search handle and 
     *     returns information about the first file that the file system finds with a name that matches the specified pattern. This may or may not be the first file or directory that appears in a directory-listing application (such as the dir command) when given the same file name string pattern. This is because <b>FindFirstFileTransacted</b> does no sorting of the search results. For additional information, see <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.
     * 
     * The following list 
     *     identifies some other search characteristics:
     * 
     * <ul>
     * <li>The search is performed strictly on the name of the file, not on any attributes such as a date or a file 
     *       type.</li>
     * <li>The search includes the long and short file names.</li>
     * <li>An attempt to open 
     *     a search with a trailing backslash always fails.</li>
     * <li>Passing an invalid string, <b>NULL</b>, or empty string for the <i>lpFileName</i> parameter is not a valid use of this function. Results in this case are undefined.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  In rare cases, file information on NTFS file systems may not be current at the time you call this 
     *     function. To be assured of getting the current file information, call  the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> function.</div>
     * <div> </div>
     * If the underlying file system does not support the specified type of filtering, other than directory 
     *     filtering, <b>FindFirstFileTransacted</b> fails with the error 
     *     <b>ERROR_NOT_SUPPORTED</b>. The application must use 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> type 
     *     <b>FileExSearchNameMatch</b> and perform its own filtering.
     * 
     * After the search handle is established, use it in the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> function to search for other 
     *     files that match the same pattern with the same filtering that is being performed. When the search handle is not 
     *     needed, it should be closed by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * As stated previously, you cannot use a trailing backslash (\\) in the <i>lpFileName</i> input string for 
     *     <b>FindFirstFileTransacted</b>, therefore it may not be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the following options would apply:
     * 
     * <ul>
     * <li>To examine files in a root directory, you can use "C:\*" and step through the directory by 
     *       using <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>.</li>
     * <li>To get the attributes of a root directory, use 
     *       the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> function.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Prepending the string "\\?\" does not allow access to the root directory.</div>
     * <div> </div>
     * 
     * On network shares, you can use an <i>lpFileName</i> in the form of the following: 
     *     "\\\\server\\service\*". However, you cannot use an <i>lpFileName</i> that points to 
     *     the share itself; for example, "\\\\server\\service" is not valid.
     * 
     * To examine a directory that is not a root directory, use the path to that directory, without a trailing 
     *     backslash. For example, an argument of "C:\\Windows" returns information about the directory 
     *     "C:\\Windows", not about a directory or file in "C:\\Windows". To examine the files and directories in "C:\\Windows", use an <i>lpFileName</i> of "C:\\Windows\\*".
     * 
     * Be aware that some other thread or process could create or delete a file with this name between the time you query for the result 
     *     and the time you act on the information. If this is a potential concern for your application,  one possible solution is to use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> function with 
     *     <b>CREATE_NEW</b> (which fails if the file exists) or <b>OPEN_EXISTING</b> (which fails 
     *     if the file does not exist).
     * 
     * If you are writing a 32-bit application to list all the files in a directory and the application may be run on 
     *     a 64-bit computer, you should call 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64disablewow64fsredirection">Wow64DisableWow64FsRedirection</a> before 
     *     calling <b>FindFirstFileTransacted</b> and call <a href="https://docs.microsoft.com/windows/desktop/api/wow64apiset/nf-wow64apiset-wow64revertwow64fsredirection">Wow64RevertWow64FsRedirection</a> after the last call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a>. For more information, see <a href="https://docs.microsoft.com/windows/desktop/WinProg64/file-system-redirector">File System Redirector</a>.
     * 
     * If the path points to a symbolic link, the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> buffer contains information about 
     *     the symbolic link, not the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FindFirstFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The directory or path, and the file name. The file name can include wildcard characters,  for example, an asterisk 
     *        (*) or a question mark (?).
     * 
     * This parameter should not be <b>NULL</b>, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).
     * 
     * If the string ends with a wildcard, period (.), or directory name, the user must have access to the root and 
     *        all subdirectories on the path.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 
     *        32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the 
     *        path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Integer} fInfoLevelId The information level of the returned data.
     *       
     * 
     * This parameter is one of the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_info_levels">FINDEX_INFO_LEVELS</a> enumeration values.
     * @param {Pointer<Void>} lpFindFileData A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-win32_find_dataa">WIN32_FIND_DATA</a> structure that 
     *        receives information about a found file or subdirectory.
     * @param {Integer} fSearchOp The type of filtering to perform that is different from wildcard matching.
     *       
     * 
     * This parameter is one of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-findex_search_ops">FINDEX_SEARCH_OPS</a> 
     *        enumeration values.
     * @param {Integer} dwAdditionalFlags Specifies additional flags that control the search.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FIND_FIRST_EX_CASE_SENSITIVE"></a><a id="find_first_ex_case_sensitive"></a><dl>
     * <dt><b>FIND_FIRST_EX_CASE_SENSITIVE</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches are case-sensitive.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilea">FindNextFile</a> or 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a>, and  the <i>lpFindFileData</i> parameter contains information about the first file or directory found.
     * 
     * If the function fails or fails to locate files from the search string in the <i>lpFileName</i> parameter, the return value is <b>INVALID_HANDLE_VALUE</b> and the contents of <i>lpFindFileData</i> are indeterminate. To get extended 
     *        error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findfirstfiletransactedw
     * @since windows6.0.6000
     */
    static FindFirstFileTransactedW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, dwAdditionalFlags, hTransaction) {
        static lpSearchFilter := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileTransactedW", "ptr", lpFileName, "int", fInfoLevelId, "ptr", lpFindFileData, "int", fSearchOp, "ptr", lpSearchFilter, "uint", dwAdditionalFlags, "ptr", hTransaction)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file. (CopyFileA)
     * @remarks
     * The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are 
     *      copied to the new file.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until 
     *       Windows 8 and Windows Server 2012.
     * 
     * File attributes for the existing file are copied to the new file. For example, if an existing file has the 
     *     <b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to 
     *     <b>CopyFile</b> will also have the 
     *     <b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.
     * 
     * This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists 
     *     and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b> 
     *     attribute set.
     * 
     * When <b>CopyFile</b> is used to copy an encrypted file, it attempts 
     *      to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done, 
     *      this function attempts to encrypt the destination file with default keys. If 
     *      neither of these methods can be done, <b>CopyFile</b> fails with an 
     *      <b>ERROR_ENCRYPTION_FAILED</b> error code.
     * 
     * Symbolic link behavior—If the source file is a symbolic link, the actual file copied is 
     *      the target of the symbolic link.
     * 
     * If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten 
     *      by the source file.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, 
     *       <b>CopyFile</b> fails, and 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {Pointer<Byte>} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} bFailIfExists If this parameter is <b>TRUE</b> and the new file specified by 
     *       <i>lpNewFileName</i> already exists, the function fails. If this parameter is 
     *       <b>FALSE</b> and the new file already exists, the function overwrites the existing file and 
     *       succeeds.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfilea
     * @since windows5.1.2600
     */
    static CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int", bFailIfExists, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The CopyFileW (Unicode) function (winbase.h) copies an existing file to a new file.
     * @remarks
     * The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are 
     *      copied to the new file.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until 
     *       Windows 8 and Windows Server 2012.
     * 
     * File attributes for the existing file are copied to the new file. For example, if an existing file has the 
     *     <b>FILE_ATTRIBUTE_READONLY</b> file attribute, a copy created through a call to 
     *     <b>CopyFile</b> will also have the 
     *     <b>FILE_ATTRIBUTE_READONLY</b> file attribute. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/retrieving-and-changing-file-attributes">Retrieving and Changing File Attributes</a>.
     * 
     * This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists 
     *     and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b> 
     *     attribute set.
     * 
     * When <b>CopyFile</b> is used to copy an encrypted file, it attempts 
     *      to encrypt the destination file with the keys used in the encryption of the source file. If this cannot be done, 
     *      this function attempts to encrypt the destination file with default keys. If 
     *      neither of these methods can be done, <b>CopyFile</b> fails with an 
     *      <b>ERROR_ENCRYPTION_FAILED</b> error code.
     * 
     * Symbolic link behavior—If the source file is a symbolic link, the actual file copied is 
     *      the target of the symbolic link.
     * 
     * If the destination file already exists and is a symbolic link, the target of the symbolic link is overwritten 
     *      by the source file.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, 
     *       <b>CopyFile</b> fails, and 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {Pointer<Char>} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CopyFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} bFailIfExists If this parameter is <b>TRUE</b> and the new file specified by 
     *       <i>lpNewFileName</i> already exists, the function fails. If this parameter is 
     *       <b>FALSE</b> and the new file already exists, the function overwrites the existing file and 
     *       succeeds.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfilew
     * @since windows5.1.2600
     */
    static CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int", bFailIfExists, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file, notifying the application of its progress through a callback function. (CopyFileExA)
     * @remarks
     * This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams, 
     *      security resource attributes, and file attributes.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8 
     *       and Windows Server 2012.
     * 
     * The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are 
     *      copied to the new file.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until 
     *       Windows 8 and Windows Server 2012.
     * 
     * This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists 
     *     and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b> 
     *     attribute set.
     * 
     * When encrypted files are copied using <b>CopyFileEx</b>, the 
     *      function attempts to encrypt the destination file with the keys used in the encryption of the source file. If 
     *      this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these 
     *      methods cannot be done, <b>CopyFileEx</b> fails with an 
     *      <b>ERROR_ENCRYPTION_FAILED</b> error code. If you want 
     *      <b>CopyFileEx</b> to complete the copy operation even if the 
     *      destination file cannot be encrypted, include the 
     *      <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the 
     *      <i>dwCopyFlags</i> parameter in your call to 
     *      <b>CopyFileEx</b>.
     * 
     * 
     * If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:
     * 
     * <ul>
     * <li>If the source file is a symbolic link, the symbolic link is copied, not the target file.</li>
     * <li>If the source file is not a symbolic link, there is no change in behavior.</li>
     * <li>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target 
     *        file.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails in all cases.</li>
     * </ul>
     * If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:
     * 
     * <ul>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails only if the target of the symbolic link exists.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</li>
     * </ul>
     * 
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> function from Windows Sockets 
     *       (Winsock). <b>TransmitFile</b> supports high-performance 
     *       network transfers and provides a simple interface to send the contents of a file to a remote computer. To use 
     *       <b>TransmitFile</b>, you must write a Winsock client 
     *       application that sends the file from the source computer as well as a Winsock server application that uses 
     *       other Winsock functions to receive the file on the remote computer.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpExistingFileName The name of an existing file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, the 
     *       <b>CopyFileEx</b> function fails, and the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {Pointer<Byte>} lpNewFileName The name of the new file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to 
     *        the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Int32>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_ALLOW_DECRYPTED_DESTINATION"></a><a id="copy_file_allow_decrypted_destination"></a><dl>
     * <dt><b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_NO_BUFFERING"></a><a id="copy_file_no_buffering"></a><dl>
     * <dt><b>COPY_FILE_NO_BUFFERING</b></dt>
     * <dt>0x00001000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended 
     *         for very large file transfers.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * 
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b></dt>
     * <dt> 0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <p>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</p>
     * <p>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</p>
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfileexa
     * @since windows5.1.2600
     */
    static CopyFileExA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileExA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "int*", pbCancel, "uint", dwCopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file, notifying the application of its progress through a callback function. (CopyFileExW)
     * @remarks
     * This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams, 
     *      security resource attributes, and file attributes.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are not copied to the new file until Windows 8 
     *       and Windows Server 2012.
     * 
     * The security resource properties (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing file are 
     *      copied to the new file.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource properties for the existing file are not copied to the new file until 
     *       Windows 8 and Windows Server 2012.
     * 
     * This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists 
     *     and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b> 
     *     attribute set.
     * 
     * When encrypted files are copied using <b>CopyFileEx</b>, the 
     *      function attempts to encrypt the destination file with the keys used in the encryption of the source file. If 
     *      this cannot be done, this function attempts to encrypt the destination file with default keys. If both of these 
     *      methods cannot be done, <b>CopyFileEx</b> fails with an 
     *      <b>ERROR_ENCRYPTION_FAILED</b> error code. If you want 
     *      <b>CopyFileEx</b> to complete the copy operation even if the 
     *      destination file cannot be encrypted, include the 
     *      <b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b> as the value of the 
     *      <i>dwCopyFlags</i> parameter in your call to 
     *      <b>CopyFileEx</b>.
     * 
     * 
     * If <b>COPY_FILE_COPY_SYMLINK</b>  is specified, the following rules apply:
     * 
     * <ul>
     * <li>If the source file is a symbolic link, the symbolic link is copied, not the target file.</li>
     * <li>If the source file is not a symbolic link, there is no change in behavior.</li>
     * <li>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target 
     *        file.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails in all cases.</li>
     * </ul>
     * If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:
     * 
     * <ul>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails only if the target of the symbolic link exists.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in behavior.</li>
     * </ul>
     * 
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>If you are writing an application that is optimizing file copy operations across a LAN, consider using the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> function from Windows Sockets 
     *       (Winsock). <b>TransmitFile</b> supports high-performance 
     *       network transfers and provides a simple interface to send the contents of a file to a remote computer. To use 
     *       <b>TransmitFile</b>, you must write a Winsock client 
     *       application that sends the file from the source computer as well as a Winsock server application that uses 
     *       other Winsock functions to receive the file on the remote computer.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CopyFileEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpExistingFileName The name of an existing file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, the 
     *       <b>CopyFileEx</b> function fails, and the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *       <b>ERROR_FILE_NOT_FOUND</b>.
     * @param {Pointer<Char>} lpNewFileName The name of the new file.
     *       
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to 
     *        the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting inWindows 10, version 1607, for the unicode version of this function (<b>CopyFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Int32>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_ALLOW_DECRYPTED_DESTINATION"></a><a id="copy_file_allow_decrypted_destination"></a><dl>
     * <dt><b>COPY_FILE_ALLOW_DECRYPTED_DESTINATION</b></dt>
     * <dt>0x00000008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to copy an encrypted file will succeed even if the destination copy cannot be encrypted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_NO_BUFFERING"></a><a id="copy_file_no_buffering"></a><dl>
     * <dt><b>COPY_FILE_NO_BUFFERING</b></dt>
     * <dt>0x00001000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation is performed using unbuffered I/O, bypassing system I/O cache resources. Recommended 
     *         for very large file transfers.
     *         
     * 
     * <b>Windows Server 2003 and Windows XP:  </b>This value is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_REQUEST_COMPRESSED_TRAFFIC</b></dt>
     * <dt> 0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <p>Request the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases.</p>
     * <p>This flag was introduced in Windows 10, version 1903 and Windows Server 2022. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</p>
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileEx</b> will return zero 
     *        and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfileexw
     * @since windows5.1.2600
     */
    static CopyFileExW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileExW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "int*", pbCancel, "uint", dwCopyFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file as a transacted operation, notifying the application of its progress through a callback function. (ANSI)
     * @remarks
     * This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams, 
     *      security attributes, and file attributes.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing 
     *       file are not copied to the new file until Windows 8 and Windows Server 2012.
     * 
     * This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists 
     *     and has the  <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b> 
     *     attribute set.
     * 
     * Encrypted files are not supported by TxF.
     * 
     * 
     * If <b>COPY_FILE_COPY_SYMLINK</b> is specified, the following rules apply:
     * 
     * <ul>
     * <li>If the source file is a symbolic link, the symbolic link is copied, not the target file.</li>
     * <li>If  the source file is not a symbolic link, there is no change in behavior.</li>
     * <li>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target 
     *        file.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails in all cases.</li>
     * </ul>
     * If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:
     * 
     * <ul>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails only if the target of the symbolic link exists.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in 
     *        behavior.</li>
     * </ul>
     * 
     * 
     * Link tracking is not supported by TxF.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CopyFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * If <i>lpExistingFileName</i> does not exist, the 
     *        <b>CopyFileTransacted</b> function fails, and the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Byte>} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Int32>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * 
     * If you attempt to call this function with a handle to a transaction that has already been rolled back, 
     *        <b>CopyFileTransacted</b> will return either 
     *        <b>ERROR_TRANSACTION_NOT_ACTIVE</b> or 
     *        <b>ERROR_INVALID_TRANSACTION</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfiletransacteda
     * @since windows6.0.6000
     */
    static CopyFileTransactedA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileTransactedA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "int*", pbCancel, "uint", dwCopyFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file as a transacted operation, notifying the application of its progress through a callback function. (Unicode)
     * @remarks
     * This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams, 
     *      security attributes, and file attributes.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008 and Windows Vista:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the existing 
     *       file are not copied to the new file until Windows 8 and Windows Server 2012.
     * 
     * This function fails with <b>ERROR_ACCESS_DENIED</b> if the destination file already exists 
     *     and has the  <b>FILE_ATTRIBUTE_HIDDEN</b> or <b>FILE_ATTRIBUTE_READONLY</b> 
     *     attribute set.
     * 
     * Encrypted files are not supported by TxF.
     * 
     * 
     * If <b>COPY_FILE_COPY_SYMLINK</b> is specified, the following rules apply:
     * 
     * <ul>
     * <li>If the source file is a symbolic link, the symbolic link is copied, not the target file.</li>
     * <li>If  the source file is not a symbolic link, there is no change in behavior.</li>
     * <li>If the destination file is an existing symbolic link, the symbolic link is overwritten, not the target 
     *        file.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails in all cases.</li>
     * </ul>
     * If <b>COPY_FILE_COPY_SYMLINK</b> is not specified, the following rules apply:
     * 
     * <ul>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is also specified, and the destination file is an 
     *        existing symbolic link, the operation fails only if the target of the symbolic link exists.</li>
     * <li>If <b>COPY_FILE_FAIL_IF_EXISTS</b> is not specified, there is no change in 
     *        behavior.</li>
     * </ul>
     * 
     * 
     * Link tracking is not supported by TxF.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CopyFileTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpExistingFileName The name of an existing file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * If <i>lpExistingFileName</i> does not exist, the 
     *        <b>CopyFileTransacted</b> function fails, and the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function returns 
     *        <b>ERROR_FILE_NOT_FOUND</b>.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @param {Pointer<Char>} lpNewFileName The name of the new file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine The address of a callback function of type <b>LPPROGRESS_ROUTINE</b> that is called 
     *       each time another portion of the file has been copied. This parameter can be <b>NULL</b>. For 
     *       more information on the progress callback function, see the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> function.
     * @param {Pointer<Void>} lpData The argument to be passed to the callback function. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Int32>} pbCancel If this flag is set to <b>TRUE</b> during the copy operation, the operation is canceled. 
     *       Otherwise, the copy operation will continue to completion.
     * @param {Integer} dwCopyFlags Flags that specify how the file is to be copied. This parameter can be a combination of the following 
     *       values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_COPY_SYMLINK"></a><a id="copy_file_copy_symlink"></a><dl>
     * <dt><b>COPY_FILE_COPY_SYMLINK</b></dt>
     * <dt>0x00000800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the source file is a symbolic link, the destination file is also a symbolic link pointing to the same 
     *         file that the source symbolic link is pointing to.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_FAIL_IF_EXISTS"></a><a id="copy_file_fail_if_exists"></a><dl>
     * <dt><b>COPY_FILE_FAIL_IF_EXISTS</b></dt>
     * <dt>0x00000001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation fails immediately if the target file already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_OPEN_SOURCE_FOR_WRITE"></a><a id="copy_file_open_source_for_write"></a><dl>
     * <dt><b>COPY_FILE_OPEN_SOURCE_FOR_WRITE</b></dt>
     * <dt>0x00000004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is copied and the original file is opened for write access.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="COPY_FILE_RESTARTABLE"></a><a id="copy_file_restartable"></a><dl>
     * <dt><b>COPY_FILE_RESTARTABLE</b></dt>
     * <dt>0x00000002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Progress of the copy is tracked in the target file in case the copy fails. The failed copy can be 
     *         restarted at a later time by specifying the same values for <i>lpExistingFileName</i> and 
     *         <i>lpNewFileName</i> as those used in the call that failed. This can significantly slow 
     *         down the copy operation as the new file may be flushed multiple times during the copy operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_CANCEL</b> due to the 
     *        user canceling the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is 
     *        deleted.
     * 
     * If <i>lpProgressRoutine</i> returns <b>PROGRESS_STOP</b> due to the 
     *        user stopping the operation, <b>CopyFileTransacted</b> 
     *        will return zero and <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. In this case, the partially copied destination file is left 
     *        intact.
     * 
     * If you attempt to call this function with a handle to a transaction that has already been rolled back, 
     *        <b>CopyFileTransacted</b> will return either 
     *        <b>ERROR_TRANSACTION_NOT_ACTIVE</b> or 
     *        <b>ERROR_INVALID_TRANSACTION</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfiletransactedw
     * @since windows6.0.6000
     */
    static CopyFileTransactedW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CopyFileTransactedW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "int*", pbCancel, "uint", dwCopyFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Copies an existing file to a new file, notifying the application of its progress through a callback function. (CopyFile2)
     * @remarks
     * This function preserves extended attributes, OLE structured storage, NTFS file system alternate data streams, 
     *     and file attributes. Security attributes for the existing file are not copied to the new file. To copy security 
     *     attributes, use the <a href="https://docs.microsoft.com/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> function.
     * 
     * This function fails with 
     *     <c>HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)</c> if the destination 
     *     file already exists and has the <b>FILE_ATTRIBUTE_HIDDEN</b> or 
     *     <b>FILE_ATTRIBUTE_READONLY</b> attribute set.
     * 
     * To compile an application that uses this function, define the <b>_WIN32_WINNT</b> macro 
     *     as <b>_WIN32_WINNT_WIN8</b> or later. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/WinProg/using-the-windows-headers">Using the Windows Headers</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Starting with Windows 10, version 1903 and Windows Server 2022, a new value, **COPY_FILE_REQUEST_COMPRESSED_TRAFFIC**, is supported for the *dwCopyFlags* field of the [COPYFILE2_EXTENDED_PARAMETERS](ns-winbase-copyfile2_extended_parameters.md) structure passed in the *pExtendedParameters* argument to this function. This new value requests that the underlying transfer channel compress the data during the copy operation. The request may not be supported for all mediums, in which case it is ignored. The compression attributes and parameters (computational complexity, memory usage) are not configurable through this API, and are subject to change between different OS releases. On Windows 10, the flag is supported for files residing on SMB shares, where the negotiated SMB protocol version is SMB v3.1.1 or greater.</p>
     * @param {Pointer<Char>} pwszExistingFileName The name of an existing file.
     * 
     * To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\".  See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * If <i>lpExistingFileName</i> does not exist, the 
     *        <b>CopyFile2</b> function fails returns 
     *        <c>HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)</c>.
     * @param {Pointer<Char>} pwszNewFileName The name of the new file.
     * 
     * To extend this limit to 32,767 wide characters, prepend "\\?\" to the path. For more 
     *        information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting in Windows 10, version 1607, you can opt-in to remove the <b>MAX_PATH</b> character limitation without prepending "\\?\". See the "Maximum Path Limitation" section of  <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details. </div>
     * <div> </div>
     * @param {Pointer<COPYFILE2_EXTENDED_PARAMETERS>} pExtendedParameters Optional address of a 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-copyfile2_extended_parameters">COPYFILE2_EXTENDED_PARAMETERS</a> 
     *       structure.
     * @returns {HRESULT} If the function succeeds, the return value will return <b>TRUE</b> when passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winerror/nf-winerror-succeeded">SUCCEEDED</a> macro.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation completed successfully.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_REQUEST_PAUSED)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation was paused by a <b>COPYFILE2_PROGRESS_PAUSE</b> return from the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pcopyfile2_progress_routine">CopyFile2ProgressRoutine</a> callback 
     *         function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_REQUEST_ABORTED)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The copy operation was paused by a <b>COPYFILE2_PROGRESS_CANCEL</b> or 
     *         <b>COPYFILE2_PROGRESS_STOP</b> return from the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-pcopyfile2_progress_routine">CopyFile2ProgressRoutine</a> callback 
     *         function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>dwCopyFlags</b> member of the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-copyfile2_extended_parameters">COPYFILE2_EXTENDED_PARAMETERS</a> structure 
     *         passed through the <i>pExtendedParameters</i> parameter contains the 
     *         <b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name existed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>dwCopyFlags</b> member of the 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-copyfile2_extended_parameters">COPYFILE2_EXTENDED_PARAMETERS</a> structure 
     *         passed through the <i>pExtendedParameters</i> parameter contains the 
     *         <b>COPY_FILE_FAIL_IF_EXISTS</b> flag and a conflicting name existed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-copyfile2
     * @since windows8.0
     */
    static CopyFile2(pwszExistingFileName, pwszNewFileName, pExtendedParameters) {
        pwszExistingFileName := pwszExistingFileName is String? StrPtr(pwszExistingFileName) : pwszExistingFileName
        pwszNewFileName := pwszNewFileName is String? StrPtr(pwszNewFileName) : pwszNewFileName

        result := DllCall("KERNEL32.dll\CopyFile2", "ptr", pwszExistingFileName, "ptr", pwszNewFileName, "ptr", pExtendedParameters, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Moves an existing file or a directory, including its children. (MoveFileA)
     * @remarks
     * The <b>MoveFile</b> function will move (rename) either a file or a 
     *     directory (including its children) either in the same directory or across directories. The one caveat is that the 
     *     <b>MoveFile</b> function will fail on directory moves when the 
     *     destination is on a different volume.
     * 
     *  If a file is moved across volumes, <b>MoveFile</b> does not move 
     *     the security descriptor with the file. The file will be assigned the default security descriptor in the 
     *     destination directory.
     * 
     * The <b>MoveFile</b> function coordinates its operation with the 
     *     link tracking service, so link sources can be tracked as they are moved.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * See comment
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * See comment
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Byte>} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *        different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefilea
     * @since windows5.1.2600
     */
    static MoveFileA(lpExistingFileName, lpNewFileName) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The MoveFileW (Unicode) function (winbase.h) moves an existing file or a directory, including its children.
     * @remarks
     * The <b>MoveFile</b> function will move (rename) either a file or a 
     *     directory (including its children) either in the same directory or across directories. The one caveat is that the 
     *     <b>MoveFile</b> function will fail on directory moves when the 
     *     destination is on a different volume.
     * 
     *  If a file is moved across volumes, <b>MoveFile</b> does not move 
     *     the security descriptor with the file. The file will be assigned the default security descriptor in the 
     *     destination directory.
     * 
     * The <b>MoveFile</b> function coordinates its operation with the 
     *     link tracking service, so link sources can be tracked as they are moved.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * See comment
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * See comment
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support rename of alternate data streams on file shares with continuous availability capability.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines MoveFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Char>} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *        different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefilew
     * @since windows5.1.2600
     */
    static MoveFileW(lpExistingFileName, lpNewFileName) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or directory, including its children, with various move options. (ANSI)
     * @remarks
     * If the <i>dwFlags</i> parameter specifies 
     *      <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, 
     *      <b>MoveFileEx</b> fails if it cannot access the registry. The 
     *      function stores the locations of the files to be renamed at restart in the following registry value:
     *      <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>CurrentControlSet</b>&#92;<b>Control</b>&#92;<b>Session Manager</b>&#92;<b>PendingFileRenameOperations</b>
     * 
     * 
     * 
     * This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one 
     *        of the following NULL-terminated strings, depending on whether the rename is a delete or not:
     * 
     * <ul>
     * <li>
     * <i>szDstFile</i>\0\0
     * 
     * </li>
     * <li>
     * <i>szSrcFile</i>\0<i>szDstFile</i>\0
     * 
     * </li>
     * </ul>
     * The string <i>szDstFile</i>\0\0 indicates that the file 
     *      <i>szDstFile</i> is to be deleted on reboot. The string 
     *      <i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that 
     *      <i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.
     * 
     * <div class="alert"><b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because 
     *      the file is considered to be renamed to a null name.</div>
     * <div> </div>
     * The system uses these registry entries to complete the operations at restart in the same order that they were 
     *      issued. For example, the following code fragment creates registry entries that delete 
     *      <i>szDstFile</i> and rename <i>szSrcFile</i> to be 
     *      <i>szDstFile</i> at restart:
     * 
     * 
     * ```cpp
     * MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
     * MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);
     * 
     * ```
     * 
     * 
     * Because the actual move and deletion operations specified with the 
     *      <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased 
     *      running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects 
     *      success or failure in placing the appropriate entries into the registry.
     * 
     * The system deletes a directory that is tagged for deletion with the 
     *      <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories, 
     *      move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot 
     *      time, but they must be deleted or moved before the system can delete the directory.
     * 
     * The move and deletion operations are carried out at boot time in the same order that they are specified in the 
     *      calling application. To delete a directory that has files in it at boot time, first delete the files.
     * 
     * If a file is moved across volumes, <b>MoveFileEx</b> does not 
     *      move the security descriptor with the file. The file is assigned the default security descriptor in the 
     *      destination directory.
     * 
     * The <b>MoveFileEx</b> function coordinates its operation with 
     *      the <a href="https://docs.microsoft.com/windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service, 
     *      so link sources can be tracked as they are moved.
     * 
     * To delete or rename a file, you must have either delete permission on the file or delete child permission in 
     *      the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of 
     *      new files are inherited, then you should be able to create a file without being able to delete it. However, you 
     *      can then create a file, and get all the access you request on the handle that is returned to you at the time that 
     *      you create the file. If you request delete permission at the time you create the file, you can delete or rename 
     *      the file with that handle but not with any other handle.  For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Byte>} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share, because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Byte>} lpNewFileName The new name of the file or directory on the local computer.
     * 
     * When moving a file, the destination can be on a different file system or volume. If the destination is on 
     *        another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in 
     *        <i>dwFlags</i>.
     * 
     * When moving a directory, the destination must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is  <b>NULL</b>, 
     *        <b>MoveFileEx</b> registers the 
     *        <i>lpExistingFileName</i> file to be deleted when the system restarts. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefileexa
     * @since windows5.1.2600
     */
    static MoveFileExA(lpExistingFileName, lpNewFileName, dwFlags) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileExA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or directory, including its children, with various move options. (Unicode)
     * @remarks
     * If the <i>dwFlags</i> parameter specifies 
     *      <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, 
     *      <b>MoveFileEx</b> fails if it cannot access the registry. The 
     *      function stores the locations of the files to be renamed at restart in the following registry value:
     *      <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>CurrentControlSet</b>&#92;<b>Control</b>&#92;<b>Session Manager</b>&#92;<b>PendingFileRenameOperations</b>
     * 
     * 
     * 
     * This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one 
     *        of the following NULL-terminated strings, depending on whether the rename is a delete or not:
     * 
     * <ul>
     * <li>
     * <i>szDstFile</i>\0\0
     * 
     * </li>
     * <li>
     * <i>szSrcFile</i>\0<i>szDstFile</i>\0
     * 
     * </li>
     * </ul>
     * The string <i>szDstFile</i>\0\0 indicates that the file 
     *      <i>szDstFile</i> is to be deleted on reboot. The string 
     *      <i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that 
     *      <i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.
     * 
     * <div class="alert"><b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because 
     *      the file is considered to be renamed to a null name.</div>
     * <div> </div>
     * The system uses these registry entries to complete the operations at restart in the same order that they were 
     *      issued. For example, the following code fragment creates registry entries that delete 
     *      <i>szDstFile</i> and rename <i>szSrcFile</i> to be 
     *      <i>szDstFile</i> at restart:
     * 
     * 
     * ```cpp
     * MoveFileEx(szDstFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
     * MoveFileEx(szSrcFile, szDstFile, MOVEFILE_DELAY_UNTIL_REBOOT);
     * 
     * ```
     * 
     * 
     * Because the actual move and deletion operations specified with the 
     *      <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag take place after the calling application has ceased 
     *      running, the return value cannot reflect success or failure in moving or deleting the file. Rather, it reflects 
     *      success or failure in placing the appropriate entries into the registry.
     * 
     * The system deletes a directory that is tagged for deletion with the 
     *      <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag only if it is empty. To ensure deletion of directories, 
     *      move or delete all files from the directory before attempting to delete it. Files may be in the directory at boot 
     *      time, but they must be deleted or moved before the system can delete the directory.
     * 
     * The move and deletion operations are carried out at boot time in the same order that they are specified in the 
     *      calling application. To delete a directory that has files in it at boot time, first delete the files.
     * 
     * If a file is moved across volumes, <b>MoveFileEx</b> does not 
     *      move the security descriptor with the file. The file is assigned the default security descriptor in the 
     *      destination directory.
     * 
     * The <b>MoveFileEx</b> function coordinates its operation with 
     *      the <a href="https://docs.microsoft.com/windows/desktop/FileIO/distributed-link-tracking-and-object-identifiers">link tracking</a> service, 
     *      so link sources can be tracked as they are moved.
     * 
     * To delete or rename a file, you must have either delete permission on the file or delete child permission in 
     *      the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of 
     *      new files are inherited, then you should be able to create a file without being able to delete it. However, you 
     *      can then create a file, and get all the access you request on the handle that is returned to you at the time that 
     *      you create the file. If you request delete permission at the time you create the file, you can delete or rename 
     *      the file with that handle but not with any other handle.  For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Char>} lpExistingFileName The current name of the file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share, because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "`\\?\`" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Char>} lpNewFileName The new name of the file or directory on the local computer.
     * 
     * When moving a file, the destination can be on a different file system or volume. If the destination is on 
     *        another drive, you must set the <b>MOVEFILE_COPY_ALLOWED</b> flag in 
     *        <i>dwFlags</i>.
     * 
     * When moving a directory, the destination must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is  <b>NULL</b>, 
     *        <b>MoveFileEx</b> registers the 
     *        <i>lpExistingFileName</i> file to be deleted when the system restarts. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "`\\?\`" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>
     * 
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileExW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefileexw
     * @since windows5.1.2600
     */
    static MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileExW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves a file or directory, including its children. You can provide a callback function that receives progress notifications. (ANSI)
     * @remarks
     * The <b>MoveFileWithProgress</b> function coordinates its operation with the link 
     *     tracking service, so link sources can be tracked as they are moved.
     * 
     * To delete or rename a file, you must have either delete permission on the file or delete child permission in 
     *     the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new 
     *     files are inherited, then you should be able to create a file without being able to delete it. However, you can 
     *     then create a file, and you will get all the access you request on the handle returned to you at the time you 
     *     create the file. If you requested delete permission at the time you created the file, you could delete or rename 
     *     the file with that handle but not with any other.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpExistingFileName The name of the existing file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Byte>} lpNewFileName The new name of the file or directory  on the local computer.
     * 
     * When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If 
     *        <i>lpNewFileName</i> is on another drive, you must set the 
     *        <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.
     * 
     * When moving a directory, <i>lpExistingFileName</i> and 
     *        <i>lpNewFileName</i> must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is <b>NULL</b>, 
     *        <b>MoveFileWithProgress</b> registers 
     *        <i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it 
     *        cannot access the registry to store the information about the delete operation. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefilewithprogressa
     * @since windows5.1.2600
     */
    static MoveFileWithProgressA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileWithProgressA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves a file or directory, including its children. You can provide a callback function that receives progress notifications. (Unicode)
     * @remarks
     * The <b>MoveFileWithProgress</b> function coordinates its operation with the link 
     *     tracking service, so link sources can be tracked as they are moved.
     * 
     * To delete or rename a file, you must have either delete permission on the file or delete child permission in 
     *     the parent directory. If you set up a directory with all access except delete and delete child and the ACLs of new 
     *     files are inherited, then you should be able to create a file without being able to delete it. However, you can 
     *     then create a file, and you will get all the access you request on the handle returned to you at the time you 
     *     create the file. If you requested delete permission at the time you created the file, you could delete or rename 
     *     the file with that handle but not with any other.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs will do redirected IO for compressed files.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines MoveFileWithProgress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpExistingFileName The name of the existing file or directory on the local computer.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, the 
     *        file cannot exist on a remote share because delayed operations are performed before the network is 
     *        available.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Char>} lpNewFileName The new name of the file or directory  on the local computer.
     * 
     * When moving a file, <i>lpNewFileName</i> can be on a different file system or volume. If 
     *        <i>lpNewFileName</i> is on another drive, you must set the 
     *        <b>MOVEFILE_COPY_ALLOWED</b> flag in <i>dwFlags</i>.
     * 
     * When moving a directory, <i>lpExistingFileName</i> and 
     *        <i>lpNewFileName</i> must be on the same drive.
     * 
     * If <i>dwFlags</i> specifies <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> and 
     *        <i>lpNewFileName</i> is <b>NULL</b>, 
     *        <b>MoveFileWithProgress</b> registers 
     *        <i>lpExistingFileName</i> to be deleted when the system restarts. The function fails if it 
     *        cannot access the registry to store the information about the delete operation. If 
     *        <i>lpExistingFileName</i> refers to a directory, the system removes the directory at restart 
     *        only if the directory is empty.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>MoveFileWithProgressW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileWithProgress</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefilewithprogressw
     * @since windows5.1.2600
     */
    static MoveFileWithProgressW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileWithProgressW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or a directory, including its children, as a transacted operation. (ANSI)
     * @remarks
     * If the <i>dwFlags</i> parameter specifies 
     *     <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, 
     *     <b>MoveFileTransacted</b> fails if it cannot access the registry. The 
     *     function transactionally stores the locations of the files to be renamed at restart in the following registry 
     *     value:
     *     <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>CurrentControlSet</b>&#92;<b>Control</b>&#92;<b>Session Manager</b>&#92;<b>PendingFileRenameOperations</b>
     * 
     * 
     * 
     * This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one of 
     *     the following <b>NULL</b>-terminated strings, depending on whether the rename is a delete or 
     *     not:
     * 
     * <i>szDstFile</i>\0\0
     * 
     * <i>szSrcFile</i>\0<i>szDstFile</i>\0
     * 
     * The string <i>szDstFile</i>\0\0 indicates that the file 
     *      <i>szDstFile</i> is to be deleted on reboot.
     * 
     * The string <i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that 
     *      <i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.
     * 
     * <div class="alert"><b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because 
     *      the file is considered to be renamed to a null name.</div>
     * <div> </div>
     * The system uses these registry entries to complete the operations at restart in the same order that they were 
     *     issued. For more information about using the <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-movefilewithprogressa">MoveFileWithProgress</a>.
     * 
     *  If a file is moved across volumes, 
     *     <b>MoveFileTransacted</b> does not move the security 
     *     descriptor with the file. The file is assigned the default security descriptor in the destination directory.
     * 
     * This function always fails if you specify the <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b> flag; 
     *     tracking is not supported by TxF.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * @param {Pointer<Byte>} lpExistingFileName The current name of the existing file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<Byte>} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *       different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefiletransacteda
     * @since windows6.0.6000
     */
    static MoveFileTransactedA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileTransactedA", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Moves an existing file or a directory, including its children, as a transacted operation. (Unicode)
     * @remarks
     * If the <i>dwFlags</i> parameter specifies 
     *     <b>MOVEFILE_DELAY_UNTIL_REBOOT</b>, 
     *     <b>MoveFileTransacted</b> fails if it cannot access the registry. The 
     *     function transactionally stores the locations of the files to be renamed at restart in the following registry 
     *     value:
     *     <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>CurrentControlSet</b>&#92;<b>Control</b>&#92;<b>Session Manager</b>&#92;<b>PendingFileRenameOperations</b>
     * 
     * 
     * 
     * This registry  value is of type <b>REG_MULTI_SZ</b>. Each rename operation stores one of 
     *     the following <b>NULL</b>-terminated strings, depending on whether the rename is a delete or 
     *     not:
     * 
     * <i>szDstFile</i>\0\0
     * 
     * <i>szSrcFile</i>\0<i>szDstFile</i>\0
     * 
     * The string <i>szDstFile</i>\0\0 indicates that the file 
     *      <i>szDstFile</i> is to be deleted on reboot.
     * 
     * The string <i>szSrcFile</i>\0<i>szDstFile</i>\0 indicates that 
     *      <i>szSrcFile</i> is to be renamed <i>szDstFile</i> on reboot.
     * 
     * <div class="alert"><b>Note</b>  Although \0\0 is technically not allowed in a <b>REG_MULTI_SZ</b> node, it can because 
     *      the file is considered to be renamed to a null name.</div>
     * <div> </div>
     * The system uses these registry entries to complete the operations at restart in the same order that they were 
     *     issued. For more information about using the <b>MOVEFILE_DELAY_UNTIL_REBOOT</b> flag, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-movefilewithprogressa">MoveFileWithProgress</a>.
     * 
     *  If a file is moved across volumes, 
     *     <b>MoveFileTransacted</b> does not move the security 
     *     descriptor with the file. The file is assigned the default security descriptor in the destination directory.
     * 
     * This function always fails if you specify the <b>MOVEFILE_FAIL_IF_NOT_TRACKABLE</b> flag; 
     *     tracking is not supported by TxF.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * @param {Pointer<Char>} lpExistingFileName The current name of the existing file or directory on the local computer.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<Char>} lpNewFileName The new name for the file or directory. The new name must not already exist. A new file may be on a 
     *       different file system or drive. A new directory must be on the same drive.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * @param {Pointer<LPPROGRESS_ROUTINE>} lpProgressRoutine A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback 
     *       function that is called each time another portion of the file has been moved. The callback function can be 
     *       useful if you provide a user interface that displays the progress of the operation. This parameter can be 
     *       <b>NULL</b>.
     * @param {Pointer<Void>} lpData An argument to be passed to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nc-winbase-lpprogress_routine">CopyProgressRoutine</a> callback function. This 
     *       parameter can be <b>NULL</b>.
     * @param {Integer} dwFlags 
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_CANCEL</b> due to the user canceling the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * 
     * When moving a file across volumes, if <i>lpProgressRoutine</i> returns 
     *        <b>PROGRESS_STOP</b> due to the user stopping the operation, 
     *        <b>MoveFileTransacted</b> will return zero and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> will return 
     *        <b>ERROR_REQUEST_ABORTED</b>. The existing file is left intact.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-movefiletransactedw
     * @since windows6.0.6000
     */
    static MoveFileTransactedW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction) {
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName
        lpNewFileName := lpNewFileName is String? StrPtr(lpNewFileName) : lpNewFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\MoveFileTransactedW", "ptr", lpExistingFileName, "ptr", lpNewFileName, "ptr", lpProgressRoutine, "ptr", lpData, "uint", dwFlags, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces one file with another file, with the option of creating a backup copy of the original file. (ANSI)
     * @remarks
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * The <b>ReplaceFile</b> function combines several steps within a 
     *      single function. An application can call <b>ReplaceFile</b> instead 
     *      of calling separate functions to save the data to a new file, rename the original file using a temporary name, 
     *      rename the new file to have the same name as the original file, and delete the original file. Another advantage is 
     *      that <b>ReplaceFile</b> not only copies the new file data, but also 
     *      preserves the following attributes of the original file:
     * 
     * <ul>
     * <li>Creation time</li>
     * <li>Short file name</li>
     * <li>Object identifier</li>
     * <li>DACLs</li>
     * <li>Security resource attributes</li>
     * <li>Encryption</li>
     * <li>Compression</li>
     * <li>Named streams not already in the replacement file</li>
     * </ul>
     * For example, if the replacement file is encrypted, but the replaced file is not encrypted, the resulting file 
     *      is not encrypted.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the original 
     *       file are not preserved until Windows 8 and Windows Server 2012.
     * 
     * <div class="alert"><b>Note</b>  <p class="note">If the replacement file is protected using <a href="https://docs.microsoft.com/previous-versions/windows/dn440592(v=win.10)">Selective Wipe</a>, then the replaced file will be protected by the enterprise id of the replacement file.
     * 
     * </div>
     * <div> </div>
     * The resulting file has the same file ID as the replacement file.
     * 
     * The backup file, replaced file, and replacement file must all reside on the same volume.
     * 
     * To delete or rename a file, you must have either delete permission on the file or delete child permission in 
     *      the parent directory. If you set up a directory with all access except delete and delete child and the DACLs of 
     *      new files are inherited, then you should be able to create a file without being able to delete it. However, you 
     *      can then create a file, and you will get all the access you request on the handle returned to you at the time you 
     *      create the file. If you requested delete permission at the time you created the file, you could delete or rename 
     *      the file with that handle but not with any other.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines ReplaceFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpReplacedFileName The name of the file to be replaced.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * This file is opened with the <b>GENERIC_READ</b>, <b>DELETE</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. The sharing mode is 
     *        <b>FILE_SHARE_READ</b> | <b>FILE_SHARE_WRITE</b> | 
     *        <b>FILE_SHARE_DELETE</b>.
     * 
     * The caller must have write access to the file to be replaced. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<Byte>} lpReplacementFileName The name of the file that will replace the <i>lpReplacedFileName</i> file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * The function attempts to open this file with the <b>SYNCHRONIZE</b>, 
     *        <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights so that it can preserve 
     *        all attributes and ACLs. If this fails, the function attempts to open the file with the 
     *        <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights. No sharing mode is 
     *        specified.
     * @param {Pointer<Byte>} lpBackupFileName The name of the file that will serve as a backup copy of the <i>lpReplacedFileName</i> 
     *        file. If this parameter is <b>NULL</b>, no backup file is created. See the Remarks section for implementation details on the backup file. 
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwReplaceFlags 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following are possible error codes 
     *        for this function.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT</b></dt>
     * <dt>1176 (0x498)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be renamed. If <i>lpBackupFileName</i> was specified, 
     *          the replaced and replacement files retain their original file names. Otherwise, the replaced file no longer 
     *          exists and the replacement file exists under its original name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</b></dt>
     * <dt>1177 (0x499)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be moved.  The replacement file still exists under its original name; 
     *          however, it has inherited the file streams and attributes from the file it is replacing. The file to be 
     *          replaced still exists with a different name. If <i>lpBackupFileName</i> is specified, it 
     *          will be the name of the replaced file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_REMOVE_REPLACED</b></dt>
     * <dt>1175 (0x497)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replaced file could not be deleted. The replaced and replacement files retain their original file 
     *          names.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If any other error is returned, such as <b>ERROR_INVALID_PARAMETER</b>, the replaced and 
     *        replacement files will retain their original file names. In this scenario, a backup file 
     *        does not exist and it is not guaranteed that the 
     *        replacement file will have inherited all of the attributes and streams of the replaced file.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-replacefilea
     * @since windows5.1.2600
     */
    static ReplaceFileA(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags) {
        static lpExclude := 0, lpReserved := 0 ;Reserved parameters must always be NULL

        lpReplacedFileName := lpReplacedFileName is String? StrPtr(lpReplacedFileName) : lpReplacedFileName
        lpReplacementFileName := lpReplacementFileName is String? StrPtr(lpReplacementFileName) : lpReplacementFileName
        lpBackupFileName := lpBackupFileName is String? StrPtr(lpBackupFileName) : lpBackupFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReplaceFileA", "ptr", lpReplacedFileName, "ptr", lpReplacementFileName, "ptr", lpBackupFileName, "uint", dwReplaceFlags, "ptr", lpExclude, "ptr", lpReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Replaces one file with another file, with the option of creating a backup copy of the original file. (Unicode)
     * @remarks
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation. See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * The <b>ReplaceFile</b> function combines several steps within a 
     *      single function. An application can call <b>ReplaceFile</b> instead 
     *      of calling separate functions to save the data to a new file, rename the original file using a temporary name, 
     *      rename the new file to have the same name as the original file, and delete the original file. Another advantage is 
     *      that <b>ReplaceFile</b> not only copies the new file data, but also 
     *      preserves the following attributes of the original file:
     * 
     * <ul>
     * <li>Creation time</li>
     * <li>Short file name</li>
     * <li>Object identifier</li>
     * <li>DACLs</li>
     * <li>Security resource attributes</li>
     * <li>Encryption</li>
     * <li>Compression</li>
     * <li>Named streams not already in the replacement file</li>
     * </ul>
     * For example, if the replacement file is encrypted, but the replaced file is not encrypted, the resulting file 
     *      is not encrypted.
     * 
     * <b>Windows 7, Windows Server 2008 R2, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:  </b>Security resource attributes (<b>ATTRIBUTE_SECURITY_INFORMATION</b>) for the original 
     *       file are not preserved until Windows 8 and Windows Server 2012.
     * 
     * <div class="alert"><b>Note</b>  <p class="note">If the replacement file is protected using <a href="https://docs.microsoft.com/previous-versions/windows/dn440592(v=win.10)">Selective Wipe</a>, then the replaced file will be protected by the enterprise id of the replacement file.
     * 
     * </div>
     * <div> </div>
     * The resulting file has the same file ID as the replacement file.
     * 
     * The backup file, replaced file, and replacement file must all reside on the same volume.
     * 
     * To delete or rename a file, you must have either delete permission on the file or delete child permission in 
     *      the parent directory. If you set up a directory with all access except delete and delete child and the DACLs of 
     *      new files are inherited, then you should be able to create a file without being able to delete it. However, you 
     *      can then create a file, and you will get all the access you request on the handle returned to you at the time you 
     *      create the file. If you requested delete permission at the time you created the file, you could delete or rename 
     *      the file with that handle but not with any other.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines ReplaceFile as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpReplacedFileName The name of the file to be replaced.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * This file is opened with the <b>GENERIC_READ</b>, <b>DELETE</b>, and 
     *        <b>SYNCHRONIZE</b> access rights. The sharing mode is 
     *        <b>FILE_SHARE_READ</b> | <b>FILE_SHARE_WRITE</b> | 
     *        <b>FILE_SHARE_DELETE</b>.
     * 
     * The caller must have write access to the file to be replaced. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access Rights</a>.
     * @param {Pointer<Char>} lpReplacementFileName The name of the file that will replace the <i>lpReplacedFileName</i> file.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * The function attempts to open this file with the <b>SYNCHRONIZE</b>, 
     *        <b>GENERIC_READ</b>, <b>GENERIC_WRITE</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights so that it can preserve 
     *        all attributes and ACLs. If this fails, the function attempts to open the file with the 
     *        <b>SYNCHRONIZE</b>, <b>GENERIC_READ</b>, 
     *        <b>DELETE</b>, and <b>WRITE_DAC</b> access rights. No sharing mode is 
     *        specified.
     * @param {Pointer<Char>} lpBackupFileName The name of the file that will serve as a backup copy of the <i>lpReplacedFileName</i> 
     *        file. If this parameter is <b>NULL</b>, no backup file is created. See the Remarks section for implementation details on the backup file. 
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>ReplaceFileW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwReplaceFlags 
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. The following are possible error codes 
     *        for this function.
     * 
     * <table>
     * <tr>
     * <th>Return code/value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT</b></dt>
     * <dt>1176 (0x498)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be renamed. If <i>lpBackupFileName</i> was specified, 
     *          the replaced and replacement files retain their original file names. Otherwise, the replaced file no longer 
     *          exists and the replacement file exists under its original name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_MOVE_REPLACEMENT_2</b></dt>
     * <dt>1177 (0x499)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replacement file could not be moved.  The replacement file still exists under its original name; 
     *          however, it has inherited the file streams and attributes from the file it is replacing. The file to be 
     *          replaced still exists with a different name. If <i>lpBackupFileName</i> is specified, it 
     *          will be the name of the replaced file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_UNABLE_TO_REMOVE_REPLACED</b></dt>
     * <dt>1175 (0x497)</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The replaced file could not be deleted. The replaced and replacement files retain their original file 
     *          names.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If any other error is returned, such as <b>ERROR_INVALID_PARAMETER</b>, the replaced and 
     *        replacement files will retain their original file names. In this scenario, a backup file 
     *        does not exist and it is not guaranteed that the 
     *        replacement file will have inherited all of the attributes and streams of the replaced file.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-replacefilew
     * @since windows5.1.2600
     */
    static ReplaceFileW(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags) {
        static lpExclude := 0, lpReserved := 0 ;Reserved parameters must always be NULL

        lpReplacedFileName := lpReplacedFileName is String? StrPtr(lpReplacedFileName) : lpReplacedFileName
        lpReplacementFileName := lpReplacementFileName is String? StrPtr(lpReplacementFileName) : lpReplacementFileName
        lpBackupFileName := lpBackupFileName is String? StrPtr(lpBackupFileName) : lpBackupFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReplaceFileW", "ptr", lpReplacedFileName, "ptr", lpReplacementFileName, "ptr", lpBackupFileName, "uint", dwReplaceFlags, "ptr", lpExclude, "ptr", lpReserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file. (ANSI)
     * @remarks
     * Any directory entry for a file that is created with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or 
     *     <b>CreateHardLink</b> is a hard link to an associated file. 
     *     An additional hard link that is created with the 
     *     <b>CreateHardLink</b> 
     *     function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file, 
     *     which can be different names in the same directory, or the same or different names in different directories. 
     *     However, all hard links to a file must be on the same volume.
     * 
     * Because hard links are only directory entries for a file, many changes to that file are instantly visible to 
     *     applications that access it through the hard links that reference it. However, the directory entry size and 
     *     attribute information is updated only for the link through which the change was made.
     * 
     * The security descriptor belongs to the file to which a hard link points. The link itself is only a directory 
     *     entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link, 
     *     you a change the security descriptor of the underlying file, and all hard links that point to the file allow the 
     *     newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.
     * 
     * This function does not modify the security descriptor of the file to be linked to, even if security descriptor 
     *     information is passed in the <i>lpSecurityAttributes</i> parameter.
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> to delete hard links. You can delete 
     *     them in any order regardless of the order in which they are created.
     * 
     * Flags, attributes, access, and sharing that are specified in 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> operate on a per-file basis. That is, if you 
     *     open a file that does not allow sharing, another application cannot share the file by creating a new hard link to 
     *     the file.
     * 
     * When you create a hard link on the NTFS file system, the file attribute information in the directory entry is 
     *     refreshed only when the file is opened, or when 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> is called with 
     *     the handle of a specific file.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function creates a hard 
     *      link to the symbolic link.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.
     * @param {Pointer<Byte>} lpFileName The name of the new file.
     *       
     * 
     * This parameter may include the path but cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Byte>} lpExistingFileName The name of the existing file.
     *       
     * 
     * This parameter may include the path cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.
     * 
     * If you pass a name longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createhardlinka
     * @since windows5.1.2600
     */
    static CreateHardLinkA(lpFileName, lpExistingFileName) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkA", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file. (Unicode)
     * @remarks
     * Any directory entry for a file that is created with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> or 
     *     <b>CreateHardLink</b> is a hard link to an associated file. 
     *     An additional hard link that is created with the 
     *     <b>CreateHardLink</b> 
     *     function allows you to have multiple directory entries for a file, that is, multiple hard links to the same file, 
     *     which can be different names in the same directory, or the same or different names in different directories. 
     *     However, all hard links to a file must be on the same volume.
     * 
     * Because hard links are only directory entries for a file, many changes to that file are instantly visible to 
     *     applications that access it through the hard links that reference it. However, the directory entry size and 
     *     attribute information is updated only for the link through which the change was made.
     * 
     * The security descriptor belongs to the file to which a hard link points. The link itself is only a directory 
     *     entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link, 
     *     you a change the security descriptor of the underlying file, and all hard links that point to the file allow the 
     *     newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.
     * 
     * This function does not modify the security descriptor of the file to be linked to, even if security descriptor 
     *     information is passed in the <i>lpSecurityAttributes</i> parameter.
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> to delete hard links. You can delete 
     *     them in any order regardless of the order in which they are created.
     * 
     * Flags, attributes, access, and sharing that are specified in 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> operate on a per-file basis. That is, if you 
     *     open a file that does not allow sharing, another application cannot share the file by creating a new hard link to 
     *     the file.
     * 
     * When you create a hard link on the NTFS file system, the file attribute information in the directory entry is 
     *     refreshed only when the file is opened, or when 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> is called with 
     *     the handle of a specific file.
     * 
     * Symbolic link behavior—If the path points to a symbolic link, the function creates a hard 
     *      link to the symbolic link.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support creation of hard links on shares with continuous availability capability.
     * @param {Pointer<Char>} lpFileName The name of the new file.
     *       
     * 
     * This parameter may include the path but cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Char>} lpExistingFileName The name of the existing file.
     *       
     * 
     * This parameter may include the path cannot specify the name of a directory.
     * 
     * In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\\\?\\" to the path. For more information, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>. If you pass a name longer than MAX_PATH characters to the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateHardLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 links are created for a file, an error results.
     * 
     * If you pass a name longer than MAX_PATH characters to the *lpFileName* or *lpExistingFileName* parameter of the ANSI version of this function or to the Unicode version of this function without prepending "\\\\?\\" to the path, the function returns ERROR_PATH_NOT_FOUND.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createhardlinkw
     * @since windows5.1.2600
     */
    static CreateHardLinkW(lpFileName, lpExistingFileName) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkW", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file as a transacted operation. (ANSI)
     * @remarks
     * Any directory entry for a file that is created with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiletransacteda">CreateFileTransacted</a> or 
     *     <b>CreateHardLinkTransacted</b> is a hard link to an 
     *     associated file. An additional hard link that is created with the 
     *     <b>CreateHardLinkTransacted</b> function allows you to 
     *     have multiple directory entries for a file, that is, multiple hard links to the same file, which can be different 
     *     names in the same directory, or the same or different names in different directories. However, all hard links to a 
     *     file must be on the same volume.
     * 
     * Because hard links are only directory entries for a file, when an application modifies a file through any hard 
     *     link, all applications that use any other hard link to the file see the changes. Also, all of the directory 
     *     entries are updated if the file changes. For example, if a file size changes, all of the hard links to the file 
     *     show the new file size.
     * 
     * The security descriptor belongs to the file to which a hard link points. The link itself is only a directory 
     *     entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link, 
     *     you a change the security descriptor of the underlying file, and all hard links that point to the file allow the 
     *     newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.
     * 
     * This function does not modify the security descriptor of the file to be linked to, even if security descriptor 
     *     information is passed in the <i>lpSecurityAttributes</i> parameter.
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-deletefiletransacteda">DeleteFileTransacted</a> to delete hard links. 
     *     You can delete them in any order regardless of the order in which they are created.
     * 
     * Flags, attributes, access, and sharing that are specified in 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiletransacteda">CreateFileTransacted</a> operate on a per-file basis. 
     *     That is, if you open a file that does not allow sharing, another application cannot share the file by creating a 
     *     new hard link to the file.
     * 
     * When you create a hard link on the NTFS file system, the file attribute information in the directory entry is 
     *     refreshed only when the file is opened, or when 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> is called with the 
     *     handle of a specific file.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the function creates a hard link to the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateHardLinkTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpFileName The name of the new file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {Pointer<Byte>} lpExistingFileName The name of the existing file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 
     *        links are created for a file, an error results.
     * 
     * The files must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createhardlinktransacteda
     * @since windows6.0.6000
     */
    static CreateHardLinkTransactedA(lpFileName, lpExistingFileName, hTransaction) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkTransactedA", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a hard link between an existing file and a new file as a transacted operation. (Unicode)
     * @remarks
     * Any directory entry for a file that is created with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiletransacteda">CreateFileTransacted</a> or 
     *     <b>CreateHardLinkTransacted</b> is a hard link to an 
     *     associated file. An additional hard link that is created with the 
     *     <b>CreateHardLinkTransacted</b> function allows you to 
     *     have multiple directory entries for a file, that is, multiple hard links to the same file, which can be different 
     *     names in the same directory, or the same or different names in different directories. However, all hard links to a 
     *     file must be on the same volume.
     * 
     * Because hard links are only directory entries for a file, when an application modifies a file through any hard 
     *     link, all applications that use any other hard link to the file see the changes. Also, all of the directory 
     *     entries are updated if the file changes. For example, if a file size changes, all of the hard links to the file 
     *     show the new file size.
     * 
     * The security descriptor belongs to the file to which a hard link points. The link itself is only a directory 
     *     entry, and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link, 
     *     you a change the security descriptor of the underlying file, and all hard links that point to the file allow the 
     *     newly specified access. You cannot give a file different security descriptors on a per-hard-link basis.
     * 
     * This function does not modify the security descriptor of the file to be linked to, even if security descriptor 
     *     information is passed in the <i>lpSecurityAttributes</i> parameter.
     * 
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-deletefiletransacteda">DeleteFileTransacted</a> to delete hard links. 
     *     You can delete them in any order regardless of the order in which they are created.
     * 
     * Flags, attributes, access, and sharing that are specified in 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-createfiletransacteda">CreateFileTransacted</a> operate on a per-file basis. 
     *     That is, if you open a file that does not allow sharing, another application cannot share the file by creating a 
     *     new hard link to the file.
     * 
     * When you create a hard link on the NTFS file system, the file attribute information in the directory entry is 
     *     refreshed only when the file is opened, or when 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a> is called with the 
     *     handle of a specific file.
     * 
     * <b>Symbolic links:  </b>If the path points to a symbolic link, the function creates a hard link to the target.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Note that SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateHardLinkTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpFileName The name of the new file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {Pointer<Char>} lpExistingFileName The name of the existing file.
     * 
     * This parameter cannot specify the name of a directory.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero (0). To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * The maximum number of hard links that can be created with this function is 1023 per file. If more than 1023 
     *        links are created for a file, an error results.
     * 
     * The files must reside on the local computer; otherwise, 
     *        the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createhardlinktransactedw
     * @since windows6.0.6000
     */
    static CreateHardLinkTransactedW(lpFileName, lpExistingFileName, hTransaction) {
        static lpSecurityAttributes := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        lpExistingFileName := lpExistingFileName is String? StrPtr(lpExistingFileName) : lpExistingFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateHardLinkTransactedW", "ptr", lpFileName, "ptr", lpExistingFileName, "ptr", lpSecurityAttributes, "ptr", hTransaction, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enumerates the first stream in the specified file or directory as a transacted operation.
     * @remarks
     * All files contain a default data stream. On NTFS, files can also contain one or more named data streams. On 
     *     FAT file systems, files cannot have more that the default data stream, and therefore, this function will not 
     *     return valid results when used on FAT filesystem files. This function works on all file systems that supports hard 
     *     links; otherwise, the function returns <b>ERROR_STATUS_NOT_IMPLEMENTED</b> (6805).
     * 
     * The <b>FindFirstStreamTransactedW</b> function 
     *     opens a search handle and returns information about the first stream in the specified file or directory. For 
     *     files, this is always the default data stream, ::$DATA. After the search handle has been established, use it in 
     *     the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a> function to search for other 
     *     streams in the specified file or directory. When the search handle is no longer needed, it should be closed using 
     *     the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * @param {Pointer<Char>} lpFileName The fully qualified file name.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).
     * @param {Integer} InfoLevel The information level of the returned data. This parameter is one of the values in the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ne-fileapi-stream_info_levels">STREAM_INFO_LEVELS</a> enumeration type.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FindStreamInfoStandard"></a><a id="findstreaminfostandard"></a><a id="FINDSTREAMINFOSTANDARD"></a><dl>
     * <dt><b>FindStreamInfoStandard</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The data is returned in a 
     *         <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/ns-fileapi-win32_find_stream_data">WIN32_FIND_STREAM_DATA</a> structure.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpFindStreamData A pointer to a buffer that receives the file data. The format of this data depends on the value of 
     *        the <i>InfoLevel</i> parameter.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle that can be used in subsequent calls to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextstreamw">FindNextStreamW</a> function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findfirststreamtransactedw
     * @since windows6.0.6000
     */
    static FindFirstStreamTransactedW(lpFileName, InfoLevel, lpFindStreamData, hTransaction) {
        static dwFlags := 0 ;Reserved parameters must always be NULL

        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstStreamTransactedW", "ptr", lpFileName, "int", InfoLevel, "ptr", lpFindStreamData, "uint", dwFlags, "ptr", hTransaction)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates an enumeration of all the hard links to the specified file as a transacted operation. The function returns a handle to the enumeration that can be used on subsequent calls to the FindNextFileNameW function.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * @param {Pointer<Char>} lpFileName The name of the file.
     * 
     * The file must reside on the local computer; otherwise, the function fails and the last error code is set to 
     *        <b>ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE</b> (6805).
     * @param {Integer} dwFlags Reserved; specify zero (0).
     * @param {Pointer<UInt32>} StringLength The size of the buffer pointed to by the <i>LinkName</i> parameter, in characters. If this 
     *        call fails and the error is <b>ERROR_MORE_DATA</b> (234), the value that is returned by this 
     *        parameter is the size that the buffer pointed to by <i>LinkName</i> must be to contain all 
     *        the data.
     * @param {Pointer<Char>} LinkName A pointer to a buffer to store the first link name found for <i>lpFileName</i>.
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle that can be used with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextfilenamew">FindNextFileNameW</a> function or closed with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findclose">FindClose</a> function.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b> (0xffffffff). To  
     *       get extended error information, call the <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 
     *       function.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findfirstfilenametransactedw
     * @since windows6.0.6000
     */
    static FindFirstFileNameTransactedW(lpFileName, dwFlags, StringLength, LinkName, hTransaction) {
        lpFileName := lpFileName is String? StrPtr(lpFileName) : lpFileName
        LinkName := LinkName is String? StrPtr(LinkName) : LinkName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstFileNameTransactedW", "ptr", lpFileName, "uint", dwFlags, "uint*", StringLength, "ptr", LinkName, "ptr", hTransaction)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the label of a file system volume. (ANSI)
     * @remarks
     * The maximum volume label length is 32 characters.
     * 
     * <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.
     * 
     * A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can 
     *     have a label, a drive letter, both, or neither. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpRootPathName A pointer to a string that contains the volume's drive letter (for example, X:\) or the path 
     *       of a mounted folder that is associated with the volume (for example, Y:\MountX\). The string must 
     *       end with a trailing backslash ('\'). If this parameter is <b>NULL</b>, the root of the 
     *       current directory is used.
     * @param {Pointer<Byte>} lpVolumeName A pointer to a string that contains the new label for the volume. If this parameter is 
     *       <b>NULL</b>, the function deletes any existing label from the specified volume and does not 
     *       assign a new label.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setvolumelabela
     * @since windows5.1.2600
     */
    static SetVolumeLabelA(lpRootPathName, lpVolumeName) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeName := lpVolumeName is String? StrPtr(lpVolumeName) : lpVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeLabelA", "ptr", lpRootPathName, "ptr", lpVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets the label of a file system volume. (Unicode)
     * @remarks
     * The maximum volume label length is 32 characters.
     * 
     * <b>FAT filesystems:  </b>The maximum volume label length is 11 characters.
     * 
     * A label is a user-friendly name that a user assigns to a volume to make it easier to recognize. A volume can 
     *     have a label, a drive letter, both, or neither. For more information, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines SetVolumeLabel as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpRootPathName A pointer to a string that contains the volume's drive letter (for example, X:\) or the path 
     *       of a mounted folder that is associated with the volume (for example, Y:\MountX\). The string must 
     *       end with a trailing backslash ('\'). If this parameter is <b>NULL</b>, the root of the 
     *       current directory is used.
     * @param {Pointer<Char>} lpVolumeName A pointer to a string that contains the new label for the volume. If this parameter is 
     *       <b>NULL</b>, the function deletes any existing label from the specified volume and does not 
     *       assign a new label.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setvolumelabelw
     * @since windows5.1.2600
     */
    static SetVolumeLabelW(lpRootPathName, lpVolumeName) {
        lpRootPathName := lpRootPathName is String? StrPtr(lpRootPathName) : lpRootPathName
        lpVolumeName := lpVolumeName is String? StrPtr(lpVolumeName) : lpVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeLabelW", "ptr", lpRootPathName, "ptr", lpVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests that bandwidth for the specified file stream be reserved. The reservation is specified as a number of bytes in a period of milliseconds for I/O requests on the specified file handle.
     * @remarks
     * The requested bandwidth reservation must be greater than or equal to one packet per period. The minimum period, 
     *      in milliseconds, maximum bytes per period, and minimum transfer size, in bytes, for a specific volume are 
     *      returned through the <i>lpPeriodMilliseconds</i>, <i>lpBytesPerPeriod</i>, 
     *      and  <i>lpTransferSize</i> parameters to 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> on a 
     *      handle that has not been used in a call to 
     *      <b>SetFileBandwidthReservation</b>. In other 
     *      words: 
     * 
     * 1 ≤ (<i>nBytesPerPeriod</i>)×(*<i>lpPeriodMilliseconds</i>)/(*<i>lpTransferSize</i>)/(<i>nPeriodMilliseconds</i>)
     * 
     * IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file.
     * @param {Integer} nPeriodMilliseconds The period of the reservation, in milliseconds. The period is the time from which the I/O is issued to the 
     *       kernel until the time the I/O should be completed. The minimum supported value for the file 
     *       stream can be determined by looking at the value returned through the 
     *       <i>lpPeriodMilliseconds</i> parameter to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function, 
     *       on a handle that has not had a bandwidth reservation set.
     * @param {Integer} nBytesPerPeriod The bandwidth to reserve, in bytes per period. The maximum supported value for the file 
     *       stream can be determined by looking at the value returned through the 
     *       <i>lpBytesPerPeriod</i> parameter to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function, 
     *       on a handle that has not had a bandwidth reservation set.
     * @param {Integer} bDiscardable Indicates whether I/O should be completed with an error if a driver is unable to satisfy an I/O operation 
     *       before the period expires. If one of the drivers for the specified file stream does not support this 
     *       functionality, this function may return success and ignore the flag. To verify whether the setting will be 
     *       honored, call the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-getfilebandwidthreservation">GetFileBandwidthReservation</a> function 
     *       using the same <i>hFile</i> handle and examine the <i>*pDiscardable</i> 
     *       return value.
     * @param {Pointer<UInt32>} lpTransferSize A pointer to a variable that receives the minimum size of any individual I/O request that may be issued by 
     *       the application. All I/O requests should be multiples of <i>TransferSize</i>.
     * @param {Pointer<UInt32>} lpNumOutstandingRequests A pointer to a variable that receives the number of <i>TransferSize</i> chunks the 
     *       application should allow to be outstanding with the operating system. This allows the storage stack to keep the 
     *       device busy and allows maximum throughput.
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * A reservation can fail if there is not enough bandwidth available on the volume because of existing 
     *        reservations; in this case <b>ERROR_NO_SYSTEM_RESOURCES</b> is returned.
     * 
     * To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setfilebandwidthreservation
     * @since windows6.0.6000
     */
    static SetFileBandwidthReservation(hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetFileBandwidthReservation", "ptr", hFile, "uint", nPeriodMilliseconds, "uint", nBytesPerPeriod, "int", bDiscardable, "uint*", lpTransferSize, "uint*", lpNumOutstandingRequests, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the bandwidth reservation properties of the volume on which the specified file resides.
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file.
     * @param {Pointer<UInt32>} lpPeriodMilliseconds A pointer to a variable that receives the period of the reservation, in milliseconds. The period is the 
     *       time from which the I/O is issued to the kernel until the time the I/O should be completed. If no bandwidth has 
     *       been reserved for this handle, then the value returned is the minimum reservation period supported for this 
     *       volume.
     * @param {Pointer<UInt32>} lpBytesPerPeriod A pointer to a variable that receives the maximum number of bytes per period that can be reserved on the 
     *       volume. If no bandwidth has been reserved for this handle, then the value returned is the maximum number of 
     *       bytes per period supported for the volume.
     * @param {Pointer<Int32>} pDiscardable <b>TRUE</b> if I/O should be completed with an error if a driver is unable to satisfy an 
     *       I/O operation before the period expires. <b>FALSE</b> if the underlying subsystem does not 
     *       support failing in this manner.
     * @param {Pointer<UInt32>} lpTransferSize The minimum size of any individual I/O request that may be issued by the application. All I/O requests 
     *       should be multiples of <i>TransferSize</i>. If no bandwidth has been reserved for this 
     *       handle, then the value returned is the minimum transfer size supported for this volume.
     * @param {Pointer<UInt32>} lpNumOutstandingRequests The number of <i>TransferSize</i> chunks  allowed to be outstanding with the operating 
     *       system.
     * @returns {Integer} Returns nonzero if successful or zero otherwise.
     * 
     * To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getfilebandwidthreservation
     * @since windows6.0.6000
     */
    static GetFileBandwidthReservation(hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileBandwidthReservation", "ptr", hFile, "uint*", lpPeriodMilliseconds, "uint*", lpBytesPerPeriod, "int*", pDiscardable, "uint*", lpTransferSize, "uint*", lpNumOutstandingRequests, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information that describes the changes within the specified directory.
     * @remarks
     * To obtain a handle to a directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 
     *     function with the <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag.
     * 
     * A call to <b>ReadDirectoryChangesW</b> can be 
     *     completed synchronously or asynchronously. To specify asynchronous completion, open the directory with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> as shown above, but additionally specify the 
     *     <b>FILE_FLAG_OVERLAPPED</b> attribute in the <i>dwFlagsAndAttributes</i> 
     *     parameter. Then specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure when you 
     *     call <b>ReadDirectoryChangesW</b>.
     * 
     * When you first call **ReadDirectoryChangesW**, the system allocates a buffer to store change information. This buffer is associated with the directory handle until it is closed and its size does not change during its lifetime. Directory changes that occur between calls to this function are added to the buffer and then returned with the next call. If the buffer overflows, **ReadDirectoryChangesW** will still return **true**, but the entire contents of the buffer are discarded and the *lpBytesReturned* parameter will be zero, which indicates that your buffer was too small to hold all of the changes that occurred.
     * 
     * Upon successful synchronous completion, the <i>lpBuffer</i> parameter is a formatted buffer 
     *     and the number of bytes written to the buffer is available in <i>lpBytesReturned</i>. If the 
     *     number of bytes transferred is zero, the buffer was either too large for the system to allocate or too small to 
     *     provide detailed information on all the changes that occurred in the directory or subtree. In this case, you 
     *     should compute the changes by enumerating the directory or subtree.
     * 
     * For asynchronous completion, you can receive notification in one of three ways:
     * 
     * <ul>
     * <li>Using the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function. To 
     *       receive notification through 
     *       <b>GetOverlappedResult</b>, do not specify a completion 
     *       routine in the <i>lpCompletionRoutine</i> parameter. Be sure to set the 
     *       <b>hEvent</b> member of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure to a unique event.</li>
     * <li>Using the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> 
     *       function. To receive notification through 
     *       <b>GetQueuedCompletionStatus</b>, do not specify 
     *       a completion routine in <i>lpCompletionRoutine</i>. Associate the directory handle 
     *       <i>hDirectory</i> with a completion port by calling the 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a> function.</li>
     * <li>Using a completion routine. To receive notification through a completion routine, do not associate the 
     *       directory with a completion port. Specify a completion routine in <i>lpCompletionRoutine</i>. 
     *       This routine is called whenever the operation has been completed or canceled while the thread is in an alertable 
     *       wait state. The <b>hEvent</b> member of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is not used by the system, so you 
     *       can use it yourself.</li>
     * </ul>
     *  For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * <b>ReadDirectoryChangesW</b> fails with 
     *     <b>ERROR_INVALID_PARAMETER</b> when the buffer length is greater than 64 KB and the application 
     *     is monitoring a directory over the network. This is due to a packet size limitation with the underlying file 
     *     sharing protocols.
     * 
     * <b>ReadDirectoryChangesW</b> fails with 
     *     <b>ERROR_NOACCESS</b> when the buffer is not aligned on a <b>DWORD</b> 
     *     boundary.
     * 
     * <b>ReadDirectoryChangesW</b> fails with
     * <b>ERROR_NOTIFY_ENUM_DIR</b>
     * when the system was unable to record all the changes to the directory.
     * In this case, you should compute the changes by enumerating the directory or subtree.
     * 
     * If you opened the file using the short name, you can receive change notifications for the short name.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following 
     *     technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the directory handle, then the notifications follow the appropriate 
     *       transaction isolation rules.
     * @param {Pointer<Void>} hDirectory A handle to the directory to be monitored. This directory must be opened with the 
     *       <b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.
     * @param {Pointer} lpBuffer A pointer to the <b>DWORD</b>-aligned formatted buffer in which the read results are 
     *       to be returned. The structure of this buffer is defined by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structure. This 
     *       buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value 
     *       is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks 
     *       section.
     * @param {Integer} nBufferLength The size of the buffer that is pointed to by the <i>lpBuffer</i> parameter, in 
     *       bytes.
     * @param {Integer} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the 
     *       specified directory. If this parameter is <b>FALSE</b>, the function monitors only the 
     *       directory specified by the <i>hDirectory</i> parameter.
     * @param {Integer} dwNotifyFilter The filter criteria that the function checks to determine if the wait operation has completed. This
     * @param {Pointer<UInt32>} lpBytesReturned For synchronous calls, this parameter receives the number of bytes transferred into the 
     *       <i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use 
     *       an asynchronous notification technique to retrieve the number of bytes transferred.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that supplies 
     *       data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The 
     *       <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not 
     *       used.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to a completion routine to be called when the operation has been completed or canceled and the 
     *       calling thread is in an alertable wait state. For more information about this completion routine, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation 
     *        succeeded. For asynchronous calls, this indicates that the operation was successfully queued.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the network redirector or the target file system does not support this operation, the function fails with 
     *        <b>ERROR_INVALID_FUNCTION</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-readdirectorychangesw
     * @since windows5.1.2600
     */
    static ReadDirectoryChangesW(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadDirectoryChangesW", "ptr", hDirectory, "ptr", lpBuffer, "uint", nBufferLength, "int", bWatchSubtree, "uint", dwNotifyFilter, "uint*", lpBytesReturned, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information that describes the changes within the specified directory, which can include extended information if that information type is specified.
     * @remarks
     * To obtain a handle to a directory, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 
     *     function with the <b>FILE_FLAG_BACKUP_SEMANTICS</b> flag.
     * 
     * A call to <b>ReadDirectoryChangesExW</b> can be 
     *     completed synchronously or asynchronously. To specify asynchronous completion, open the directory with 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> as shown above, but additionally specify the 
     *     <b>FILE_FLAG_OVERLAPPED</b> attribute in the <i>dwFlagsAndAttributes</i> 
     *     parameter. Then specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure when you 
     *     call <b>ReadDirectoryChangesExW</b>.
     * 
     * When you first call **ReadDirectoryChangesExW**, the system allocates a buffer to store change information. This buffer is associated with the directory handle until it is closed and its size does not change during its lifetime. Directory changes that occur between calls to this function are added to the buffer and then returned with the next call. If the buffer overflows, **ReadDirectoryChangesExW** will still return **true**, but the entire contents of the buffer are discarded and the *lpBytesReturned* parameter will be zero, which indicates that your buffer was too small to hold all of the changes that occurred.
     * 
     * Upon successful synchronous completion, the <i>lpBuffer</i> parameter is a formatted buffer 
     *     and the number of bytes written to the buffer is available in <i>lpBytesReturned</i>. If the 
     *     number of bytes transferred is zero, the buffer was either too large for the system to allocate or too small to 
     *     provide detailed information on all the changes that occurred in the directory or subtree. In this case, you 
     *     should compute the changes by enumerating the directory or subtree.
     * 
     * For asynchronous completion, you can receive notification in one of three ways:
     * 
     * <ul>
     * <li>Using the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function. To 
     *       receive notification through 
     *       <b>GetOverlappedResult</b>, do not specify a completion 
     *       routine in the <i>lpCompletionRoutine</i> parameter. Be sure to set the 
     *       <b>hEvent</b> member of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure to a unique event.</li>
     * <li>Using the <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> 
     *       function. To receive notification through 
     *       <b>GetQueuedCompletionStatus</b>, do not specify 
     *       a completion routine in <i>lpCompletionRoutine</i>. Associate the directory handle 
     *       <i>hDirectory</i> with a completion port by calling the 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/createiocompletionport">CreateIoCompletionPort</a> function.</li>
     * <li>Using a completion routine. To receive notification through a completion routine, do not associate the 
     *       directory with a completion port. Specify a completion routine in <i>lpCompletionRoutine</i>. 
     *       This routine is called whenever the operation has been completed or canceled while the thread is in an alertable 
     *       wait state. The <b>hEvent</b> member of the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is not used by the system, so you 
     *       can use it yourself.</li>
     * </ul>
     *  For more information, see 
     *      <a href="https://docs.microsoft.com/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">Synchronous and Asynchronous I/O</a>.
     * 
     * <b>ReadDirectoryChangesExW</b> fails with 
     *     <b>ERROR_INVALID_PARAMETER</b> when the buffer length is greater than 64 KB and the application 
     *     is monitoring a directory over the network. This is due to a packet size limitation with the underlying file 
     *     sharing protocols.
     * 
     * <b>ReadDirectoryChangesExW</b> fails with 
     *     <b>ERROR_NOACCESS</b> when the buffer is not aligned on a <b>DWORD</b> 
     *     boundary.
     * 
     * <b>ReadDirectoryChangesExW</b> fails with
     * <b>ERROR_NOTIFY_ENUM_DIR</b>
     * when the system was unable to record all the changes to the directory.
     * In this case, you should compute the changes by enumerating the directory or subtree.
     * 
     * If you opened the file using the short name, you can receive change notifications for the short name.
     * 
     * <b>ReadDirectoryChangesExW</b> is currently supported only for the NTFS file system.
     *    
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the directory handle, then the notifications follow the appropriate 
     *       transaction isolation rules.
     * @param {Pointer<Void>} hDirectory A handle to the directory to be monitored. This directory must be opened with the 
     *       <b>FILE_LIST_DIRECTORY</b> access right, or an access right such as <b>GENERIC_READ</b> that includes the <b>FILE_LIST_DIRECTORY</b> access right.
     * @param {Pointer} lpBuffer A pointer to the <b>DWORD</b>-aligned formatted buffer in which <b>ReadDirectoryChangesExW</b> should return the read results. The structure of this buffer is defined by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> structure if the value of the <i>ReadDirectoryNotifyInformationClass</i> parameter is <b>ReadDirectoryNotifyExtendedInformation</b>, or by the <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structure if <i>ReadDirectoryNotifyInformationClass</i> is <b>ReadDirectoryNotifyInformation</b>.
     * 
     * This 
     *       buffer is filled either synchronously or asynchronously, depending on how the directory is opened and what value 
     *       is given to the <i>lpOverlapped</i> parameter. For more information, see the Remarks 
     *       section.
     * @param {Integer} nBufferLength The size of the buffer to which the <i>lpBuffer</i> parameter points, in 
     *       bytes.
     * @param {Integer} bWatchSubtree If this parameter is <b>TRUE</b>, the function monitors the directory tree rooted at the 
     *       specified directory. If this parameter is <b>FALSE</b>, the function monitors only the 
     *       directory specified by the <i>hDirectory</i> parameter.
     * @param {Integer} dwNotifyFilter The filter criteria that the function checks to determine if the wait operation has completed. This
     * @param {Pointer<UInt32>} lpBytesReturned For synchronous calls, this parameter receives the number of bytes transferred into the 
     *       <i>lpBuffer</i> parameter. For asynchronous calls, this parameter is undefined. You must use 
     *       an asynchronous notification technique to retrieve the number of bytes transferred.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that supplies 
     *       data to be used during asynchronous operation. Otherwise, this value is <b>NULL</b>. The 
     *       <b>Offset</b> and <b>OffsetHigh</b> members of this structure are not 
     *       used.
     * @param {Pointer<LPOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine A pointer to a completion routine to be called when the operation has been completed or canceled and the 
     *       calling thread is in an alertable wait state. For more information about this completion routine, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/nc-minwinbase-lpoverlapped_completion_routine">FileIOCompletionRoutine</a>.
     * @param {Integer} ReadDirectoryNotifyInformationClass The type of   information that
     *         <b>ReadDirectoryChangesExW</b> should write to the buffer to which the <i>lpBuffer</i> parameter points. Specify <b>ReadDirectoryNotifyInformation</b> to indicate 
     *         that the information should consist of <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_information">FILE_NOTIFY_INFORMATION</a> structures, or <b>ReadDirectoryNotifyExtendedInformation</b> to indicate 
     *         that the information should consist of <a href="https://docs.microsoft.com/windows/desktop/api/winnt/ns-winnt-file_notify_extended_information">FILE_NOTIFY_EXTENDED_INFORMATION</a> structures.
     * @returns {Integer} If the function succeeds, the return value is nonzero. For synchronous calls, this means that the operation 
     *        succeeded. For asynchronous calls, this indicates that the operation was successfully queued.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the network redirector or the target file system does not support this operation, the function fails with 
     *        <b>ERROR_INVALID_FUNCTION</b>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-readdirectorychangesexw
     * @since windows10.0.16299
     */
    static ReadDirectoryChangesExW(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\ReadDirectoryChangesExW", "ptr", hDirectory, "ptr", lpBuffer, "uint", nBufferLength, "int", bWatchSubtree, "uint", dwNotifyFilter, "uint*", lpBytesReturned, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int", ReadDirectoryNotifyInformationClass, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the name of a volume on a computer. (FindFirstVolumeA)
     * @remarks
     * The <b>FindFirstVolume</b> function opens a volume search handle and returns 
     *     information about the first volume found on a computer. After the search handle is established, you can use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> function to search for other volumes. When 
     *     the search handle is no longer needed, close it by using the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> function.
     * 
     * You should not assume any correlation between the order of the volumes that are returned by these functions 
     *     and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume 
     *     order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Byte>} lpszVolumeName A pointer to a buffer that receives a null-terminated string that specifies a volume 
     *       <b>GUID</b> path for the first volume that is found.
     * @param {Integer} cchBufferLength The length of the buffer to receive the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> functions.
     * 
     * If the function fails to find any volumes, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findfirstvolumea
     * @since windows5.1.2600
     */
    static FindFirstVolumeA(lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeA", "ptr", lpszVolumeName, "uint", cchBufferLength)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a volume search started by a call to the FindFirstVolume function. (FindNextVolumeA)
     * @remarks
     * After the search handle is established by calling 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a>, you can use the 
     *     <b>FindNextVolume</b> function to search for other volumes.
     * 
     * You should not assume any correlation between the order of the volumes that are returned by these functions 
     *     and the order of the volumes that are on the computer. In particular, do not assume any correlation between volume 
     *     order and drive letters as assigned by the BIOS (if any) or the Disk Administrator.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Void>} hFindVolume The volume search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> function.
     * @param {Pointer<Byte>} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the volume <b>GUID</b> path, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no matching files can be found, the 
     *        <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findnextvolumea
     * @since windows5.1.2600
     */
    static FindNextVolumeA(hFindVolume, lpszVolumeName, cchBufferLength) {
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeA", "ptr", hFindVolume, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the name of a mounted folder on the specified volume. (ANSI)
     * @remarks
     * The <b>FindFirstVolumeMountPoint</b> function 
     *     opens a mounted folder search handle and returns information about the first mounted folder that is found on the 
     *     specified volume. After the search handle is established, you can use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> function to search for 
     *     other mounted folders. When the search handle is no longer needed, close it with the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> function.
     * 
     * The <b>FindFirstVolumeMountPoint</b>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a>, and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions return 
     *     paths to mounted folders for a specified volume. They do not return drive letters or volume 
     *     <b>GUID</b> paths. For information about enumerating the volume 
     *     <b>GUID</b> paths for a volume, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.
     * 
     * You should not assume any correlation between the order of the mounted folders that are returned by these 
     *     functions and the order of the mounted folders that are returned by other functions or tools.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume. 
     *      ReFS does not index mount points.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpszRootPathName A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.
     * @param {Pointer<Byte>} lpszVolumeMountPoint A pointer to a buffer that receives the name of the first mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the path to the mounted folder, in 
     *       <b>TCHAR</b>s.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions.
     * 
     * If the function fails to find a mounted folder on the volume, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointa
     * @since windows5.1.2600
     */
    static FindFirstVolumeMountPointA(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength) {
        lpszRootPathName := lpszRootPathName is String? StrPtr(lpszRootPathName) : lpszRootPathName
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeMountPointA", "ptr", lpszRootPathName, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the name of a mounted folder on the specified volume. (Unicode)
     * @remarks
     * The <b>FindFirstVolumeMountPoint</b> function 
     *     opens a mounted folder search handle and returns information about the first mounted folder that is found on the 
     *     specified volume. After the search handle is established, you can use the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> function to search for 
     *     other mounted folders. When the search handle is no longer needed, close it with the 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> function.
     * 
     * The <b>FindFirstVolumeMountPoint</b>, 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a>, and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions return 
     *     paths to mounted folders for a specified volume. They do not return drive letters or volume 
     *     <b>GUID</b> paths. For information about enumerating the volume 
     *     <b>GUID</b> paths for a volume, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.
     * 
     * You should not assume any correlation between the order of the mounted folders that are returned by these 
     *     functions and the order of the mounted folders that are returned by other functions or tools.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume. 
     *      ReFS does not index mount points.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FindFirstVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpszRootPathName A volume GUID path for the volume to scan for mounted folders. A trailing backslash is required.
     * @param {Pointer<Char>} lpszVolumeMountPoint A pointer to a buffer that receives the name of the first mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the path to the mounted folder, in 
     *       <b>TCHAR</b>s.
     * @returns {Pointer<Void>} If the function succeeds, the return value is a search handle used in a subsequent call to the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> and 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions.
     * 
     * If the function fails to find a mounted folder on the volume, the return value is the 
     *        <b>INVALID_HANDLE_VALUE</b> error code. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointw
     * @since windows5.1.2600
     */
    static FindFirstVolumeMountPointW(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength) {
        lpszRootPathName := lpszRootPathName is String? StrPtr(lpszRootPathName) : lpszRootPathName
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindFirstVolumeMountPointW", "ptr", lpszRootPathName, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a mounted folder search started by a call to the FindFirstVolumeMountPoint function. (ANSI)
     * @remarks
     * After the search handle is established by calling 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a>, you can 
     *     use the <b>FindNextVolumeMountPoint</b> function to 
     *     search for other mounted folders.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a>, 
     *     <b>FindNextVolumeMountPoint</b>, and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions return 
     *     paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For 
     *     information about enumerating the volume <b>GUID</b> paths for a volume, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.
     * 
     * You should not assume any correlation between the order of the mounted folders that are returned with these 
     *     functions and the order of the mounted folders that are returned by other functions or tools.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume. 
     *      ReFS does not index mount points.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hFindVolumeMountPoint A mounted folder search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.
     * @param {Pointer<Byte>} lpszVolumeMountPoint A pointer to a buffer that receives the name of the mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the mounted folder name, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no more mounted folders can be found, 
     *        the <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointa
     * @since windows5.1.2600
     */
    static FindNextVolumeMountPointA(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeMountPointA", "ptr", hFindVolumeMountPoint, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Continues a mounted folder search started by a call to the FindFirstVolumeMountPoint function. (Unicode)
     * @remarks
     * After the search handle is established by calling 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a>, you can 
     *     use the <b>FindNextVolumeMountPoint</b> function to 
     *     search for other mounted folders.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a>, 
     *     <b>FindNextVolumeMountPoint</b>, and 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> functions return 
     *     paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For 
     *     information about enumerating the volume <b>GUID</b> paths for a volume, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.
     * 
     * You should not assume any correlation between the order of the mounted folders that are returned with these 
     *     functions and the order of the mounted folders that are returned by other functions or tools.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume. 
     *      ReFS does not index mount points.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines FindNextVolumeMountPoint as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} hFindVolumeMountPoint A mounted folder search handle returned by a previous call to the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.
     * @param {Pointer<Char>} lpszVolumeMountPoint A pointer to a buffer that receives the name of the mounted folder that is found.
     * @param {Integer} cchBufferLength The length of the buffer that receives the mounted folder name, in 
     *       <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If no more mounted folders can be found, 
     *        the <b>GetLastError</b> function returns the 
     *        <b>ERROR_NO_MORE_FILES</b> error code. In that case, close the search with the 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findvolumemountpointclose">FindVolumeMountPointClose</a> function.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointw
     * @since windows5.1.2600
     */
    static FindNextVolumeMountPointW(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindNextVolumeMountPointW", "ptr", hFindVolumeMountPoint, "ptr", lpszVolumeMountPoint, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Closes the specified mounted folder search handle.
     * @remarks
     * After the 
     * <b>FindVolumeMountPointClose</b> function is called, the handle <i>hFindVolumeMountPoint</i> cannot be used in subsequent calls to either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> or 
     * <b>FindVolumeMountPointClose</b>.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a>, and <b>FindVolumeMountPointClose</b> functions return paths to mounted folders for a specified volume. They do not return drive letters or volume GUID paths. For information about enumerating the volume GUID paths for a volume, see <a href="https://docs.microsoft.com/windows/desktop/FileIO/enumerating-unique-volume-names">Enumerating Volume GUID Paths</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. CsvFS does not support adding mount point on a CSV volume.
     * @param {Pointer<Void>} hFindVolumeMountPoint The mounted folder search handle to be closed. This handle must have been previously opened by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-findvolumemountpointclose
     * @since windows5.1.2600
     */
    static FindVolumeMountPointClose(hFindVolumeMountPoint) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\FindVolumeMountPointClose", "ptr", hFindVolumeMountPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates a volume with a drive letter or a directory on another volume. (ANSI)
     * @remarks
     * When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.
     * 
     * It is an error to associate a volume with a directory that has any files or subdirectories in it. This 
     *     error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden 
     *     files.
     * 
     * When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain 
     *     circumstances. For information on how to create and configure mounted folders to ensure that this does not happen, 
     *     see <a href="https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.
     * 
     * IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.
     * @param {Pointer<Byte>} lpszVolumeMountPoint The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\\") or a directory 
     *       on another volume (for example, "Y:\MountX\"). The string must end with a trailing backslash ('\').
     * @param {Pointer<Byte>} lpszVolumeName A volume <b>GUID</b> path for the volume. This string must be of the form 
     *       "\\\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies 
     *       the volume. The "\\\\?\" turns off path parsing and is ignored as part of the path, as discussed in 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setvolumemountpointa
     * @since windows5.1.2600
     */
    static SetVolumeMountPointA(lpszVolumeMountPoint, lpszVolumeName) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeMountPointA", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates a volume with a drive letter or a directory on another volume. (Unicode)
     * @remarks
     * When this function is used to associate a volume with a directory on another volume, the associated directory is called a <i>mounted folder</i>.
     * 
     * It is an error to associate a volume with a directory that has any files or subdirectories in it. This 
     *     error occurs for system and hidden directories as well as other directories, and it occurs for system and hidden 
     *     files.
     * 
     * When mounted folders are created on a volume on a clustered disk, they may be deleted unexpectedly under certain 
     *     circumstances. For information on how to create and configure mounted folders to ensure that this does not happen, 
     *     see <a href="https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2003/cc757627(v=ws.10)">Cluster Disk and Drive Connection Problems</a>.
     * 
     * IIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. For CsvFS a new mount point will not be replicated to the other nodes on the cluster.
     * @param {Pointer<Char>} lpszVolumeMountPoint The user-mode path to be associated with the volume. This may be a drive letter (for example, "X:\\") or a directory 
     *       on another volume (for example, "Y:\MountX\"). The string must end with a trailing backslash ('\').
     * @param {Pointer<Char>} lpszVolumeName A volume <b>GUID</b> path for the volume. This string must be of the form 
     *       "\\\\?\\Volume{<i>GUID</i>}\\" where <i>GUID</i> is a <b>GUID</b> that identifies 
     *       the volume. The "\\\\?\\" turns off path parsing and is ignored as part of the path, as discussed in 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming a Volume</a>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * 
     * If the <i>lpszVolumeMountPoint</i> parameter contains a path to a mounted folder, <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns <b>ERROR_DIR_NOT_EMPTY</b>, even if the directory is empty.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-setvolumemountpointw
     * @since windows5.1.2600
     */
    static SetVolumeMountPointW(lpszVolumeMountPoint, lpszVolumeName) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\SetVolumeMountPointW", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Deletes a drive letter or mounted folder. (DeleteVolumeMountPointA)
     * @remarks
     * Deleting a mounted folder does not cause the underlying directory to be deleted.
     * 
     * If the <i>lpszVolumeMountPoint</i> parameter is a directory that is not a mounted folder, 
     *     the function does nothing. The directory is not deleted.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions. For CsvFs, a new mount point will not be replicated to the other nodes on the cluster.
     * @param {Pointer<Byte>} lpszVolumeMountPoint The drive letter or mounted folder to be deleted. A trailing backslash is required, for example, 
     *       "X:\" or "Y:\MountX\".
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-deletevolumemountpointa
     * @since windows5.1.2600
     */
    static DeleteVolumeMountPointA(lpszVolumeMountPoint) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint

        A_LastError := 0

        result := DllCall("KERNEL32.dll\DeleteVolumeMountPointA", "ptr", lpszVolumeMountPoint, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a volume GUID path for the volume that is associated with the specified volume mount point ( drive letter, volume GUID path, or mounted folder). (GetVolumeNameForVolumeMountPointA)
     * @remarks
     * Use 
     * <b>GetVolumeNameForVolumeMountPoint</b> to obtain a volume <b>GUID</b> path for use with functions such as <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-setvolumemountpointa">SetVolumeMountPoint</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> that require a volume <b>GUID</b> path as an input parameter. For more information about volume <b>GUID</b> paths, see 
     * <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-volume">Naming A Volume</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * Mount points aren't supported by ReFS volumes.
     * @param {Pointer<Byte>} lpszVolumeMountPoint A pointer to a string that contains the path of a mounted folder (for example, "Y:\MountX\") or a drive letter (for example, "X:\\"). The string must end with a trailing backslash ('\').
     * @param {Pointer<Byte>} lpszVolumeName A pointer to a string that receives the volume <b>GUID</b> path. This path is of the form "\\?\Volume{<i>GUID</i>}\" where <i>GUID</i> is a <b>GUID</b> that identifies the volume. If there is more than one volume <b>GUID</b> path for the volume, only the first one in the mount manager's cache is returned.
     * @param {Integer} cchBufferLength The length of the output buffer, in <b>TCHARs</b>. A reasonable size for the buffer to accommodate the largest possible volume <b>GUID</b> path is 50 characters.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getvolumenameforvolumemountpointa
     * @since windows5.1.2600
     */
    static GetVolumeNameForVolumeMountPointA(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength) {
        lpszVolumeMountPoint := lpszVolumeMountPoint is String? StrPtr(lpszVolumeMountPoint) : lpszVolumeMountPoint
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumeNameForVolumeMountPointA", "ptr", lpszVolumeMountPoint, "ptr", lpszVolumeName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves the volume mount point where the specified path is mounted. (GetVolumePathNameA)
     * @remarks
     * If a specified path is passed, <b>GetVolumePathName</b> 
     *     returns the path to the volume mount point, which means that it returns the root of the volume where the end point 
     *     of the specified path is located.
     * 
     * For example, assume that you have volume D mounted at C:\Mnt\Ddrive 
     *     and volume E mounted at "C:\Mnt\Ddrive\Mnt\Edrive". Also assume that you 
     *     have a file with the path "E:\Dir\Subdir\MyFile". If you pass 
     *     "C:\Mnt\Ddrive\Mnt\Edrive\Dir\Subdir\MyFile" to 
     *     <b>GetVolumePathName</b>, it returns the path 
     *     "C:\Mnt\Ddrive\Mnt\Edrive\".
     * 
     * If either a relative directory or a file is passed without a volume qualifier, the function returns the drive 
     *     letter of the boot volume. The drive letter of the boot volume is also returned if an invalid file or directory 
     *     name is specified without a valid volume qualifier. If a valid volume specifier is given, and the volume exists, 
     *     but an invalid file or directory name is specified, the function will succeed and that volume name will be 
     *     returned. For examples, see the Examples section of this topic.
     * 
     * You must specify a valid Win32 namespace path. If you specify an NT namespace path, for example, 
     *     "\DosDevices\H:" or 
     *     "\Device\HardDiskVolume6", the function returns the drive letter of the 
     *     boot volume, not the drive letter of that NT namespace path.
     * 
     * For more information about path names and namespaces, see 
     *     <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a>.
     * 
     * You can specify both local and remote paths. If you specify a local path, 
     *     <b>GetVolumePathName</b> returns a full path whose prefix is 
     *     the longest prefix that represents a volume.
     * 
     * If a network share is specified, <b>GetVolumePathName</b> 
     *     returns the shortest path for which <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdrivetypea">GetDriveType</a> returns 
     *     <b>DRIVE_REMOTE</b>, which means that the path is validated as a remote drive that exists, 
     *     which the current user can access.
     * 
     * There are certain special cases that do not return a trailing backslash. These occur when the output buffer 
     *     length is one character too short. For example, if <i>lpszFileName</i> is 
     *     C: and <i>lpszVolumePathName</i> is 4 characters long, the value 
     *     returned is "C:\"; however, if 
     *     <i>lpszVolumePathName</i> is 3 characters long, the value returned is 
     *     "C:". A safer but slower way to set the size of the return buffer is to 
     *     call the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea">GetFullPathName</a> function, and then make sure 
     *     that the buffer size is at least the same size as the full path that 
     *     <b>GetFullPathName</b> returns. If the output buffer is more 
     *     than one character too short, the function will fail and return an error.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following 
     *     technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * 
     * <h3><a id="Trailing_Path_Elements"></a><a id="trailing_path_elements"></a><a id="TRAILING_PATH_ELEMENTS"></a>Trailing Path Elements</h3>
     * Trailing path elements that are invalid are ignored. For remote paths, the entire path (not just trailing 
     *       elements) is considered invalid if one of the following conditions is true: 
     *       <ul>
     * <li>The path is not formed correctly.</li>
     * <li>The path does not exist.</li>
     * <li>The current user does not have access to the path.</li>
     * </ul>
     * 
     * 
     * <h3><a id="Junction_Points_and_Mounted_Folders"></a><a id="junction_points_and_mounted_folders"></a><a id="JUNCTION_POINTS_AND_MOUNTED_FOLDERS"></a>Junction Points and Mounted Folders</h3>
     * If the specified path traverses a junction point, 
     *       <b>GetVolumePathName</b> returns the volume to which the 
     *       junction point refers. For example, if <c>W:\Adir</c> is a junction point 
     *       that points to <c>C:\Adir</c>, then 
     *       <b>GetVolumePathName</b> invoked on 
     *       <c>W:\Adir\Afile</code> returns "<code>C:\</c>". 
     *       If the specified path traverses multiple junction points, the entire chain is followed, and 
     *       <b>GetVolumePathName</b> returns the volume to which the 
     *       last junction point in the chain refers.
     * 
     * If a remote path to a mounted folder or junction point is specified, the path is parsed as a remote path, and 
     *       the mounted folder or junction point are ignored. For example if 
     *       <c>C:\Dir_C</c> is linked to 
     *       <c>D:\Dir_D</code> and <code>C:</c> is mapped to 
     *       <c>X:</c> on a remote computer, calling 
     *       <b>GetVolumePathName</b> and specifying 
     *       <c>X:\Dir_C</c> on the remote computer returns 
     *       <c>X:\</c>.
     * @param {Pointer<Byte>} lpszFileName A pointer to the input path string. Both absolute and relative file and directory names, for example 
     *        "..", are acceptable in this path.
     * 
     * If you specify a relative directory or file name without a volume qualifier, 
     *        <b>GetVolumePathName</b> returns the drive letter of the 
     *        boot volume.
     * 
     * If this parameter is an empty string, "", the function fails but the last error is set to 
     *        <b>ERROR_SUCCESS</b>.
     * @param {Pointer<Byte>} lpszVolumePathName A pointer to a string that receives the volume mount point for the input path.
     * @param {Integer} cchBufferLength The length of the output buffer, in <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getvolumepathnamea
     * @since windows5.1.2600
     */
    static GetVolumePathNameA(lpszFileName, lpszVolumePathName, cchBufferLength) {
        lpszFileName := lpszFileName is String? StrPtr(lpszFileName) : lpszFileName
        lpszVolumePathName := lpszVolumePathName is String? StrPtr(lpszVolumePathName) : lpszVolumePathName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNameA", "ptr", lpszFileName, "ptr", lpszVolumePathName, "uint", cchBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves a list of drive letters and mounted folder paths for the specified volume. (GetVolumePathNamesForVolumeNameA)
     * @remarks
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB does not support volume management functions.
     * @param {Pointer<Byte>} lpszVolumeName A volume <b>GUID</b> path for the volume. A volume <b>GUID</b> 
     *       path is of the form 
     *       "\\?\Volume{<i>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</i>}\".
     * @param {Pointer<Byte>} lpszVolumePathNames A pointer to a buffer that receives the list of drive letters and mounted folder paths. The list is an 
     *       array of null-terminated strings terminated by an additional <b>NULL</b> character. If the 
     *       buffer is not large enough to hold the complete list, the buffer holds as much of the list as possible.
     * @param {Integer} cchBufferLength The length of the <i>lpszVolumePathNames</i> buffer, in 
     *       <b>TCHARs</b>, including all <b>NULL</b> characters.
     * @param {Pointer<UInt32>} lpcchReturnLength If the call is successful, this parameter is the number of <b>TCHARs</b> copied to 
     *       the <i>lpszVolumePathNames</i> buffer. Otherwise, this parameter is the size of the buffer 
     *       required to hold the complete list, in <b>TCHARs</b>.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. If the buffer is not large enough to 
     *        hold the complete list, the error code is <b>ERROR_MORE_DATA</b> and the 
     *        <i>lpcchReturnLength</i> parameter receives the required buffer size.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getvolumepathnamesforvolumenamea
     * @since windows5.1.2600
     */
    static GetVolumePathNamesForVolumeNameA(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength) {
        lpszVolumeName := lpszVolumeName is String? StrPtr(lpszVolumeName) : lpszVolumeName
        lpszVolumePathNames := lpszVolumePathNames is String? StrPtr(lpszVolumePathNames) : lpszVolumePathNames

        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetVolumePathNamesForVolumeNameA", "ptr", lpszVolumeName, "ptr", lpszVolumePathNames, "uint", cchBufferLength, "uint*", lpcchReturnLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves file information for the specified file. (GetFileInformationByHandleEx)
     * @remarks
     * If <i>FileInformationClass</i> is <b>FileStreamInfo</b> and the calls 
     *     succeed but no streams are returned, the error that is returned by 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> is 
     *     <b>ERROR_HANDLE_EOF</b>.
     * 
     * Certain file information classes behave slightly differently on different operating system releases. These 
     *     classes are supported by the underlying drivers, and any information they return is subject to change between 
     *     operating system releases.
     * 
     * The following table shows the valid file information class types and their corresponding data structure types 
     *      for use with this function.
     * 
     * <table>
     * <tr>
     * <th><i>FileInformationClass</i> value</th>
     * <th><i>lpFileInformation</i> type</th>
     * </tr>
     * <tr>
     * <td><b>FileBasicInfo</b> (0)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_basic_info">FILE_BASIC_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileStandardInfo</b> (1)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_standard_info">FILE_STANDARD_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileNameInfo</b> (2)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_name_info">FILE_NAME_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileStreamInfo</b> (7)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_stream_info">FILE_STREAM_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileCompressionInfo</b> (8)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_compression_info">FILE_COMPRESSION_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileAttributeTagInfo</b> (9)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_attribute_tag_info">FILE_ATTRIBUTE_TAG_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileIdBothDirectoryInfo</b> (0xa)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileIdBothDirectoryRestartInfo</b> (0xb)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileRemoteProtocolInfo</b> (0xd)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_remote_protocol_info">FILE_REMOTE_PROTOCOL_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileFullDirectoryInfo</b> (0xe)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_full_dir_info">FILE_FULL_DIR_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileFullDirectoryRestartInfo</b> (0xf)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_full_dir_info">FILE_FULL_DIR_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileStorageInfo</b> (0x10)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_storage_info">FILE_STORAGE_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileAlignmentInfo</b> (0x11)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_alignment_info">FILE_ALIGNMENT_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileIdInfo</b> (0x12)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_info">FILE_ID_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileIdExtdDirectoryInfo</b> (0x13)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_extd_dir_info">FILE_ID_EXTD_DIR_INFO</a>
     * </td>
     * </tr>
     * <tr>
     * <td><b>FileIdExtdDirectoryRestartInfo</b> (0x14)</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_extd_dir_info">FILE_ID_EXTD_DIR_INFO</a>
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <h3><a id="Transacted_Operations"></a><a id="transacted_operations"></a><a id="TRANSACTED_OPERATIONS"></a>Transacted Operations</h3>
     * If there is a transaction bound to the thread at the time of the call, then the function returns the 
     *       compressed file size of the isolated file view. For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/about-transactional-ntfs">About Transactional NTFS</a>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hFile A handle to the file that contains the information to be retrieved.
     * 
     * This handle should not be a pipe handle.
     * @param {Integer} FileInformationClass A <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ne-minwinbase-file_info_by_handle_class">FILE_INFO_BY_HANDLE_CLASS</a> enumeration 
     *        value that specifies the type of information to be retrieved.
     * 
     * For a table of valid values, see the Remarks section.
     * @param {Pointer} lpFileInformation A pointer to the buffer that receives the requested file information. The structure that is returned 
     *       corresponds to the class that is specified by <i>FileInformationClass</i>. For a table of 
     *       valid structure types, see the Remarks section.
     * @param {Integer} dwBufferSize The size of the <i>lpFileInformation</i> buffer, in bytes.
     * @returns {Integer} If the function succeeds, the return value is nonzero and file information data is contained in the buffer 
     *        pointed to by the <i>lpFileInformation</i> parameter.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-getfileinformationbyhandleex
     * @since windows6.0.6000
     */
    static GetFileInformationByHandleEx(hFile, FileInformationClass, lpFileInformation, dwBufferSize) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\GetFileInformationByHandleEx", "ptr", hFile, "int", FileInformationClass, "ptr", lpFileInformation, "uint", dwBufferSize, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Opens the file that matches the specified identifier.
     * @remarks
     * Use the <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close an object handle 
     *     that <b>OpenFileById</b> returns.
     * 
     * If you call <b>OpenFileById</b> on a file that is pending 
     *     deletion as a result of a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a>, the 
     *     function fails. The operating system delays file deletion until all handles to the file are closed. 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> returns 
     *     <b>ERROR_ACCESS_DENIED</b>.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hVolumeHint A handle to any file on a volume or share on which the file to be opened is stored.
     * @param {Pointer<FILE_ID_DESCRIPTOR>} lpFileId A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winbase/ns-winbase-file_id_descriptor">FILE_ID_DESCRIPTOR</a> that identifies 
     *        the file to open.
     * @param {Integer} dwDesiredAccess The access to the object. Access can be read, write, or both.
     * 
     * For more information, see 
     *       <a href="https://docs.microsoft.com/windows/desktop/FileIO/file-security-and-access-rights">File Security and Access
     *       Rights</a>. You cannot request an access mode that conflicts with the sharing mode that is specified in an
     *       open request that has an open handle.
     * 
     * If this parameter is zero (0), the application can query file and device attributes without accessing a
     *       device. This is useful for an application to determine the size of a floppy disk drive and the formats it
     *       supports without requiring a floppy in a drive. It can also be used to test for the existence of a file or
     *       directory without opening them for read or write access.
     * @param {Integer} dwShareMode The sharing mode of an object, which can be read, write, both, or none.
     * 
     * You cannot request a sharing mode that conflicts with the access mode that is specified in an open request 
     *        that has an open handle, because that would result in the following sharing violation: 
     *        (<b>ERROR_SHARING_VIOLATION</b>). For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/creating-and-opening-files">Creating and Opening Files</a>.
     * 
     * If this parameter is zero (0) and <b>OpenFileById</b> 
     *        succeeds, the object cannot be shared and cannot be opened again until the handle is closed. For more 
     *        information, see the Remarks section of this topic.
     * 
     * The sharing options remain in effect until you close the handle to an object.
     * 
     * To enable a processes to share an object while another process has the object open, use a combination of one
     * @param {Pointer<SECURITY_ATTRIBUTES>} lpSecurityAttributes Reserved.
     * @param {Integer} dwFlagsAndAttributes The file flags.
     * 
     * When <b>OpenFileById</b> opens a file, it combines the file 
     *        flags with existing file attributes, and ignores any supplied file attributes. This parameter can include any 
     *        combination of the following flags.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_BACKUP_SEMANTICS"></a><a id="file_flag_backup_semantics"></a><dl>
     * <dt><b>FILE_FLAG_BACKUP_SEMANTICS</b></dt>
     * <dt>0x02000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file is being opened for a backup or restore operation. The system ensures that the calling process 
     *          overrides file security checks when the process has <b>SE_BACKUP_NAME</b> and 
     *          <b>SE_RESTORE_NAME</b> privileges. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/SecBP/changing-privileges-in-a-token">Changing Privileges in a Token</a>.
     * 
     * You must set this flag to obtain a handle to a directory. A directory handle can be passed to some 
     *          functions  instead of a file handle. For more information, see 
     *          <a href="https://docs.microsoft.com/windows/desktop/FileIO/obtaining-a-handle-to-a-directory">Directory Handles</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_NO_BUFFERING"></a><a id="file_flag_no_buffering"></a><dl>
     * <dt><b>FILE_FLAG_NO_BUFFERING</b></dt>
     * <dt>0x20000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system opens a file with no system caching. This flag does not affect hard disk caching. When combined 
     *          with <b>FILE_FLAG_OVERLAPPED</b>, the flag gives maximum asynchronous performance, because 
     *          the I/O does not rely on the synchronous operations of the memory manager. However, some I/O operations take 
     *          more time, because data is not being held in the cache. Also, the file metadata may still be cached. To flush 
     *          the metadata to disk, use the <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 
     *          function.
     * 
     * An application must meet certain requirements when working with files that are opened with 
     *          <b>FILE_FLAG_NO_BUFFERING</b>:
     * 
     * <ul>
     * <li>File access must begin at byte offsets within a file that are integer multiples of the volume sector 
     *           size.</li>
     * <li>File access must be for numbers of bytes that are integer multiples of the volume sector size. For 
     *           example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, 1536, or 
     *           2048 bytes, but not of 335, 981, or 7171 bytes.</li>
     * <li>Buffer addresses for read and write operations should be sector aligned, which means aligned on 
     *           addresses in memory that are integer multiples of the volume sector size. Depending on the disk, this 
     *           requirement may not be enforced.</li>
     * </ul>
     * One way to align buffers on integer multiples of the volume sector size is to use 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a> to allocate the buffers. It allocates 
     *          memory that is aligned on addresses that are integer multiples of the operating system's memory page size. 
     *          Because both memory page and volume sector sizes are powers of 2, this memory is also aligned on addresses 
     *          that are integer multiples of a volume sector size. Memory pages are 4-8 KB in size; sectors are 512 bytes 
     *          (hard disks) or 2048 bytes (CD), and therefore, volume sectors can never be larger than memory pages.
     * 
     * An application can determine a volume sector size by calling the 
     *          <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_NO_RECALL"></a><a id="file_flag_open_no_recall"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_NO_RECALL</b></dt>
     * <dt>0x00100000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file data is requested, but it should continue to be located in remote storage. It should not be 
     *          transported back to local storage. This flag is for use by remote storage systems.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OPEN_REPARSE_POINT"></a><a id="file_flag_open_reparse_point"></a><dl>
     * <dt><b>FILE_FLAG_OPEN_REPARSE_POINT</b></dt>
     * <dt>0x00200000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * When this flag is used, normal <a href="https://docs.microsoft.com/windows/desktop/FileIO/reparse-points">reparse point</a> 
     *          processing does not occur, and <b>OpenFileById</b> attempts 
     *          to open the reparse point. When a file is opened, a file handle is returned, whether or not the filter that 
     *          controls the reparse point is operational. This flag cannot be used with the 
     *          <b>CREATE_ALWAYS</b> flag. If the file is not a reparse point, then this flag is 
     *          ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_OVERLAPPED"></a><a id="file_flag_overlapped"></a><dl>
     * <dt><b>FILE_FLAG_OVERLAPPED</b></dt>
     * <dt>0x40000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The file is being opened or created for asynchronous I/O. When the operation is complete, the event 
     *          specified to the call in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure is 
     *          set to the signaled state. Operations that take a significant amount of time to process return 
     *          <b>ERROR_IO_PENDING</b>.
     * 
     * If this flag is specified, the file can be used for simultaneous read and write operations. The system does 
     *          not maintain the file pointer, therefore you must pass the file position to the read and write functions in 
     *          the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a>  structure or update the file 
     *          pointer.
     * 
     * If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write 
     *          functions specify an <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_RANDOM_ACCESS"></a><a id="file_flag_random_access"></a><dl>
     * <dt><b>FILE_FLAG_RANDOM_ACCESS</b></dt>
     * <dt>0x10000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file is accessed randomly. The system can use this as a hint to optimize file caching.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_SEQUENTIAL_SCAN"></a><a id="file_flag_sequential_scan"></a><dl>
     * <dt><b>FILE_FLAG_SEQUENTIAL_SCAN</b></dt>
     * <dt>0x08000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A file is accessed sequentially from beginning to end. The system can use this as a hint to optimize file 
     *          caching. If an application moves the file pointer for random access, optimum caching may not occur. However, 
     *          correct operation is still guaranteed.
     * 
     * Specifying this flag can increase performance for applications that read large files using sequential 
     *          access. Performance gains can be even more noticeable for applications that read large files mostly 
     *          sequentially, but occasionally skip over small ranges of bytes.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="FILE_FLAG_WRITE_THROUGH"></a><a id="file_flag_write_through"></a><dl>
     * <dt><b>FILE_FLAG_WRITE_THROUGH</b></dt>
     * <dt>0x80000000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system writes through any intermediate cache and goes directly to disk.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is not also specified, so that system caching is in 
     *          effect, then the data is written to the system cache, but is flushed to disk without delay.
     * 
     * If <b>FILE_FLAG_NO_BUFFERING</b> is also specified, so that system caching is not in 
     *          effect, then the data is immediately flushed to disk without going through the system cache. The operating 
     *          system also requests a write-through the hard disk cache to persistent media. However, not all hardware 
     *          supports this write-through capability.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer<Void>} If the function succeeds, the return value is an open handle to a specified file.
     * 
     * If the function fails, the return value is <b>INVALID_HANDLE_VALUE</b>. To get extended 
     *        error information, call <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-openfilebyid
     * @since windows6.0.6000
     */
    static OpenFileById(hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes) {
        A_LastError := 0

        result := DllCall("KERNEL32.dll\OpenFileById", "ptr", hVolumeHint, "ptr", lpFileId, "uint", dwDesiredAccess, "uint", dwShareMode, "ptr", lpSecurityAttributes, "uint", dwFlagsAndAttributes)
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a symbolic link. (ANSI)
     * @remarks
     * Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of 
     *     the path name; relative links are determined relative to where relative–link specifiers are 
     *     in a specified path. Relative links are specified using the following conventions:
     * 
     * <ul>
     * <li>Dot (. and ..) conventions—for example, 
     *       "..\" resolves the path relative to the parent directory.</li>
     * <li>Names with no slashes (\\)—for example, "tmp" resolves 
     *       the path relative to the current directory.</li>
     * <li>Root relative—for example, "\Windows\System32" resolves 
     *       to "<i>current drive</i>:\Windows\System32".</li>
     * <li>Current working directory–relative—for example, if the current 
     *       working directory is C:\Windows\System32, "C:File.txt" resolves to 
     *       "C:\Windows\System32\File.txt".
     *       <div class="alert"><b>Note</b>  If you specify a current working directory–relative link, it is created as an 
     *        absolute link, due to the way the current working directory is processed based on the user and the 
     *        thread.</div>
     * <div> </div>
     * </li>
     * </ul>
     * To remove a symbolic link, delete the file (using 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> or similar APIs) or remove the directory (using 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> or similar APIs) depending on what type 
     *     of symbolic link is used.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs does not support soft link or any other reparse points.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpSymlinkFileName The symbolic link to be created.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Byte>} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     *  If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as 
     *       an absolute link; otherwise, the link is treated as a relative link.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE"></a><a id="symbolic_link_flag_allow_unprivileged_create"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specify this flag to allow creation of symbolic links when the process is not elevated. In UWP, <a href="https://docs.microsoft.com/windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.  Under MSIX, developer mode is not required to be enabled for this flag.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createsymboliclinka
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkA(lpSymlinkFileName, lpTargetFileName, dwFlags) {
        lpSymlinkFileName := lpSymlinkFileName is String? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String? StrPtr(lpTargetFileName) : lpTargetFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkA", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a symbolic link. (Unicode)
     * @remarks
     * Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of 
     *     the path name; relative links are determined relative to where relative–link specifiers are 
     *     in a specified path. Relative links are specified using the following conventions:
     * 
     * <ul>
     * <li>Dot (. and ..) conventions—for example, 
     *       "..\" resolves the path relative to the parent directory.</li>
     * <li>Names with no slashes (\\)—for example, "tmp" resolves 
     *       the path relative to the current directory.</li>
     * <li>Root relative—for example, "\Windows\System32" resolves 
     *       to "<i>current drive</i>:\Windows\System32".</li>
     * <li>Current working directory–relative—for example, if the current 
     *       working directory is C:\Windows\System32, "C:File.txt" resolves to 
     *       "C:\Windows\System32\File.txt".
     *       <div class="alert"><b>Note</b>  If you specify a current working directory–relative link, it is created as an 
     *        absolute link, due to the way the current working directory is processed based on the user and the 
     *        thread.</div>
     * <div> </div>
     * </li>
     * </ul>
     * To remove a symbolic link, delete the file (using 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> or similar APIs) or remove the directory (using 
     *     <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> or similar APIs) depending on what type 
     *     of symbolic link is used.
     * 
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * Yes
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * CsvFs does not support soft link or any other reparse points.
     * 
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateSymbolicLink as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpSymlinkFileName The symbolic link to be created.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Pointer<Char>} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     *  If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as 
     *       an absolute link; otherwise, the link is treated as a relative link.
     * 
     * This parameter may include the path. In the ANSI version of this function, the name is limited to <b>MAX_PATH</b> characters. 
     *        To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend 
     *        "\\?\" to the path. For more information, see 
     *        <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming a File</a>.
     * 
     * <div class="alert"><b>Tip</b>  Starting with Windows 10, version 1607, for the unicode version of this function (<b>CreateSymbolicLinkW</b>), you can opt-in to remove the <b>MAX_PATH</b> limitation without prepending "\\?\". See the "Maximum Path Length Limitation" section of <a href="https://docs.microsoft.com/windows/desktop/FileIO/naming-a-file">Naming Files, Paths, and Namespaces</a> for details.</div>
     * <div> </div>
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE"></a><a id="symbolic_link_flag_allow_unprivileged_create"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE</b></dt>
     * <dt>0x2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Specify this flag to allow creation of symbolic links when the process is not elevated. <a href="https://docs.microsoft.com/windows/uwp/get-started/enable-your-device-for-development">Developer Mode</a> must first be enabled on the machine before  this option will function.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createsymboliclinkw
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkW(lpSymlinkFileName, lpTargetFileName, dwFlags) {
        lpSymlinkFileName := lpSymlinkFileName is String? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String? StrPtr(lpTargetFileName) : lpTargetFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkW", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a symbolic link as a transacted operation. (ANSI)
     * @remarks
     * Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of 
     *     the path name; relative links are determined relative to where relative–link specifiers are 
     *     in a specified path. Relative links are specified using the following conventions:
     * 
     * <ul>
     * <li>Dot (. and ..) conventions—for example, 
     *       "..\" resolves the path relative to the parent directory.</li>
     * <li>Names with no slashes (\\)—for example, "tmp" resolves 
     *       the path relative to the current directory.</li>
     * <li>Root relative—for example, "\Windows\System32" resolves 
     *       to "<i>current drive</i>:\Windows\System32".</li>
     * <li>Current working directory–relative—for example, if the current 
     *       working directory is C:\Windows\System32, "C:File.txt" resolves to 
     *       "C:\Windows\System32\File.txt".
     *       <div class="alert"><b>Note</b>  If you specify a current working directory–relative link, it is created as an 
     *        absolute link, due to the way the current working directory is processed based on the user and the 
     *        thread.</div>
     * <div> </div>
     * </li>
     * </ul>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateSymbolicLinkTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} lpSymlinkFileName The symbolic link to be created.
     * @param {Pointer<Byte>} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     * If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an 
     *        absolute link; otherwise, the link is treated as a relative link.
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createsymboliclinktransacteda
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkTransactedA(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction) {
        lpSymlinkFileName := lpSymlinkFileName is String? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String? StrPtr(lpTargetFileName) : lpTargetFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkTransactedA", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "ptr", hTransaction, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Creates a symbolic link as a transacted operation. (Unicode)
     * @remarks
     * Symbolic links can either be absolute or relative links. Absolute links are links that specify each portion of 
     *     the path name; relative links are determined relative to where relative–link specifiers are 
     *     in a specified path. Relative links are specified using the following conventions:
     * 
     * <ul>
     * <li>Dot (. and ..) conventions—for example, 
     *       "..\" resolves the path relative to the parent directory.</li>
     * <li>Names with no slashes (\\)—for example, "tmp" resolves 
     *       the path relative to the current directory.</li>
     * <li>Root relative—for example, "\Windows\System32" resolves 
     *       to "<i>current drive</i>:\Windows\System32".</li>
     * <li>Current working directory–relative—for example, if the current 
     *       working directory is C:\Windows\System32, "C:File.txt" resolves to 
     *       "C:\Windows\System32\File.txt".
     *       <div class="alert"><b>Note</b>  If you specify a current working directory–relative link, it is created as an 
     *        absolute link, due to the way the current working directory is processed based on the user and the 
     *        thread.</div>
     * <div> </div>
     * </li>
     * </ul>
     * In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
     * 
     * <table>
     * <tr>
     * <th>Technology</th>
     * <th>Supported</th>
     * </tr>
     * <tr>
     * <td>
     * Server Message Block (SMB) 3.0 protocol
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 Transparent Failover (TFO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * SMB 3.0 with Scale-out File Shares (SO)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Cluster Shared Volume File System (CsvFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>
     * Resilient File System (ReFS)
     * 
     * </td>
     * <td>
     * No
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * SMB 3.0 does not support TxF.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winbase.h header defines CreateSymbolicLinkTransacted as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} lpSymlinkFileName The symbolic link to be created.
     * @param {Pointer<Char>} lpTargetFileName The name of the target for the symbolic link to be created.
     * 
     * If <i>lpTargetFileName</i> has a device name associated with it, the link is treated as an 
     *        absolute link; otherwise, the link is treated as a relative link.
     * @param {Integer} dwFlags Indicates whether the link target, <i>lpTargetFileName</i>, is a directory.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt>0x0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SYMBOLIC_LINK_FLAG_DIRECTORY"></a><a id="symbolic_link_flag_directory"></a><dl>
     * <dt><b>SYMBOLIC_LINK_FLAG_DIRECTORY</b></dt>
     * <dt>0x1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The link target is a directory.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} hTransaction A handle to the transaction. This handle is returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ktmw32/nf-ktmw32-createtransaction">CreateTransaction</a> function.
     * @returns {Integer} If the function succeeds, the return value is nonzero.
     * 
     * If the function fails, the return value is zero. To get extended error information, call 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://learn.microsoft.com/windows/win32/api/winbase/nf-winbase-createsymboliclinktransactedw
     * @since windows6.0.6000
     */
    static CreateSymbolicLinkTransactedW(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction) {
        lpSymlinkFileName := lpSymlinkFileName is String? StrPtr(lpSymlinkFileName) : lpSymlinkFileName
        lpTargetFileName := lpTargetFileName is String? StrPtr(lpTargetFileName) : lpTargetFileName

        A_LastError := 0

        result := DllCall("KERNEL32.dll\CreateSymbolicLinkTransactedW", "ptr", lpSymlinkFileName, "ptr", lpTargetFileName, "uint", dwFlags, "ptr", hTransaction, "char")
        if(A_LastError)
            throw OSError()

        return result
    }

;@endregion Methods
}
