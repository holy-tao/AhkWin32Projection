#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.System.Rpc
 * @version v4.0.30319
 */
class Rpc {

;@region Constants

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_BINDING_INFINITE_TIMEOUT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_BINDING_MIN_TIMEOUT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_BINDING_DEFAULT_TIMEOUT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_BINDING_MAX_TIMEOUT => 9

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_CANCEL_INFINITE_TIMEOUT => -1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_LISTEN_MAX_CALLS_DEFAULT => 1234

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PROTSEQ_MAX_REQS_DEFAULT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_BIND_TO_ALL_NICS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_USE_INTERNET_PORT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_USE_INTRANET_PORT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_DONT_FAIL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_RPCHTTP_USE_LOAD_BALANCE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_TRY_ENFORCE_MAX_CALLS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_TEMPORARY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_PERMANENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_CLEAR_ON_OPEN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_USE_EXISTING_SECURITY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_AUTHN_LEVEL_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_AUTHN_LEVEL_PKT_INTEGRITY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_AUTHN_LEVEL_PKT_PRIVACY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_EXPRESS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_RECOVERABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_JOURNAL_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_JOURNAL_DEADLETTER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MQ_JOURNAL_ALWAYS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_DELIVERY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_PRIORITY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_JOURNAL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_ACKNOWLEDGE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_AUTHN_SERVICE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_AUTHN_LEVEL => 6

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_TIME_TO_REACH_QUEUE => 7

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MQ_TIME_TO_BE_RECEIVED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_BINDING_NONCAUSAL => 9

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_SECURITY_CALLBACK => 10

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_UNIQUE_BINDING => 11

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_MAX_OPTIONS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_CALL_TIMEOUT => 12

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_DONT_LINGER => 13

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_TRANS_SEND_BUFFER_SIZE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_TRUST_PEER => 14

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_ASYNC_BLOCK => 15

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_OPTIMIZE_TIME => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_FULL_CERT_CHAIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_STATS_CALLS_IN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_STATS_CALLS_OUT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_STATS_PKTS_IN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_STATS_PKTS_OUT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_DCE_PRIVATE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_DCE_PUBLIC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_DEC_PUBLIC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_GSS_NEGOTIATE => 9

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_WINNT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_GSS_SCHANNEL => 14

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_GSS_KERBEROS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_DPA => 17

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_MSN => 18

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_DIGEST => 21

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_KERNEL => 20

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_NEGO_EXTENDER => 30

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_PKU2U => 31

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_LIVE_SSP => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_LIVEXP_SSP => 35

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_CLOUD_AP => 36

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_MSONLINE => 82

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHN_MQ => 100

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_AUTHN_DEFAULT => -1

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_SECURITY_QOS_VERSION => 1

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_SECURITY_QOS_VERSION_1 => 1

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_SECURITY_QOS_VERSION_2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_HTTP_AUTHN_SCHEME_BASIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_HTTP_AUTHN_SCHEME_NTLM => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_HTTP_AUTHN_SCHEME_PASSPORT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_HTTP_AUTHN_SCHEME_DIGEST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_HTTP_AUTHN_SCHEME_CERT => 65536

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_SECURITY_QOS_VERSION_3 => 3

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_SECURITY_QOS_VERSION_4 => 4

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_SECURITY_QOS_VERSION_5 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_PROTSEQ_TCP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_PROTSEQ_NMP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_PROTSEQ_LRPC => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_PROTSEQ_HTTP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_BHT_OBJECT_UUID_VALID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_BHO_EXCLUSIVE_AND_GUARANTEED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHZ_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHZ_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHZ_DCE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_AUTHZ_DEFAULT => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static DCE_C_ERROR_STRING_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_EP_ALL_ELTS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_EP_MATCH_BY_IF => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_EP_MATCH_BY_OBJ => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_EP_MATCH_BY_BOTH => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_VERS_ALL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_VERS_COMPATIBLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_VERS_EXACT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_VERS_MAJOR_ONLY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_VERS_UPTO => 5

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MGMT_INQ_IF_IDS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MGMT_INQ_PRINC_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MGMT_INQ_STATS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MGMT_IS_SERVER_LISTEN => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_MGMT_STOP_SERVER_LISTEN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PARM_MAX_PACKET_LENGTH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PARM_BUFFER_LENGTH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_AUTOLISTEN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_OLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_ALLOW_UNKNOWN_AUTHORITY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_ALLOW_SECURE_ONLY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_ALLOW_LOCAL_ONLY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_SEC_NO_CACHE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_SEC_CACHE_PER_PROC => 128

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_IF_ASYNC_CALLBACK => 256

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_FW_IF_FLAG_DCOM => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_NOTIFY_ON_SEND_COMPLETE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static MaxNumberOfEEInfoParams => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_EEINFO_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EEInfoPreviousRecordsMissing => 1

    /**
     * @type {Integer (UInt32)}
     */
    static EEInfoNextRecordsMissing => 2

    /**
     * @type {Integer (UInt32)}
     */
    static EEInfoUseFileTime => 4

    /**
     * @type {Integer (UInt32)}
     */
    static EEInfoGCCOM => 11

    /**
     * @type {Integer (UInt32)}
     */
    static EEInfoGCFRS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_CALL_ATTRIBUTES_VERSION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_QUERY_SERVER_PRINCIPAL_NAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_QUERY_CLIENT_PRINCIPAL_NAME => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_QUERY_CALL_LOCAL_ADDRESS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_QUERY_CLIENT_PID => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_QUERY_IS_CLIENT_LOCAL => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_QUERY_NO_AUTH_REQUIRED => 64

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_QUERY_CLIENT_ID => 128

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_CALL_STATUS_CANCELLED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_CALL_STATUS_DISCONNECTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_CONTEXT_HANDLE_DEFAULT_FLAGS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_CONTEXT_HANDLE_FLAGS => 805306368

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_CONTEXT_HANDLE_SERIALIZE => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_CONTEXT_HANDLE_DONT_SERIALIZE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_TYPE_STRICT_CONTEXT_HANDLE => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_TYPE_DISCONNECT_EVENT_CONTEXT_HANDLE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_NCA_FLAGS_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_NCA_FLAGS_IDEMPOTENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_NCA_FLAGS_BROADCAST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_NCA_FLAGS_MAYBE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_HAS_GUARANTEE => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_WINRT_REMOTE_ASYNC => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_BUFFER_COMPLETE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_BUFFER_PARTIAL => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_BUFFER_EXTRA => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_BUFFER_ASYNC => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_BUFFER_NONOTIFY => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_MESSAGE => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_AUTO_COMPLETE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_LOCAL_CALL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_INPUT_SYNCHRONOUS => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_ASYNCHRONOUS => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_NON_NDR => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_HAS_MULTI_SYNTAXES => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_HAS_CALLBACK => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_ACCESSIBILITY_BIT1 => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_ACCESSIBILITY_BIT2 => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_ACCESS_LOCAL => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static NDR_CUSTOM_OR_DEFAULT_ALLOCATOR => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static NDR_DEFAULT_ALLOCATOR => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_NDR64_CONTAINS_ARM_LAYOUT => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static RPCFLG_SENDER_WAITING_FOR_REPLY => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_FLAGS_VALID_BIT => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static NT351_INTERFACE_SIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_INTERFACE_HAS_PIPES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_SYSTEM_HANDLE_FREE_UNRETRIEVED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_SYSTEM_HANDLE_FREE_RETRIEVED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_SYSTEM_HANDLE_FREE_ALL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_SYSTEM_HANDLE_FREE_ERROR_ON_CLOSE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSPORT_TYPE_CN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSPORT_TYPE_DG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSPORT_TYPE_LPC => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TRANSPORT_TYPE_WMSG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_P_ADDR_FORMAT_TCP_IPV4 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_P_ADDR_FORMAT_TCP_IPV6 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_SESSION_ID => 6

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_COOKIE_AUTH => 7

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_RESOURCE_TYPE_UUID => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_PROXY_CONNECTION_TYPE_IN_PROXY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_PROXY_CONNECTION_TYPE_OUT_PROXY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_PRIVATE_SUPPRESS_WAKE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_PRIVATE_DO_NOT_DISTURB => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_OPT_PRIVATE_BREAK_ON_SUSPEND => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PROFILE_DEFAULT_ELT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PROFILE_ALL_ELT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PROFILE_ALL_ELTS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PROFILE_MATCH_BY_IF => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PROFILE_MATCH_BY_MBR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static RPC_C_PROFILE_MATCH_BY_BOTH => 4

    /**
     * @type {Integer (Int32)}
     */
    static RPC_C_NS_DEFAULT_EXP_AGE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT1012_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT102_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT100_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT63_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT62_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT61_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT60_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT51_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT50_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT40_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TARGET_IS_NT351_OR_WIN95_OR_LATER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static cbNDRContext => 20

    /**
     * @type {Integer (UInt32)}
     */
    static USER_CALL_IS_ASYNC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static USER_CALL_NEW_CORRELATION_DESC => 512

    /**
     * @type {Integer (Int32)}
     */
    static MIDL_WINRT_TYPE_SERIALIZATION_INFO_CURRENT_VERSION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_BYTE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_CHAR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_SMALL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_USMALL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_WCHAR => 5

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_SHORT => 6

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_USHORT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_LONG => 8

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_ULONG => 9

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_FLOAT => 10

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_HYPER => 11

    /**
     * @type {Integer (UInt32)}
     */
    static USER_MARSHAL_FC_DOUBLE => 12

    /**
     * @type {Integer (UInt32)}
     */
    static INVALID_FRAGMENT_ID => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NDR64_FC_EXPLICIT_HANDLE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NDR64_FC_BIND_GENERIC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NDR64_FC_BIND_PRIMITIVE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NDR64_FC_AUTO_HANDLE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NDR64_FC_CALLBACK_HANDLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NDR64_FC_NO_HANDLE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static __RPCPROXY_H_VERSION__ => 477

    /**
     * @type {Integer (Int32)}
     */
    static MidlInterceptionInfoVersionOne => 1

    /**
     * @type {Integer (Int32)}
     */
    static MidlWinrtTypeSerializationInfoVersionOne => 1
;@endregion Constants

;@region Methods
    /**
     * The IUnknown_QueryInterface_Proxy function implements the QueryInterface method for all interface proxies.
     * @remarks
     * This function is used internally by proxies that are generated by MIDL.
     * @param {Pointer<IUnknown>} This_R 
     * @param {Pointer<Guid>} riid IID of the interface to be queried.
     * @param {Pointer<Void>} ppvObject Address to a pointer whose interface is queried or null when an interface is not supported.
     * @returns {HRESULT} Returns S_OK on success.
     * @see https://learn.microsoft.com/windows/win32/api/unknwnbase/nf-unknwnbase-iunknown_queryinterface_proxy
     * @since windows5.0
     */
    static IUnknown_QueryInterface_Proxy(This_R, riid, ppvObject) {
        result := DllCall("RPCRT4.dll\IUnknown_QueryInterface_Proxy", "ptr", This_R, "ptr", riid, "ptr", ppvObject, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * The IUnknown_AddRef_Proxy function implements the AddRef method for all interface proxies.
     * @remarks
     * The return value is for diagnostic and testing purposes only; the return value may be unstable.
     * 
     * This function is used internally by proxies that are generated by MIDL.
     * @param {Pointer<IUnknown>} This_R 
     * @returns {Integer} Returns an integer from 1 to <i>n</i>, indicating the value of the new reference count.
     * @see https://learn.microsoft.com/windows/win32/api/unknwnbase/nf-unknwnbase-iunknown_addref_proxy
     * @since windows5.0
     */
    static IUnknown_AddRef_Proxy(This_R) {
        result := DllCall("RPCRT4.dll\IUnknown_AddRef_Proxy", "ptr", This_R, "uint")
        return result
    }

    /**
     * The IUnknown_Release_Proxy function implements the Release method for all interface proxies.
     * @remarks
     * The return value is for diagnostic and testing purposes only; the return value may be unstable.
     * 
     * This function is used internally by proxies that are generated by MIDL.
     * @param {Pointer<IUnknown>} This_R 
     * @returns {Integer} Returns an integer from 1 to <i>n</i>, indicating the value of the new reference count.
     * @see https://learn.microsoft.com/windows/win32/api/unknwnbase/nf-unknwnbase-iunknown_release_proxy
     * @since windows5.0
     */
    static IUnknown_Release_Proxy(This_R) {
        result := DllCall("RPCRT4.dll\IUnknown_Release_Proxy", "ptr", This_R, "uint")
        return result
    }

    /**
     * The RpcBindingCopy function copies binding information and creates a new binding handle.
     * @remarks
     * The 
     * <b>RpcBindingCopy</b> function copies the server-binding information referenced by the <i>SourceBinding</i> parameter. 
     * <b>RpcBindingCopy</b> uses the <i>DestinationBinding</i> parameter to return a new server binding handle for the copied binding information. 
     * <b>RpcBindingCopy</b> also copies the authentication information from the <i>SourceBinding</i> parameter to the <i>DestinationBinding</i> parameter.
     * 
     * An application uses 
     * <b>RpcBindingCopy</b> when it wants to prevent a change being made to binding information by one thread from affecting the binding information used by other threads.
     * 
     * Once an application calls 
     * <b>RpcBindingCopy</b>, operations performed on the <i>SourceBinding</i> binding handle do not affect the binding information referenced by the <i>DestinationBinding</i> binding handle. Similarly, operations performed on the <i>DestinationBinding</i> binding handle do not affect the binding information referenced by the <i>SourceBinding</i> binding handle.
     * 
     * If an application wants one thread's changes to binding information to affect the binding information used by other threads, the application should share a single binding handle across the threads. In this case, the application is responsible for binding-handle concurrency control.
     * 
     * When an application is finished using the binding handle specified by the <i>DestinationBinding</i> parameter, the application should call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> function to release the memory used by the <i>DestinationBinding</i> binding handle and its referenced binding information.
     * 
     * <div class="alert"><b>Note</b>  Microsoft RPC supports 
     * <b>RpcBindingCopy</b> only in client applications, not in server applications.</div>
     * <div> </div>
     * @param {Pointer<Void>} SourceBinding Server binding handle whose referenced binding information is copied.
     * @param {Pointer<Void>} DestinationBinding Returns a pointer to the server binding handle that refers to the copied binding information.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingcopy
     * @since windows5.0
     */
    static RpcBindingCopy(SourceBinding, DestinationBinding) {
        result := DllCall("RPCRT4.dll\RpcBindingCopy", "ptr", SourceBinding, "ptr", DestinationBinding, "int")
        return result
    }

    /**
     * The RpcBindingFree function releases binding-handle resources.
     * @remarks
     * The 
     * <b>RpcBindingFree</b> function releases memory used by a server binding handle. Referenced binding information that was dynamically created during program execution is released as well. An application calls the 
     * <b>RpcBindingFree</b> function when it is finished using the binding handle. RPC binding handles must not be freed until all calls using the handle have completed; failure to do so will cause unpredictable results.
     * 
     * Binding handles are dynamically created by calling the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingcopy">RpcBindingCopy</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfromstringbinding">RpcBindingFromStringBinding</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingserverfromclient">RpcBindingServerFromClient</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingselect">RpcNsBindingSelect</a>
     * </li>
     * </ul>
     * If the operation successfully frees the binding, the <i>Binding</i> parameter returns a value of <b>NULL</b>.
     * 
     * <div class="alert"><b>Note</b>  Microsoft RPC supports 
     * <b>RpcBindingFree</b> only in client applications, or in server applications for binding handles generated with RpcBindingServerFromClient.</div>
     * <div> </div>
     * @param {Pointer<Void>} Binding Pointer to the server binding to be freed.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingfree
     * @since windows5.0
     */
    static RpcBindingFree(Binding) {
        result := DllCall("RPCRT4.dll\RpcBindingFree", "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcBindingSetOption function enables client applications to specify message-queuing options on a binding handle.
     * @remarks
     * RPC client processes use 
     * <b>RpcBindingSetOption</b> to control the delivery quality-of-service, call logging, and call lifetimes. Changing the binding-handle properties will affect all remote calls until the properties are changed by another call to 
     * <b>RpcBindingSetOption</b>. You can also call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> to set security options for the binding handle.
     * 
     * <b>Windows XP:  </b>RPC Call Timeout feature:
     * 
     * Calling the 
     * <b>RpcBindingSetOption</b> function with <i>Option</i> set to RPC_C_OPT_CALL_TIMEOUT and <i>OptionValue</i> set to the time-out value (in milliseconds) enables developers to set an RPC-server time-out that prevents a thread from becoming captive to an unresponsive RPC server. This feature saves developers from explicitly canceling a call to an unresponsive RPC server. The timer monitoring for time-out is reset by the RPC client upon receipt of each packet. If the time-out expires without receiving a packet from the server, the RPC client returns RPC_S_CALL_CANCELLED. Note that the RPC server may still eventually execute a call, even though the client will discard the response.
     * 
     * Set <i>OptionValue</i> to INFINITE or zero for an infinite time-out. Do not change this option from another thread while a call is in progress. Do not attempt to retry a canceled call; doing so increases the burden on the already unresponsive server. The RPC call time-out feature is only useful for connection-oriented, synchronous RPC calls, such as those made on <b>ncacn_*</b> protocol sequences. For datagram, asynchronous, or local RPC calls, this option is ignored by the RPC run-time.
     * 
     * The RPC call time-out feature is useful in many situations, such as user interface updates that would otherwise wait for the busy RPC server to respond (leaving the user watching an hourglass), or when many RPC servers can service a request, thereby enabling clients to more quickly identify and bypass unresponsive servers.
     * @param {Pointer<Void>} hBinding Server binding to modify.
     * @param {Integer} option Binding property to modify. For a list of binding options and their possible values, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/binding-option-constants">Binding Option Constants</a>. See Remarks for information on the RPC Call time-out feature.
     * @param {Pointer} optionValue New value for the binding property. See Remarks.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function is not supported for either the operating system or the transport. Note that calling 
     * <b>RpcBindingSetOption</b> on binding handles that use any protocol sequence other than <b>ncacn_*</b> will fail and return this value.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetoption
     * @since windows5.0
     */
    static RpcBindingSetOption(hBinding, option, optionValue) {
        result := DllCall("RPCRT4.dll\RpcBindingSetOption", "ptr", hBinding, "uint", option, "ptr", optionValue, "int")
        return result
    }

    /**
     * RPC client processes use RpcBindingInqOption to determine current values of the binding options for a given binding handle.
     * @remarks
     * Client processes call 
     * <b>RpcBindingInqOption</b> to determine the current settings of the binding handle options. To inquire about authentication settings clients call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthclient">RpcBindingInqAuthClient</a> function. .
     * @param {Pointer<Void>} hBinding Server binding about which to determine binding-option values.
     * @param {Integer} option Binding handle property to inquire about.
     * @param {Pointer<UIntPtr>} pOptionValue Memory location to place the value for the specified <i>Option</i>
     * 
     * <div class="alert"><b>Note</b>  For a list of binding options and their possible values, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/binding-option-constants">Binding Option Constants</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function is not supported for either the operating system or the transport.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqoption
     * @since windows5.0
     */
    static RpcBindingInqOption(hBinding, option, pOptionValue) {
        result := DllCall("RPCRT4.dll\RpcBindingInqOption", "ptr", hBinding, "uint", option, "ptr*", pOptionValue, "int")
        return result
    }

    /**
     * Returns a binding handle from a string representation of a binding handle. (RpcBindingFromStringBindingA)
     * @remarks
     * The 
     * <b>RpcBindingFromStringBinding</b> function creates a server binding handle from a string representation of a binding handle. The <i>StringBinding</i> parameter does not have to contain an object 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>. In this case, the returned binding contains a nil UUID. If the provided <i>StringBinding</i> parameter does not contain an endpoint field, the returned <i>Binding</i> parameter is a partially-bound binding handle. If the provided <i>StringBinding</i> parameter contains an endpoint field, the endpoint is considered to be a well-known endpoint. If the provided <i>StringBinding</i> parameter does not contain a host address field, the returned <i>Binding</i> parameter references the local host.
     * 
     * An application creates a string binding by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringbindingcompose">RpcStringBindingCompose</a> function or by providing a character-string constant. The creation of a string binding by this method does not involve contact with the server. Success or failure of the API will not indicate server availability.
     * 
     * When an application is finished using the <i>Binding</i> parameter, the application should call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> function to release the memory used by the binding handle.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingFromStringBinding as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} StringBinding Pointer to a string representation of a binding handle.
     * @param {Pointer<Void>} Binding Returns a pointer to the server binding handle.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string binding is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Protocol sequence not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_STRING_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * String too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NET_ADDR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network address is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAF_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network address family identifier is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingfromstringbindinga
     * @since windows5.0
     */
    static RpcBindingFromStringBindingA(StringBinding, Binding) {
        StringBinding := StringBinding is String? StrPtr(StringBinding) : StringBinding

        result := DllCall("RPCRT4.dll\RpcBindingFromStringBindingA", "ptr", StringBinding, "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcBindingFromStringBindingW (Unicode) function (rpcdce.h) returns a binding handle from a string representation of a binding handle.
     * @remarks
     * The 
     * <b>RpcBindingFromStringBinding</b> function creates a server binding handle from a string representation of a binding handle. The <i>StringBinding</i> parameter does not have to contain an object 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>. In this case, the returned binding contains a nil UUID. If the provided <i>StringBinding</i> parameter does not contain an endpoint field, the returned <i>Binding</i> parameter is a partially-bound binding handle. If the provided <i>StringBinding</i> parameter contains an endpoint field, the endpoint is considered to be a well-known endpoint. If the provided <i>StringBinding</i> parameter does not contain a host address field, the returned <i>Binding</i> parameter references the local host.
     * 
     * An application creates a string binding by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringbindingcompose">RpcStringBindingCompose</a> function or by providing a character-string constant. The creation of a string binding by this method does not involve contact with the server. Success or failure of the API will not indicate server availability.
     * 
     * When an application is finished using the <i>Binding</i> parameter, the application should call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> function to release the memory used by the binding handle.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingFromStringBinding as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} StringBinding Pointer to a string representation of a binding handle.
     * @param {Pointer<Void>} Binding Returns a pointer to the server binding handle.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string binding is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Protocol sequence not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_STRING_TOO_LONG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * String too long.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NET_ADDR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network address is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAF_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network address family identifier is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingfromstringbindingw
     * @since windows5.0
     */
    static RpcBindingFromStringBindingW(StringBinding, Binding) {
        StringBinding := StringBinding is String? StrPtr(StringBinding) : StringBinding

        result := DllCall("RPCRT4.dll\RpcBindingFromStringBindingW", "ptr", StringBinding, "ptr", Binding, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} ContextHandle 
     * @param {Pointer<Void>} Binding 
     * @returns {Integer} 
     */
    static RpcSsGetContextBinding(ContextHandle, Binding) {
        result := DllCall("RPCRT4.dll\RpcSsGetContextBinding", "ptr", ContextHandle, "ptr", Binding, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<UInt32>} MaxCalls 
     * @returns {Integer} 
     */
    static RpcBindingInqMaxCalls(Binding, MaxCalls) {
        result := DllCall("RPCRT4.dll\RpcBindingInqMaxCalls", "ptr", Binding, "uint*", MaxCalls, "int")
        return result
    }

    /**
     * The RpcBindingInqObject function returns the object UUID from a binding handle.
     * @remarks
     * An application calls the 
     * <b>RpcBindingInqObject</b> function to see the object 
     * <a href="https://msdn.microsoft.com/">UUID</a> associated with a client or server binding handle.
     * @param {Pointer<Void>} Binding Client or server binding handle.
     * @param {Pointer<Guid>} ObjectUuid Returns a pointer to the object 
     * <a href="https://msdn.microsoft.com/">UUID</a> found in the <i>Binding</i> parameter. <i>ObjectUuid</i> is a unique identifier of an object to which a remote procedure call can be made.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqobject
     * @since windows5.0
     */
    static RpcBindingInqObject(Binding, ObjectUuid) {
        result := DllCall("RPCRT4.dll\RpcBindingInqObject", "ptr", Binding, "ptr", ObjectUuid, "int")
        return result
    }

    /**
     * The RpcBindingReset function resets a binding handle so that the host is specified but the server on that host is unspecified.
     * @remarks
     * A client calls the 
     * <b>RpcBindingReset</b> function to disassociate a particular server instance from the server binding handle specified in the <i>Binding</i> parameter. The 
     * <b>RpcBindingReset</b> function dissociates a server instance by removing the endpoint portion of the server address in the binding handle. The host remains unchanged in the binding handle. The result is a partially-bound server binding handle.
     * 
     * <b>RpcBindingReset</b> does not affect the <i>Binding</i> parameter's authentication information, if there is any.
     * 
     * If a client is willing to be serviced by any compatible server instance on the host specified in the binding handle, the client calls the 
     * <b>RpcBindingReset</b> function before making a remote procedure call using the <i>Binding</i> binding handle. Clients must not call the 
     * <b>RpcBindingReset</b> function for binding handles on which calls are being executed.
     * 
     * When the client makes the next remote procedure call using the reset (partially-bound) binding, the client's RPC run-time library uses a well-known endpoint from the client's interface specification, if any. Otherwise, the client's run-time library automatically communicates with the endpoint-mapping service on the specified remote host to obtain the endpoint of a compatible server from the endpoint-map database. If a compatible server is located, the RPC run-time library updates the binding with a new endpoint. If a compatible server is not found, the remote procedure call fails. For calls using a connection protocol (ncacn), the EPT_S_NOT_REGISTERED status code is returned to the client. For calls using a datagram protocol (ncadg), the RPC_S_COMM_FAILURE status code is returned to the client.
     * 
     * Server applications should register all binding handles by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregisternoreplace">RpcEpRegisterNoReplace</a> if the server wants to be available to clients that make a remote procedure call on a reset binding handle.
     * @param {Pointer<Void>} Binding Server binding handle to reset.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingreset
     * @since windows5.0
     */
    static RpcBindingReset(Binding) {
        result := DllCall("RPCRT4.dll\RpcBindingReset", "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcBindingSetObject function sets the object UUID value in a binding handle.
     * @remarks
     * An application calls the 
     * <b>RpcBindingSetObject</b> function to associate an object 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> with a server binding handle. The set-object operation replaces the previously associated object UUID with the UUID in the <i>ObjectUuid</i> parameter.
     * 
     * To set the object 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> to the nil UUID, specify a null value or the nil UUID for the <i>ObjectUuid</i> parameter.
     * @param {Pointer<Void>} Binding Server binding into which the <i>ObjectUuid</i> is set.
     * @param {Pointer<Guid>} ObjectUuid Pointer to the 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> of the object serviced by the server specified in the <i>Binding</i> parameter. <i>ObjectUuid</i> is a unique identifier of an object to which a remote procedure call can be made.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetobject
     * @since windows5.0
     */
    static RpcBindingSetObject(Binding, ObjectUuid) {
        result := DllCall("RPCRT4.dll\RpcBindingSetObject", "ptr", Binding, "ptr", ObjectUuid, "int")
        return result
    }

    /**
     * The RpcMgmtInqDefaultProtectLevel function returns the default authentication level for an authentication service.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtInqDefaultProtectLevel</b> function to obtain the default authentication level for a specified authentication service.
     * @param {Integer} AuthnSvc Authentication service for which to return the default authentication level. Valid values are the constant for any valid security provider.
     * @param {Pointer<UInt32>} AuthnLevel Returns the default authentication level for the specified authentication service. The authentication level determines the degree to which authenticated communications between the client and server are protected. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication Level Constants</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_AUTH_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown authentication service.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtinqdefaultprotectlevel
     * @since windows5.0
     */
    static RpcMgmtInqDefaultProtectLevel(AuthnSvc, AuthnLevel) {
        result := DllCall("RPCRT4.dll\RpcMgmtInqDefaultProtectLevel", "uint", AuthnSvc, "uint*", AuthnLevel, "int")
        return result
    }

    /**
     * The RpcBindingToStringBinding function returns a string representation of a binding handle. (RpcBindingToStringBindingA)
     * @remarks
     * The 
     * <b>RpcBindingToStringBinding</b> function converts a client or server binding handle to its string representation.
     * 
     * The RPC run-time library allocates memory for the string returned in the <i>StringBinding</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function to deallocate that memory.
     * 
     * If the binding handle in the <i>Binding</i> parameter contained a nil object 
     * <a href="https://msdn.microsoft.com/">UUID</a>, the object UUID field is not included in the returned string.
     * 
     * To parse the returned <i>StringBinding</i> parameter, call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringbindingparse">RpcStringBindingParse</a> function.
     * 
     * <div class="alert"><b>Note</b>  To query a client's address, an application starts by calling the RpcBindingServerFromClient function to obtain a partially bound server binding handle.  The server binding handle can be used to obtain a string binding by invoking RpcBindingToStringBinding.  The server can then call RpcStringBindingParse to extract the client's network address from the string binding.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingToStringBinding as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Client or server binding handle to convert to a string representation of a binding handle.
     * @param {Pointer<Byte>} StringBinding Returns a pointer to a pointer to the string representation of the binding handle specified in the <i>Binding</i> parameter. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingToStringBinding</b> from returning the <i>StringBinding</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingtostringbindinga
     * @since windows5.0
     */
    static RpcBindingToStringBindingA(Binding, StringBinding) {
        result := DllCall("RPCRT4.dll\RpcBindingToStringBindingA", "ptr", Binding, "ptr", StringBinding, "int")
        return result
    }

    /**
     * The RpcBindingToStringBindingW (Unicode) function (rpcdce.h) returns a string representation of a binding handle.
     * @remarks
     * The 
     * <b>RpcBindingToStringBinding</b> function converts a client or server binding handle to its string representation.
     * 
     * The RPC run-time library allocates memory for the string returned in the <i>StringBinding</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function to deallocate that memory.
     * 
     * If the binding handle in the <i>Binding</i> parameter contained a nil object 
     * <a href="https://msdn.microsoft.com/">UUID</a>, the object UUID field is not included in the returned string.
     * 
     * To parse the returned <i>StringBinding</i> parameter, call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringbindingparse">RpcStringBindingParse</a> function.
     * 
     * <div class="alert"><b>Note</b>  To query a client's address, an application starts by calling the RpcBindingServerFromClient function to obtain a partially bound server binding handle.  The server binding handle can be used to obtain a string binding by invoking RpcBindingToStringBinding.  The server can then call RpcStringBindingParse to extract the client's network address from the string binding.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingToStringBinding as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Client or server binding handle to convert to a string representation of a binding handle.
     * @param {Pointer<Char>} StringBinding Returns a pointer to a pointer to the string representation of the binding handle specified in the <i>Binding</i> parameter. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingToStringBinding</b> from returning the <i>StringBinding</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingtostringbindingw
     * @since windows5.0
     */
    static RpcBindingToStringBindingW(Binding, StringBinding) {
        result := DllCall("RPCRT4.dll\RpcBindingToStringBindingW", "ptr", Binding, "ptr", StringBinding, "int")
        return result
    }

    /**
     * The RpcBindingVectorFree function frees the binding handles contained in the vector and the vector itself.
     * @remarks
     * An application calls the 
     * <b>RpcBindingVectorFree</b> function to release the memory used to store a vector of server binding handles. The function frees both the binding handles and the vector itself.
     * 
     * A server obtains a vector of binding handles by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function. A client obtains a vector of binding handles by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a> function.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Pointer to a pointer to a vector of server binding handles. On return, the pointer is set to <b>NULL</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingvectorfree
     * @since windows5.0
     */
    static RpcBindingVectorFree(BindingVector) {
        result := DllCall("RPCRT4.dll\RpcBindingVectorFree", "ptr", BindingVector, "int")
        return result
    }

    /**
     * The RpcStringBindingCompose function creates a string binding handle. (RpcStringBindingComposeA)
     * @remarks
     * An application calls 
     * <b>RpcStringBindingCompose</b> routine to combine an object UUID, a protocol sequence, a network address, an endpoint and other network options into a string representation of a binding handle.
     * 
     * The RPC run-time library allocates memory for the string returned in the <i>StringBinding</i> parameter. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> to deallocate that memory.
     * 
     * Specify a <b>null</b> parameter value or provide an empty string (\0) for each input string that has no data.
     * 
     * Literal backslash characters within C-language strings must be quoted. The actual C string for the server name for the <b>ncacn_np</b> protocol sequence appears as \\\\servername, and the actual C string for a pipe name appears as \\pipe\\pipename.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcStringBindingCompose as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} ObjUuid Pointer to a <b>null</b>-terminated string representation of an object 
     * <a href="https://msdn.microsoft.com/">UUID</a>. For example, the string 6B29FC40-CA47-1067-B31D-00DD010662DA represents a valid UUID.
     * @param {Pointer<Byte>} ProtSeq Pointer to a <b>null</b>-terminated string representation of a protocol sequence. See Note.
     * @param {Pointer<Byte>} NetworkAddr Pointer to a <b>null</b>-terminated string representation of a network address. The network-address format is associated with the protocol sequence. See Note.
     * @param {Pointer<Byte>} Endpoint Pointer to a <b>null</b>-terminated string representation of an endpoint. The endpoint format and content are associated with the protocol sequence. For example, the endpoint associated with the protocol sequence <b>ncacn_np</b> is a pipe name in the format \pipe\pipename. See Note.
     * @param {Pointer<Byte>} Options Pointer to a <b>null</b>-terminated string representation of network options. The option string is associated with the protocol sequence. See Note.
     * @param {Pointer<Byte>} StringBinding Returns a pointer to a pointer to a <b>null</b>-terminated string representation of a binding handle. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingCompose</b> from returning the <i>StringBinding</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>. See Note.
     * 
     * <div class="alert"><b>Note</b>  For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_UUID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string representation of the UUID is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcomposea
     * @since windows5.0
     */
    static RpcStringBindingComposeA(ObjUuid, ProtSeq, NetworkAddr, Endpoint, Options, StringBinding) {
        ObjUuid := ObjUuid is String? StrPtr(ObjUuid) : ObjUuid
        ProtSeq := ProtSeq is String? StrPtr(ProtSeq) : ProtSeq
        NetworkAddr := NetworkAddr is String? StrPtr(NetworkAddr) : NetworkAddr
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint
        Options := Options is String? StrPtr(Options) : Options

        result := DllCall("RPCRT4.dll\RpcStringBindingComposeA", "ptr", ObjUuid, "ptr", ProtSeq, "ptr", NetworkAddr, "ptr", Endpoint, "ptr", Options, "ptr", StringBinding, "int")
        return result
    }

    /**
     * The RpcStringBindingComposeW (Unicode) function (rpcdce.h) creates a string binding handle.
     * @remarks
     * An application calls 
     * <b>RpcStringBindingCompose</b> routine to combine an object UUID, a protocol sequence, a network address, an endpoint and other network options into a string representation of a binding handle.
     * 
     * The RPC run-time library allocates memory for the string returned in the <i>StringBinding</i> parameter. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> to deallocate that memory.
     * 
     * Specify a <b>null</b> parameter value or provide an empty string (\0) for each input string that has no data.
     * 
     * Literal backslash characters within C-language strings must be quoted. The actual C string for the server name for the <b>ncacn_np</b> protocol sequence appears as \\\\servername, and the actual C string for a pipe name appears as \\pipe\\pipename.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcStringBindingCompose as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} ObjUuid Pointer to a <b>null</b>-terminated string representation of an object 
     * <a href="https://msdn.microsoft.com/">UUID</a>. For example, the string 6B29FC40-CA47-1067-B31D-00DD010662DA represents a valid UUID.
     * @param {Pointer<Char>} ProtSeq Pointer to a <b>null</b>-terminated string representation of a protocol sequence. See Note.
     * @param {Pointer<Char>} NetworkAddr Pointer to a <b>null</b>-terminated string representation of a network address. The network-address format is associated with the protocol sequence. See Note.
     * @param {Pointer<Char>} Endpoint Pointer to a <b>null</b>-terminated string representation of an endpoint. The endpoint format and content are associated with the protocol sequence. For example, the endpoint associated with the protocol sequence <b>ncacn_np</b> is a pipe name in the format \pipe\pipename. See Note.
     * @param {Pointer<Char>} Options Pointer to a <b>null</b>-terminated string representation of network options. The option string is associated with the protocol sequence. See Note.
     * @param {Pointer<Char>} StringBinding Returns a pointer to a pointer to a <b>null</b>-terminated string representation of a binding handle. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingCompose</b> from returning the <i>StringBinding</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>. See Note.
     * 
     * <div class="alert"><b>Note</b>  For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_UUID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string representation of the UUID is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcomposew
     * @since windows5.0
     */
    static RpcStringBindingComposeW(ObjUuid, ProtSeq, NetworkAddr, Endpoint, Options, StringBinding) {
        ObjUuid := ObjUuid is String? StrPtr(ObjUuid) : ObjUuid
        ProtSeq := ProtSeq is String? StrPtr(ProtSeq) : ProtSeq
        NetworkAddr := NetworkAddr is String? StrPtr(NetworkAddr) : NetworkAddr
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint
        Options := Options is String? StrPtr(Options) : Options

        result := DllCall("RPCRT4.dll\RpcStringBindingComposeW", "ptr", ObjUuid, "ptr", ProtSeq, "ptr", NetworkAddr, "ptr", Endpoint, "ptr", Options, "ptr", StringBinding, "int")
        return result
    }

    /**
     * The RpcStringBindingParse function returns the object UUID part and the address parts of a string binding as separate strings. (RpcStringBindingParseA)
     * @remarks
     * An application calls 
     * <b>RpcStringBindingParse</b> routine to parse a string representation of a binding handle into its component fields.
     * 
     * The RPC run-time library allocates memory for each component string returned. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> once for each returned string to deallocate the memory for that string.
     * 
     * If any field of the <i>StringBinding</i> parameter is empty, 
     * <b>RpcStringBindingParse</b> returns an empty string (\0) in the corresponding output parameter.
     * 
     * <div class="alert"><b>Note</b>  To query a client's address, an application starts by calling the RpcBindingServerFromClient function to obtain a partially bound server binding handle.  The server binding handle can be used to obtain a string binding by invoking RpcBindingToStringBinding.  The server can then call RpcStringBindingParse to extract the client's network address from the string binding.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcStringBindingParse as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} StringBinding Pointer to a <b>null</b>-terminated string representation of a binding.
     * @param {Pointer<Byte>} ObjUuid Returns a pointer to a pointer to a <b>null</b>-terminated string representation of an object 
     * <a href="https://msdn.microsoft.com/">UUID</a>. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>ObjectUuid</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Byte>} Protseq Returns a pointer to a pointer to a <b>null</b>-terminated string representation of a protocol sequence. For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>ProtSeq</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Byte>} NetworkAddr Returns a pointer to a pointer to a <b>null</b>-terminated string representation of a network address. Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>NetworkAddr</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Byte>} Endpoint Returns a pointer to a pointer to a <b>null</b>-terminated string representation of an endpoint. Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>EndPoint</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Byte>} NetworkOptions Returns a pointer to a pointer to a <b>null</b>-terminated string representation of network options. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>NetworkOptions</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string binding is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingparsea
     * @since windows5.0
     */
    static RpcStringBindingParseA(StringBinding, ObjUuid, Protseq, NetworkAddr, Endpoint, NetworkOptions) {
        StringBinding := StringBinding is String? StrPtr(StringBinding) : StringBinding

        result := DllCall("RPCRT4.dll\RpcStringBindingParseA", "ptr", StringBinding, "ptr", ObjUuid, "ptr", Protseq, "ptr", NetworkAddr, "ptr", Endpoint, "ptr", NetworkOptions, "int")
        return result
    }

    /**
     * The RpcStringBindingParseW (Unicode) function (rpcdce.h) returns the object UUID part and the address parts of a string binding as separate strings.
     * @remarks
     * An application calls 
     * <b>RpcStringBindingParse</b> routine to parse a string representation of a binding handle into its component fields.
     * 
     * The RPC run-time library allocates memory for each component string returned. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> once for each returned string to deallocate the memory for that string.
     * 
     * If any field of the <i>StringBinding</i> parameter is empty, 
     * <b>RpcStringBindingParse</b> returns an empty string (\0) in the corresponding output parameter.
     * 
     * <div class="alert"><b>Note</b>  To query a client's address, an application starts by calling the RpcBindingServerFromClient function to obtain a partially bound server binding handle.  The server binding handle can be used to obtain a string binding by invoking RpcBindingToStringBinding.  The server can then call RpcStringBindingParse to extract the client's network address from the string binding.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcStringBindingParse as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} StringBinding Pointer to a <b>null</b>-terminated string representation of a binding.
     * @param {Pointer<Char>} ObjUuid Returns a pointer to a pointer to a <b>null</b>-terminated string representation of an object 
     * <a href="https://msdn.microsoft.com/">UUID</a>. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>ObjectUuid</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Char>} Protseq Returns a pointer to a pointer to a <b>null</b>-terminated string representation of a protocol sequence. For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>ProtSeq</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Char>} NetworkAddr Returns a pointer to a pointer to a <b>null</b>-terminated string representation of a network address. Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>NetworkAddr</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Char>} Endpoint Returns a pointer to a pointer to a <b>null</b>-terminated string representation of an endpoint. Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>EndPoint</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @param {Pointer<Char>} NetworkOptions Returns a pointer to a pointer to a <b>null</b>-terminated string representation of network options. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> value to prevent 
     * <b>RpcStringBindingParse</b> from returning the <i>NetworkOptions</i> parameter. In this case, the application does not call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string binding is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingparsew
     * @since windows5.0
     */
    static RpcStringBindingParseW(StringBinding, ObjUuid, Protseq, NetworkAddr, Endpoint, NetworkOptions) {
        StringBinding := StringBinding is String? StrPtr(StringBinding) : StringBinding

        result := DllCall("RPCRT4.dll\RpcStringBindingParseW", "ptr", StringBinding, "ptr", ObjUuid, "ptr", Protseq, "ptr", NetworkAddr, "ptr", Endpoint, "ptr", NetworkOptions, "int")
        return result
    }

    /**
     * The RpcStringFree function frees a character string allocated by the RPC run-time library. (RpcStringFreeA)
     * @remarks
     * An application is responsible for calling 
     * <b>RpcStringFree</b> once for each character string allocated and returned by calls to other RPC run-time library routines.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcStringFree as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} String Pointer to a pointer to the character string to free.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcstringfreea
     * @since windows5.0
     */
    static RpcStringFreeA(String) {
        result := DllCall("RPCRT4.dll\RpcStringFreeA", "ptr", String, "int")
        return result
    }

    /**
     * The RpcStringFreeW (Unicode) function (rpcdce.h) frees a character string allocated by the RPC run-time library.
     * @remarks
     * An application is responsible for calling 
     * <b>RpcStringFree</b> once for each character string allocated and returned by calls to other RPC run-time library routines.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcStringFree as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} String Pointer to a pointer to the character string to free.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcstringfreew
     * @since windows5.0
     */
    static RpcStringFreeW(String) {
        result := DllCall("RPCRT4.dll\RpcStringFreeW", "ptr", String, "int")
        return result
    }

    /**
     * The RpcIfInqId function returns the interface-identification part of an interface specification.
     * @remarks
     * An application calls the 
     * <b>RpcIfInqId</b> function to obtain a copy of the interface identification from the provided interface specification.
     * 
     * The returned interface identification consists of the interface UUID and interface version numbers (major and minor) specified in the <i>IfSpec</i> parameter from the IDL file.
     * @param {Pointer<Void>} RpcIfHandle Stub-generated structure specifying the interface to query.
     * @param {Pointer<RPC_IF_ID>} RpcIfId Returns a pointer to the interface identification. The application provides memory for the returned data.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcifinqid
     * @since windows5.0
     */
    static RpcIfInqId(RpcIfHandle, RpcIfId) {
        result := DllCall("RPCRT4.dll\RpcIfInqId", "ptr", RpcIfHandle, "ptr", RpcIfId, "int")
        return result
    }

    /**
     * The RpcNetworkIsProtseqValid function tells whether the specified protocol sequence is supported by both the RPC run-time library and the operating system. Server applications often use RpcNetworkInqProtseqs. (RpcNetworkIsProtseqValidA)
     * @remarks
     * An application calls the 
     * <b>RpcNetworkIsProtseqValid</b> function to determine whether an individual protocol sequence is available for making remote procedure calls.
     * 
     * A protocol sequence is valid if both the RPC run-time library and the operating system support the specified protocols. For a list of Microsoft RPC's supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>. An application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcnetworkinqprotseqs">RpcNetworkInqProtseqs</a> to see all of the supported protocol sequences.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcNetworkIsProtseqValid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} Protseq Pointer to a string identifier of the protocol sequence to be checked. 
     * 
     * 
     * 
     * 
     * If the <i>Protseq</i> parameter is not a valid protocol sequence string, 
     * <b>RpcNetworkIsProtseqValid</b> returns RPC_S_INVALID_RPC_PROTSEQ.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.; protocol sequence supported
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Protocol sequence not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid protocol sequence.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcnetworkisprotseqvalida
     * @since windows5.0
     */
    static RpcNetworkIsProtseqValidA(Protseq) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcNetworkIsProtseqValidA", "ptr", Protseq, "int")
        return result
    }

    /**
     * The RpcNetworkIsProtseqValidW (Unicode) function (rpcdce.h) tells if the RPC run-time library and the operating system support the specified protocol sequence.
     * @remarks
     * An application calls the 
     * <b>RpcNetworkIsProtseqValid</b> function to determine whether an individual protocol sequence is available for making remote procedure calls.
     * 
     * A protocol sequence is valid if both the RPC run-time library and the operating system support the specified protocols. For a list of Microsoft RPC's supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>. An application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcnetworkinqprotseqs">RpcNetworkInqProtseqs</a> to see all of the supported protocol sequences.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcNetworkIsProtseqValid as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} Protseq Pointer to a string identifier of the protocol sequence to be checked. 
     * 
     * 
     * 
     * 
     * If the <i>Protseq</i> parameter is not a valid protocol sequence string, 
     * <b>RpcNetworkIsProtseqValid</b> returns RPC_S_INVALID_RPC_PROTSEQ.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.; protocol sequence supported
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Protocol sequence not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid protocol sequence.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcnetworkisprotseqvalidw
     * @since windows5.0
     */
    static RpcNetworkIsProtseqValidW(Protseq) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcNetworkIsProtseqValidW", "ptr", Protseq, "int")
        return result
    }

    /**
     * The RpcMgmtInqComTimeout function returns the binding-communications time-out value in a binding handle.
     * @remarks
     * A client application calls 
     * <b>RpcMgmtInqComTimeout</b> to view the time-out value in a server binding handle. The time-out value specifies the relative amount of time that should be spent to wait for a response from the server before giving up. For a table of the time-out values, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/binding-time-out-constants">Binding Time-out Constants</a>. For more information on how the COM time-out operates, and when to use it, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-and-the-network">RPC and the Network</a>.
     * 
     * A client also calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout">RpcMgmtSetComTimeout</a> to change the time-out value.
     * @param {Pointer<Void>} Binding Specifies a binding.
     * @param {Pointer<UInt32>} Timeout Returns a pointer to the time-out value from the <i>Binding</i> parameter.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtinqcomtimeout
     * @since windows5.0
     */
    static RpcMgmtInqComTimeout(Binding, Timeout) {
        result := DllCall("RPCRT4.dll\RpcMgmtInqComTimeout", "ptr", Binding, "uint*", Timeout, "int")
        return result
    }

    /**
     * The RpcMgmtSetComTimeout function sets the binding-communications time-out value in a binding handle.
     * @remarks
     * In Windows XP and Windows 2000, during bind the RPC run time uses the shorter of a 15-minute call time-out, and the time-out set using the 
     * <b>RpcMgmtSetComTimeout</b> function. In exchanges subsequent to binding, the RPC run time uses only the time-out set in using the 
     * <b>RpcMgmtSetComTimeout</b> function. This option is ignored for <b>ncalrpc</b> and <b>ncadg_*</b> protocol sequences.
     * 
     * A client application calls 
     * <b>RpcMgmtSetComTimeout</b> to change the communications time-out value for a server binding handle. Depending on the protocol sequence for the specified binding handle, the time-out value acts only as a hint to the RPC run-time library. Each protocol sequence interprets this setting differently; for <b>ncacn_ip_tcp</b>, the value is used to turn on keep-alives for all calls. For example, for <b>ncacn_ip_tcp</b>, setting <i>Timeout</i> to zero instructs RPC to turn on keep-alives if a response isn't received in 60 seconds (the 60 second interval is implementation-specific and subject to change). In this situation, the client call is not timed out as long as the server us running; however, if the server fails or loses its IP address, RPC fails the call. The TCP time-out hint is used during connection establishment, as well as during request/reply exchanges.
     * 
     * <div class="alert"><b>Note</b>  Using the TCP time-out hint is the best practice for detecting failed servers.<p class="note">In Windows XP, keep-alives for a given connection are turned off when the server responds.
     * 
     * </div>
     * <div> </div>
     * For convenience, constants are provided for certain values in the time-out range. For a list of the RPC-defined values that an application can use for the time-out argument, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/binding-time-out-constants">Binding Time-out Constants</a>.
     * @param {Pointer<Void>} Binding Server binding handle whose time-out value is set.
     * @param {Integer} Timeout Communications time-out value, from zero to 10. These values are not seconds; they represent a relative amount of time on a scale of zero to 10.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_TIMEOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The time-out value was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout
     * @since windows5.0
     */
    static RpcMgmtSetComTimeout(Binding, Timeout) {
        result := DllCall("RPCRT4.dll\RpcMgmtSetComTimeout", "ptr", Binding, "uint", Timeout, "int")
        return result
    }

    /**
     * The RpcMgmtSetCancelTimeout function sets the lower bound on the time to wait before timing out after forwarding a cancel.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtSetCancelTimeout</b> function to reset the amount of time the run-time library waits for a server to acknowledge a cancel. The application specifies either to wait forever or to wait a specified length of time in seconds. If the value of <i>Seconds</i> is 0 (zero), the call is immediately abandoned upon a cancel command and control returns to the client application. The default value is RPC_C_CANCEL_INFINITE_TIMEOUT, which specifies waiting indefinitely for the call to complete.
     * 
     * The value for the cancel command time-out applies to all remote procedure calls made in the current thread. To change the time-out value, a multithreaded client must call this function in each thread of execution.
     * @param {Integer} Timeout Seconds to wait for a server to acknowledge a cancel command. To specify that a client waits an indefinite amount of time, supply the value RPC_C_CANCEL_INFINITE_TIMEOUT.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Called from an MS-DOS or Windows 3.<i>x</i> client.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtsetcanceltimeout
     * @since windows5.0
     */
    static RpcMgmtSetCancelTimeout(Timeout) {
        result := DllCall("RPCRT4.dll\RpcMgmtSetCancelTimeout", "int", Timeout, "int")
        return result
    }

    /**
     * The RpcNetworkInqProtseqs function returns all protocol sequences supported by both the RPC run-time library and the operating system. (RpcNetworkInqProtseqsA)
     * @remarks
     * A server application calls the 
     * <b>RpcNetworkInqProtseqs</b> function to obtain a vector containing the protocol sequences supported by both the RPC run-time library and the operating system. If there are no supported protocol sequences, this function returns the RPC_S_NO_PROTSEQS status code and a <i>ProtSeqVector</i> parameter value of <b>NULL</b>.
     * 
     * The server is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcprotseqvectorfree">RpcProtseqVectorFree</a> function to release the memory used by the vector.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcNetworkInqProtseqs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_PROTSEQ_VECTORA>} ProtseqVector Returns a pointer to a pointer to a protocol sequence vector.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_PROTSEQS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No supported protocol sequences.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcnetworkinqprotseqsa
     * @since windows5.0
     */
    static RpcNetworkInqProtseqsA(ProtseqVector) {
        result := DllCall("RPCRT4.dll\RpcNetworkInqProtseqsA", "ptr", ProtseqVector, "int")
        return result
    }

    /**
     * The RpcNetworkInqProtseqsW (Unicode) function (rpcdce.h) returns all protocol sequences supported by both the RPC run-time library and the operating system.
     * @remarks
     * A server application calls the 
     * <b>RpcNetworkInqProtseqs</b> function to obtain a vector containing the protocol sequences supported by both the RPC run-time library and the operating system. If there are no supported protocol sequences, this function returns the RPC_S_NO_PROTSEQS status code and a <i>ProtSeqVector</i> parameter value of <b>NULL</b>.
     * 
     * The server is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcprotseqvectorfree">RpcProtseqVectorFree</a> function to release the memory used by the vector.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcNetworkInqProtseqs as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_PROTSEQ_VECTORW>} ProtseqVector Returns a pointer to a pointer to a protocol sequence vector.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_PROTSEQS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No supported protocol sequences.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcnetworkinqprotseqsw
     * @since windows5.0
     */
    static RpcNetworkInqProtseqsW(ProtseqVector) {
        result := DllCall("RPCRT4.dll\RpcNetworkInqProtseqsW", "ptr", ProtseqVector, "int")
        return result
    }

    /**
     * The RpcObjectInqType function returns the type of an object.
     * @remarks
     * A server application calls 
     * <b>RpcObjectInqType</b> to obtain the type UUID of an object. If the object was registered with the RPC run-time library using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsettype">RpcObjectSetType</a> function, the registered type is returned.
     * 
     * Optionally, an application can privately maintain an object/type registration. In this case, if the application has provided an object inquiry function (see under 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsetinqfn">RpcObjectSetInqFn</a>). The RPC run-time library uses that function to determine an object's type.
     * 
     * The 
     * <b>RpcObjectInqType</b> function obtains the type UUID as described in the following table.
     * 
     * <table>
     * <tr>
     * <th>Object UUID<div> </div>registered</th>
     * <th>Inquiry function<div> </div>registered</th>
     * <th>Return<div> </div>value</th>
     * </tr>
     * <tr>
     * <td>Yes (
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsettype">RpcObjectSetType</a>)</td>
     * <td>Ignored</td>
     * <td>The object's registered type UUID.</td>
     * </tr>
     * <tr>
     * <td>No</td>
     * <td>Yes (
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsetinqfn">RpcObjectSetInqFn</a>)</td>
     * <td>The type UUID returned from the inquiry function.</td>
     * </tr>
     * <tr>
     * <td>No</td>
     * <td>No</td>
     * <td>The nil UUID.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * <div> </div>
     * @param {Pointer<Guid>} ObjUuid Pointer to the object UUID whose associated type UUID is returned.
     * @param {Pointer<Guid>} TypeUuid Returns a pointer to the type UUID of the <i>ObjUuid</i> parameter. 
     * 
     * 
     * 
     * 
     * Specify a parameter value of <b>NULL</b> to prevent the return of a type UUID. In this way, an application can determine (from the returned status) whether <i>ObjUuid</i> is registered without specifying an output type UUID variable.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OBJECT_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Object not found.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcobjectinqtype
     * @since windows5.0
     */
    static RpcObjectInqType(ObjUuid, TypeUuid) {
        result := DllCall("RPCRT4.dll\RpcObjectInqType", "ptr", ObjUuid, "ptr", TypeUuid, "int")
        return result
    }

    /**
     * The RpcObjectSetInqFn function registers an object-inquiry function. A null value turns off a previously registered object-inquiry function.
     * @remarks
     * A server application calls 
     * <b>RpcObjectSetInqFn</b> to override the default mapping function that maps object UUIDs to type UUIDs, which determine an object's type. If an application privately maintains an object/type registration, the specified inquiry function returns the type UUID of an object.
     * 
     * The RPC run-time library automatically calls the inquiry function when the application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectinqtype">RpcObjectInqType</a> and the object of interest was not previously registered with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsettype">RpcObjectSetType</a>. The <i>TypeUuid</i> and <i>Status</i> values of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_object_inq_fn">RPC_OBJECT_INQ_FN</a> function are returned as the output from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectinqtype">RpcObjectInqType</a>.
     * @param {Pointer<RPC_OBJECT_INQ_FN>} InquiryFn Object-type inquiry function. See 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_object_inq_fn">RPC_OBJECT_INQ_FN</a>. When an application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectinqtype">RpcObjectInqType</a> and the RPC run-time library finds that the specified object is not registered, the run-time library automatically calls 
     * <b>RpcObjectSetInqFn</b> to determine the object's type.
     * @returns {Integer} This function returns the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcobjectsetinqfn
     * @since windows5.0
     */
    static RpcObjectSetInqFn(InquiryFn) {
        result := DllCall("RPCRT4.dll\RpcObjectSetInqFn", "ptr", InquiryFn, "int")
        return result
    }

    /**
     * The RpcObjectSetType function assigns the type of an object.
     * @remarks
     * A server application calls 
     * <b>RpcObjectSetType</b> to assign a type UUID to an object UUID. By default, the RPC run-time library automatically assigns all object UUIDs with the nil-type UUID. A server application that contains one implementation of an interface (one manager entry-point vector [EPV]) does not need to call 
     * <b>RpcObjectSetType</b> provided that the server registered the interface with the nil-type UUID (see under 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a>).
     * 
     * A server application that contains multiple implementations of an interface (multiple manager EPVs—that is, multiple type UUIDs) calls 
     * <b>RpcObjectSetType</b> once for each different object UUID/non-nil type UUID association the server supports. Associating each object with a type UUID tells the RPC run-time library which manager EPV (interface implementation) to use when the server receives a remote procedure call for a non-nil object UUID.
     * 
     * The RPC run-time library allows an application to set the type for an unlimited number of objects. To remove the association between an object UUID and its type UUID (established by calling 
     * <b>RpcObjectSetType</b>), a server calls 
     * <b>RpcObjectSetType</b> again, specifying a null value or a nil UUID for the <i>TypeUuid</i> parameter. This resets the object UUID/type UUID association to the default association of object UUID/nil-type UUID. A server cannot assign a type to the nil object UUID. The RPC run-time library automatically assigns the nil object UUID a nil-type UUID.
     * 
     * For detailed information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/registering-interfaces">Registering Interfaces</a>.
     * @param {Pointer<Guid>} ObjUuid Pointer to an object UUID to associate with the type UUID in the <i>TypeUuid</i> parameter.
     * @param {Pointer<Guid>} TypeUuid Pointer to the type UUID of the <i>ObjUuid</i> parameter. 
     * 
     * 
     * 
     * 
     * Specify a parameter value of NULL or a nil UUID to reset the object type to the default association of object UUID/nil-type UUID.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_OBJECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ALREADY_REGISTERED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The object is already registered.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcobjectsettype
     * @since windows5.0
     */
    static RpcObjectSetType(ObjUuid, TypeUuid) {
        result := DllCall("RPCRT4.dll\RpcObjectSetType", "ptr", ObjUuid, "ptr", TypeUuid, "int")
        return result
    }

    /**
     * The RpcProtseqVectorFree function frees the protocol sequences contained in the vector and the vector itself. (RpcProtseqVectorFreeA)
     * @remarks
     * A server calls 
     * <b>RpcProtseqVectorFree</b> to release the memory used to store a vector of protocol sequences and the individual protocol sequences. 
     * <b>RpcProtseqVectorFree</b> sets the <i>ProtSeqVector</i> parameter to a null value.
     * 
     * For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * A server obtains a vector of protocol sequences by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcnetworkinqprotseqs">RpcNetworkInqProtseqs</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>RpcProtseqVectorFree</b> is available for server and client applications using Microsoft RPC, but is more common and convenient for server applications.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcProtseqVectorFree as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_PROTSEQ_VECTORA>} ProtseqVector Pointer to a pointer to a vector of protocol sequences. On return, the pointer is set to NULL.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcprotseqvectorfreea
     * @since windows5.0
     */
    static RpcProtseqVectorFreeA(ProtseqVector) {
        result := DllCall("RPCRT4.dll\RpcProtseqVectorFreeA", "ptr", ProtseqVector, "int")
        return result
    }

    /**
     * The RpcProtseqVectorFreeW (Unicode) function (rpcdce.h) frees the protocol sequences contained in the vector and the vector itself.
     * @remarks
     * A server calls 
     * <b>RpcProtseqVectorFree</b> to release the memory used to store a vector of protocol sequences and the individual protocol sequences. 
     * <b>RpcProtseqVectorFree</b> sets the <i>ProtSeqVector</i> parameter to a null value.
     * 
     * For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * A server obtains a vector of protocol sequences by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcnetworkinqprotseqs">RpcNetworkInqProtseqs</a>.
     * 
     * <div class="alert"><b>Note</b>  <b>RpcProtseqVectorFree</b> is available for server and client applications using Microsoft RPC, but is more common and convenient for server applications.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcProtseqVectorFree as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_PROTSEQ_VECTORW>} ProtseqVector Pointer to a pointer to a vector of protocol sequences. On return, the pointer is set to NULL.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcprotseqvectorfreew
     * @since windows5.0
     */
    static RpcProtseqVectorFreeW(ProtseqVector) {
        result := DllCall("RPCRT4.dll\RpcProtseqVectorFreeW", "ptr", ProtseqVector, "int")
        return result
    }

    /**
     * The RpcServerInqBindings function returns the binding handles over which remote procedure calls can be received.
     * @remarks
     * A server application calls 
     * <b>RpcServerInqBindings</b> to obtain a vector of server binding handles. The RPC run-time library creates binding handles when a server application calls the following functions to register protocol sequences:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsex">RpcServerUseAllProtseqsEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex">RpcServerUseAllProtseqsIfEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqex">RpcServerUseProtseqEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqepex">RpcServerUseProtseqEpEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqifex">RpcServerUseProtseqIfEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>
     * </li>
     * </ul>
     * The returned binding vector can contain binding handles with dynamic endpoints or binding handles with well-known endpoints, depending on which of the above functions the server application called.
     * 
     * A server uses the vector of binding handles for exporting to the name service, for registering with the local endpoint-map database, or for conversion to string bindings. If there are no binding handles (no registered protocol sequences), this routine returns the RPC_S_NO_BINDINGS status code and a <i>BindingVector</i> parameter value of NULL. The server is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingvectorfree">RpcBindingVectorFree</a> function to release the memory used by the vector.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Returns a pointer to a pointer to a vector of server binding handles.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no bindings.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinqbindings
     * @since windows5.0
     */
    static RpcServerInqBindings(BindingVector) {
        result := DllCall("RPCRT4.dll\RpcServerInqBindings", "ptr", BindingVector, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} SecurityDescriptor 
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector 
     * @returns {Integer} 
     */
    static RpcServerInqBindingsEx(SecurityDescriptor, BindingVector) {
        result := DllCall("RPCRT4.dll\RpcServerInqBindingsEx", "ptr", SecurityDescriptor, "ptr", BindingVector, "int")
        return result
    }

    /**
     * The RpcServerInqIf function returns the manager entry-point vector (EPV) registered for an interface.
     * @remarks
     * A server application calls the 
     * <b>RpcServerInqIf</b> function to determine the manager EPV for a registered interface and manager type UUID.
     * @param {Pointer<Void>} IfSpec Interface whose manager EPV is returned.
     * @param {Pointer<Guid>} MgrTypeUuid Pointer to the manager type UUID whose manager EPV is returned. 
     * 
     * 
     * 
     * 
     * Specifying a parameter value of <b>NULL</b> (or a nil UUID) signifies to return the manager EPV registered with <i>IfSpec</i> and the nil manager type UUID.
     * @param {Pointer<Void>} MgrEpv Returns a pointer to the manager EPV for the requested interface.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_IF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_MGR_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The manager type is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinqif
     * @since windows5.0
     */
    static RpcServerInqIf(IfSpec, MgrTypeUuid, MgrEpv) {
        result := DllCall("RPCRT4.dll\RpcServerInqIf", "ptr", IfSpec, "ptr", MgrTypeUuid, "ptr", MgrEpv, "int")
        return result
    }

    /**
     * The RpcServerListen function signals the RPC run-time library to listen for remote procedure calls. This function will not affect auto-listen interfaces; use RpcServerRegisterIfEx if you need that functionality.
     * @remarks
     * A server calls 
     * <b>RpcServerListen</b> when the server is ready to process remote procedure calls. RPC allows a server to simultaneously process multiple calls. The <i>MaxCalls</i> parameter recommends the maximum number of concurrent remote procedure calls the server should execute.
     * 
     * The <i>MaxCalls</i> value should not be zero, and should be larger than <i>MinimumCallThreads</i>. Values larger than 0x7FFFFFFF are set to 0x7FFFFFFF without notice.
     * 
     * <b>Windows XP/2000:  </b>Setting the <i>MaxCalls</i> parameter to RPC_C_LISTEN_MAX_CALLS_DEFAULT removes the limit on concurrent remote procedure calls, rather than setting it to the constant-defined value of 1234. Removing the limit on maximum concurrent calls allows as many concurrent remote procedure calls as the computer can handle. This behavior enables increased efficiency in the RPC run time.
     * 
     * A server application is responsible for concurrency control between the server manager routines because each routine executes in a separate thread.
     * 
     * When the <i>DontWait</i> parameter has a value of zero, the RPC run-time library continues listening for remote procedure calls (that is, the routine does not return to the server application) until one of the following events occurs:
     * 
     * <ul>
     * <li>One of the server application's manager routines calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a>.</li>
     * <li>A client calls a remote procedure provided by the server that directs the server to call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a>.</li>
     * <li>A client calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a> with a binding handle to the server.</li>
     * </ul>
     * After it receives a stop-listening request, the RPC run-time library stops accepting new remote procedure calls for all registered interfaces. Executing calls are allowed to complete, including callbacks. After all calls complete, 
     * <b>RpcServerListen</b> returns to the caller.
     * 
     * When the <i>DontWait</i> parameter has a nonzero value, 
     * <b>RpcServerListen</b> returns to the server immediately after processing all the instructions associated with the function. You can use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtwaitserverlisten">RpcMgmtWaitServerListen</a> function to perform the wait operation usually associated with 
     * <b>RpcServerListen</b>.
     * 
     * <div class="alert"><b>Note</b>  The Microsoft RPC implementation of 
     * <b>RpcServerListen</b> includes two additional parameters that do not appear in the DCE specification: <i>DontWait</i> and <i>MinimumCallThreads</i>.</div>
     * <div> </div>
     * @param {Integer} MinimumCallThreads Hint to the RPC run time that specifies the minimum number of call threads that should be created and maintained in the given server. This value is only a hint and is interpreted differently in different versions of Windows. In Windows XP, this value is the number of previously created threads in each thread pool that the RPC run time creates. An application should specify one for this parameter, and defer thread creation decisions to the RPC run time.
     * @param {Integer} MaxCalls Recommended maximum number of concurrent remote procedure calls the server can execute. To allow efficient performance, the RPC run-time libraries interpret the <i>MaxCalls</i> parameter as a suggested limit rather than as an absolute upper bound. 
     * 
     * 
     * 
     * 
     * Use RPC_C_LISTEN_MAX_CALLS_DEFAULT to specify the default value.
     * @param {Integer} DontWait Flag controlling the return from 
     * <b>RpcServerListen</b>. A value of nonzero indicates that 
     * <b>RpcServerListen</b> should return immediately after completing function processing. A value of zero indicates that 
     * <b>RpcServerListen</b> should not return until the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a> function has been called and all remote calls have completed.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ALREADY_LISTENING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The server is already listening.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_PROTSEQS_REGISTERED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no protocol sequences registered.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_MAX_CALLS_TOO_SMALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The maximum calls value is too small.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverlisten
     * @since windows5.0
     */
    static RpcServerListen(MinimumCallThreads, MaxCalls, DontWait) {
        result := DllCall("RPCRT4.dll\RpcServerListen", "uint", MinimumCallThreads, "uint", MaxCalls, "uint", DontWait, "int")
        return result
    }

    /**
     * The RpcServerRegisterIf function registers an interface with the RPC run-time library.
     * @remarks
     * A server can register an unlimited number of interfaces with the RPC run-time library. Registration makes an interface available to clients using a binding handle to the server. To register an interface, the server application code calls 
     * <b>RpcServerRegisterIf</b>. For each implementation of an interface that a server offers, it must register a separate manager EPV.
     * 
     * When calling 
     * <b>RpcServerRegisterIf</b>, the server provides the following information:
     * 
     * <ul>
     * <li>Interface specification 
     * 
     * 
     * The interface specification is a data structure that the MIDL compiler generates. The server specifies the interface using the <i>IfSpec</i> parameter.
     * 
     * </li>
     * <li>Manager type UUID and manager EPV 
     * 
     * 
     * The manager type UUID and the manager EPV determine which manager routine executes when a server receives a remote procedure call request from a client.
     * 
     * The server specifies the manager type UUID and EPV using the <i>MgrTypeUuid</i> and <i>MgrEpv</i> parameters. Note that when specifying a non-nil manager-type UUID, the server must also call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsettype">RpcObjectSetType</a> function to register objects of this non-nil type.
     * 
     * </li>
     * </ul>
     * If your server application needs to register an auto-listen interface or use a callback function for authentication purposes, use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterifex">RpcServerRegisterIfEx</a>.
     * @param {Pointer<Void>} IfSpec MIDL-generated structure indicating the interface to register.
     * @param {Pointer<Guid>} MgrTypeUuid Pointer to a type UUID to associate with the <i>MgrEpv</i> parameter. Specifying a null parameter value (or a nil UUID) registers <i>IfSpec</i> with a nil-type UUID.
     * @param {Pointer<Void>} MgrEpv Manager routines' entry-point vector (EPV). To use the MIDL-generated default EPV, specify a null value. For more information, please see <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-mgr-epv">RPC_MGR_EPV</a>.
     * @returns {Integer} Returns RPC_S_OK upon success.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif
     * @since windows5.0
     */
    static RpcServerRegisterIf(IfSpec, MgrTypeUuid, MgrEpv) {
        result := DllCall("RPCRT4.dll\RpcServerRegisterIf", "ptr", IfSpec, "ptr", MgrTypeUuid, "ptr", MgrEpv, "int")
        return result
    }

    /**
     * The RpcServerRegisterIfEx function registers an interface with the RPC run-time library.
     * @remarks
     * The parameters and effects of 
     * <b>RpcServerRegisterIfEx</b> subsume those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a>. The difference is the ability to register an auto-listen interface and to specify a security-callback function.
     * 
     * The server application code calls 
     * <b>RpcServerRegisterIfEx</b> to register an interface. To register an interface, the server provides the following information:
     * 
     * <ul>
     * <li>Interface specification 
     * 
     * 
     * The interface specification is a data structure that the MIDL compiler generates.
     * 
     * </li>
     * <li>Manager type UUID and manager EPV 
     * 
     * 
     * The manager type UUID and the manager EPV determine which manager routine executes when a server receives a remote procedure call request from a client. For each implementation of an interface offered by a server, it must register a separate manager EPV.
     * 
     * Note that when specifying a non-nil, manager type UUID, the server must also call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsettype">RpcObjectSetType</a> to register objects of this non-nil type.
     * 
     * </li>
     * </ul>
     * Specifying the RPC_IF_AUTOLISTEN flags marks the interface as an auto-listen interface. The run time begins listening for calls as soon as the interface is registered, and stops listening when the interface is unregistered. A call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverunregisterif">RpcServerUnregisterIf</a> for this interface will wait for the completion of all pending calls on this interface. Calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a> will not affect the interface, nor will a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverunregisterif">RpcServerUnregisterIf</a> with <i>IfSpec</i> == <b>NULL</b>. This allows a DLL to register RPC interfaces or remove them from the registry without changing the main application's RPC state.
     * 
     * Specifying a security-callback function allows the server application to restrict access to its interfaces on a per-client basis. Remember that, by default, security is optional; the server run time will dispatch unsecured calls even if the server has called 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a>. If the server wants to accept only authenticated clients, an interface callback function must call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthclient">RpcBindingInqAuthClient</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcgetauthorizationcontextforclient">RpcGetAuthorizationContextForClient</a> function to retrieve the security level, or attempt to impersonate the client with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcimpersonateclient">RpcImpersonateClient</a>. It can also specify the RPC_IF_ALLOW_SECURE_ONLY flag in the interface flags.
     * 
     * When a server application specifies a security-callback function for its interface(s), the RPC run time automatically rejects unauthenticated calls to that interface. In addition, the run-time records the interfaces that each client has used. When a client makes an RPC to an interface that it has not used during the current communication session, the RPC run-time library will call the interface's security-callback function. Specifying RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH flag will prevent the automatic rejection of unauthenticated clients.
     * 
     * For the signature for the callback function, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_if_callback_fn">RPC_IF_CALLBACK_FN</a>.
     * 
     * The callback function should return RPC_S_OK if the client is allowed to call methods in this interface. Any other return code will cause the client to receive the exception RPC_S_ACCESS_DENIED.
     * 
     * In some cases, the RPC run time may call the security-callback function more than once per client–per interface. Be sure your callback function can handle this possibility.
     * @param {Pointer<Void>} IfSpec MIDL-generated structure indicating the interface to register.
     * @param {Pointer<Guid>} MgrTypeUuid Pointer to a type UUID to associate with the <i>MgrEpv</i> parameter. Specifying a <b>null</b> parameter value (or a nil UUID) registers <i>IfSpec</i> with a nil-type UUID.
     * @param {Pointer<Void>} MgrEpv Manager routines' entry-point vector (EPV). To use the MIDL-generated default EPV, specify a <b>null</b> value. For more information, please see <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-mgr-epv">RPC_MGR_EPV</a>.
     * @param {Integer} Flags Flags. For a list of flag values, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/interface-registration-flags">Interface Registration Flags</a>.
     * @param {Integer} MaxCalls Maximum number of concurrent remote procedure call requests the server can accept on an auto-listen interface. The <i>MaxCalls</i> parameters is only applicable on an auto-listen interface, and is ignored on interfaces that are not auto-listen. The RPC run-time library makes its best effort to ensure the server does not allow more concurrent call requests than the number of calls specified in <i>MaxCalls</i>. The actual number can be greater and can vary for each protocol sequence. 
     * 
     * 
     * 
     * 
     * Calls on other interfaces are governed by the value of the process-wide <i>MaxCalls</i> parameter specified in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> function call.
     * 
     * If the number of concurrent calls is not a concern, you can achieve slightly better server-side performance by specifying the default value using RPC_C_LISTEN_MAX_CALLS_DEFAULT. Doing so relieves the RPC run-time environment from enforcing an unnecessary restriction.
     * @param {Pointer<RPC_IF_CALLBACK_FN>} IfCallback Security-callback function, or <b>NULL</b> for no callback. Each registered interface can have a different callback function. See Remarks for more details.
     * @returns {Integer} Returns RPC_S_OK upon success.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterifex
     * @since windows5.1.2600
     */
    static RpcServerRegisterIfEx(IfSpec, MgrTypeUuid, MgrEpv, Flags, MaxCalls, IfCallback) {
        result := DllCall("RPCRT4.dll\RpcServerRegisterIfEx", "ptr", IfSpec, "ptr", MgrTypeUuid, "ptr", MgrEpv, "uint", Flags, "uint", MaxCalls, "ptr", IfCallback, "int")
        return result
    }

    /**
     * The RpcServerRegisterIf2 function registers an interface with the RPC run-time library.
     * @remarks
     * The parameters and effects of the 
     * <b>RpcServerRegisterIf2</b> function extend those of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a> function. The difference is the ability to register an <b>auto-listen</b> interface and to specify a security-callback function.
     * 
     * The server application code calls 
     * <b>RpcServerRegisterIf2</b> to register an interface. To register an interface, the server provides the following information:
     * 
     * <ul>
     * <li>Interface specification 
     * 
     * 
     * The interface specification is a data structure that the MIDL compiler generates.
     * 
     * </li>
     * <li>Manager type <b>UUID</b> and manager EPV 
     * 
     * 
     * The manager type <b>UUID</b> and the manager EPV determine which manager routine executes when a server receives a remote procedure call request from a client. For each implementation of an interface offered by a server, it must register a separate manager EPV.
     * 
     * Note that when specifying a non-nil, manager type <b>UUID</b>, the server must also call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcobjectsettype">RpcObjectSetType</a> to register objects of this non-nil type.
     * 
     * </li>
     * </ul>
     * Specifying the RPC_IF_AUTOLISTEN flags marks the interface as an <b>auto-listen</b> interface. The run time begins listening for calls as soon as the interface is registered, and stops listening when the interface is unregistered. A call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverunregisterif">RpcServerUnregisterIf</a> for this interface waits for the completion of all pending calls on this interface. Calls to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> and the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a> functions do not affect the interface, nor does a call to the 
     * <b>RpcServerUnregisterIf</b> function with <i>IfSpec</i> set to the value <b>NULL</b>. This allows a DLL to register RPC interfaces or remove them from the registry without changing the main application's RPC state.
     * 
     * Specifying a security-callback function allows the server application to restrict access to its interfaces on an individual client basis. That is, by default, security is optional; the server run-time will dispatch unsecured calls even if the server has called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. If the server wants to accept only authenticated clients, an interface callback function must call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthclient">RpcBindingInqAuthClient</a>, <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcgetauthorizationcontextforclient">RpcGetAuthorizationContextForClient</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcserverinqcallattributesa">RpcServerInqCallAttributes</a> function to retrieve the security level, or attempt to impersonate the client with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcimpersonateclient">RpcImpersonateClient</a> function. It can also specify the RPC_IF_ALLOW_SECURE_ONLY flag in the interface flags to reject unauthenticated calls.
     * 
     * When a server application specifies a security-callback function for its interface(s), the RPC run time automatically rejects calls without authentication information to that interface. In addition, the run-time records the interfaces  each client has used. When a client makes an RPC to an interface that it has not used during the current communication session, the RPC run-time library  calls the interface's security-callback function. Specifying RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH flag will prevent the automatic rejection of unauthenticated clients. Note that calls on the so-called <b>NULL</b> security session can have authentication information, even though they come from anonymous clients. Thus the existence of a callback alone is not sufficient to prevent anonymous clients from connecting. Either the security callback function must check for that, or the RPC_IF_ALLOW_SECURE_ONLY flag must be used. RPC_IF_ALLOW_SECURE_ONLY rejects <b>null</b> session calls only on Windows XP and later versions of Windows.
     * 
     * For the signature for the callback function, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_if_callback_fn">RPC_IF_CALLBACK_FN</a>.
     * 
     * The callback function should return RPC_S_OK, if the client is allowed to call methods in this interface. Any other return code will cause the client to receive the exception RPC_S_ACCESS_DENIED.
     * 
     * In some cases, the RPC run time may call the security-callback function more than once per client, per interface. Be sure your callback function can handle this possibility.
     * @param {Pointer<Void>} IfSpec MIDL-generated structure indicating the interface to register.
     * @param {Pointer<Guid>} MgrTypeUuid Pointer to a type <b>UUID</b> to associate with the <i>MgrEpv</i> parameter. Specifying a <b>null</b> parameter value (or a nil <b>UUID</b>) registers <i>IfSpec</i> with a nil-type <b>UUID</b>.
     * @param {Pointer<Void>} MgrEpv Manager routines' entry-point vector (EPV). To use the MIDL-generated default EPV, specify a <b>null</b> value. For more information, please see <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-mgr-epv">RPC_MGR_EPV</a>.
     * @param {Integer} Flags Flags. For a list of flag values, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/interface-registration-flags">Interface Registration Flags</a>.
     * @param {Integer} MaxCalls Maximum number of concurrent remote procedure call requests the server can accept on an <b>auto-listen</b> interface. The <i>MaxCalls</i> parameter is only applicable on an <b>auto-listen</b> interface, and is ignored on interfaces that are not <b>auto-listen</b>. The RPC run-time library makes its best effort to ensure the server does not allow more concurrent call requests than the number of calls specified in <i>MaxCalls</i>. The actual number can be greater and can vary for each protocol sequence. 
     * 
     * 
     * 
     * 
     * Calls on other interfaces are governed by the value of the process-wide <i>MaxCalls</i> parameter specified in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> function call.
     * 
     * If the number of concurrent calls is not a concern, you can achieve slightly better server-side performance by specifying the default value using RPC_C_LISTEN_MAX_CALLS_DEFAULT. Doing so relieves the RPC run-time environment from enforcing an unnecessary restriction.
     * @param {Integer} MaxRpcSize Maximum size of incoming data blocks, in bytes. This parameter may be used to help prevent malicious denial-of-service attacks. If the data block of a remote procedure call is larger than <i>MaxRpcSize</i>, the RPC run-time library rejects the call and sends an RPC_S_ACCESS_DENIED error to the client. Specifying a value of (unsigned int) –1 for this parameter removes the limit on the size of incoming data blocks. This parameter has no effect on calls made over the <a href="https://docs.microsoft.com/windows/desktop/Midl/ncalrpc">ncalrpc</a> protocol.
     * @param {Pointer<RPC_IF_CALLBACK_FN>} IfCallbackFn Security-callback function, or <b>NULL</b> for no callback. Each registered interface can have a different callback function. See Remarks.
     * @returns {Integer} Returns RPC_S_OK upon success.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif2
     * @since windows5.0
     */
    static RpcServerRegisterIf2(IfSpec, MgrTypeUuid, MgrEpv, Flags, MaxCalls, MaxRpcSize, IfCallbackFn) {
        result := DllCall("RPCRT4.dll\RpcServerRegisterIf2", "ptr", IfSpec, "ptr", MgrTypeUuid, "ptr", MgrEpv, "uint", Flags, "uint", MaxCalls, "uint", MaxRpcSize, "ptr", IfCallbackFn, "int")
        return result
    }

    /**
     * The RpcServerRegisterIf3 function registers an interface with the RPC run-time library.
     * @remarks
     * The parameters and effects of the 
     * <b>RpcServerRegisterIf3</b> function extend those of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif2">RpcServerRegisterIf2</a> function. The difference is the ability to specify a security descriptor for controlling access to the registered RPC interface.
     * 
     * If both <i>SecurityDescriptor</i> and <i>IfCallbackFn</i> are specified, the security descriptor in <i>SecurityDescriptor</i> will be checked first and the callback in <i>IfCallbackFn</i> will be called after the access check against the security descriptor passes.
     * 
     * When calling <b>RpcServerRegisterIf3</b> with <i>SecurityDescriptor</i> set to <b>NULL</b>, or calling <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a>, <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif2">RpcServerRegisterIf2</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterifex">RpcServerRegisterIfEx</a> to register an interface, a default security descriptor will be used. The default security descriptor will not allow access from any AppContainer process to the interface if the RPC server is not an AppContainer process. The default security descriptor will not allow access from any process in other AppContainer processes to the interface if the RPC server is an AppContainer process. The default security descriptor will allow access from normal processes including Low integrity processes.
     * @param {Pointer<Void>} IfSpec MIDL-generated  structure indicating the interface to register.
     * @param {Pointer<Guid>} MgrTypeUuid Pointer to a type <b>UUID</b> to associate with the <i>MgrEpv</i> parameter. Specifying a <b>null</b> parameter value (or a nil <b>UUID</b>) registers <i>IfSpec</i> with a nil-type <b>UUID</b>.
     * @param {Pointer<Void>} MgrEpv Manager routines' entry-point vector (EPV). To use the MIDL-generated default EPV, specify a <b>null</b> value. For more information, please see <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-mgr-epv">RPC_MGR_EPV</a>.
     * @param {Integer} Flags Flags. For a list of flag values, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/interface-registration-flags">Interface Registration Flags</a>.
     * @param {Integer} MaxCalls Maximum number of concurrent remote procedure call requests the server can accept on an <b>auto-listen</b> interface. The <i>MaxCalls</i> parameter is only applicable on an <b>auto-listen</b> interface, and is ignored on interfaces that are not <b>auto-listen</b>. The RPC run-time library makes its best effort to ensure the server does not allow more concurrent call requests than the number of calls specified in <i>MaxCalls</i>. The actual number can be greater and can vary for each protocol sequence. 
     * 
     * 
     * 
     * 
     * Calls on other interfaces are governed by the value of the process-wide <i>MaxCalls</i> parameter specified in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> function call.
     * 
     * If the number of concurrent calls is not a concern, you can achieve slightly better server-side performance by specifying the default value using RPC_C_LISTEN_MAX_CALLS_DEFAULT. Doing so relieves the RPC run-time environment from enforcing an unnecessary restriction.
     * @param {Integer} MaxRpcSize Maximum size of incoming data blocks, in bytes. This parameter may be used to help prevent malicious denial-of-service attacks. If the data block of a remote procedure call is larger than <i>MaxRpcSize</i>, the RPC run-time library rejects the call and sends an RPC_S_ACCESS_DENIED error to the client. Specifying a value of (unsigned int) –1 for this parameter removes the limit on the size of incoming data blocks. This parameter has no effect on calls made over the <a href="https://docs.microsoft.com/windows/desktop/Midl/ncalrpc">ncalrpc</a> protocol.
     * @param {Pointer<RPC_IF_CALLBACK_FN>} IfCallback Security-callback function, or <b>NULL</b> for no callback. Each registered interface can have a different callback function. See the Remarks on <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif2">RpcServerRegisterIf2</a>.
     * @param {Pointer<Void>} SecurityDescriptor Security descriptor for accessing the RPC interface. Each registered interface can have a different security descriptor.
     * @returns {Integer} Returns RPC_S_OK upon success.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif3
     * @since windows8.0
     */
    static RpcServerRegisterIf3(IfSpec, MgrTypeUuid, MgrEpv, Flags, MaxCalls, MaxRpcSize, IfCallback, SecurityDescriptor) {
        result := DllCall("RPCRT4.dll\RpcServerRegisterIf3", "ptr", IfSpec, "ptr", MgrTypeUuid, "ptr", MgrEpv, "uint", Flags, "uint", MaxCalls, "uint", MaxRpcSize, "ptr", IfCallback, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUnregisterIf function removes an interface from the RPC run-time library registry.
     * @remarks
     * A server calls 
     * <b>RpcServerUnregisterIf</b> to remove the association between an interface and a manager EPV. To specify the manager EPV to remove in the <i>MgrTypeUuid</i> parameter, provide the type UUID value that was specified in a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a>. After it is removed from the registry, an interface is no longer available to client applications.
     * 
     * When an interface is removed from the registry, the RPC run-time library stops accepting new calls for that interface. Calls that are currently executing on the interface are allowed to complete, including callbacks.
     * 
     * The following table summarizes the behavior of 
     * <b>RpcServerUnregisterIf</b>.
     * 
     * <table>
     * <tr>
     * <th>IfSpec</th>
     * <th>MgrTypeUuid</th>
     * <th>Behavior</th>
     * </tr>
     * <tr>
     * <td>Non-<b>null</b></td>
     * <td>Non-<b>null</b></td>
     * <td>Removes from the registry the manager EPV associated with the specified parameters.</td>
     * </tr>
     * <tr>
     * <td>Non-<b>null</b></td>
     * <td><b>NULL</b></td>
     * <td>Removes all manager EPVs associated with the <i>IfSpec</i> parameter.</td>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td>Non-<b>null</b></td>
     * <td>Removes all manager EPVs associated with the <i>MgrTypeUuid</i> parameter.</td>
     * </tr>
     * <tr>
     * <td><b>NULL</b></td>
     * <td><b>NULL</b></td>
     * <td>Removes all manager EPVs. This call has the effect of preventing the server from receiving any new remote procedure calls because all the manager EPVs for all interfaces have been unregistered.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * <div> </div>
     * 
     * 
     * <div class="alert"><b>Note</b>  If the value of <i>IfSpec</i> is <b>NULL</b>, this function will leave <i>auto-listen</i> interfaces registered. <i>Auto-listen</i> interfaces must be removed from the registry individually. See 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterifex">RpcServerRegisterIfEx</a> for more details.</div>
     * <div> </div>
     * @param {Pointer<Void>} IfSpec Interface to remove from the registry. 
     * 
     * 
     * 
     * 
     * Specify a <b>null</b> value to remove all interfaces previously registered with the type UUID value specified in the <i>MgrTypeUuid</i> parameter.
     * @param {Pointer<Guid>} MgrTypeUuid Pointer to the type UUID of the manager entry-point vector (EPV) to remove from the registry. The value of <i>MgrTypeUuid</i> should be the same value as was provided in a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a> function, <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif2">RpcServerRegisterIf2</a> function, or the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterifex">RpcServerRegisterIfEx</a> function. 
     * 
     * 
     * 
     * 
     * Specify a <b>null</b> value to remove the interface specified in the <i>IfSpec</i> parameter for all previously registered type UUIDs from the registry.
     * 
     * Specify a nil UUID to remove the MIDL-generated default manager EPV from the registry. In this case, all manager EPVs registered with a non-nil type UUID remain registered.
     * @param {Integer} WaitForCallsToComplete Flag that indicates whether to remove the interface from the registry immediately or to wait until all current calls are complete. 
     * 
     * 
     * 
     * 
     * Specify a value of zero to disregard calls in progress and remove the interface from the registry immediately. Specify any nonzero value to wait until all active calls complete.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_MGR_TYPE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The manager type is unknown.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_IF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverunregisterif
     * @since windows5.0
     */
    static RpcServerUnregisterIf(IfSpec, MgrTypeUuid, WaitForCallsToComplete) {
        result := DllCall("RPCRT4.dll\RpcServerUnregisterIf", "ptr", IfSpec, "ptr", MgrTypeUuid, "uint", WaitForCallsToComplete, "int")
        return result
    }

    /**
     * The RpcServerUnregisterIfEx function removes an interface from the RPC run-time library registry. This function extends the functionality of the RpcServerUnregisterIf function.
     * @remarks
     * The 
     * <b>RpcServerUnregisterIfEx</b> function waits for all calls on a given interface to complete before unregistering the context handles.
     * 
     * The 
     * <b>RpcServerUnregisterIfEx</b> function supplies all the functionality provided in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverunregisterif">RpcServerUnregisterIf</a> function. In addition, the 
     * <b>RpcServerUnregisterIfEx</b> function unregisters all context handles registered by the given interface. The interface must use the <b>strict_context_handle</b> attribute, otherwise the results are undefined.
     * 
     * <b>RpcServerUnregisterIfEx</b> is the only function that provides safe unloading of a DLL with active context handles outside of process shutdown. It is available on Windows XP and later versions of Windows only.
     * @param {Pointer<Void>} IfSpec Interface to remove from the registry. 
     * 
     * 
     * 
     * 
     * Specify a null value to remove all interfaces previously registered with the type UUID value specified in the <i>MgrTypeUuid</i> parameter.
     * @param {Pointer<Guid>} MgrTypeUuid Pointer to the type UUID of the manager entry-point vector (EPV) to remove from the registry. The value of <i>MgrTypeUuid</i> should be the same value as was provided in a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif">RpcServerRegisterIf</a> function, <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterif2">RpcServerRegisterIf2</a> function, or the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterifex">RpcServerRegisterIfEx</a> function. 
     * 
     * 
     * 
     * 
     * Specify a null value to remove the interface specified in the <i>IfSpec</i> parameter for all previously registered type UUIDs from the registry.
     * 
     * Specify a nil UUID to remove the MIDL-generated default manager EPV from the registry. In this case, all manager EPVs registered with a non-nil type UUID remain registered.
     * @param {Integer} RundownContextHandles Specifies whether rundown is called for active context handles. If non-zero, the rundown is called once all calls on the interface have completed. If set to zero, the RPC run time assumes the server has already destroyed its portion of the context handle and it will not call the rundown routines.
     * @returns {Integer} Returns RPC status. 
     * <b>RpcServerUnregisterIfEx</b> does not fail unless supplied with invalid values.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverunregisterifex
     * @since windows5.1.2600
     */
    static RpcServerUnregisterIfEx(IfSpec, MgrTypeUuid, RundownContextHandles) {
        result := DllCall("RPCRT4.dll\RpcServerUnregisterIfEx", "ptr", IfSpec, "ptr", MgrTypeUuid, "int", RundownContextHandles, "int")
        return result
    }

    /**
     * The RpcServerUseAllProtseqs function tells the RPC run-time library to use all supported protocol sequences for receiving remote procedure calls.
     * @remarks
     * <div class="alert"><b>Note</b>  Listening on all supported protocol sequences is not recommended, because it causes the server to listen on all protocol sequences, including non-mainstream protocol sequences.  It is recommended that servers listen on <a href="https://docs.microsoft.com/windows/desktop/Rpc/use-mainstream-protocol-sequences">mainstream</a> protocol sequences only.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseAllProtseqs</b> to register all supported protocol sequences with the RPC run-time library. To receive remote procedure calls, a server must register at least one protocol sequence with the RPC run-time library. For a list of Microsoft RPC supported protocol sequences, see the reference topic 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. The endpoint name is generated by the RPC run time or the operating system. For example, for <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a>, the port number is dynamically determined by the RPC run time, depending on availability and registry settings.
     * 
     * <div class="alert"><b>Note</b>  Using the 
     * <b>RpcServerUseAllProtseqs</b> function does not cause the server to listen on the following protocol sequences:<ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-nb">ncacn_nb_nb</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-tcp">ncacn_nb_tcp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-ipx">ncacn_nb_ipx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-mq">ncadg_mq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-at-dsp">ncacn_at_dsp</a>
     * </li>
     * <li>
     * <a href="https://msdn.microsoft.com/">ncacn_http</a>
     * </li>
     * </ul>
     * </div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  To listen on any of those protocol sequences, each sequence must be selected individually.</div>
     * <div> </div>
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. To selectively register protocol sequences, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>.
     * @param {Integer} MaxCalls Backlog queue length for the <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-np">ncacn_np</a> and <a href="https://docs.microsoft.com/windows/desktop/Midl/ncalrpc">ncalrpc</a> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_PROTSEQS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no supported protocol sequences.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory is not available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs
     * @since windows5.0
     */
    static RpcServerUseAllProtseqs(MaxCalls, SecurityDescriptor) {
        result := DllCall("RPCRT4.dll\RpcServerUseAllProtseqs", "uint", MaxCalls, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseAllProtseqsEx function tells the RPC run-time library to use all supported protocol sequences for receiving remote procedure calls.
     * @remarks
     * <div class="alert"><b>Note</b>  Listening on all supported protocol sequences is not recommended, because it causes the server to listen on all protocol sequences, including non-mainstream protocol sequences.  It is recommended that servers listen on <a href="https://docs.microsoft.com/windows/desktop/Rpc/use-mainstream-protocol-sequences">mainstream</a> protocol sequences only.</div>
     * <div> </div>
     * The parameters and effects of 
     * <b>RpcServerUseAllProtseqsEx</b> subsume those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>. The difference is the <i>Policy</i> parameter, which allows you to restrict port allocation for dynamic ports and allows multihomed machines to selectively bind to specified NICs.
     * 
     * Setting the <b>NICFlags</b> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to zero makes this extended API functionally equivalent to the original 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>, and the server will bind to NICs based on the settings in the system registry. For information on how the registry settings define the available Internet and intranet ports, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>.
     * 
     * <div class="alert"><b>Note</b>  The flag settings in the <i>Policy</i> field are effective only when the 
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a> or
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-ip-udp">ncadg_ip_udp</a> protocol sequence is in use. For all other protocol sequences, the RPC run-time ignores these values.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseAllProtseqsEx</b> to register all supported protocol sequences with the RPC run-time library. To receive remote procedure calls, a server must register at least one protocol sequence with the RPC run-time library.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. The endpoint name is generated by the RPC run time or the operating system. For example, for <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a>, the port number is dynamically determined by the RPC run time, depending on availability and registry settings.
     * 
     * <div class="alert"><b>Note</b>  Using the 
     * <b>RpcServerUseAllProtseqsEx</b> function does not cause the server to listen on the following protocol sequences:<ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-nb">ncacn_nb_nb</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-tcp">ncacn_nb_tcp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-ipx">ncacn_nb_ipx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-mq">ncadg_mq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-at-dsp">ncacn_at_dsp</a>
     * </li>
     * <li>
     * <a href="https://msdn.microsoft.com/">ncacn_http</a>
     * </li>
     * </ul>
     * </div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  To listen on any of those protocol sequences, each sequence must be selected individually.</div>
     * <div> </div>
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function.
     * 
     * 
     * 
     * To selectively register protocol sequences, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqex">RpcServerUseProtseqEx</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqifex">RpcServerUseProtseqIfEx</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqepex">RpcServerUseProtseqEpEx</a>. See 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a> for a description of the routines that a server will typically call after registering protocol sequences.
     * @param {Integer} MaxCalls Backlog queue length for the <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-np">ncacn_np</a> and <a href="https://docs.microsoft.com/windows/desktop/Midl/ncalrpc">ncalrpc</a> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which allows you to override the default policies for dynamic port allocation and binding to network interface cards (NICs) on multihomed computers (computers with multiple network cards).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_PROTSEQS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no supported protocol sequences.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory is not available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsex
     * @since windows5.0
     */
    static RpcServerUseAllProtseqsEx(MaxCalls, SecurityDescriptor, Policy) {
        result := DllCall("RPCRT4.dll\RpcServerUseAllProtseqsEx", "uint", MaxCalls, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * The RpcServerUseAllProtseqsIf function tells the RPC run-time library to use all specified protocol sequences and endpoints in the interface specification for receiving remote procedure calls.
     * @remarks
     * <div class="alert"><b>Note</b>  Listening on all supported protocol sequences is not recommended, because it causes the server to listen on all protocol sequences, including non-mainstream protocol sequences.  It is recommended that servers listen on <a href="https://docs.microsoft.com/windows/desktop/Rpc/use-mainstream-protocol-sequences">mainstream</a> protocol sequences only.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseAllProtseqsIf</b> to register with the RPC run-time library all protocol sequences and associated endpoint address information provided in the IDL file. For a list of RPC-supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence.
     * 
     * <div class="alert"><b>Note</b>  Using the 
     * <b>RpcServerUseAllProtseqsIf</b> function does not cause the server to listen on the following protocol sequences:<ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-nb">ncacn_nb_nb</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-tcp">ncacn_nb_tcp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-ipx">ncacn_nb_ipx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-mq">ncadg_mq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-at-dsp">ncacn_at_dsp</a>
     * </li>
     * <li>
     * <a href="https://msdn.microsoft.com/">ncacn_http</a>
     * </li>
     * </ul>
     * </div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  To listen on any of those protocol sequences, each sequence must be selected individually.</div>
     * <div> </div>
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. To register selected protocol sequences specified in the IDL file, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>.
     * @param {Integer} MaxCalls Backlog queue length for the <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} IfSpec Interface containing the protocol sequences and corresponding endpoint information to use in creating binding handles.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-np">ncacn_np</a> and <a href="https://docs.microsoft.com/windows/desktop/Midl/ncalrpc">ncalrpc</a> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_PROTSEQS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no supported protocol sequences.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_DUPLICATE_ENDPOINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint is a duplicate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * RPC protocol sequence invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif
     * @since windows5.0
     */
    static RpcServerUseAllProtseqsIf(MaxCalls, IfSpec, SecurityDescriptor) {
        result := DllCall("RPCRT4.dll\RpcServerUseAllProtseqsIf", "uint", MaxCalls, "ptr", IfSpec, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseAllProtseqsIfEx function tells the RPC run-time library to use all the specified protocol sequences and endpoints in the interface specification for receiving remote procedure calls.
     * @remarks
     * <div class="alert"><b>Note</b>  Listening on all supported protocol sequences is not recommended, because it causes the server to listen on all protocol sequences, including non-mainstream protocol sequences.  It is recommended that servers listen on <a href="https://docs.microsoft.com/windows/desktop/Rpc/use-mainstream-protocol-sequences">mainstream</a> protocol sequences only.</div>
     * <div> </div>
     * The parameters and effects of 
     * <b>RpcServerUseAllProtseqsIfEx</b> subsume those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>. The difference is the <i>Policy</i> field, which allows you to restrict port allocation for dynamic ports and allows multihomed machines to selectively bind to network interface cards.
     * 
     * Setting the <i>NICFlags</i> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to zero makes this extended function functionally equivalent to the original <b>RpcServerUseAllProtseqsIfEx</b>, and the server will bind to NICs based on the settings in the system registry. For information on how the registry settings define the available Internet and intranet ports, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>.
     * 
     * <div class="alert"><b>Note</b>  The flag settings in the <i>Policy</i> field are effective only when the <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a> or <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-ip-udp">ncadg_ip_udp</a> protocol sequence is in use. For all other protocol sequences, the RPC run time ignores these values.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseAllProtseqsIfEx</b> to register with the RPC run-time library all protocol sequences and associated endpoint address information provided in the IDL file.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence.
     * 
     * <div class="alert"><b>Note</b>  Using the 
     * <b>RpcServerUseAllProtseqsIfEx</b> function does not cause the server to listen on the following protocol sequences:<ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-nb">ncacn_nb_nb</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-tcp">ncacn_nb_tcp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-nb-ipx">ncacn_nb_ipx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-mq">ncadg_mq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-at-dsp">ncacn_at_dsp</a>
     * </li>
     * <li>
     * <a href="https://msdn.microsoft.com/">ncacn_http</a>
     * </li>
     * </ul>
     * </div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  To listen on any of those protocol sequences, each sequence must be selected individually.</div>
     * <div> </div>
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function.
     * 
     * 
     * 
     * To register selected protocol sequences specified in the IDL file, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqifex">RpcServerUseProtseqIfEx</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>.
     * @param {Integer} MaxCalls Backlog queue length for the <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} IfSpec Interface containing the protocol sequences and corresponding endpoint information to use in creating binding handles.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-np">ncacn_np</a> and <a href="https://docs.microsoft.com/windows/desktop/Midl/ncalrpc">ncalrpc</a> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which contains flags to restrict port allocation for dynamic ports and allow multihomed computers to selectively bind to network interface cards.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_PROTSEQS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no supported protocol sequences.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_DUPLICATE_ENDPOINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint is a duplicate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The RPC protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex
     * @since windows5.1.2600
     */
    static RpcServerUseAllProtseqsIfEx(MaxCalls, IfSpec, SecurityDescriptor, Policy) {
        result := DllCall("RPCRT4.dll\RpcServerUseAllProtseqsIfEx", "uint", MaxCalls, "ptr", IfSpec, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * The RpcServerUseProtseq function tells the RPC run-time library to use the specified protocol sequence for receiving remote procedure calls. (RpcServerUseProtseqA)
     * @remarks
     * A server application calls 
     * <b>RpcServerUseProtseq</b> to register one protocol sequence with the RPC run-time library. To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call 
     * <b>RpcServerUseProtseq</b> multiple times to register additional protocol sequences. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. The endpoint name is generated by the RPC run time or the operating system. For example, for <b>ncacn_ip_tcp</b>, the port number is dynamically determined by the RPC run time, depending on availability and registry settings.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. To register all protocol sequences, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseq as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqa
     * @since windows5.0
     */
    static RpcServerUseProtseqA(Protseq, MaxCalls, SecurityDescriptor) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqA", "ptr", Protseq, "uint", MaxCalls, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqEx function tells the RPC run-time library to use the specified protocol sequence for receiving remote procedure calls. (RpcServerUseProtseqExA)
     * @remarks
     * The parameters and effects of 
     * <b>RpcServerUseProtseqEx</b> subsume those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>. The difference is the <b>Policy</b> field, which allows you to restrict port allocation for dynamic ports and allows multihomed machines to selectively bind to network interface cards.
     * 
     * Setting the <b>NICFlags</b> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to zero makes this extended function functionally equivalent to the original 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>, and the server will bind to NICs based on the settings in the system registry. For information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>.
     * 
     * <div class="alert"><b>Note</b>  The flag settings in the <b>Policy</b> field are effective only when the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> protocol sequence is in use. For all other protocol sequences, the RPC run time ignores these values.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseProtseqEx</b> to register one protocol sequence with the RPC run-time library. To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call 
     * <b>RpcServerUseProtseqEx</b> multiple times to register additional protocol sequences.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. The endpoint name is generated by the RPC run time or the operating system. For example, for <b>ncacn_ip_tcp</b>, the port number is dynamically determined by the RPC run time, depending on availability and registry settings.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * To register all protocol sequences, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsex">RpcServerUseAllProtseqsEx</a> routine.
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the Windows XP/2000/NT security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which contains flags to restrict port allocation for dynamic ports and allow multihomed computers to selectively bind to network interface cards. The 
     * <b>RPC_POLICY</b> structure enables the caller to direct the RPC run-time library to use an intranet port or an Internet port, among other options.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqexa
     * @since windows5.0
     */
    static RpcServerUseProtseqExA(Protseq, MaxCalls, SecurityDescriptor, Policy) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqExA", "ptr", Protseq, "uint", MaxCalls, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqW (Unicode) function (rpcdce.h) tells the RPC run-time library to use the specified protocol sequence for receiving remote procedure calls.
     * @remarks
     * A server application calls 
     * <b>RpcServerUseProtseq</b> to register one protocol sequence with the RPC run-time library. To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call 
     * <b>RpcServerUseProtseq</b> multiple times to register additional protocol sequences. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. The endpoint name is generated by the RPC run time or the operating system. For example, for <b>ncacn_ip_tcp</b>, the port number is dynamically determined by the RPC run time, depending on availability and registry settings.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. To register all protocol sequences, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseq as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqw
     * @since windows5.0
     */
    static RpcServerUseProtseqW(Protseq, MaxCalls, SecurityDescriptor) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqW", "ptr", Protseq, "uint", MaxCalls, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqExW (Unicode) function (rpcdce.h) tells the RPC run-time library to use the specified protocol sequence for receiving remote procedure calls.
     * @remarks
     * The parameters and effects of 
     * <b>RpcServerUseProtseqEx</b> subsume those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>. The difference is the <b>Policy</b> field, which allows you to restrict port allocation for dynamic ports and allows multihomed machines to selectively bind to network interface cards.
     * 
     * Setting the <b>NICFlags</b> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to zero makes this extended function functionally equivalent to the original 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>, and the server will bind to NICs based on the settings in the system registry. For information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>.
     * 
     * <div class="alert"><b>Note</b>  The flag settings in the <b>Policy</b> field are effective only when the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> protocol sequence is in use. For all other protocol sequences, the RPC run time ignores these values.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseProtseqEx</b> to register one protocol sequence with the RPC run-time library. To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call 
     * <b>RpcServerUseProtseqEx</b> multiple times to register additional protocol sequences.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. The endpoint name is generated by the RPC run time or the operating system. For example, for <b>ncacn_ip_tcp</b>, the port number is dynamically determined by the RPC run time, depending on availability and registry settings.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * To register all protocol sequences, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsex">RpcServerUseAllProtseqsEx</a> routine.
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the Windows XP/2000/NT security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which contains flags to restrict port allocation for dynamic ports and allow multihomed computers to selectively bind to network interface cards. The 
     * <b>RPC_POLICY</b> structure enables the caller to direct the RPC run-time library to use an intranet port or an Internet port, among other options.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqexw
     * @since windows5.0
     */
    static RpcServerUseProtseqExW(Protseq, MaxCalls, SecurityDescriptor, Policy) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqExW", "ptr", Protseq, "uint", MaxCalls, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqEp function tells the RPC run-time library to use the specified protocol sequence combined with the specified endpoint for receiving remote procedure calls. (RpcServerUseProtseqEpA)
     * @remarks
     * A server application calls 
     * <b>RpcServerUseProtseqEp</b> to register one protocol sequence with the RPC run-time library. With each protocol sequence registration, 
     * <b>RpcServerUseProtseqEp</b> includes the specified endpoint-address information.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this routine multiple times to register additional protocol sequences and endpoints. For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqEp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Byte>} Endpoint Pointer to the endpoint-address information to use in creating a binding for the protocol sequence specified in the <i>Protseq</i> parameter.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_DUPLICATE_ENDPOINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint is a duplicate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqepa
     * @since windows5.0
     */
    static RpcServerUseProtseqEpA(Protseq, MaxCalls, Endpoint, SecurityDescriptor) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqEpA", "ptr", Protseq, "uint", MaxCalls, "ptr", Endpoint, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqEpEx function tells the RPC run-time library to use the specified protocol sequence combined with the specified endpoint for receiving remote procedure calls. (RpcServerUseProtseqEpExA)
     * @remarks
     * The parameters and effects of 
     * <b>RpcServerUseProtseqEpEx</b> subsume those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>. The difference is the <i>Policy</i> parameter, which allows you to set specific policies at the endpoints. Setting the <b>NICFlags</b> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to zero makes this extended function equivalent to the original 
     * <b>RpcServerUseProtseqEp</b> when used with the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> transports.
     * 
     * A server application calls 
     * <b>RpcServerUseProtseqEpEx</b> to register one protocol sequence with the RPC run-time library. With each protocol sequence registration, 
     * <b>RpcServerUseProtseqEpEx</b> includes the specified endpoint-address information.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this routine many times to register additional protocol sequences and endpoints. For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-message-queuing">RPC Message Queuing</a> and the MIDL reference pages 
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/message">message</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-mq">ncadg_mq</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqEpEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Byte>} Endpoint Pointer to the endpoint-address information to use in creating a binding for the protocol sequence specified by <i>Protseq</i>.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <i>ncalrpc</i> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which contains flags that set transport-specific attributes. In the case of the <b>ncadg_mq</b> transport, these flags specify the properties of the server process–receive queue. In the case of the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> transports, these flags restrict port allocation for dynamic ports and allow multihomed computers to selectively bind to network interface cards. 
     * 
     * 
     * 
     * 
     * The flag settings in the <b>Policy</b> field are effective only when the <b>ncacn_ip_tcp</b>, <b>ncadg_ip_udp</b>, or <b>ncadg_mq</b> protocol sequences are in use. For all other protocol sequences, the RPC run time ignores these values.
     * 
     * <div class="alert"><b>Note</b>  Portions of the policy associated with dynamic endpoints are ignored when the RpcServerUseProtseqEpEx function is called, since the port is specified in the endpoint itself.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_DUPLICATE_ENDPOINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint is a duplicate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqepexa
     * @since windows5.0
     */
    static RpcServerUseProtseqEpExA(Protseq, MaxCalls, Endpoint, SecurityDescriptor, Policy) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqEpExA", "ptr", Protseq, "uint", MaxCalls, "ptr", Endpoint, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqEpW (Unicode) function (rpcdce.h) tells the RPC run-time library to use the specified protocol sequence and endpoint for receiving remote procedure calls.
     * @remarks
     * A server application calls 
     * <b>RpcServerUseProtseqEp</b> to register one protocol sequence with the RPC run-time library. With each protocol sequence registration, 
     * <b>RpcServerUseProtseqEp</b> includes the specified endpoint-address information.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this routine multiple times to register additional protocol sequences and endpoints. For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqEp as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Char>} Endpoint Pointer to the endpoint-address information to use in creating a binding for the protocol sequence specified in the <i>Protseq</i> parameter.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_DUPLICATE_ENDPOINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint is a duplicate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqepw
     * @since windows5.0
     */
    static RpcServerUseProtseqEpW(Protseq, MaxCalls, Endpoint, SecurityDescriptor) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqEpW", "ptr", Protseq, "uint", MaxCalls, "ptr", Endpoint, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqEpExW (Unicode) function (rpcdce.h) tells the RPC run-time library to use the specified protocol sequence and endpoint for receiving remote procedure calls.
     * @remarks
     * The parameters and effects of 
     * <b>RpcServerUseProtseqEpEx</b> subsume those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>. The difference is the <i>Policy</i> parameter, which allows you to set specific policies at the endpoints. Setting the <b>NICFlags</b> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to zero makes this extended function equivalent to the original 
     * <b>RpcServerUseProtseqEp</b> when used with the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> transports.
     * 
     * A server application calls 
     * <b>RpcServerUseProtseqEpEx</b> to register one protocol sequence with the RPC run-time library. With each protocol sequence registration, 
     * <b>RpcServerUseProtseqEpEx</b> includes the specified endpoint-address information.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this routine many times to register additional protocol sequences and endpoints. For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-message-queuing">RPC Message Queuing</a> and the MIDL reference pages 
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/message">message</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-mq">ncadg_mq</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqEpEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Char>} Endpoint Pointer to the endpoint-address information to use in creating a binding for the protocol sequence specified by <i>Protseq</i>.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <i>ncalrpc</i> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which contains flags that set transport-specific attributes. In the case of the <b>ncadg_mq</b> transport, these flags specify the properties of the server process–receive queue. In the case of the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> transports, these flags restrict port allocation for dynamic ports and allow multihomed computers to selectively bind to network interface cards. 
     * 
     * 
     * 
     * 
     * The flag settings in the <b>Policy</b> field are effective only when the <b>ncacn_ip_tcp</b>, <b>ncadg_ip_udp</b>, or <b>ncadg_mq</b> protocol sequences are in use. For all other protocol sequences, the RPC run time ignores these values.
     * 
     * <div class="alert"><b>Note</b>  Portions of the policy associated with dynamic endpoints are ignored when the RpcServerUseProtseqEpEx function is called, since the port is specified in the endpoint itself.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_DUPLICATE_ENDPOINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint is a duplicate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqepexw
     * @since windows5.0
     */
    static RpcServerUseProtseqEpExW(Protseq, MaxCalls, Endpoint, SecurityDescriptor, Policy) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqEpExW", "ptr", Protseq, "uint", MaxCalls, "ptr", Endpoint, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqIf function tells the RPC run-time library to use the specified protocol sequence combined with the endpoints in the interface specification for receiving remote procedure calls. (RpcServerUseProtseqIfA)
     * @remarks
     * A server application calls 
     * <b>RpcServerUseProtseqIf</b> to register one protocol sequence with the RPC run-time library. With each protocol-sequence registration, the routine includes the endpoint-address information provided in the IDL file.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this function multiple times to register additional protocol sequences.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>. To register all protocol sequences from the IDL file, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>.
     * 
     * <div class="alert"><b>Note</b>  The Microsoft RPC implementation of 
     * <b>RpcServerUseProtseqIf</b> includes a new, additional parameter, <i>SecurityDescriptor</i>, that does not appear in the DCE specification.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqIf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} IfSpec Interface containing endpoint information to use in creating a binding for the protocol sequence specified in the <i>Protseq</i> parameter.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint for this protocol sequence is not specified in the IDL file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqifa
     * @since windows5.0
     */
    static RpcServerUseProtseqIfA(Protseq, MaxCalls, IfSpec, SecurityDescriptor) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqIfA", "ptr", Protseq, "uint", MaxCalls, "ptr", IfSpec, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqIfEx function tells the RPC run-time library to use the specified protocol sequence combined with the endpoints in the interface specification for receiving remote procedure calls. (RpcServerUseProtseqIfExA)
     * @remarks
     * The parameters and effects of 
     * <b>RpcServerUseProtseqIfEx</b> extend those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>. The difference is the <i>Policy</i> parameter, which allows you to restrict port allocation for dynamic ports and allows multihomed computers to selectively bind to network interface cards.
     * 
     * Setting the <b>NICFlags</b> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to 0 makes this extended API functionally equivalent to the original 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>, and the server will bind to NICs based on the settings in the system registry. For information on how the registry settings define the available Internet and intranet ports, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>.
     * 
     * <div class="alert"><b>Note</b>  The flag settings in the <b>Policy</b> field are effective only when the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> protocol sequence is in use; for all other protocol sequences, the RPC run time ignores these values.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseProtseqIfEx</b> to register one protocol sequence with the RPC run-time library. With each protocol-sequence registration, the routine includes the endpoint-address information provided in the IDL file.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this routine multiple times to register additional protocol sequences.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * To register all protocol sequences from the IDL file, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex">RpcServerUseAllProtseqsIfEx</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqIfEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} IfSpec Interface containing endpoint information to use in creating a binding for the protocol sequence specified in the <i>Protseq</i> parameter.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which contains flags to restrict port allocation for dynamic ports and that allow multihomed computers to selectively bind to network interface cards.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint for this protocol sequence is not specified in the IDL file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqifexa
     * @since windows5.1.2600
     */
    static RpcServerUseProtseqIfExA(Protseq, MaxCalls, IfSpec, SecurityDescriptor, Policy) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqIfExA", "ptr", Protseq, "uint", MaxCalls, "ptr", IfSpec, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqIfW (Unicode) function (rpcdce.h) tells the RPC run-time library to use the specified protocol sequence and endpoints in the interface specification for receiving remote procedure calls.
     * @remarks
     * A server application calls 
     * <b>RpcServerUseProtseqIf</b> to register one protocol sequence with the RPC run-time library. With each protocol-sequence registration, the routine includes the endpoint-address information provided in the IDL file.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this function multiple times to register additional protocol sequences.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>. To register all protocol sequences from the IDL file, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>.
     * 
     * <div class="alert"><b>Note</b>  The Microsoft RPC implementation of 
     * <b>RpcServerUseProtseqIf</b> includes a new, additional parameter, <i>SecurityDescriptor</i>, that does not appear in the DCE specification.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqIf as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} IfSpec Interface containing endpoint information to use in creating a binding for the protocol sequence specified in the <i>Protseq</i> parameter.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint for this protocol sequence is not specified in the IDL file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqifw
     * @since windows5.0
     */
    static RpcServerUseProtseqIfW(Protseq, MaxCalls, IfSpec, SecurityDescriptor) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqIfW", "ptr", Protseq, "uint", MaxCalls, "ptr", IfSpec, "ptr", SecurityDescriptor, "int")
        return result
    }

    /**
     * The RpcServerUseProtseqIfExW (Unicode) function (rpcdce.h) tells the RPC run-time library to use the specified protocol sequence and endpoints in the interface specification for receiving remote procedure calls.
     * @remarks
     * The parameters and effects of 
     * <b>RpcServerUseProtseqIfEx</b> extend those of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>. The difference is the <i>Policy</i> parameter, which allows you to restrict port allocation for dynamic ports and allows multihomed computers to selectively bind to network interface cards.
     * 
     * Setting the <b>NICFlags</b> field of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure to 0 makes this extended API functionally equivalent to the original 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>, and the server will bind to NICs based on the settings in the system registry. For information on how the registry settings define the available Internet and intranet ports, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/configuring-the-windows-xp-2000-nt-registry-for-port-allocations-and-selective-binding">Configuring the Registry for Port Allocations and Selective Binding</a>.
     * 
     * <div class="alert"><b>Note</b>  The flag settings in the <b>Policy</b> field are effective only when the <b>ncacn_ip_tcp</b> or <b>ncadg_ip_udp</b> protocol sequence is in use; for all other protocol sequences, the RPC run time ignores these values.</div>
     * <div> </div>
     * A server application calls 
     * <b>RpcServerUseProtseqIfEx</b> to register one protocol sequence with the RPC run-time library. With each protocol-sequence registration, the routine includes the endpoint-address information provided in the IDL file.
     * 
     * To receive remote procedure call requests, a server must register at least one protocol sequence with the RPC run-time library. A server application can call this routine multiple times to register additional protocol sequences.
     * 
     * For each protocol sequence registered by a server, the RPC run-time library creates one or more endpoints through which the server receives remote procedure call requests. The RPC run-time library creates different endpoints for each protocol sequence. However, each interface in the process is accessible through any endpoint. For more information, see Writing a Secure RPC Client or Server.
     * 
     * For <i>MaxCalls</i>, the value provided by the application is only a hint. The RPC run time or the Windows Sockets provider may override the value. For example, on Windows XP or Windows 2000 Professional, the value is limited to 5. Values greater than 5 are ignored and 5 is used instead. On Windows Server 2003 and Windows 2000 Server, the value will be honored.
     * 
     * Applications must be careful to pass reasonable values in <i>MaxCalls</i>. Large values on Server, Advanced Server, or Datacenter Server can cause a large amount of non-paged pool memory to be used. Using too small a value is also unfavorable, as it may result in TCP SYN packets being met by TCP RST from the server if the backlog queue gets exhausted. An application developer should balance memory footprint versus scalability requirements when determining the proper value for <i>MaxCalls</i>.
     * 
     * When the computer is configured to use selective binding, successful return does not guarantee that the server has created endpoints for all the network interfaces present on the computer.  The RPC run-time may not listen on some network interfaces depending on the selective binding settings.  In addition, if an interface has not yet received an IP address using DHCP, the RPC server does not listen on the network interface until a DHCP address is assigned to it.  A successful return implies that the server is listening on at least one network interface;  the full list of the binding handles over which remote procedure calls can be received can be obtained with a call to the RpcServerInqBindings function.
     * 
     * 
     * 
     * To register all protocol sequences from the IDL file, a server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex">RpcServerUseAllProtseqsIfEx</a>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/server-side-binding">Server-Side Binding</a>. For a list of Microsoft RPC supported protocol sequences, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/string-binding">String Binding</a>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerUseProtseqIfEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} Protseq Pointer to a string identifier of the protocol sequence to register with the RPC run-time library.
     * @param {Integer} MaxCalls Backlog queue length for the <b>ncacn_ip_tcp</b> protocol sequence. All other protocol sequences ignore this parameter. Use RPC_C_PROTSEQ_MAX_REQS_DEFAULT to specify the default value. See Remarks.
     * @param {Pointer<Void>} IfSpec Interface containing endpoint information to use in creating a binding for the protocol sequence specified in the <i>Protseq</i> parameter.
     * @param {Pointer<Void>} SecurityDescriptor Pointer to an optional parameter provided for the security subsystem. Used only for <b>ncacn_np</b> and <b>ncalrpc</b> protocol sequences. All other protocol sequences ignore this parameter. Using a security descriptor on the endpoint in order to make a server secure is not recommended. This parameter does not appear in the DCE specification for this API.
     * @param {Pointer<RPC_POLICY>} Policy Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_policy">RPC_POLICY</a> structure, which contains flags to restrict port allocation for dynamic ports and that allow multihomed computers to selectively bind to network interface cards.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint for this protocol sequence is not specified in the IDL file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserveruseprotseqifexw
     * @since windows5.1.2600
     */
    static RpcServerUseProtseqIfExW(Protseq, MaxCalls, IfSpec, SecurityDescriptor, Policy) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\RpcServerUseProtseqIfExW", "ptr", Protseq, "uint", MaxCalls, "ptr", IfSpec, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static RpcServerYield() {
        DllCall("RPCRT4.dll\RpcServerYield")
    }

    /**
     * The RpcMgmtStatsVectorFree function frees a statistics vector.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtStatsVectorFree</b> function to release the memory used to store statistics.
     * 
     * An application obtains a vector of statistics by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtinqstats">RpcMgmtInqStats</a> function.
     * @param {Pointer<RPC_STATS_VECTOR>} StatsVector Pointer to a pointer to a statistics vector. On return, the pointer is set to <b>NULL</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtstatsvectorfree
     * @since windows5.0
     */
    static RpcMgmtStatsVectorFree(StatsVector) {
        result := DllCall("RPCRT4.dll\RpcMgmtStatsVectorFree", "ptr", StatsVector, "int")
        return result
    }

    /**
     * The RpcMgmtInqStats function returns RPC run-time statistics.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtInqStats</b> function to obtain statistics about the specified server from the RPC run-time library.
     * 
     * Each array element in the returned statistics vector contains an <b>unsigned long</b> value. The following table describes the statistics indexed by the specified constant.
     * 
     * <table>
     * <tr>
     * <th>Statistic</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>RPC_C_STATS_CALLS_IN</td>
     * <td>Number of remote procedure calls received by the RPC server specified by the binding handle.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_STATS_CALLS_OUT</td>
     * <td>Number of remote procedure calls initiated by the RPC server specified by the binding handle.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_STATS_PKTS_IN</td>
     * <td>Number of network packets received by the RPC server specified by the binding handle.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_STATS_PKTS_OUT</td>
     * <td>Number of network packets sent by the RPC server specified by the binding handle.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * <div> </div>
     * 
     * 
     * The RPC run-time library allocates memory for the statistics vector. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstatsvectorfree">RpcMgmtStatsVectorFree</a> function to release the memory used by the statistics vector.
     * 
     * The server must be listening for remote procedure calls for this function to succeed.  If the server is not listening, the function fails.
     * @param {Pointer<Void>} Binding To receive statistics about a remote application, specify a server binding handle for that application. To receive statistics about your own (local) application, specify a value of <b>NULL</b>.
     * @param {Pointer<RPC_STATS_VECTOR>} Statistics Returns a pointer to a pointer to the statistics about the server specified by the <i>Binding</i> parameter. Each statistic is an <b>unsigned long</b> value.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtinqstats
     * @since windows5.0
     */
    static RpcMgmtInqStats(Binding, Statistics) {
        result := DllCall("RPCRT4.dll\RpcMgmtInqStats", "ptr", Binding, "ptr", Statistics, "int")
        return result
    }

    /**
     * The RpcMgmtIsServerListening function tells whether a server is listening for remote procedure calls.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtIsServerListening</b> function to determine whether the server specified in the <i>Binding</i> parameter is listening for remote procedure calls.
     * 
     * The 
     * <b>RpcMgmtIsServerListening</b> function returns a value of <b>RPC_S_OK</b> if the server has called 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a>.
     * 
     * The server must be listening for remote procedure calls for this function to succeed.  If the server is not listening, the function fails.
     * @param {Pointer<Void>} Binding To determine whether a remote application is listening for remote procedure calls, specify a server binding handle for that application. To determine whether your own (local) application is listening for remote procedure calls, specify a value of <b>NULL</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Server listening for remote procedure calls.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_LISTENING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Server not listening for remote procedure calls, or the interface is auto-listening.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * 
     * <div> </div>
     * 
     * 
     * The 
     * <b>RpcMgmtIsServerListening</b> function returns correct results only for interfaces that are not auto-listening. If the server application is auto-listening and calls the 
     * <b>RpcMgmtIsServerListening</b> function, 
     * <b>RpcMgmtIsServerListening</b> returns RPC_SERVER_NOT_LISTENING, yet the server may be listening, and subsequent RPC calls may succeed.
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtisserverlistening
     * @since windows5.0
     */
    static RpcMgmtIsServerListening(Binding) {
        result := DllCall("RPCRT4.dll\RpcMgmtIsServerListening", "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcMgmtStopServerListening function tells a server to stop listening for remote procedure calls. This function will not affect auto-listen interfaces. See RpcServerRegisterIfEx for more details.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtStopServerListening</b> function to direct a server to stop listening for remote procedure calls. If <i>DontWait</i> was <b>TRUE</b>, the application should call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtwaitserverlisten">RpcMgmtWaitServerListen</a> to wait for all calls to complete.
     * 
     * When it receives a stop-listening request, the RPC run-time library stops accepting new remote procedure calls for all registered interfaces. Executing calls are allowed to complete, including callbacks. After all calls complete, this function signals <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> function that it must stop listening and return to the caller. If the <i>DontWait</i> parameter of <b>RpcServerListen</b> was set to <b>TRUE</b>, the application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtwaitserverlisten">RpcMgmtWaitServerListen</a> for all remaining calls to complete.
     * 
     * <div class="alert"><b>Note</b>  From the client-side, 
     * <b>RpcMgmtStopServerListening</b> is disabled by default. To enable this function, create an authorization function in your server application that returns <b>TRUE</b> (to allow a remote shutdown) whenever 
     * <b>RpcMgmtStopServerListening</b> is called. Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtsetauthorizationfn">RpcMgmtSetAuthorizationFn</a> to give the client access to the management function.</div>
     * <div> </div>
     * The server must be listening for remote procedure calls for this function to succeed.  If the server is not listening, the function fails.
     * @param {Pointer<Void>} Binding To direct a remote application to stop listening for remote procedure calls, specify a server binding handle for that application. To direct your own (local) application to stop listening for remote procedure calls, specify a value of <b>NULL</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening
     * @since windows5.0
     */
    static RpcMgmtStopServerListening(Binding) {
        result := DllCall("RPCRT4.dll\RpcMgmtStopServerListening", "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcMgmtWaitServerListen function performs the wait operation usually associated with RpcServerListen.
     * @remarks
     * When the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> flag parameter <i>DontWait</i> has a nonzero value, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> function returns to the server application without performing the wait operation. In this case, the wait can be performed by 
     * <b>RpcMgmtWaitServerListen</b>.
     * 
     * Applications must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> with a nonzero value for the <i>DontWait</i> parameter before calling 
     * <b>RpcMgmtWaitServerListen</b>. The 
     * <b>RpcMgmtWaitServerListen</b> function returns after the server application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a> and all active remote procedure calls complete, or after a fatal error occurs in the RPC run-time library.
     * 
     * <div class="alert"><b>Note</b>  <b>RpcMgmtWaitServerListen</b> is a Microsoft extension to the DCE API set.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All remote procedure calls are complete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ALREADY_LISTENING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Another thread has called 
     * <b>RpcMgmtWaitServerListen</b> and has not yet returned.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_LISTENING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The server application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverlisten">RpcServerListen</a> before calling 
     * <b>RpcMgmtWaitServerListen</b>.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtwaitserverlisten
     * @since windows5.0
     */
    static RpcMgmtWaitServerListen() {
        result := DllCall("RPCRT4.dll\RpcMgmtWaitServerListen", "int")
        return result
    }

    /**
     * The RpcMgmtSetServerStackSize function specifies the stack size for server threads created by the RPC run time.
     * @remarks
     * A server application calls the 
     * <b>RpcMgmtSetServerStackSize</b> function to specify the thread stack size to use when the RPC run-time library creates call threads for executing remote procedure calls.
     * 
     * Servers that know the stack requirements of all the manager functions in the interfaces it offers can call the 
     * <b>RpcMgmtSetServerStackSize</b> function to ensure that each call thread has the necessary stack size.
     * 
     * Calling 
     * <b>RpcMgmtSetServerStackSize</b> is optional. If a server does not call 
     * <b>RpcMgmtSetServerStackSize</b>, the default thread stack size from the executable image is used.
     * @param {Integer} ThreadStackSize Stack size allocated for each thread created by the RPC run time, in bytes. This value is applied to all threads created for the server, but not to threads already created. Select this value based on the stack requirements of the remote procedures offered by the server.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtsetserverstacksize
     * @since windows5.0
     */
    static RpcMgmtSetServerStackSize(ThreadStackSize) {
        result := DllCall("RPCRT4.dll\RpcMgmtSetServerStackSize", "uint", ThreadStackSize, "int")
        return result
    }

    /**
     * The RpcSsDontSerializeContext function disables run-time serialization of multiple calls dispatched to server-manager routines on the same context handle.
     * @remarks
     * The 
     * <b>RpcSsDontSerializeContext</b> function prevents the run time from performing this serialization service, allowing multiple calls to be dispatched on a given context handle. Calling this function does not disable serialization entirely—when a context run down occurs, your context run-down routine will not run until all outstanding client requests have completed. Changes to the context handle state, including freeing the context handle typically, must continue to be serialized.
     * 
     * It is recommended that, if your distributed application invokes the 
     * <b>RpcSsDontSerializeContext</b> function, the call should be made before the server program begins handling remote procedure calls.
     * 
     * <div class="alert"><b>Note</b>  Typically, the RPC run-time serializes calls on the same context handle dispatched to server manager routines. Context handles are maintained on a per-client basis and typically represent the server-side state. This means that your server manager does not have to guard against another thread from the same client changing the context or against the context running down while a call is dispatched.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  After it is called, the 
     * <b>RpcSsDontSerializeContext</b> function is not revertible for the life of the process.</div>
     * <div> </div>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcssdontserializecontext
     * @since windows5.0
     */
    static RpcSsDontSerializeContext() {
        DllCall("RPCRT4.dll\RpcSsDontSerializeContext")
    }

    /**
     * The RpcMgmtEnableIdleCleanup function enables RPC to close idle resources, such as network connections, on the client.
     * @remarks
     * <div class="alert"><b>Note</b>  <b>RpcMgmtEnableIdleCleanup</b> is a Microsoft extension to the OSF-DCE RPC specification.</div>
     * <div> </div>
     * Calling this function only is sufficient. Once called, idle resource cleanup cannot be turned off. In some cases, depending on Windows version and configuration, RPC Runtime may need to create a separate thread in order to perform such cleanup, which is why idle resource cleanup is not always turned on. On Windows XP and later versions of Windows, RPC Runtime is programmed to automatically turn on idle resource cleanup if idle resources reach a certain threshold.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_THREADS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of threads.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_RESOURCES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of resources.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtenableidlecleanup
     * @since windows5.0
     */
    static RpcMgmtEnableIdleCleanup() {
        result := DllCall("RPCRT4.dll\RpcMgmtEnableIdleCleanup", "int")
        return result
    }

    /**
     * The RpcMgmtInqIfIds function returns a vector containing the identifiers of the interfaces offered by the server.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtInqIfIds</b> function to obtain a vector of interface identifiers about the specified server from the RPC run-time library.
     * 
     * The RPC run-time library allocates memory for the interface identifier vector. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcifidvectorfree">RpcIfIdVectorFree</a> function to release the memory used by this vector.
     * 
     * The server must be listening for remote procedure calls for this function to succeed.  If the server is not listening, the function fails.
     * @param {Pointer<Void>} Binding To receive interface identifiers about a remote application, specify a server binding handle for that application. To receive interface information about your own application, specify a value of <b>NULL</b>.
     * @param {Pointer<RPC_IF_ID_VECTOR>} IfIdVector Returns the address of an interface identifier vector.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtinqifids
     * @since windows5.0
     */
    static RpcMgmtInqIfIds(Binding, IfIdVector) {
        result := DllCall("RPCRT4.dll\RpcMgmtInqIfIds", "ptr", Binding, "ptr", IfIdVector, "int")
        return result
    }

    /**
     * The RpcIfIdVectorFree function frees the vector and the interface-identification structures contained in the vector.
     * @remarks
     * An application calls the 
     * <b>RpcIfIdVectorFree</b> function to release the memory used to store a vector of interface identifications. 
     * <b>RpcIfIdVectorFree</b> frees memory containing the interface identifications and the vector itself. On return, this function sets the <i>IfIdVec</i> parameter to <b>NULL</b>.
     * 
     * An application obtains a vector of interface identifications by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentryinqifidsa">RpcNsMgmtEntryInqIfIds</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtinqifids">RpcMgmtInqIfIds</a> functions.
     * @param {Pointer<RPC_IF_ID_VECTOR>} IfIdVector Address of a pointer to a vector of interface information. On return, the pointer is set to <b>NULL</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcifidvectorfree
     * @since windows5.0
     */
    static RpcIfIdVectorFree(IfIdVector) {
        result := DllCall("RPCNS4.dll\RpcIfIdVectorFree", "ptr", IfIdVector, "int")
        return result
    }

    /**
     * The RpcMgmtInqServerPrincName function returns a server's principal name. (RpcMgmtInqServerPrincNameA)
     * @remarks
     * An application calls the 
     * <b>RpcMgmtInqServerPrincName</b> function to obtain the principal name of a server that is registered for a specified authentication service.
     * 			
     * 
     * The RPC run-time library allocates memory for the string returned in <i>ServerPrincName</i>. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function to release the memory used by this function.
     * 
     * The server must be listening for remote procedure calls for this function to succeed.  If the server is not listening, the function fails.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcMgmtInqServerPrincName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding To receive the principal name for a server, specify a server binding handle for that server. To receive the principal name for your own (local) application, specify a value of <b>NULL</b>.
     * @param {Integer} AuthnSvc Authentication service for which a principal name is returned. Valid values are the constant for any valid security provider.
     * @param {Pointer<Byte>} ServerPrincName Returns a principal name that is registered for the authentication service in <i>AuthnSvc</i> by the server referenced in <i>Binding</i>. If multiple names are registered, only one name is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtinqserverprincnamea
     * @since windows5.0
     */
    static RpcMgmtInqServerPrincNameA(Binding, AuthnSvc, ServerPrincName) {
        result := DllCall("RPCRT4.dll\RpcMgmtInqServerPrincNameA", "ptr", Binding, "uint", AuthnSvc, "ptr", ServerPrincName, "int")
        return result
    }

    /**
     * The RpcMgmtInqServerPrincNameW (Unicode) function (rpcdce.h) returns a server's principal name.
     * @remarks
     * An application calls the 
     * <b>RpcMgmtInqServerPrincName</b> function to obtain the principal name of a server that is registered for a specified authentication service.
     * 			
     * 
     * The RPC run-time library allocates memory for the string returned in <i>ServerPrincName</i>. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function to release the memory used by this function.
     * 
     * The server must be listening for remote procedure calls for this function to succeed.  If the server is not listening, the function fails.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcMgmtInqServerPrincName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding To receive the principal name for a server, specify a server binding handle for that server. To receive the principal name for your own (local) application, specify a value of <b>NULL</b>.
     * @param {Integer} AuthnSvc Authentication service for which a principal name is returned. Valid values are the constant for any valid security provider.
     * @param {Pointer<Char>} ServerPrincName Returns a principal name that is registered for the authentication service in <i>AuthnSvc</i> by the server referenced in <i>Binding</i>. If multiple names are registered, only one name is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtinqserverprincnamew
     * @since windows5.0
     */
    static RpcMgmtInqServerPrincNameW(Binding, AuthnSvc, ServerPrincName) {
        result := DllCall("RPCRT4.dll\RpcMgmtInqServerPrincNameW", "ptr", Binding, "uint", AuthnSvc, "ptr", ServerPrincName, "int")
        return result
    }

    /**
     * The RpcServerInqDefaultPrincName function obtains the default principal name for a given authentication service. (RpcServerInqDefaultPrincNameA)
     * @remarks
     * This function is the recommended way to obtain the server principal name to be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. While composing the server principal name is possible without using this function, calling the function is easier and more portable across operating system versions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerInqDefaultPrincName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} AuthnSvc Authentication service to use when the server receives a request for a remote procedure call.
     * @param {Pointer<Byte>} PrincName Upon success, contains the default principal name for the given authentication service as specified by the <i>AuthnSvc</i> parameter. The authentication service in use defines the content of the name and its syntax. This principal name must be used as the <i>ServerPrincName</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. If the function succeeds, <i>PrincName</i> must be freed using the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function. If the function fails, the contents of <i>PrincName</i> is undefined and the caller has no obligation to free it.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is insufficient memory to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinqdefaultprincnamea
     * @since windows5.0
     */
    static RpcServerInqDefaultPrincNameA(AuthnSvc, PrincName) {
        result := DllCall("RPCRT4.dll\RpcServerInqDefaultPrincNameA", "uint", AuthnSvc, "ptr", PrincName, "int")
        return result
    }

    /**
     * The RpcServerInqDefaultPrincNameW (Unicode) function (rpcdce.h) obtains the default principal name for a given authentication service.
     * @remarks
     * This function is the recommended way to obtain the server principal name to be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. While composing the server principal name is possible without using this function, calling the function is easier and more portable across operating system versions.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerInqDefaultPrincName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} AuthnSvc Authentication service to use when the server receives a request for a remote procedure call.
     * @param {Pointer<Char>} PrincName Upon success, contains the default principal name for the given authentication service as specified by the <i>AuthnSvc</i> parameter. The authentication service in use defines the content of the name and its syntax. This principal name must be used as the <i>ServerPrincName</i> parameter of the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. If the function succeeds, <i>PrincName</i> must be freed using the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function. If the function fails, the contents of <i>PrincName</i> is undefined and the caller has no obligation to free it.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is insufficient memory to complete the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinqdefaultprincnamew
     * @since windows5.0
     */
    static RpcServerInqDefaultPrincNameW(AuthnSvc, PrincName) {
        result := DllCall("RPCRT4.dll\RpcServerInqDefaultPrincNameW", "uint", AuthnSvc, "ptr", PrincName, "int")
        return result
    }

    /**
     * The RpcEpResolveBinding function resolves a partially-bound server binding handle into a fully-bound server binding handle.
     * @remarks
     * An application calls the 
     * <b>RpcEpResolveBinding</b> function to resolve a partially-bound server binding handle into a fully-bound binding handle.
     * 
     * Resolving binding handles requires an interface UUID and an object UUID (which may be nil). The RPC run-time library asks the endpoint-mapping service on the host specified by the <i>Binding</i> parameter to look up an endpoint for a compatible server instance. To find the endpoint, the endpoint-mapping service looks in the endpoint-map database for the interface UUID in the <i>IfSpec</i> parameter and the object UUID in the <i>Binding</i> parameter, if any.
     * 
     * How the resolve-binding operation functions depends on whether the specified binding handle is partially- or fully-bound. When the client specifies a partially-bound handle, the resolve-binding operation has the following possible outcomes:
     * 
     * <ul>
     * <li>If no compatible server instances are registered in the endpoint-map database, the resolve-binding operation returns the EPT_S_NOT_REGISTERED status code.</li>
     * <li>If a compatible server instance is registered in the endpoint-map database, the resolve-binding operation returns a fully-bound binding and the RPC_S_OK status code.</li>
     * </ul>
     * When the client specifies a fully-bound binding handle, the resolve-binding operation returns the specified binding handle and the RPC_S_OK status code. The resolve-binding operation does not contact the endpoint-mapping service.
     * 
     * In neither the partially- nor the fully-bound binding case does the resolve-binding operation contact a compatible server instance.
     * 
     * <div class="alert"><b>Note</b>  Calling 
     * <b>RpcEpResolveBinding</b> is not strictly necessary. If an RPC call is made on a partially-bound server binding handle, the RPC run time takes the necessary steps to make the binding into fully bound binding handle. The RPC run time calls 
     * <b>RpcEpResolveBinding</b>, but does so more efficiently due to additional caching techniques. In Windows XP and Windows 2000, applications have no reason to call 
     * <b>RpcEpResolveBinding</b>.</div>
     * <div> </div>
     * @param {Pointer<Void>} Binding Partially-bound server binding handle to resolve to a fully-bound server binding handle.
     * @param {Pointer<Void>} IfSpec Stub-generated structure specifying the interface of interest.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcepresolvebinding
     * @since windows5.0
     */
    static RpcEpResolveBinding(Binding, IfSpec) {
        result := DllCall("RPCRT4.dll\RpcEpResolveBinding", "ptr", Binding, "ptr", IfSpec, "int")
        return result
    }

    /**
     * The RpcNsBindingInqEntryName function returns the entry name from which the binding handle came. (RpcNsBindingInqEntryNameA)
     * @remarks
     * The 
     * <b>RpcNsBindingInqEntryName</b> function returns the name of the name service–database entry name from which a client compatible–binding handle came.
     * 
     * The RPC run-time library allocates memory for the string returned in the <i>EntryName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function to deallocate that memory.
     * 
     * An entry name is associated only with binding handles returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingselect">RpcNsBindingSelect</a> functions.
     * 
     * If the binding handle specified in the <i>Binding</i> parameter was not returned from a name-service database entry (for example, if the binding handle was created by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfromstringbinding">RpcBindingFromStringBinding</a>), 
     * <b>RpcNsBindingInqEntryName</b> returns an empty string ("\0") and an RPC_S_NO_ENTRY_NAME status code.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcNsBindingInqEntryName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Binding handle whose name-service database entry name is returned.
     * @param {Integer} EntryNameSyntax Syntax used in <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry
     * 
     * <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Returns the address of a pointer to the name of the name-service database entry in which <i>Binding</i> was found. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsBindingInqEntryName</b> from returning the <i>EntryName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_ENTRY_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No entry name for binding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcnsbindinginqentrynamea
     * @since windows5.0
     */
    static RpcNsBindingInqEntryNameA(Binding, EntryNameSyntax, EntryName) {
        result := DllCall("RPCRT4.dll\RpcNsBindingInqEntryNameA", "ptr", Binding, "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * The RpcNsBindingInqEntryNameW (Unicode) function (rpcdce.h) returns the entry name from which the binding handle came.
     * @remarks
     * The 
     * <b>RpcNsBindingInqEntryName</b> function returns the name of the name service–database entry name from which a client compatible–binding handle came.
     * 
     * The RPC run-time library allocates memory for the string returned in the <i>EntryName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function to deallocate that memory.
     * 
     * An entry name is associated only with binding handles returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingselect">RpcNsBindingSelect</a> functions.
     * 
     * If the binding handle specified in the <i>Binding</i> parameter was not returned from a name-service database entry (for example, if the binding handle was created by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfromstringbinding">RpcBindingFromStringBinding</a>), 
     * <b>RpcNsBindingInqEntryName</b> returns an empty string ("\0") and an RPC_S_NO_ENTRY_NAME status code.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcNsBindingInqEntryName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Binding handle whose name-service database entry name is returned.
     * @param {Integer} EntryNameSyntax Syntax used in <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry
     * 
     * <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Returns the address of a pointer to the name of the name-service database entry in which <i>Binding</i> was found. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsBindingInqEntryName</b> from returning the <i>EntryName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_ENTRY_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No entry name for binding.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcnsbindinginqentrynamew
     * @since windows5.0
     */
    static RpcNsBindingInqEntryNameW(Binding, EntryNameSyntax, EntryName) {
        result := DllCall("RPCRT4.dll\RpcNsBindingInqEntryNameW", "ptr", Binding, "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * The RpcBindingCreate function creates a new fast RPC binding handle based on a supplied template. (ANSI)
     * @remarks
     * The RPC binding handle returned by this API can be used with any other functions that accepts a binding handle as a parameter.
     * 
     * However, before any calls can be made on the binding handle, <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcbindingbind">RpcBindingBind</a> must be called to make the binding handle available for remote calls. The <b>RpcBindingCreate</b> API does not touch the network or attempt to communicate with the RPC server -- rather, it simply builds an internal data structure based on the values supplied in the template. A successful return does not indicate that the RPC server is available, accessible, or correctly specified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingCreate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_BINDING_HANDLE_TEMPLATE_V1_A>} Template <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_template_v1_a">RPC_BINDING_HANDLE_TEMPLATE</a> structure that describes the binding handle to be created by this call. This data may be overwritten during the call, so the API does not maintain a reference to this data. The caller must free the memory used by this structure when the API returns.
     * @param {Pointer<RPC_BINDING_HANDLE_SECURITY_V1_A>} Security <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_security_v1_a">RPC_BINDING_HANDLE_SECURITY</a> structure that describes the security options for this binding handle. This data may be overwritten during the call, so the API does not maintain a reference to this data. The caller must free the memory used by this structure when the API returns.
     * 
     * This parameter is optional. If this parameter is set to <b>NULL</b>, the default security settings for <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_security_v1_a">RPC_BINDING_HANDLE_SECURITY</a> will be used.
     * @param {Pointer<RPC_BINDING_HANDLE_OPTIONS_V1>} Options <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_options_v1">RPC_BINDING_HANDLE_OPTIONS</a> structure that describes additional options for the binding handle. This data may be overwritten during the call, so the API does not maintain a reference to this data. The caller must free the memory used by this structure when the API returns.
     * 
     * This parameter is optional. If this parameter is set to <b>NULL</b>, the default options for <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_options_v1">RPC_BINDING_HANDLE_OPTIONS</a> will be used.
     * @param {Pointer<Void>} Binding <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-binding-handle">RPC_BINDING_HANDLE</a> structure that contains the newly-created binding handle. If this function did not return RPC_S_OK, then the contents of this structure are undefined. For non-local RPC calls, this handle must be passed to <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcbindingbind">RpcBindingBind</a>.
     * @returns {Integer} This function returns RPC_S_OK on success; otherwise, an RPC_S_* error code is returned. For information on these error codes, see <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was successfully created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An obsolete feature of RPC was requested for this binding handle.
     * 
     * <div class="alert"><b>Note</b>  The only supported protocol sequences for this API is <b>ncalrpc</b>; choosing another protocol sequence results in the return of this error status code.</div>
     * <div> </div>
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingcreatea
     * @since windows6.0.6000
     */
    static RpcBindingCreateA(Template, Security, Options, Binding) {
        result := DllCall("RPCRT4.dll\RpcBindingCreateA", "ptr", Template, "ptr", Security, "ptr", Options, "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcBindingCreate function creates a new fast RPC binding handle based on a supplied template. (Unicode)
     * @remarks
     * The RPC binding handle returned by this API can be used with any other functions that accepts a binding handle as a parameter.
     * 
     * However, before any calls can be made on the binding handle, <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcbindingbind">RpcBindingBind</a> must be called to make the binding handle available for remote calls. The <b>RpcBindingCreate</b> API does not touch the network or attempt to communicate with the RPC server -- rather, it simply builds an internal data structure based on the values supplied in the template. A successful return does not indicate that the RPC server is available, accessible, or correctly specified.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingCreate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_BINDING_HANDLE_TEMPLATE_V1_W>} Template <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_template_v1_a">RPC_BINDING_HANDLE_TEMPLATE</a> structure that describes the binding handle to be created by this call. This data may be overwritten during the call, so the API does not maintain a reference to this data. The caller must free the memory used by this structure when the API returns.
     * @param {Pointer<RPC_BINDING_HANDLE_SECURITY_V1_W>} Security <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_security_v1_a">RPC_BINDING_HANDLE_SECURITY</a> structure that describes the security options for this binding handle. This data may be overwritten during the call, so the API does not maintain a reference to this data. The caller must free the memory used by this structure when the API returns.
     * 
     * This parameter is optional. If this parameter is set to <b>NULL</b>, the default security settings for <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_security_v1_a">RPC_BINDING_HANDLE_SECURITY</a> will be used.
     * @param {Pointer<RPC_BINDING_HANDLE_OPTIONS_V1>} Options <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_options_v1">RPC_BINDING_HANDLE_OPTIONS</a> structure that describes additional options for the binding handle. This data may be overwritten during the call, so the API does not maintain a reference to this data. The caller must free the memory used by this structure when the API returns.
     * 
     * This parameter is optional. If this parameter is set to <b>NULL</b>, the default options for <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_binding_handle_options_v1">RPC_BINDING_HANDLE_OPTIONS</a> will be used.
     * @param {Pointer<Void>} Binding <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-binding-handle">RPC_BINDING_HANDLE</a> structure that contains the newly-created binding handle. If this function did not return RPC_S_OK, then the contents of this structure are undefined. For non-local RPC calls, this handle must be passed to <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcbindingbind">RpcBindingBind</a>.
     * @returns {Integer} This function returns RPC_S_OK on success; otherwise, an RPC_S_* error code is returned. For information on these error codes, see <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was successfully created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An obsolete feature of RPC was requested for this binding handle.
     * 
     * <div class="alert"><b>Note</b>  The only supported protocol sequences for this API is <b>ncalrpc</b>; choosing another protocol sequence results in the return of this error status code.</div>
     * <div> </div>
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingcreatew
     * @since windows6.0.6000
     */
    static RpcBindingCreateW(Template, Security, Options, Binding) {
        result := DllCall("RPCRT4.dll\RpcBindingCreateW", "ptr", Template, "ptr", Security, "ptr", Options, "ptr", Binding, "int")
        return result
    }

    /**
     * Obtains the binding handle for RPC calls serviced by the thread in which RpcServerInqBindingHandle is called.
     * @remarks
     * <b>RpcServerInqBindingHandle</b> is used to obtain the binding handle for the RPC call that is currently executing on the thread from which this API is also called. Since many RPC APIs require a binding handle as input, this is a convenient way to obtain a binding handle.
     * 
     * Note that all server-side RPC APIs that take a binding handle as a parameter allow you to pass NULL as an accepted value. Passing NULL instead of a binding handle indicates  that the binding handle for the RPC call currently executing in the same thread should be used. However, if you call a server-side API from a separate thread, then you will need to supply a non-NULL binding handle to them.
     * 
     * If you use explicit binding handles and do not use thread-specific context handles, the binding handle for the call is the first parameter to your server manager routine. However, if you do not use explicit handles or if you use context handles, <b>RpcServerInqBindingHandle</b> is the only way to obtain a binding handle to use in another thread.
     * 
     * This API can be used for both asynchronous and synchronous calls, although it is less useful for asynchronous calls since the binding handle can be obtained as the async state is always the first parameter for all asynchronous RPC calls and the binding handle can be obtained directly from it using <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasyncgetcallhandle">RpcAsyncGetCallHandle</a>.
     * @param {Pointer<Void>} Binding <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-binding-handle">RPC_BINDING_HANDLE</a> structure that, upon success, receives the binding handle for the call serviced by the thread on which <b>RpcServerInqBindingHandle</b> is also called.
     * 
     * If the call fails, this parameter is undefined.
     * @returns {Integer} This function returns RPC_S_OK on success; otherwise, an RPC_S_* error code is returned. This function cannot fail unless it is called on a thread that is not currently servicing an RPC call.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinqbindinghandle
     * @since windows6.0.6000
     */
    static RpcServerInqBindingHandle(Binding) {
        result := DllCall("RPCRT4.dll\RpcServerInqBindingHandle", "ptr", Binding, "int")
        return result
    }

    /**
     * A server thread that is processing client remote procedure calls can call the RpcImpersonateClient function to impersonate the active client.
     * @remarks
     * In a multithreaded application, if the call to 
     * <b>RpcImpersonateClient</b> is with a handle to another client thread, you must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcreverttoselfex">RpcRevertToSelfEx</a> with the handle to that thread to end impersonation.
     * 
     * All  functions that impersonate check to determine whether the caller of this function (the RPC Server) has the SeImpersonatePrivilege privilege. If the caller has the SeImpersonatePrivilege, or if the authenticated identity is the same as the identity of the caller of this function, the requested impersonation is allowed. Otherwise, the impersonation succeeds at Identify level only.
     * 
     * <b>Windows XP/2000/NT:  </b>The SeImpersonatePrivilege privilege is not supported until Windows XP with Service Pack 2 (SP2).
     * 
     * <h3><a id="Security_Remarks"></a><a id="security_remarks"></a><a id="SECURITY_REMARKS"></a>Security Remarks</h3>
     * If the call to 
     * <b>RpcImpersonateClient</b> fails for any reason, the client connection is not impersonated and the client request is made in the security context of the process. If the process is running as a highly privileged account, such as LocalSystem, or as a member of an administrative group, the user may be able to perform actions they would otherwise be disallowed. Therefore it is important to always check the return value of the call, and if it fails, raise an error; do not continue execution of the client request.
     * @param {Pointer<Void>} BindingHandle Binding handle on the server that represents a binding to a client. The server impersonates the client indicated by this handle. If a value of zero is specified, the server impersonates the client that is being served by this server thread.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_CALL_ACTIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No client is active on this server thread.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function is not supported for either the operating system, the transport, or this security subsystem.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_CONTEXT_AVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The server does not have permission to impersonate the client.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcimpersonateclient
     * @since windows5.0
     */
    static RpcImpersonateClient(BindingHandle) {
        result := DllCall("RPCRT4.dll\RpcImpersonateClient", "ptr", BindingHandle, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} BindingHandle 
     * @returns {Integer} 
     */
    static RpcImpersonateClient2(BindingHandle) {
        result := DllCall("RPCRT4.dll\RpcImpersonateClient2", "ptr", BindingHandle, "int")
        return result
    }

    /**
     * The RpcRevertToSelfEx function allows a server to impersonate a client and then revert in a multithreaded operation where the call to impersonate a client can come from a thread other than the thread originally dispatched from the RPC.
     * @remarks
     * After calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcimpersonateclient">RpcImpersonateClient</a> and completing any tasks that require client impersonation, the server calls 
     * <b>RpcRevertToSelfEx</b> to end impersonation and to reestablish its own security identity. For example, consider a primary thread, called thread1, which is dispatched from a remote client and wakes up a worker thread, called thread2. If thread2 requires that the server impersonate the client, the server calls 
     * <b>RpcImpersonateClient</b>(THREAD1_CALL_HANDLE), performs the required task, calls 
     * <b>RpcRevertToSelfEx</b>(THREAD1_CALL_HANDLE) to end the impersonation, and then wakes up thread1.
     * @param {Pointer<Void>} BindingHandle Binding handle on the server that represents a binding to the client that the server impersonated. A value of zero specifies the client handle of the current thread; in this case, the functionality of 
     * <b>RpcRevertToSelfEx</b> is identical to that of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcreverttoself">RpcRevertToSelf</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_CALL_ACTIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The server does not have a client to impersonate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is the wrong kind of binding for this operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call is not supported for this operating system, this transport, or this security subsystem.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcreverttoselfex
     * @since windows5.0
     */
    static RpcRevertToSelfEx(BindingHandle) {
        result := DllCall("RPCRT4.dll\RpcRevertToSelfEx", "ptr", BindingHandle, "int")
        return result
    }

    /**
     * After calling RpcImpersonateClient and completing any tasks that require client impersonation, the server calls RpcRevertToSelf to end impersonation and to reestablish its own security identity.
     * @remarks
     * In a multithreaded application, if the call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcimpersonateclient">RpcImpersonateClient</a> is with a handle to another client thread, you must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcreverttoselfex">RpcRevertToSelfEx</a> with the handle to that thread to end impersonation.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_CALL_ACTIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The server does not have a client to impersonate.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is the wrong kind of binding for this operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call is not supported for this operating system, this transport, or this security subsystem.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcreverttoself
     * @since windows5.0
     */
    static RpcRevertToSelf() {
        result := DllCall("RPCRT4.dll\RpcRevertToSelf", "int")
        return result
    }

    /**
     * RpcImpersonateClientContainer may be altered or unavailable.
     * @param {Pointer<Void>} BindingHandle Reserved.
     * @returns {Integer} Reserved.
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcimpersonateclientcontainer
     * @since windows10.0.10240
     */
    static RpcImpersonateClientContainer(BindingHandle) {
        result := DllCall("RPCRT4.dll\RpcImpersonateClientContainer", "ptr", BindingHandle, "int")
        return result
    }

    /**
     * RpcRevertContainerImpersonation may be altered or unavailable.
     * @returns {Integer} Reserved.
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcrevertcontainerimpersonation
     * @since windows10.0.10240
     */
    static RpcRevertContainerImpersonation() {
        result := DllCall("RPCRT4.dll\RpcRevertContainerImpersonation", "int")
        return result
    }

    /**
     * A server application calls the RpcBindingInqAuthClient function to obtain the principal name or privilege attributes of the authenticated client that made the remote procedure call. (RpcBindingInqAuthClientA)
     * @remarks
     * A server application calls the 
     * <b>RpcBindingInqAuthClient</b> function to obtain the principal name or privilege attributes of the authenticated client that made the remote procedure call. In addition, 
     * <b>RpcBindingInqAuthClient</b> returns the authentication service, authentication level, and server principal name specified by the client. The server can use the returned data for authorization purposes.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for the returned argument string.
     * 
     * For synchronous RPC calls, the server application can use zero as the value for the <i>ClientBinding</i> parameter. Using zero retrieves the authentication and authorization information from the currently executing remote procedure call.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthClient as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} ClientBinding Client binding handle of the client that made the remote procedure call. This value can be zero. See Remarks.
     * @param {Pointer<Void>} Privs Returns a pointer to a handle to the privileged information for the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For <b>ncalrpc</b> calls, <i>Privs</i> contains a string with the client's principal name.
     * 
     * The data referenced by this parameter is read-only and should not be modified by the server application. If the server wants to preserve any of the returned data, the server must copy the data into server-allocated memory.
     * 
     * The data that the <i>Privs</i> parameter points to comes directly from the SSP. Therefore, the format of the data is specific to the SSP. For more information on SSPs, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/security-support-providers-ssps-">Security Support Providers (SSPs)</a>.
     * @param {Pointer<Byte>} ServerPrincName Returns a pointer to a pointer to the server principal name specified by the server application that called the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. The content of the returned name and its syntax are defined by the authentication service in use. For the SCHANNEL SSP, the principal name is in Microsoft-standard (msstd) format. For further information on msstd format, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">Principal Names</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>AuthnLevel</i> parameter.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>AuthnSvc</i> parameter.
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>AuthzSvc</i> parameter. This parameter is not used by the RPC_C_AUTHN_WINNT authentication service. The returned value will always be RPC_C_AUTHZ_NONE.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthclienta
     * @since windows5.0
     */
    static RpcBindingInqAuthClientA(ClientBinding, Privs, ServerPrincName, AuthnLevel, AuthnSvc, AuthzSvc) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthClientA", "ptr", ClientBinding, "ptr", Privs, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "uint*", AuthzSvc, "int")
        return result
    }

    /**
     * The RpcBindingInqAuthClientW (Unicode) function (rpcdce.h) gets the principal name or privilege attributes of the client that made the remote procedure call.
     * @remarks
     * A server application calls the 
     * <b>RpcBindingInqAuthClient</b> function to obtain the principal name or privilege attributes of the authenticated client that made the remote procedure call. In addition, 
     * <b>RpcBindingInqAuthClient</b> returns the authentication service, authentication level, and server principal name specified by the client. The server can use the returned data for authorization purposes.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for the returned argument string.
     * 
     * For synchronous RPC calls, the server application can use zero as the value for the <i>ClientBinding</i> parameter. Using zero retrieves the authentication and authorization information from the currently executing remote procedure call.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthClient as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} ClientBinding Client binding handle of the client that made the remote procedure call. This value can be zero. See Remarks.
     * @param {Pointer<Void>} Privs Returns a pointer to a handle to the privileged information for the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For <b>ncalrpc</b> calls, <i>Privs</i> contains a string with the client's principal name.
     * 
     * The data referenced by this parameter is read-only and should not be modified by the server application. If the server wants to preserve any of the returned data, the server must copy the data into server-allocated memory.
     * 
     * The data that the <i>Privs</i> parameter points to comes directly from the SSP. Therefore, the format of the data is specific to the SSP. For more information on SSPs, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/security-support-providers-ssps-">Security Support Providers (SSPs)</a>.
     * @param {Pointer<Char>} ServerPrincName Returns a pointer to a pointer to the server principal name specified by the server application that called the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. The content of the returned name and its syntax are defined by the authentication service in use. For the SCHANNEL SSP, the principal name is in Microsoft-standard (msstd) format. For further information on msstd format, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">Principal Names</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>AuthnLevel</i> parameter.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>AuthnSvc</i> parameter.
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClient</b> from returning the <i>AuthzSvc</i> parameter. This parameter is not used by the RPC_C_AUTHN_WINNT authentication service. The returned value will always be RPC_C_AUTHZ_NONE.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthclientw
     * @since windows5.0
     */
    static RpcBindingInqAuthClientW(ClientBinding, Privs, ServerPrincName, AuthnLevel, AuthnSvc, AuthzSvc) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthClientW", "ptr", ClientBinding, "ptr", Privs, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "uint*", AuthzSvc, "int")
        return result
    }

    /**
     * A server application calls the RpcBindingInqAuthClientEx function to obtain extended information about the client program that made the remote procedure call. (RpcBindingInqAuthClientExA)
     * @remarks
     * A server application calls the 
     * <b>RpcBindingInqAuthClientEx</b> function to obtain the principal name or privilege attributes of the authenticated client that made the remote procedure call. In addition, 
     * <b>RpcBindingInqAuthClientEx</b> returns the authentication service, authentication level, and server principal name specified by the client. The server can use the returned data for authorization purposes.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for the returned argument string.
     * 
     * For synchronous RPC calls, the server application can use zero as the value for the <i>ClientBinding</i> parameter. Using zero retrieves the authentication and authorization information from the currently executing remote procedure call.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthClientEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} ClientBinding Client binding handle of the client that made the remote procedure call. This value can be zero. See Remarks.
     * @param {Pointer<Void>} Privs Returns a pointer to a handle to the privileged information for the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For <b>ncalrpc</b> calls, <i>Privs</i> contains a string with the client's principal name.
     * 
     * The server application must cast the <i>Privs</i> parameter to the data type specified by the <i>AuthnSvc</i> parameter. The data referenced by this argument is read-only and should not be modified by the server application. If the server wants to preserve any of the returned data, the server must copy the data into server-allocated memory.
     * 
     * For more information on SSPs, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/security-support-providers-ssps-">Security Support Providers (SSPs)</a>.
     * @param {Pointer<Byte>} ServerPrincName Returns a pointer to a pointer to the server principal name specified by the server application that called the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. The content of the returned name and its syntax are defined by the authentication service in use. For the SCHANNEL SSP, the principal name is in msstd format. For further information on msstd format, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">Principal Names</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>AuthnLevel</i> parameter.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>AuthnSvc</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  <i>AuthnSvc</i> corresponds to the <b>SECURITY_STATUS</b> returned by <a href="https://docs.microsoft.com/windows/desktop/api/sspi/nf-sspi-querycontextattributesa">QueryContextAttributes</a> on each certificate-based SSP for  <b>SECPKG_ATTR_DCE_INFO</b> or<b> SECPKG_ATTR_REMOTE_CERT_CONTEXT</b>.</div>
     * <div> </div>
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on the <i>Binding</i> binding handle. For a list of the RPC-supported authorization services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authorization-service-constants">Authorization-Service Constants </a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>AuthzSvc</i> parameter. This parameter is not used by the RPC_C_AUTHN_WINNT authentication service. The returned value will always be RPC_S_AUTHZ_NONE.
     * @param {Integer} Flags Controls the format of the principal name. This parameter can be set to the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_FULL_CERT_CHAIN"></a><a id="rpc_c_full_cert_chain"></a><dl>
     * <dt><b>RPC_C_FULL_CERT_CHAIN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Passes back the principal name in 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">fullsic</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthclientexa
     * @since windows5.0
     */
    static RpcBindingInqAuthClientExA(ClientBinding, Privs, ServerPrincName, AuthnLevel, AuthnSvc, AuthzSvc, Flags) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthClientExA", "ptr", ClientBinding, "ptr", Privs, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "uint*", AuthzSvc, "uint", Flags, "int")
        return result
    }

    /**
     * The RpcBindingInqAuthClientExW (Unicode) function (rpcdce.h) obtains extended information about the client program that made the remote procedure call.
     * @remarks
     * A server application calls the 
     * <b>RpcBindingInqAuthClientEx</b> function to obtain the principal name or privilege attributes of the authenticated client that made the remote procedure call. In addition, 
     * <b>RpcBindingInqAuthClientEx</b> returns the authentication service, authentication level, and server principal name specified by the client. The server can use the returned data for authorization purposes.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for the returned argument string.
     * 
     * For synchronous RPC calls, the server application can use zero as the value for the <i>ClientBinding</i> parameter. Using zero retrieves the authentication and authorization information from the currently executing remote procedure call.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthClientEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} ClientBinding Client binding handle of the client that made the remote procedure call. This value can be zero. See Remarks.
     * @param {Pointer<Void>} Privs Returns a pointer to a handle to the privileged information for the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For <b>ncalrpc</b> calls, <i>Privs</i> contains a string with the client's principal name.
     * 
     * The server application must cast the <i>Privs</i> parameter to the data type specified by the <i>AuthnSvc</i> parameter. The data referenced by this argument is read-only and should not be modified by the server application. If the server wants to preserve any of the returned data, the server must copy the data into server-allocated memory.
     * 
     * For more information on SSPs, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/security-support-providers-ssps-">Security Support Providers (SSPs)</a>.
     * @param {Pointer<Char>} ServerPrincName Returns a pointer to a pointer to the server principal name specified by the server application that called the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfo">RpcServerRegisterAuthInfo</a> function. The content of the returned name and its syntax are defined by the authentication service in use. For the SCHANNEL SSP, the principal name is in msstd format. For further information on msstd format, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">Principal Names</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>AuthnLevel</i> parameter.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service requested by the client application that made the remote procedure call on the <i>ClientBinding</i> binding handle. For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>AuthnSvc</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  <i>AuthnSvc</i> corresponds to the <b>SECURITY_STATUS</b> returned by <a href="https://docs.microsoft.com/windows/desktop/api/sspi/nf-sspi-querycontextattributesa">QueryContextAttributes</a> on each certificate-based SSP for  <b>SECPKG_ATTR_DCE_INFO</b> or<b> SECPKG_ATTR_REMOTE_CERT_CONTEXT</b>.</div>
     * <div> </div>
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on the <i>Binding</i> binding handle. For a list of the RPC-supported authorization services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authorization-service-constants">Authorization-Service Constants </a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthClientEx</b> from returning the <i>AuthzSvc</i> parameter. This parameter is not used by the RPC_C_AUTHN_WINNT authentication service. The returned value will always be RPC_S_AUTHZ_NONE.
     * @param {Integer} Flags Controls the format of the principal name. This parameter can be set to the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_FULL_CERT_CHAIN"></a><a id="rpc_c_full_cert_chain"></a><dl>
     * <dt><b>RPC_C_FULL_CERT_CHAIN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Passes back the principal name in 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">fullsic</a> format.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthclientexw
     * @since windows5.0
     */
    static RpcBindingInqAuthClientExW(ClientBinding, Privs, ServerPrincName, AuthnLevel, AuthnSvc, AuthzSvc, Flags) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthClientExW", "ptr", ClientBinding, "ptr", Privs, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "uint*", AuthzSvc, "uint", Flags, "int")
        return result
    }

    /**
     * The RpcBindingInqAuthInfo function returns authentication and authorization information from a binding handle. (RpcBindingInqAuthInfoA)
     * @remarks
     * A client application calls the 
     * <b>RpcBindingInqAuthInfo</b> function to view the authentication and authorization information associated with a server binding handle. A similar function, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexa">RpcBindingInqAuthInfoEx</a> additionally provides security quality-of-service information on the binding handle.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for that returned argument string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle from which authentication and authorization information is returned.
     * @param {Pointer<Byte>} ServerPrincName Returns a pointer to a pointer to the expected principal name of the server referenced in <i>Binding</i>. The content of the returned name and its syntax are defined by the authentication service in use.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication used for remote procedure calls made using <i>Binding</i>. See Note.
     * 
     * Specify a null value to prevent the function from returning the <i>AuthnLevel</i> parameter.
     * 
     * The level returned in the <i>AuthnLevel</i> parameter may be different from the level specified when the client called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> function. This discrepancy occurs when the RPC run-time library does not support the authentication level specified by the client and automatically upgrades to the next higher authentication level.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service specified for remote procedure calls made using <i>Binding</i>. See Note.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>AuthnSvc</i> parameter.
     * @param {Pointer<Void>} AuthIdentity Returns a pointer to a handle to the data structure that contains the client's authentication and authorization credentials specified for remote procedure calls made using <i>Binding</i>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>AuthIdentity</i> parameter.
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on <i>Binding</i> See Note.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>AuthzSvc</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoa
     * @since windows5.0
     */
    static RpcBindingInqAuthInfoA(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthInfoA", "ptr", Binding, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "ptr", AuthIdentity, "uint*", AuthzSvc, "int")
        return result
    }

    /**
     * The RpcBindingInqAuthInfoW (Unicode) function (rpcdce.h) returns authentication and authorization information from a binding handle.
     * @remarks
     * A client application calls the 
     * <b>RpcBindingInqAuthInfo</b> function to view the authentication and authorization information associated with a server binding handle. A similar function, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexa">RpcBindingInqAuthInfoEx</a> additionally provides security quality-of-service information on the binding handle.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for that returned argument string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle from which authentication and authorization information is returned.
     * @param {Pointer<Char>} ServerPrincName Returns a pointer to a pointer to the expected principal name of the server referenced in <i>Binding</i>. The content of the returned name and its syntax are defined by the authentication service in use.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication used for remote procedure calls made using <i>Binding</i>. See Note.
     * 
     * Specify a null value to prevent the function from returning the <i>AuthnLevel</i> parameter.
     * 
     * The level returned in the <i>AuthnLevel</i> parameter may be different from the level specified when the client called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> function. This discrepancy occurs when the RPC run-time library does not support the authentication level specified by the client and automatically upgrades to the next higher authentication level.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service specified for remote procedure calls made using <i>Binding</i>. See Note.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>AuthnSvc</i> parameter.
     * @param {Pointer<Void>} AuthIdentity Returns a pointer to a handle to the data structure that contains the client's authentication and authorization credentials specified for remote procedure calls made using <i>Binding</i>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>AuthIdentity</i> parameter.
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on <i>Binding</i> See Note.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfo</b> from returning the <i>AuthzSvc</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfow
     * @since windows5.0
     */
    static RpcBindingInqAuthInfoW(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthInfoW", "ptr", Binding, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "ptr", AuthIdentity, "uint*", AuthzSvc, "int")
        return result
    }

    /**
     * The RpcBindingSetAuthInfo function sets a binding handle's authentication and authorization information. (RpcBindingSetAuthInfoA)
     * @remarks
     * A client application calls the 
     * <b>RpcBindingSetAuthInfo</b> function to set up a server binding handle for making authenticated remote procedure calls. A client is not required to call this function.
     * 
     * Unless a client calls 
     * <b>RpcBindingSetAuthInfo</b>, no remote procedure calls on the <i>Binding</i> binding handle are authenticated. A server can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthclient">RpcBindingInqAuthClient</a> from within a remote procedure call to determine whether that call has been authenticated.
     * 
     * The 
     * <b>RpcBindingSetAuthInfo</b> function takes a snapshot of the credentials. Therefore, the memory dedicated to the <i>AuthIdentity</i> parameter can be freed before the binding handle.
     * 
     * Due to varying requirements of different versions of Microsoft RPC, Microsoft recommends that your application maintain a pointer to the <i>AuthIdentity</i> parameter for as long as the binding handle exists. Doing so increases the application's portability.
     * 
     * <b>Windows Server 2003 with SP1 and Windows XP with SP2:  </b>For Windows XP SP2 and Windows Server 2003 SP1, the pointer to the <i>AuthIdentity</i> parameter need not be maintained for the life of the binding handle. This pointer must only be maintained if subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfo">RpcBindingInqAuthInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexa">RpcBindingInqAuthInfoEx</a> are made.
     * 
     * <div class="alert"><b>Note</b>  The <b>RpcBindingSetAuthInfo</b> function must not be called on a binding handle while an RPC call on the same handle is in progress. Doing so produces undefined results.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingSetAuthInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle to which authentication and authorization information is to be applied.
     * @param {Pointer<Byte>} ServerPrincName Pointer to the expected principal name of the server referenced by <i>Binding</i>. The content of the name and its syntax are defined by the authentication service in use. 
     * 
     * <div class="alert"><b>Note</b>  For the set of allowable target names for SSPs, please refer to the comments in the <a href="https://docs.microsoft.com/windows/desktop/api/sspi/nf-sspi-initializesecuritycontexta">InitializeSecurityContext</a> documentation.</div>
     * <div> </div>
     * @param {Integer} AuthnLevel Level of authentication to be performed on remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication levels, see the list of 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * @param {Integer} AuthnSvc Authentication service to use. See Note. 
     * 
     * 
     * 
     * 
     * Specify RPC_C_AUTHN_NONE to turn off authentication for remote procedure calls made using <i>Binding</i>.
     * 
     * If RPC_C_AUTHN_DEFAULT is specified, the RPC run-time library uses the RPC_C_AUTHN_WINNT authentication service for remote procedure calls made using <i>Binding</i>.
     * @param {Pointer<Void>} AuthIdentity Handle to the structure containing the client's authentication and authorization credentials appropriate for the selected authentication and authorization service.When using the RPC_C_AUTHN_WINNT authentication service <i>AuthIdentity</i> should be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-sec_winnt_auth_identity_a">SEC_WINNT_AUTH_IDENTITY</a> structure (defined in Rpcdce.h). Kerberos and Negotiate authentication services also use the 
     * <b>SEC_WINNT_AUTH_IDENTITY</b> structure. 
     * 
     * 
     * 
     * 
     * When you select the RPC_C_AUTHN_GSS_SCHANNEL authentication service, the <i>AuthIdentity</i> parameter should be a pointer to an <b>SCHANNEL_CRED</b> structure (defined in Schannel.h). Specify a null value to use the security login context for the current address space. Pass the value RPC_C_NO_CREDENTIALS to use an anonymous log-in context.
     * 
     * <div class="alert"><b>Note</b>  When selecting the RPC_C_AUTHN_GSS_SCHANNEL authentication service, the <i>AuthIdentity</i> parameter may also be a pointer to a <b>SCH_CRED</b> structure. However, in Windows XP and later releases of Windows, the only acceptable structure to be passed as the <i>AuthIdentity</i> parameter for the RPC_C_AUTHN_GSS_SCHANNEL authentication service is the <b>SCHANNEL_CRED</b> structure.</div>
     * <div> </div>
     * @param {Integer} AuthzSvc Authorization service implemented by the server for the interface of interest. See Note. 
     * 
     * 
     * 
     * 
     * The validity and trustworthiness of authorization data, like any application data, depends on the authentication service and authentication level selected. This parameter is ignored when using the RPC_C_AUTHN_WINNT authentication service.
     * 
     * <div class="alert"><b>Note</b>  For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_AUTHN_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown authentication service.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoa
     * @since windows5.0
     */
    static RpcBindingSetAuthInfoA(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc) {
        ServerPrincName := ServerPrincName is String? StrPtr(ServerPrincName) : ServerPrincName

        result := DllCall("RPCRT4.dll\RpcBindingSetAuthInfoA", "ptr", Binding, "ptr", ServerPrincName, "uint", AuthnLevel, "uint", AuthnSvc, "ptr", AuthIdentity, "uint", AuthzSvc, "int")
        return result
    }

    /**
     * The RpcBindingSetAuthInfoEx function sets a binding handle's authentication, authorization, and security quality-of-service information. (ANSI)
     * @remarks
     * A client application calls the 
     * <b>RpcBindingSetAuthInfoEx</b> function to set up a server binding handle for making authenticated remote procedure calls. This function provides the capability to set security quality-of-service information on the binding handle. It is otherwise identical to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a>.
     * 
     * Unless a client calls 
     * <b>RpcBindingSetAuthInfoEx</b>, all remote procedure calls on <i>Binding</i> are unauthenticated. A client is not required to call this function.
     * 
     * The 
     * <b>RpcBindingSetAuthInfoEx</b> function takes a snapshot of the credentials. Therefore, the memory dedicated to the <i>AuthIdentity</i> parameter can be freed before the binding handle. The exception to this is when your application uses 
     * <b>RpcBindingSetAuthInfoEx</b> with RPC_C_QOS_IDENTITY_DYNAMIC and also specifies a non-<b>NULL</b> value for <i>AuthIdentity</i>.
     * 
     * <div class="alert"><b>Note</b>  The <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> function must not be called on a binding handle while an RPC call on the same handle is in progress. Doing so produces undefined results.</div>
     * <div> </div>
     * Due to the varying requirements of different versions of Microsoft RPC, Microsoft recommends that an application maintain a pointer to the <i>AuthIdentity</i> parameter for as long as the binding handle exists. Doing so increases the applications portability.
     * 
     * <b>Windows Server 2003 with SP1 and Windows XP with SP2:  </b>For Windows XP SP2 and Windows Server 2003 SP1, the pointer to the <i>AuthIdentity</i> parameter need not be maintained for the life of the binding handle. This pointer must only be maintained if subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfo">RpcBindingInqAuthInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexa">RpcBindingInqAuthInfoEx</a> are made.
     * 
     * <div class="alert"><b>Note</b>  The <b>ncalrpc</b> protocol sequence supports only RPC_C_AUTHN_WINNT, but does support mutual authentication; supply an SPN and request mutual authentication through the <i>SecurityQOS</i> parameter to achieve this.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingSetAuthInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle into which authentication and authorization information is set.
     * @param {Pointer<Byte>} ServerPrincName Pointer to the expected principal name of the server referenced by <i>Binding</i>. The content of the name and its syntax are defined by the authentication service in use.
     * 
     * <div class="alert"><b>Note</b>  For the set of allowable target names for SSPs, please refer to the comments in the <a href="https://docs.microsoft.com/windows/desktop/api/sspi/nf-sspi-initializesecuritycontexta">InitializeSecurityContext</a> documentation.</div>
     * <div> </div>
     * @param {Integer} AuthnLevel Level of authentication to be performed on remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * @param {Integer} AuthnSvc Authentication service to use.
     * 
     * Specify RPC_C_AUTHN_NONE to turn off authentication for remote procedure calls made using <i>Binding</i>.
     * 
     * If RPC_C_AUTHN_DEFAULT is specified, the RPC run-time library uses the RPC_C_AUTHN_WINNT authentication service for remote procedure calls made using <i>Binding</i>.
     * @param {Pointer<Void>} AuthIdentity Handle for the structure that contains the client's authentication and authorization credentials appropriate for the selected authentication and authorization service. 
     * 
     * 
     * 
     * 
     * When using the <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">RPC_C_AUTHN_WINNT</a> authentication service <i>AuthIdentity</i> should be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-sec_winnt_auth_identity_a">SEC_WINNT_AUTH_IDENTITY</a> structure (defined in Rpcdce.h). Kerberos and Negotiate authentication services also use the 
     * <b>SEC_WINNT_AUTH_IDENTITY</b> structure.
     * 
     * Specify a null value to use the security login context for the current address space. Pass the value RPC_C_NO_CREDENTIALS to use an anonymous log-in context. Note that RPC_C_NO_CREDENTIALS is only valid if RPC_C_AUTHN_GSS_SCHANNEL is selected as the authentication service.
     * @param {Integer} AuthzSvc Authorization service implemented by the server for the interface of interest. The validity and trustworthiness of authorization data, like any application data, depends on the authentication service and authentication level selected. This parameter is ignored when using the RPC_C_AUTHN_WINNT authentication service. See Note.
     * @param {Pointer<RPC_SECURITY_QOS>} SecurityQos TBD
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_AUTHN_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown authentication service.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa
     * @since windows5.0
     */
    static RpcBindingSetAuthInfoExA(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc, SecurityQos) {
        ServerPrincName := ServerPrincName is String? StrPtr(ServerPrincName) : ServerPrincName

        result := DllCall("RPCRT4.dll\RpcBindingSetAuthInfoExA", "ptr", Binding, "ptr", ServerPrincName, "uint", AuthnLevel, "uint", AuthnSvc, "ptr", AuthIdentity, "uint", AuthzSvc, "ptr", SecurityQos, "int")
        return result
    }

    /**
     * The RpcBindingSetAuthInfoW (Unicode) function (rpcdce.h) sets a binding handle's authentication and authorization information.
     * @remarks
     * A client application calls the 
     * <b>RpcBindingSetAuthInfo</b> function to set up a server binding handle for making authenticated remote procedure calls. A client is not required to call this function.
     * 
     * Unless a client calls 
     * <b>RpcBindingSetAuthInfo</b>, no remote procedure calls on the <i>Binding</i> binding handle are authenticated. A server can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthclient">RpcBindingInqAuthClient</a> from within a remote procedure call to determine whether that call has been authenticated.
     * 
     * The 
     * <b>RpcBindingSetAuthInfo</b> function takes a snapshot of the credentials. Therefore, the memory dedicated to the <i>AuthIdentity</i> parameter can be freed before the binding handle.
     * 
     * Due to varying requirements of different versions of Microsoft RPC, Microsoft recommends that your application maintain a pointer to the <i>AuthIdentity</i> parameter for as long as the binding handle exists. Doing so increases the application's portability.
     * 
     * <b>Windows Server 2003 with SP1 and Windows XP with SP2:  </b>For Windows XP SP2 and Windows Server 2003 SP1, the pointer to the <i>AuthIdentity</i> parameter need not be maintained for the life of the binding handle. This pointer must only be maintained if subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfo">RpcBindingInqAuthInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexa">RpcBindingInqAuthInfoEx</a> are made.
     * 
     * <div class="alert"><b>Note</b>  The <b>RpcBindingSetAuthInfo</b> function must not be called on a binding handle while an RPC call on the same handle is in progress. Doing so produces undefined results.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingSetAuthInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle to which authentication and authorization information is to be applied.
     * @param {Pointer<Char>} ServerPrincName Pointer to the expected principal name of the server referenced by <i>Binding</i>. The content of the name and its syntax are defined by the authentication service in use. 
     * 
     * <div class="alert"><b>Note</b>  For the set of allowable target names for SSPs, please refer to the comments in the <a href="https://docs.microsoft.com/windows/desktop/api/sspi/nf-sspi-initializesecuritycontexta">InitializeSecurityContext</a> documentation.</div>
     * <div> </div>
     * @param {Integer} AuthnLevel Level of authentication to be performed on remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication levels, see the list of 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * @param {Integer} AuthnSvc Authentication service to use. See Note. 
     * 
     * 
     * 
     * 
     * Specify RPC_C_AUTHN_NONE to turn off authentication for remote procedure calls made using <i>Binding</i>.
     * 
     * If RPC_C_AUTHN_DEFAULT is specified, the RPC run-time library uses the RPC_C_AUTHN_WINNT authentication service for remote procedure calls made using <i>Binding</i>.
     * @param {Pointer<Void>} AuthIdentity Handle to the structure containing the client's authentication and authorization credentials appropriate for the selected authentication and authorization service.When using the RPC_C_AUTHN_WINNT authentication service <i>AuthIdentity</i> should be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-sec_winnt_auth_identity_a">SEC_WINNT_AUTH_IDENTITY</a> structure (defined in Rpcdce.h). Kerberos and Negotiate authentication services also use the 
     * <b>SEC_WINNT_AUTH_IDENTITY</b> structure. 
     * 
     * When you select the RPC_C_AUTHN_GSS_SCHANNEL authentication service, the <i>AuthIdentity</i> parameter should be a pointer to an <b>SCHANNEL_CRED</b> structure (defined in Schannel.h). Specify a null value to use the security login context for the current address space. Pass the value RPC_C_NO_CREDENTIALS to use an anonymous log-in context.
     * 
     * <div class="alert"><b>Note</b>  When selecting the RPC_C_AUTHN_GSS_SCHANNEL authentication service, the <i>AuthIdentity</i> parameter may also be a pointer to a <b>SCH_CRED</b> structure. However, in Windows XP and later releases of Windows, the only acceptable structure to be passed as the <i>AuthIdentity</i> parameter for the RPC_C_AUTHN_GSS_SCHANNEL authentication service is the <b>SCHANNEL_CRED</b> structure.</div>
     * <div> </div>
     * @param {Integer} AuthzSvc Authorization service implemented by the server for the interface of interest. See Note. 
     * 
     * 
     * 
     * 
     * The validity and trustworthiness of authorization data, like any application data, depends on the authentication service and authentication level selected. This parameter is ignored when using the RPC_C_AUTHN_WINNT authentication service.
     * 
     * <div class="alert"><b>Note</b>  For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_AUTHN_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown authentication service.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfow
     * @since windows5.0
     */
    static RpcBindingSetAuthInfoW(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc) {
        ServerPrincName := ServerPrincName is String? StrPtr(ServerPrincName) : ServerPrincName

        result := DllCall("RPCRT4.dll\RpcBindingSetAuthInfoW", "ptr", Binding, "ptr", ServerPrincName, "uint", AuthnLevel, "uint", AuthnSvc, "ptr", AuthIdentity, "uint", AuthzSvc, "int")
        return result
    }

    /**
     * The RpcBindingSetAuthInfoEx function sets a binding handle's authentication, authorization, and security quality-of-service information. (Unicode)
     * @remarks
     * A client application calls the 
     * <b>RpcBindingSetAuthInfoEx</b> function to set up a server binding handle for making authenticated remote procedure calls. This function provides the capability to set security quality-of-service information on the binding handle. It is otherwise identical to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a>.
     * 
     * Unless a client calls 
     * <b>RpcBindingSetAuthInfoEx</b>, all remote procedure calls on <i>Binding</i> are unauthenticated. A client is not required to call this function.
     * 
     * The 
     * <b>RpcBindingSetAuthInfoEx</b> function takes a snapshot of the credentials. Therefore, the memory dedicated to the <i>AuthIdentity</i> parameter can be freed before the binding handle. The exception to this is when your application uses 
     * <b>RpcBindingSetAuthInfoEx</b> with RPC_C_QOS_IDENTITY_DYNAMIC and also specifies a non-<b>NULL</b> value for <i>AuthIdentity</i>.
     * 
     * <div class="alert"><b>Note</b>  The <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> function must not be called on a binding handle while an RPC call on the same handle is in progress. Doing so produces undefined results.</div>
     * <div> </div>
     * Due to the varying requirements of different versions of Microsoft RPC, Microsoft recommends that an application maintain a pointer to the <i>AuthIdentity</i> parameter for as long as the binding handle exists. Doing so increases the applications portability.
     * 
     * <b>Windows Server 2003 with SP1 and Windows XP with SP2:  </b>For Windows XP SP2 and Windows Server 2003 SP1, the pointer to the <i>AuthIdentity</i> parameter need not be maintained for the life of the binding handle. This pointer must only be maintained if subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfo">RpcBindingInqAuthInfo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexa">RpcBindingInqAuthInfoEx</a> are made.
     * 
     * <div class="alert"><b>Note</b>  The <b>ncalrpc</b> protocol sequence supports only RPC_C_AUTHN_WINNT, but does support mutual authentication; supply an SPN and request mutual authentication through the <i>SecurityQOS</i> parameter to achieve this.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingSetAuthInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle into which authentication and authorization information is set.
     * @param {Pointer<Char>} ServerPrincName Pointer to the expected principal name of the server referenced by <i>Binding</i>. The content of the name and its syntax are defined by the authentication service in use.
     * 
     * <div class="alert"><b>Note</b>  For the set of allowable target names for SSPs, please refer to the comments in the <a href="https://docs.microsoft.com/windows/desktop/api/sspi/nf-sspi-initializesecuritycontexta">InitializeSecurityContext</a> documentation.</div>
     * <div> </div>
     * @param {Integer} AuthnLevel Level of authentication to be performed on remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>.
     * @param {Integer} AuthnSvc Authentication service to use.
     * 
     * Specify RPC_C_AUTHN_NONE to turn off authentication for remote procedure calls made using <i>Binding</i>.
     * 
     * If RPC_C_AUTHN_DEFAULT is specified, the RPC run-time library uses the RPC_C_AUTHN_WINNT authentication service for remote procedure calls made using <i>Binding</i>.
     * @param {Pointer<Void>} AuthIdentity Handle for the structure that contains the client's authentication and authorization credentials appropriate for the selected authentication and authorization service. 
     * 
     * 
     * 
     * 
     * When using the <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">RPC_C_AUTHN_WINNT</a> authentication service <i>AuthIdentity</i> should be a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-sec_winnt_auth_identity_a">SEC_WINNT_AUTH_IDENTITY</a> structure (defined in Rpcdce.h). Kerberos and Negotiate authentication services also use the 
     * <b>SEC_WINNT_AUTH_IDENTITY</b> structure.
     * 
     * Specify a null value to use the security login context for the current address space. Pass the value RPC_C_NO_CREDENTIALS to use an anonymous log-in context. Note that RPC_C_NO_CREDENTIALS is only valid if RPC_C_AUTHN_GSS_SCHANNEL is selected as the authentication service.
     * @param {Integer} AuthzSvc Authorization service implemented by the server for the interface of interest. The validity and trustworthiness of authorization data, like any application data, depends on the authentication service and authentication level selected. This parameter is ignored when using the RPC_C_AUTHN_WINNT authentication service. See Note.
     * @param {Pointer<RPC_SECURITY_QOS>} SecurityQOS Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_security_qos">RPC_SECURITY_QOS</a> structure, which defines the security quality-of-service. 
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.</div>
     * <div> </div>
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_AUTHN_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown authentication service.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoexw
     * @since windows5.0
     */
    static RpcBindingSetAuthInfoExW(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc, SecurityQOS) {
        ServerPrincName := ServerPrincName is String? StrPtr(ServerPrincName) : ServerPrincName

        result := DllCall("RPCRT4.dll\RpcBindingSetAuthInfoExW", "ptr", Binding, "ptr", ServerPrincName, "uint", AuthnLevel, "uint", AuthnSvc, "ptr", AuthIdentity, "uint", AuthzSvc, "ptr", SecurityQOS, "int")
        return result
    }

    /**
     * The RpcBindingInqAuthInfoEx function returns authentication, authorization, and security quality-of-service information from a binding handle. (ANSI)
     * @remarks
     * A client application calls the 
     * <b>RpcBindingInqAuthInfoEx</b> function to view the authentication and authorization information associated with a server binding handle. This function provides the ability to inquire about the security quality of service on the binding handle. It is otherwise identical to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfo">RpcBindingInqAuthInfo</a>.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for that returned argument string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle from which authentication and authorization information is returned.
     * @param {Pointer<Byte>} ServerPrincName Returns a pointer to a pointer to the expected principal name of the server referenced in <i>Binding</i>. The content of the returned name and its syntax are defined by the authentication service in use.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication used for remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>. Specify a null value to prevent the function from returning the <i>AuthnLevel</i> parameter.
     * 
     * The level returned in the <i>AuthnLevel</i> parameter may be different from the level specified when the client called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa">RpcBindingSetAuthInfoEx</a> function. This discrepancy happens when the RPC run-time library does not support the authentication level specified by the client and automatically upgrades to the next higher authentication level.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service specified for remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>AuthnSvc</i> parameter.
     * @param {Pointer<Void>} AuthIdentity Returns a pointer to a handle to the data structure that contains the client's authentication and authorization credentials specified for remote procedure calls made using <i>Binding</i>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>AuthIdentity</i> parameter.
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on <i>Binding</i>. For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>AuthzSvc</i> parameter.
     * @param {Integer} RpcQosVersion Passes value of current version (needed for forward compatibility if extensions are made to this function). Always set this parameter to RPC_C_SECURITY_QOS_VERSION.
     * @param {Pointer<RPC_SECURITY_QOS>} SecurityQOS Returns pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_security_qos">RPC_SECURITY_QOS</a> structure, which defines quality-of-service settings.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexa
     * @since windows5.0
     */
    static RpcBindingInqAuthInfoExA(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc, RpcQosVersion, SecurityQOS) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthInfoExA", "ptr", Binding, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "ptr", AuthIdentity, "uint*", AuthzSvc, "uint", RpcQosVersion, "ptr", SecurityQOS, "int")
        return result
    }

    /**
     * The RpcBindingInqAuthInfoEx function returns authentication, authorization, and security quality-of-service information from a binding handle. (Unicode)
     * @remarks
     * A client application calls the 
     * <b>RpcBindingInqAuthInfoEx</b> function to view the authentication and authorization information associated with a server binding handle. This function provides the ability to inquire about the security quality of service on the binding handle. It is otherwise identical to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfo">RpcBindingInqAuthInfo</a>.
     * 
     * The RPC run-time library allocates memory for the returned <i>ServerPrincName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for that returned argument string.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcBindingInqAuthInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} Binding Server binding handle from which authentication and authorization information is returned.
     * @param {Pointer<Char>} ServerPrincName Returns a pointer to a pointer to the expected principal name of the server referenced in <i>Binding</i>. The content of the returned name and its syntax are defined by the authentication service in use.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>ServerPrincName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} AuthnLevel Returns a pointer set to the level of authentication used for remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication levels, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-level-constants">Authentication-Level Constants</a>. Specify a null value to prevent the function from returning the <i>AuthnLevel</i> parameter.
     * 
     * The level returned in the <i>AuthnLevel</i> parameter may be different from the level specified when the client called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa">RpcBindingSetAuthInfoEx</a> function. This discrepancy happens when the RPC run-time library does not support the authentication level specified by the client and automatically upgrades to the next higher authentication level.
     * @param {Pointer<UInt32>} AuthnSvc Returns a pointer set to the authentication service specified for remote procedure calls made using <i>Binding</i>. For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>AuthnSvc</i> parameter.
     * @param {Pointer<Void>} AuthIdentity Returns a pointer to a handle to the data structure that contains the client's authentication and authorization credentials specified for remote procedure calls made using <i>Binding</i>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>AuthIdentity</i> parameter.
     * @param {Pointer<UInt32>} AuthzSvc Returns a pointer set to the authorization service requested by the client application that made the remote procedure call on <i>Binding</i>. For a list of the RPC-supported authentication services, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/authentication-service-constants">Authentication-Service Constants</a>.
     * 
     * Specify a null value to prevent 
     * <b>RpcBindingInqAuthInfoEx</b> from returning the <i>AuthzSvc</i> parameter.
     * @param {Integer} RpcQosVersion Passes value of current version (needed for forward compatibility if extensions are made to this function). Always set this parameter to RPC_C_SECURITY_QOS_VERSION.
     * @param {Pointer<RPC_SECURITY_QOS>} SecurityQOS Returns pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_security_qos">RPC_SECURITY_QOS</a> structure, which defines quality-of-service settings.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_BINDING_HAS_NO_AUTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Binding has no authentication information.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindinginqauthinfoexw
     * @since windows5.0
     */
    static RpcBindingInqAuthInfoExW(Binding, ServerPrincName, AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc, RpcQosVersion, SecurityQOS) {
        result := DllCall("RPCRT4.dll\RpcBindingInqAuthInfoExW", "ptr", Binding, "ptr", ServerPrincName, "uint*", AuthnLevel, "uint*", AuthnSvc, "ptr", AuthIdentity, "uint*", AuthzSvc, "uint", RpcQosVersion, "ptr", SecurityQOS, "int")
        return result
    }

    /**
     * The RpcServerCompleteSecurityCallback function completes an asynchronous security callback.
     * @param {Pointer<Void>} BindingHandle The Server Call that this function dispatches or fails.
     * @param {Integer} Status Specifies an RPC status. If this value is not <b>RPC_S_OK</b>, the Server Call is failed with a value of <b>RPC_S_ACCESS_DENIED</b>.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @returns {Integer} This function returns RPC_STATUS.
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcservercompletesecuritycallback
     * @since windows5.0
     */
    static RpcServerCompleteSecurityCallback(BindingHandle, Status) {
        result := DllCall("RPCRT4.dll\RpcServerCompleteSecurityCallback", "ptr", BindingHandle, "int", Status, "int")
        return result
    }

    /**
     * The RpcServerRegisterAuthInfo function registers authentication information with the RPC run-time library. (RpcServerRegisterAuthInfoA)
     * @remarks
     * A server application calls 
     * <b>RpcServerRegisterAuthInfo</b> to register an authentication service to use for authenticating remote procedure calls. A server calls this routine once for each authentication service the server wants to register. If the server calls this function more than once for a given authentication service, the results are undefined.
     * 
     * The authentication service that a client application specifies (using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> or 
     * <b>RpcServerRegisterAuthInfo</b>) must be one of the authentication services specified by the server application. Otherwise, the client's remote procedure call fails and an RPC_S_UNKNOWN_AUTHN_SERVICE status code is returned.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerRegisterAuthInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} ServerPrincName Pointer to the principal name to use for the server when authenticating remote procedure calls using the service specified by the <i>AuthnSvc</i> parameter. The content of the name and its syntax are defined by the authentication service in use. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">Principal Names</a>.
     * @param {Integer} AuthnSvc Authentication service to use when the server receives a request for a remote procedure call.
     * @param {Pointer<RPC_AUTH_KEY_RETRIEVAL_FN>} GetKeyFn Address of a server-application-provided routine that returns encryption keys. See 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_auth_key_retrieval_fn">RPC_AUTH_KEY_RETRIEVAL_FN</a>. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> parameter value to use the default method of encryption-key acquisition. In this case, the authentication service specifies the default behavior. Set this parameter to <b>NULL</b> when using the RPC_C_AUTHN_WINNT authentication service.
     * 
     * <table>
     * <tr>
     * <th>Authentication service</th>
     * <th>GetKeyFn</th>
     * <th>Arg</th>
     * <th>Run-time behavior</th>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DPA</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_GSS_KERBEROS</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_GSS_NEGOTIATE</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_GSS_SCHANNEL</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_MQ</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_MSN</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_WINNT</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DCE_PRIVATE</td>
     * <td><b>NULL</b></td>
     * <td>Non-<b>null</b></td>
     * <td>Uses default method of encryption-key acquisition from specified key table; specified argument is passed to default acquisition function.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DCE_PRIVATE</td>
     * <td>Non-<b>null</b></td>
     * <td><b>NULL</b></td>
     * <td>Uses specified encryption-key acquisition function to obtain keys from default key table.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DCE_PRIVATE</td>
     * <td>Non-<b>null</b></td>
     * <td>Non-<b>null</b></td>
     * <td>Uses specified encryption-key acquisition function to obtain keys from specified key table; specified argument is passed to acquisition function.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DEC_PUBLIC</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Reserved for future use.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * <div> </div>
     * 
     * 
     * The RPC run-time library passes the <i>ServerPrincName</i> parameter value from 
     * <b>RpcServerRegisterAuthInfo</b> as the <i>ServerPrincName</i> parameter value to the <i>GetKeyFn</i> acquisition function. The RPC run-time library automatically provides a value for the key version (<i>KeyVer</i>) parameter. For a <i>KeyVer</i> parameter value of zero, the acquisition function must return the most recent key available. The retrieval function returns the authentication key in the <i>Key</i> parameter.
     * 
     * If the acquisition function called from 
     * <b>RpcServerRegisterAuthInfo</b> returns a status other than RPC_S_OK, then this function fails and returns an error code to the server application. If the acquisition function called by the RPC run-time library while authenticating a client's remote procedure call request returns a status other than RPC_S_OK, the request fails and the RPC run-time library returns an error code to the client application.
     * @param {Pointer<Void>} Arg Pointer to a parameter to pass to the <i>GetKeyFn</i> routine, if specified. This parameter can also be used to pass a pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/schannel/ns-schannel-schannel_cred">SCHANNEL_CRED</a> structure to specify explicit credentials if the authentication service is set to SCHANNEL. 
     * 
     * 
     * If the <i>Arg</i> parameter is set to <b>NULL</b>, this function will use the default certificate or credential if it has been set up in the directory service.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_AUTHN_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The authentication service is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfoa
     * @since windows5.0
     */
    static RpcServerRegisterAuthInfoA(ServerPrincName, AuthnSvc, GetKeyFn, Arg) {
        ServerPrincName := ServerPrincName is String? StrPtr(ServerPrincName) : ServerPrincName

        result := DllCall("RPCRT4.dll\RpcServerRegisterAuthInfoA", "ptr", ServerPrincName, "uint", AuthnSvc, "ptr", GetKeyFn, "ptr", Arg, "int")
        return result
    }

    /**
     * The RpcServerRegisterAuthInfoW (Unicode) function (rpcdce.h) registers authentication information with the RPC run-time library.
     * @remarks
     * A server application calls 
     * <b>RpcServerRegisterAuthInfo</b> to register an authentication service to use for authenticating remote procedure calls. A server calls this routine once for each authentication service the server wants to register. If the server calls this function more than once for a given authentication service, the results are undefined.
     * 
     * The authentication service that a client application specifies (using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> or 
     * <b>RpcServerRegisterAuthInfo</b>) must be one of the authentication services specified by the server application. Otherwise, the client's remote procedure call fails and an RPC_S_UNKNOWN_AUTHN_SERVICE status code is returned.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerRegisterAuthInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} ServerPrincName Pointer to the principal name to use for the server when authenticating remote procedure calls using the service specified by the <i>AuthnSvc</i> parameter. The content of the name and its syntax are defined by the authentication service in use. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">Principal Names</a>.
     * @param {Integer} AuthnSvc Authentication service to use when the server receives a request for a remote procedure call.
     * @param {Pointer<RPC_AUTH_KEY_RETRIEVAL_FN>} GetKeyFn Address of a server-application-provided routine that returns encryption keys. See 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_auth_key_retrieval_fn">RPC_AUTH_KEY_RETRIEVAL_FN</a>. 
     * 
     * 
     * 
     * 
     * Specify a <b>NULL</b> parameter value to use the default method of encryption-key acquisition. In this case, the authentication service specifies the default behavior. Set this parameter to <b>NULL</b> when using the RPC_C_AUTHN_WINNT authentication service.
     * 
     * <table>
     * <tr>
     * <th>Authentication service</th>
     * <th>GetKeyFn</th>
     * <th>Arg</th>
     * <th>Run-time behavior</th>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DPA</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_GSS_KERBEROS</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_GSS_NEGOTIATE</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_GSS_SCHANNEL</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_MQ</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_MSN</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_WINNT</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Does not support</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DCE_PRIVATE</td>
     * <td><b>NULL</b></td>
     * <td>Non-<b>null</b></td>
     * <td>Uses default method of encryption-key acquisition from specified key table; specified argument is passed to default acquisition function.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DCE_PRIVATE</td>
     * <td>Non-<b>null</b></td>
     * <td><b>NULL</b></td>
     * <td>Uses specified encryption-key acquisition function to obtain keys from default key table.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DCE_PRIVATE</td>
     * <td>Non-<b>null</b></td>
     * <td>Non-<b>null</b></td>
     * <td>Uses specified encryption-key acquisition function to obtain keys from specified key table; specified argument is passed to acquisition function.</td>
     * </tr>
     * <tr>
     * <td>RPC_C_AUTHN_DEC_PUBLIC</td>
     * <td>Ignored</td>
     * <td>Ignored</td>
     * <td>Reserved for future use.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * <div> </div>
     * 
     * 
     * The RPC run-time library passes the <i>ServerPrincName</i> parameter value from 
     * <b>RpcServerRegisterAuthInfo</b> as the <i>ServerPrincName</i> parameter value to the <i>GetKeyFn</i> acquisition function. The RPC run-time library automatically provides a value for the key version (<i>KeyVer</i>) parameter. For a <i>KeyVer</i> parameter value of zero, the acquisition function must return the most recent key available. The retrieval function returns the authentication key in the <i>Key</i> parameter.
     * 
     * If the acquisition function called from 
     * <b>RpcServerRegisterAuthInfo</b> returns a status other than RPC_S_OK, then this function fails and returns an error code to the server application. If the acquisition function called by the RPC run-time library while authenticating a client's remote procedure call request returns a status other than RPC_S_OK, the request fails and the RPC run-time library returns an error code to the client application.
     * @param {Pointer<Void>} Arg Pointer to a parameter to pass to the <i>GetKeyFn</i> routine, if specified. This parameter can also be used to pass a pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/schannel/ns-schannel-schannel_cred">SCHANNEL_CRED</a> structure to specify explicit credentials if the authentication service is set to SCHANNEL.  
     * 
     * 
     * If the <i>Arg</i> parameter is set to <b>NULL</b>, this function will use the default certificate or credential if it has been set up in the directory service.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_AUTHN_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The authentication service is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterauthinfow
     * @since windows5.0
     */
    static RpcServerRegisterAuthInfoW(ServerPrincName, AuthnSvc, GetKeyFn, Arg) {
        ServerPrincName := ServerPrincName is String? StrPtr(ServerPrincName) : ServerPrincName

        result := DllCall("RPCRT4.dll\RpcServerRegisterAuthInfoW", "ptr", ServerPrincName, "uint", AuthnSvc, "ptr", GetKeyFn, "ptr", Arg, "int")
        return result
    }

    /**
     * An application calls RpcBindingServerFromClient to convert a client binding handle into a partially-bound server binding handle.
     * @remarks
     * The following protocol sequences support 
     * <b>RpcBindingServerFromClient</b>:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncadg-ip-udp">ncadg_ip_udp</a>
     * </li>
     * <li>
     * <a href="https://msdn.microsoft.com/">ncadg_ipx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-ip-tcp">ncacn_ip_tcp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-spx">ncacn_spx</a>.</li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/ncacn-np">ncacn_np</a> (effective with Windows 2000)</li>
     * <li>
     * <a href="https://msdn.microsoft.com/">ncacn_http</a>
     * </li>
     * <li>ncalrpc</li>
     * </ul>
     * An application gets a client binding handle from the RPC run-time. When the remote procedure call arrives at a server, the run-time creates a client binding handle that contains information about the calling client. The run-time passes this handle to the server manager function as the first argument.
     * 
     * Calling 
     * <b>RpcBindingServerFromClient</b> converts this client handle to a server handle that has these properties:
     * 
     * <ul>
     * <li>The server handle is a partially-bound handle. It contains a network address for the calling client, but lacks an endpoint.</li>
     * <li>The server handle contains the same object 
     * <a href="https://msdn.microsoft.com/">UUID</a> used by the calling client. This can be the nil UUID. For more information on how a client specifies an object UUID for a call, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetobject">RpcBindingsetObject</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina">RpcNsBindingLookupBegin</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfromstringbinding">RpcBindingFromStringBinding</a>.</li>
     * <li>The server handle contains no authentication information.</li>
     * </ul>
     * The server application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> to free the resources used by the server binding handle once it is no longer needed.
     * 
     * <div class="alert"><b>Note</b>  To query a client's address, an application starts by calling the RpcBindingServerFromClient function to obtain a partially bound server binding handle.  The server binding handle can be used to obtain a string binding by invoking RpcBindingToStringBinding.  The server can then call RpcStringBindingParse to extract the client's network address from the string binding.</div>
     * <div> </div>
     * @param {Pointer<Void>} ClientBinding Client binding handle to convert to a server binding handle. If a value of zero is specified, the server impersonates the client that is being served by this server thread.
     * 
     * <div class="alert"><b>Note</b>  This parameter cannot be <b>NULL</b> in Windows NT 4.0.</div>
     * <div> </div>
     * @param {Pointer<Void>} ServerBinding Returns a server binding handle.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Cannot determine the client's host. See Remarks for a list of supported protocol sequences.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingserverfromclient
     * @since windows5.0
     */
    static RpcBindingServerFromClient(ClientBinding, ServerBinding) {
        result := DllCall("RPCRT4.dll\RpcBindingServerFromClient", "ptr", ClientBinding, "ptr", ServerBinding, "int")
        return result
    }

    /**
     * Use the RpcRaiseException function to raise an exception. The function does not return to the caller.
     * @remarks
     * <b>RpcRaiseException</b> raises an exception. The exception handler can then handle the exception. For more information about handling exceptions, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/making-rpc-function-calls">Making RPC Function Calls</a>.
     * @param {Integer} exception Exception code for the exception.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcraiseexception
     * @since windows5.0
     */
    static RpcRaiseException(exception) {
        DllCall("RPCRT4.dll\RpcRaiseException", "int", exception)
    }

    /**
     * The RpcTestCancel function checks for a cancel indication.
     * @remarks
     * An application server stub calls 
     * <b>RpcTestCancel</b> to determine whether a call has been canceled. If the call has been canceled, RPC_S_OK is returned; otherwise, another value is returned.
     * 
     * This function should be called periodically by the server stub so that it can respond to cancels in a timely fashion. If the function returns RPC_S_OK, the stub should clean up its data structures and return to the client.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call has been canceled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other values</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call has not been canceled.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * It is not unusual for the 
     * <b>RpcTestCancel</b> function to return the value ERROR_ACCESS_DENIED. This indicates that the remote procedure call has not been canceled.
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpctestcancel
     * @since windows5.0
     */
    static RpcTestCancel() {
        result := DllCall("RPCRT4.dll\RpcTestCancel", "int")
        return result
    }

    /**
     * The server calls RpcServerTestCancel to test for client cancel requests.
     * @remarks
     * The server calls 
     * <b>RpcServerTestCancel</b> to find out if the client has requested cancelation of an outstanding call. The 
     * <b>RpcServerTestCancel</b> function only indicates whether a client has canceled the call; state is not changed on the server or client. The canceled call must still be completed or aborted by the RPC server, using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasynccompletecall">RpcAsyncCompleteCall</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasyncabortcall">RpcAsyncAbortCall</a> function calls, respectively.
     * 
     * The <i>BindingHandle</i> parameter specifies the call on which to test. If the parameter has a value of zero, the call on the current thread is tested. The server can call the 
     * <b>RpcServerTestCancel(RpcAsyncGetCallHandle(pAsync))</b> function to test for a cancel message using the asynchronous handle to obtain the binding handle.
     * @param {Pointer<Void>} BindingHandle Call to test for cancel commands. If a value of zero is specified, the server impersonates the client that is being served by this server thread.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call was canceled by the client. The server must still complete or abort the call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_CALL_ACTIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no active call on the current thread.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CALL_IN_PROGRESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call was not canceled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle is not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcservertestcancel
     * @since windows5.0
     */
    static RpcServerTestCancel(BindingHandle) {
        result := DllCall("RPCRT4.dll\RpcServerTestCancel", "ptr", BindingHandle, "int")
        return result
    }

    /**
     * The RpcCancelThread function cancels a thread. The RpcCancelThread function should not be used to cancel asynchronous RPC calls; instead, use the RpcAsyncCancelCall function to cancel an asynchronous RPC call.
     * @remarks
     * The 
     * <b>RpcCancelThread</b> function allows one client thread to cancel an RPC in progress on another client thread. When the function is called, the server run-time is informed of the cancel operation. The server stub can determine if the call has been canceled by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpctestcancel">RpcTestCancel</a>. If the call has been canceled, the server stub should clean up and return control to the client.
     * 
     * The <b>RpcCancelThread</b> function cannot be used to cancel a call that has issued a static callback.  Do not cancel remote procedure calls that may call a function declared with the <b>[callback]</b> attribute in the IDL-file.
     * 
     * By default, the client waits forever for the server to return control after a cancel. To reduce this time, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtsetcanceltimeout">RpcMgmtSetCancelTimeout</a>, specifying the number of seconds to wait for a response. If the server does not return within this interval, the call fails at the client with an <b>RPC_S_CALL_FAILED</b> exception. The server stub continues to run.
     * 
     * If you are using the named pipes protocol, <b>ncacn_np</b>, you must specify a finite time-out.
     * 
     * You can use 
     * <b>RpcCancelThread</b> with any of the connection-oriented protocols <b>(ncacn_*)</b> and with any of the datagram protocols except <b>ncadg_mq</b> and <b>ncalrpc</b>. 
     * 
     * <b>Note</b>  Windows XP/2000 The <b>RpcCancelThread</b> function is not available for <b>ncacn_http</b>.  The <b>RpcCancelThread</b> function supports <b>ncacn_http</b> on Windows Server 2003 or later operating systems and Windows XP with Service Pack 1 (SP1) and later.
     * @param {Pointer<Void>} Thread Handle of the thread to cancel.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Thread handle does not have privilege. Thread handles must have THREAD_SET_CONTEXT set properly for the function to execute properly.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Called by an MS-DOS or Windows 3.x client.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpccancelthread
     * @since windows5.0
     */
    static RpcCancelThread(Thread) {
        result := DllCall("RPCRT4.dll\RpcCancelThread", "ptr", Thread, "int")
        return result
    }

    /**
     * The RpcCancelThreadEx function stops the execution of a thread.
     * @remarks
     * The <b>RpcCancelThreadEx</b> function allows one client thread to cancel an RPC in progress on another client thread. When the function is called, the server run-time is informed of the cancel operation. The server stub can determine if the call has been canceled by calling 
     * <a href="https://docs.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpctestcancel">RpcTestCancel</a>. If the call has been canceled, the server stub should clean up and return control to the client.
     * 
     * Using the <i>Timeout</i> parameter, your application can specify the number of seconds to wait for a response. If the server does not return within this interval, the call fails at the client with an RPC_S_CALL_CANCELLED exception. The server stub continues to execute.
     * 
     * If you are using the named pipes protocol, <a href="https://docs.microsoft.com/windows/win32/midl/ncacn-np">ncacn_np</a>, you must specify a finite time-out.
     * 
     * <div class="alert"><b>Note</b>  You can use <b>RpcCancelThreadEx</b> with any of the connection-oriented protocols (<b>ncacn_*</b>) except 
     * <a href="https://docs.microsoft.com/windows/win32/midl/ncacn-http">ncacn_http</a>, and with any of the datagram protocols except 
     * <a href="https://docs.microsoft.com/windows/win32/midl/ncadg-mq">ncadg_mq</a> and 
     * <a href="https://docs.microsoft.com/windows/win32/midl/ncalrpc">ncalrpc</a>.</div>
     * <div> </div>
     * @param {Pointer<Void>} Thread Handle of the thread to cancel.
     * @param {Integer} Timeout Number of seconds to wait for the thread to be canceled before this function returns. To specify that a client waits an indefinite amount of time, pass the value RPC_C_CANCEL_INFINITE_TIMEOUT.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ACCESS_DENIED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Thread handle does not have privilege. Thread handles must have THREAD_SET_CONTEXT set properly for the function to execute properly.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Called by an MS-DOS or Windows 3.<i>x</i> client.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/win32/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpccancelthreadex
     * @since windows5.0
     */
    static RpcCancelThreadEx(Thread, Timeout) {
        result := DllCall("RPCRT4.dll\RpcCancelThreadEx", "ptr", Thread, "int", Timeout, "int")
        return result
    }

    /**
     * The UuidCreate function creates a new UUID.
     * @remarks
     * For security reasons, it is often desirable to keep ethernet addresses on networks from becoming available outside a company or organization. The 
     * <b>UuidCreate</b> function generates a <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> that cannot be traced to the ethernet address of the computer on which it was generated. It also cannot be associated with other <b>UUID</b>s created on the same computer. If you do not need this level of security, your application can use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-uuidcreatesequential">UuidCreateSequential</a> function, which behaves exactly as the 
     * <b>UuidCreate</b> function does on all other versions of the operating system.
     * @param {Pointer<Guid>} Uuid Returns a pointer to the created <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UUID_LOCAL_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> is guaranteed to be unique to this computer only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UUID_NO_ADDRESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Cannot get Ethernet or token-ring hardware address for this computer.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidcreate
     * @since windows5.0
     */
    static UuidCreate(Uuid) {
        result := DllCall("RPCRT4.dll\UuidCreate", "ptr", Uuid, "int")
        return result
    }

    /**
     * The UuidCreateSequential function creates a new UUID.
     * @remarks
     * For security reasons, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-uuidcreate">UuidCreate</a> was modified so that it no longer uses a machine's MAC address to generate <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>s. 
     * <b>UuidCreateSequential</b> was introduced to allow creation of <b>UUID</b>s using the MAC address of a machine's Ethernet card.
     * 
     * The 
     * <b>UuidCreateSequential</b> function returns RPC_S_UUID_LOCAL_ONLY when the originating computer does not have an ethernet/token ring (IEEE 802.<i>x</i>) address. In this case, the generated <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> is a valid identifier, and is guaranteed to be unique among all <b>UUID</b>s generated on the computer. However, the possibility exists that another computer without an ethernet/token ring address generated the identical <b>UUID</b>. Therefore you should never use this <b>UUID</b> to identify an object that is not strictly local to your computer. Computers with ethernet/token ring addresses generate <b>UUID</b>s that are guaranteed to be globally unique.
     * 
     * <div class="alert"><b>Note</b>  The 
     * <b>UuidCreateSequential</b> function tends to be slightly faster than the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-uuidcreate">UuidCreate</a> function. When the performance of the generation of a <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> is a significant consideration, the 
     * <b>UuidCreateSequential</b> function may be used.</div>
     * <div> </div>
     * @param {Pointer<Guid>} Uuid Returns a pointer to the created <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UUID_LOCAL_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> is guaranteed to be unique to this computer only.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UUID_NO_ADDRESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Cannot get Ethernet or token-ring hardware address for this computer.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidcreatesequential
     * @since windows5.0
     */
    static UuidCreateSequential(Uuid) {
        result := DllCall("RPCRT4.dll\UuidCreateSequential", "ptr", Uuid, "int")
        return result
    }

    /**
     * The UuidToString function converts a UUID to a string. (UuidToStringA)
     * @remarks
     * An application calls 
     * <b>UuidToString</b> to convert a binary <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> to a string <b>UUID</b>. The RPC run-time library allocates memory for the string returned in the <i>StringUuid</i> parameter. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> to deallocate that memory.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines UuidToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} Uuid Pointer to a binary 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * @param {Pointer<Byte>} StringUuid Pointer to the null-terminated string into which the <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> specified in the <i>Uuid</i> parameter will be placed.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidtostringa
     * @since windows5.0
     */
    static UuidToStringA(Uuid, StringUuid) {
        result := DllCall("RPCRT4.dll\UuidToStringA", "ptr", Uuid, "ptr", StringUuid, "int")
        return result
    }

    /**
     * The UuidFromString function converts a string to a UUID. (UuidFromStringA)
     * @remarks
     * An application calls the 
     * <b>UuidFromString</b> function to convert a string <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> to a binary <b>UUID</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines UuidFromString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Byte>} StringUuid Pointer to a string representation of a 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * @param {Pointer<Guid>} Uuid Returns a pointer to a <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> in binary form.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_UUID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidfromstringa
     * @since windows5.0
     */
    static UuidFromStringA(StringUuid, Uuid) {
        StringUuid := StringUuid is String? StrPtr(StringUuid) : StringUuid

        result := DllCall("RPCRT4.dll\UuidFromStringA", "ptr", StringUuid, "ptr", Uuid, "int")
        return result
    }

    /**
     * The UuidToStringW (Unicode) function (rpcdce.h) converts a UUID to a string.
     * @remarks
     * An application calls 
     * <b>UuidToString</b> to convert a binary <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> to a string <b>UUID</b>. The RPC run-time library allocates memory for the string returned in the <i>StringUuid</i> parameter. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> to deallocate that memory.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines UuidToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} Uuid Pointer to a binary 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * @param {Pointer<Char>} StringUuid Pointer to the null-terminated string into which the <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> specified in the <i>Uuid</i> parameter will be placed.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidtostringw
     * @since windows5.0
     */
    static UuidToStringW(Uuid, StringUuid) {
        result := DllCall("RPCRT4.dll\UuidToStringW", "ptr", Uuid, "ptr", StringUuid, "int")
        return result
    }

    /**
     * The UuidFromStringW (Unicode) function (rpcdce.h) converts a string to a UUID.
     * @remarks
     * An application calls the 
     * <b>UuidFromString</b> function to convert a string <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> to a binary <b>UUID</b>.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines UuidFromString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Char>} StringUuid Pointer to a string representation of a 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * @param {Pointer<Guid>} Uuid Returns a pointer to a <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> in binary form.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_STRING_UUID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The string <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidfromstringw
     * @since windows5.0
     */
    static UuidFromStringW(StringUuid, Uuid) {
        StringUuid := StringUuid is String? StrPtr(StringUuid) : StringUuid

        result := DllCall("RPCRT4.dll\UuidFromStringW", "ptr", StringUuid, "ptr", Uuid, "int")
        return result
    }

    /**
     * An application calls the UuidCompare function to compare two UUIDs and determine their order. The returned value gives the order.
     * @param {Pointer<Guid>} Uuid1 Pointer to a 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>. This <b>UUID</b> is compared with the <b>UUID</b> specified in the <i>Uuid2</i> parameter.
     * @param {Pointer<Guid>} Uuid2 Pointer to a <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>. This <b>UUID</b> is compared with the <b>UUID</b> specified in the <i>Uuid1</i> parameter.
     * @param {Pointer<Int32>} Status Returns any errors that may occur, and will typically be set by the function to RPC_S_OK upon return.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>–1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Uuid1</i> parameter is less than the <i>Uuid2</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>0</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Uuid1</i> parameter is equal to the <i>Uuid2</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>1</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Uuid1</i> parameter is greater than the <i>Uuid2</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidcompare
     * @since windows5.0
     */
    static UuidCompare(Uuid1, Uuid2, Status) {
        result := DllCall("RPCRT4.dll\UuidCompare", "ptr", Uuid1, "ptr", Uuid2, "int*", Status, "int")
        return result
    }

    /**
     * The UuidCreateNil function creates a nil-valued UUID.
     * @param {Pointer<Guid>} NilUuid Returns a nil-valued 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * @returns {Integer} Returns RPC_S_OK.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidcreatenil
     * @since windows5.0
     */
    static UuidCreateNil(NilUuid) {
        result := DllCall("RPCRT4.dll\UuidCreateNil", "ptr", NilUuid, "int")
        return result
    }

    /**
     * An application calls the UuidEqual function to compare two UUIDs and determine whether they are equal.
     * @param {Pointer<Guid>} Uuid1 Pointer to a 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>. This <b>UUID</b> is compared with the <b>UUID</b> specified in the <i>Uuid2</i> parameter.
     * @param {Pointer<Guid>} Uuid2 Pointer to a <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>. This <b>UUID</b> is compared with the <b>UUID</b> specified in the <i>Uuid1</i> parameter.
     * @param {Pointer<Int32>} Status Returns RPC_S_OK.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>TRUE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Uuid1</i> parameter is equal to the <i>Uuid2</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Uuid1</i> parameter is not equal to the <i>Uuid2</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidequal
     * @since windows5.0
     */
    static UuidEqual(Uuid1, Uuid2, Status) {
        result := DllCall("RPCRT4.dll\UuidEqual", "ptr", Uuid1, "ptr", Uuid2, "int*", Status, "int")
        return result
    }

    /**
     * An application calls the UuidHash function to generate a hash value for a specified UUID.
     * @remarks
     * An application calls 
     * <b>UuidHash</b> to generate a hash value for a specified <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>. The hash value returned is implementation dependent and may vary from implementation to implementation.
     * @param {Pointer<Guid>} Uuid <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> for which a hash value is created.
     * @param {Pointer<Int32>} Status Returns RPC_S_OK.
     * @returns {Integer} <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidhash
     * @since windows5.0
     */
    static UuidHash(Uuid, Status) {
        result := DllCall("RPCRT4.dll\UuidHash", "ptr", Uuid, "int*", Status, "ushort")
        return result
    }

    /**
     * An application calls the UuidIsNil function to determine whether the specified UUID is a nil-valued UUID.
     * @remarks
     * This function acts as though the application called 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-uuidcreatenil">UuidCreateNil</a>, and then called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-uuidequal">UuidEqual</a> to compare the returned nil-value <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> to the <b>UUID</b> specified in the <i>Uuid</i> parameter.
     * 
     * Upon completion, one of the following values is returned.
     * 
     * <table>
     * <tr>
     * <th>Returned value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>TRUE</b></td>
     * <td>The <i>Uuid</i> parameter is a nil-valued <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.</td>
     * </tr>
     * <tr>
     * <td><b>FALSE</b></td>
     * <td>The <i>Uuid</i> parameter is not a nil-valued <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * <div> </div>
     * @param {Pointer<Guid>} Uuid <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> to test for nil value.
     * @param {Pointer<Int32>} Status Returns RPC_S_OK.
     * @returns {Integer} <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-uuidisnil
     * @since windows5.0
     */
    static UuidIsNil(Uuid, Status) {
        result := DllCall("RPCRT4.dll\UuidIsNil", "ptr", Uuid, "int*", Status, "int")
        return result
    }

    /**
     * The RpcEpRegisterNoReplace function adds server-address information to the local endpoint-map database. (RpcEpRegisterNoReplaceA)
     * @remarks
     * The 
     * <b>RpcEpRegisterNoReplace</b> function adds entries to the local host's endpoint-map database. This function does not replace existing database entries.
     * 
     * A server uses 
     * <b>RpcEpRegisterNoReplace</b> rather than 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> when multiple instances of the server will run on the same host. In other words, use this function when more than one server instance will offer the same interface UUID, object UUID, and protocol sequence at any one time.
     * 
     * Because entries are not replaced when calling 
     * <b>RpcEpRegisterNoReplace</b>, servers must unregister themselves before they stop running. Otherwise, stale data accumulates each time a server instance stops running without calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepunregister">RpcEpUnregister</a>. Stale entries increase the likelihood that a client will receive endpoints to nonexistent servers. The client will spend time trying to communicate with a nonexistent server before obtaining another endpoint.
     * 
     * A server can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> and 
     * <b>RpcEpRegisterNoReplace</b> to register entries in the endpoint mapper database. Previous to Windows 2000, two functions were available to enable a server to overwrite stale entries in the endpoint mapper database left from previous server instances that are no longer running. The endpoint mapper database automatically removes entries registered by a server instance as soon as the server stops functioning. However, servers are not allowed to replace the endpoint mapper entries of another server for security purposes. Therefore, <b>RpcEpRegister</b> and 
     * <b>RpcEpRegisterNoReplace</b> perform largely the same functionality.
     * 
     * A server application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> to register endpoints specified by calling any of the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>
     * </li>
     * </ul>
     * If the server also exports to the name-service database, the server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> with the same <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> values used when calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> function.
     * 
     * If a protocol sequence is used without specifying an endpoint, the RPC run-time library automatically generates a dynamic endpoint. In this case, the server can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> followed by 
     * <b>RpcEpRegisterNoReplace</b> to make itself available to multiple clients. Otherwise, the automatically started server is known only to the client for which the server was started.
     * 
     * Each element added to the endpoint-map database logically contains the following:
     * 
     * <ul>
     * <li>Interface UUID</li>
     * <li>Interface version (major and minor)</li>
     * <li>Binding handle</li>
     * <li>Object UUID (optional)</li>
     * <li>Annotation (optional)</li>
     * </ul>
     * <b>RpcEpRegisterNoReplace</b> creates a cross-product from the <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> parameters and adds each element in the cross-product as a separate registration in the endpoint-map database.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcEpRegisterNoReplace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} IfSpec Interface to register with the local endpoint-map database.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Pointer to a vector of binding handles over which the server can receive remote procedure calls.
     * @param {Pointer<UUID_VECTOR>} UuidVector Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector. 
     * 
     * 
     * 
     * 
     * A null parameter value indicates there are no object UUIDs to register.
     * @param {Pointer<Byte>} Annotation Pointer to the character-string comment applied to each cross-product element added to the local endpoint-map database. The string can be up to 64 characters long, including the null-terminating character. Specify a null value or a null-terminated string ("\0") if there is no annotation string. 
     * 
     * 
     * 
     * 
     * The annotation string is used by applications for information only. RPC does not use this string to determine which server instance a client communicates with or to enumerate elements in the endpoint-map database.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No bindings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcepregisternoreplacea
     * @since windows5.0
     */
    static RpcEpRegisterNoReplaceA(IfSpec, BindingVector, UuidVector, Annotation) {
        Annotation := Annotation is String? StrPtr(Annotation) : Annotation

        result := DllCall("RPCRT4.dll\RpcEpRegisterNoReplaceA", "ptr", IfSpec, "ptr", BindingVector, "ptr", UuidVector, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcEpRegisterNoReplaceW (Unicode) function (rpcdce.h) adds server-address information to the local endpoint-map database.
     * @remarks
     * The 
     * <b>RpcEpRegisterNoReplace</b> function adds entries to the local host's endpoint-map database. This function does not replace existing database entries.
     * 
     * A server uses 
     * <b>RpcEpRegisterNoReplace</b> rather than 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> when multiple instances of the server will run on the same host. In other words, use this function when more than one server instance will offer the same interface UUID, object UUID, and protocol sequence at any one time.
     * 
     * Because entries are not replaced when calling 
     * <b>RpcEpRegisterNoReplace</b>, servers must unregister themselves before they stop running. Otherwise, stale data accumulates each time a server instance stops running without calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepunregister">RpcEpUnregister</a>. Stale entries increase the likelihood that a client will receive endpoints to nonexistent servers. The client will spend time trying to communicate with a nonexistent server before obtaining another endpoint.
     * 
     * A server can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> and 
     * <b>RpcEpRegisterNoReplace</b> to register entries in the endpoint mapper database. Previous to Windows 2000, two functions were available to enable a server to overwrite stale entries in the endpoint mapper database left from previous server instances that are no longer running. The endpoint mapper database automatically removes entries registered by a server instance as soon as the server stops functioning. However, servers are not allowed to replace the endpoint mapper entries of another server for security purposes. Therefore, <b>RpcEpRegister</b> and 
     * <b>RpcEpRegisterNoReplace</b> perform largely the same functionality.
     * 
     * A server application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> to register endpoints specified by calling any of the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>
     * </li>
     * </ul>
     * If the server also exports to the name-service database, the server calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> with the same <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> values used when calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> function.
     * 
     * If a protocol sequence is used without specifying an endpoint, the RPC run-time library automatically generates a dynamic endpoint. In this case, the server can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> followed by 
     * <b>RpcEpRegisterNoReplace</b> to make itself available to multiple clients. Otherwise, the automatically started server is known only to the client for which the server was started.
     * 
     * Each element added to the endpoint-map database logically contains the following:
     * 
     * <ul>
     * <li>Interface UUID</li>
     * <li>Interface version (major and minor)</li>
     * <li>Binding handle</li>
     * <li>Object UUID (optional)</li>
     * <li>Annotation (optional)</li>
     * </ul>
     * <b>RpcEpRegisterNoReplace</b> creates a cross-product from the <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> parameters and adds each element in the cross-product as a separate registration in the endpoint-map database.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcEpRegisterNoReplace as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} IfSpec Interface to register with the local endpoint-map database.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Pointer to a vector of binding handles over which the server can receive remote procedure calls.
     * @param {Pointer<UUID_VECTOR>} UuidVector Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector. 
     * 
     * 
     * 
     * 
     * A null parameter value indicates there are no object UUIDs to register.
     * @param {Pointer<Char>} Annotation Pointer to the character-string comment applied to each cross-product element added to the local endpoint-map database. The string can be up to 64 characters long, including the null-terminating character. Specify a null value or a null-terminated string ("\0") if there is no annotation string. 
     * 
     * 
     * 
     * 
     * The annotation string is used by applications for information only. RPC does not use this string to determine which server instance a client communicates with or to enumerate elements in the endpoint-map database.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No bindings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcepregisternoreplacew
     * @since windows5.0
     */
    static RpcEpRegisterNoReplaceW(IfSpec, BindingVector, UuidVector, Annotation) {
        Annotation := Annotation is String? StrPtr(Annotation) : Annotation

        result := DllCall("RPCRT4.dll\RpcEpRegisterNoReplaceW", "ptr", IfSpec, "ptr", BindingVector, "ptr", UuidVector, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcEpRegister function adds to or replaces server address information in the local endpoint-map database. (RpcEpRegisterA)
     * @remarks
     * The 
     * <b>RpcEpRegister</b> function adds or replaces entries in the local host's endpoint-map database. For an existing database entry that matches the provided interface specification, binding handle, and object UUID, this function replaces the entry's endpoint with the endpoint in the provided binding handle.
     * 
     * A server can use 
     * <b>RpcEpRegister</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregisternoreplace">RpcEpRegisterNoReplace</a> to register entries in the endpoint mapper database. Previous to Windows 2000, two functions were available to enable a server to overwrite stale entries in the endpoint mapper database left from previous server instances that are no longer running. The endpoint mapper database automatically removes entries registered by a server instance as soon as the server stops functioning. However, servers are not allowed to replace the endpoint mapper entries of another server for security purposes. Therefore, <b>RpcEpRegister</b> and 
     * <b>RpcEpRegisterNoReplace</b> perform largely the same functionality.
     * 
     * A server application calls 
     * <b>RpcEpRegister</b> to register endpoints specified by calling any of the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>
     * </li>
     * </ul>
     * If the server also exports to the name-service database, the server calls 
     * <b>RpcEpRegister</b> with the same <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> values used when calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> function.
     * 
     * If a protocol sequence is used without specifying an endpoint, the RPC run-time library automatically generates a dynamic endpoint.. In this case, the server can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> followed by 
     * <b>RpcEpRegister</b> to make itself available to multiple clients. Otherwise, the automatically started server is known only to the client for which the server was started.Each element added to the endpoint-map database logically contains the following:
     * 
     * <ul>
     * <li>Interface 
     * <a href="https://msdn.microsoft.com/">UUID</a>
     * </li>
     * <li>Interface version (major and minor)</li>
     * <li>Binding handle</li>
     * <li>Object UUID (optional)</li>
     * <li>Annotation (optional)</li>
     * </ul>
     * <b>RpcEpRegister</b> creates a cross-product from the <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> parameters and adds each element in the cross-product as a separate registration in the endpoint-map database.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcEpRegister as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} IfSpec Interface to register with the local endpoint-map database.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Pointer to a vector of binding handles over which the server can receive remote procedure calls.
     * @param {Pointer<UUID_VECTOR>} UuidVector Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector.A null argument value indicates there are no object UUIDs to register.
     * @param {Pointer<Byte>} Annotation Pointer to the character-string comment applied to each cross-product element added to the local endpoint-map database. The string can be up to 64 characters long, including the null terminating character. Specify a null value or a null-terminated string ("\0") if there is no annotation string. 
     * 
     * 
     * 
     * 
     * The annotation string is used by applications for information only. RPC does not use this string to determine which server instance a client communicates with or for enumerating elements in the endpoint-map database.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No bindings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcepregistera
     * @since windows5.0
     */
    static RpcEpRegisterA(IfSpec, BindingVector, UuidVector, Annotation) {
        Annotation := Annotation is String? StrPtr(Annotation) : Annotation

        result := DllCall("RPCRT4.dll\RpcEpRegisterA", "ptr", IfSpec, "ptr", BindingVector, "ptr", UuidVector, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcEpRegisterW (Unicode) function (rpcdce.h) adds to or replaces server address information in the local endpoint-map database.
     * @remarks
     * The 
     * <b>RpcEpRegister</b> function adds or replaces entries in the local host's endpoint-map database. For an existing database entry that matches the provided interface specification, binding handle, and object UUID, this function replaces the entry's endpoint with the endpoint in the provided binding handle.
     * 
     * A server can use 
     * <b>RpcEpRegister</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregisternoreplace">RpcEpRegisterNoReplace</a> to register entries in the endpoint mapper database. Previous to Windows 2000, two functions were available to enable a server to overwrite stale entries in the endpoint mapper database left from previous server instances that are no longer running. The endpoint mapper database automatically removes entries registered by a server instance as soon as the server stops functioning. However, servers are not allowed to replace the endpoint mapper entries of another server for security purposes. Therefore, <b>RpcEpRegister</b> and 
     * <b>RpcEpRegisterNoReplace</b> perform largely the same functionality.
     * 
     * A server application calls 
     * <b>RpcEpRegister</b> to register endpoints specified by calling any of the following functions:
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>
     * </li>
     * </ul>
     * If the server also exports to the name-service database, the server calls 
     * <b>RpcEpRegister</b> with the same <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> values used when calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> function.
     * 
     * If a protocol sequence is used without specifying an endpoint, the RPC run-time library automatically generates a dynamic endpoint.. In this case, the server can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> followed by 
     * <b>RpcEpRegister</b> to make itself available to multiple clients. Otherwise, the automatically started server is known only to the client for which the server was started.Each element added to the endpoint-map database logically contains the following:
     * 
     * <ul>
     * <li>Interface 
     * <a href="https://msdn.microsoft.com/">UUID</a>
     * </li>
     * <li>Interface version (major and minor)</li>
     * <li>Binding handle</li>
     * <li>Object UUID (optional)</li>
     * <li>Annotation (optional)</li>
     * </ul>
     * <b>RpcEpRegister</b> creates a cross-product from the <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> parameters and adds each element in the cross-product as a separate registration in the endpoint-map database.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcEpRegister as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} IfSpec Interface to register with the local endpoint-map database.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Pointer to a vector of binding handles over which the server can receive remote procedure calls.
     * @param {Pointer<UUID_VECTOR>} UuidVector Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector.A null argument value indicates there are no object UUIDs to register.
     * @param {Pointer<Char>} Annotation Pointer to the character-string comment applied to each cross-product element added to the local endpoint-map database. The string can be up to 64 characters long, including the null terminating character. Specify a null value or a null-terminated string ("\0") if there is no annotation string. 
     * 
     * 
     * 
     * 
     * The annotation string is used by applications for information only. RPC does not use this string to determine which server instance a client communicates with or for enumerating elements in the endpoint-map database.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No bindings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcepregisterw
     * @since windows5.0
     */
    static RpcEpRegisterW(IfSpec, BindingVector, UuidVector, Annotation) {
        Annotation := Annotation is String? StrPtr(Annotation) : Annotation

        result := DllCall("RPCRT4.dll\RpcEpRegisterW", "ptr", IfSpec, "ptr", BindingVector, "ptr", UuidVector, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcEpUnregister function removes server-address information from the local endpoint-map database.
     * @remarks
     * The 
     * <b>RpcEpUnregister</b> function removes elements from the local host's endpoint-map database. A server application calls this function only when the server has previously registered endpoints and the server wants to remove that address information from the endpoint-map database.
     * 
     * Specifically, 
     * <b>RpcEpUnregister</b> allows a server application to remove its own endpoint-map database elements (server-address information) based on the interface specification or on both the interface specification and the object UUID(s) of the resource(s) offered.
     * 
     * The server calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function to obtain the required <i>BindingVector</i> parameter. To unregister selected endpoints, the server can prune the binding vector prior to calling this function.
     * 
     * <b>RpcEpUnregister</b> creates a cross-product from the <i>IfSpec</i>, <i>BindingVector</i>, and <i>UuidVector</i> parameters and removes each element in the cross-product from the endpoint-map database.
     * @param {Pointer<Void>} IfSpec Interface to unregister from the local endpoint-map database.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Pointer to a vector of binding handles to unregister.
     * @param {Pointer<UUID_VECTOR>} UuidVector Pointer to an optional vector of object UUIDs to unregister. The server application constructs this vector. 
     * <b>RpcEpUnregister</b> unregisters all endpoint-map database elements that match the specified <i>IfSpec</i> and <i>BindingVector</i> parameters and the object UUID(s). 
     * 
     * 
     * 
     * 
     * A null parameter value indicates there are no object UUIDs to unregister.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No bindings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcepunregister
     * @since windows5.0
     */
    static RpcEpUnregister(IfSpec, BindingVector, UuidVector) {
        result := DllCall("RPCRT4.dll\RpcEpUnregister", "ptr", IfSpec, "ptr", BindingVector, "ptr", UuidVector, "int")
        return result
    }

    /**
     * The DceErrorInqText function returns the message text for a status code. (DceErrorInqTextA)
     * @remarks
     * The 
     * <b>DceErrorInqText</b> routine fills the string pointed to by the <i>ErrorText</i> parameter with a null-terminated character string message for a particular status code.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines DceErrorInqText as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} RpcStatus Status code to convert to a text string.
     * @param {Pointer<Byte>} ErrorText Returns the text corresponding to the error code.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_S_OK"></a><a id="rpc_s_ok"></a><dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_S_INVALID_ARG"></a><a id="rpc_s_invalid_arg"></a><dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown error code.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} This function returns RPC_S_OK if it is successful, or an error code if not.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-dceerrorinqtexta
     * @since windows5.0
     */
    static DceErrorInqTextA(RpcStatus, ErrorText) {
        ErrorText := ErrorText is String? StrPtr(ErrorText) : ErrorText

        result := DllCall("RPCRT4.dll\DceErrorInqTextA", "int", RpcStatus, "ptr", ErrorText, "int")
        return result
    }

    /**
     * The DceErrorInqTextW (Unicode) function (rpcdce.h) returns the message text for a status code.
     * @remarks
     * The 
     * <b>DceErrorInqText</b> routine fills the string pointed to by the <i>ErrorText</i> parameter with a null-terminated character string message for a particular status code.
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines DceErrorInqText as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} RpcStatus Status code to convert to a text string.
     * @param {Pointer<Char>} ErrorText Returns the text corresponding to the error code.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_S_OK"></a><a id="rpc_s_ok"></a><dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_S_INVALID_ARG"></a><a id="rpc_s_invalid_arg"></a><dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown error code.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} This function returns RPC_S_OK if it is successful, or an error code if not.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-dceerrorinqtextw
     * @since windows5.0
     */
    static DceErrorInqTextW(RpcStatus, ErrorText) {
        ErrorText := ErrorText is String? StrPtr(ErrorText) : ErrorText

        result := DllCall("RPCRT4.dll\DceErrorInqTextW", "int", RpcStatus, "ptr", ErrorText, "int")
        return result
    }

    /**
     * The RpcMgmtEpEltInqBegin function creates an inquiry context for viewing the elements in an endpoint map.
     * @remarks
     * The 
     * <b>RpcMgmtEpEltInqBegin</b> function creates an inquiry context for viewing server-address information stored in the endpoint map. Using <i>InquiryType</i> and <i>VersOption</i>, an application specifies which of the following endpoint-map elements are to be returned from calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a>:
     * 
     * <ul>
     * <li>All elements</li>
     * <li>Those elements with the specified interface identifier</li>
     * <li>Those elements with the specified object UUID</li>
     * <li>Those elements with both the specified interface identifier and object UUID</li>
     * </ul>
     * Before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a>, the application must first call this function to create an inquiry context. After viewing the endpoint-map elements, the application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqdone">RpcMgmtEpEltInqDone</a> to delete the inquiry context.
     * @param {Pointer<Void>} EpBinding Binding handle to a host whose endpoint-map elements is to be viewed. Specify <b>NULL</b> to view elements from the local host. If a binding handle is specified, the object UUID on the binding handle must be <b>NULL</b>. If present, the endpoint on the binding handle is ignored and the endpoint to the endpoint mapper database on the given host is used.
     * @param {Integer} InquiryType Integer value that indicates the type of inquiry to perform on the endpoint map. The following are valid inquiry types. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_EP_ALL_ELTS"></a><a id="rpc_c_ep_all_elts"></a><dl>
     * <dt><b>RPC_C_EP_ALL_ELTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns every element from the endpoint map. The <i>IfId</i>, <i>VersOption</i>, and <i>ObjectUuid</i> parameters are ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_EP_MATCH_BY_IF"></a><a id="rpc_c_ep_match_by_if"></a><dl>
     * <dt><b>RPC_C_EP_MATCH_BY_IF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the endpoint map for elements that contain the interface identifier specified by the <i>IfId</i> and <i>VersOption</i> values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_EP_MATCH_BY_OBJ"></a><a id="rpc_c_ep_match_by_obj"></a><dl>
     * <dt><b>RPC_C_EP_MATCH_BY_OBJ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the endpoint map for elements that contain the object UUID specified by <i>ObjectUuid</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_EP_MATCH_BY_BOTH"></a><a id="rpc_c_ep_match_by_both"></a><dl>
     * <dt><b>RPC_C_EP_MATCH_BY_BOTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the endpoint map for elements that contain the interface identifier and object UUID specified by <i>IfId</i>, <i>VersOption</i>, and <i>ObjectUuid</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<RPC_IF_ID>} IfId Interface identifier of the endpoint-map elements to be returned by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a>. This parameter is only used when <i>InquiryType</i> is either RPC_C_EP_MATCH_BY_IF or RPC_C_EP_MATCH_BY_BOTH. Otherwise, it is ignored.
     * @param {Integer} VersOption Specifies how 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a> uses the <i>IfId</i> parameter. This parameter is only used when <i>InquiryType</i> is either RPC_C_EP_MATCH_BY_IF or RPC_C_EP_MATCH_BY_BOTH. Otherwise, it is ignored. The following are valid values for this parameter. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_ALL"></a><a id="rpc_c_vers_all"></a><dl>
     * <dt><b>RPC_C_VERS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns endpoint-map elements that offer the specified interface 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>, regardless of the version numbers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_COMPATIBLE"></a><a id="rpc_c_vers_compatible"></a><dl>
     * <dt><b>RPC_C_VERS_COMPATIBLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns endpoint-map elements that offer the same major version of the specified interface 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> and a minor version greater than or equal to the minor version of the specified interface 
     * <b>UUID</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_EXACT"></a><a id="rpc_c_vers_exact"></a><dl>
     * <dt><b>RPC_C_VERS_EXACT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns endpoint-map elements that offer the specified version of the specified interface 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_MAJOR_ONLY"></a><a id="rpc_c_vers_major_only"></a><dl>
     * <dt><b>RPC_C_VERS_MAJOR_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns endpoint-map elements that offer the same major version of the specified interface 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> and ignores the minor version.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_UPTO"></a><a id="rpc_c_vers_upto"></a><dl>
     * <dt><b>RPC_C_VERS_UPTO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns endpoint-map elements that offer a version of the specified interface 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> less than or equal to the specified major and minor version.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} ObjectUuid The object UUID that 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a> looks for in endpoint-map elements. This parameter is used only when <i>InquiryType</i> is either RPC_C_EP_MATCH_BY_OBJ or RPC_C_EP_MATCH_BY_BOTH.
     * @param {Pointer<Void>} InquiryContext Returns an inquiry context for use with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqdone">RpcMgmtEpEltInqDone</a>. See 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-ep-inq-handle">RPC_EP_INQ_HANDLE</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin
     * @since windows5.0
     */
    static RpcMgmtEpEltInqBegin(EpBinding, InquiryType, IfId, VersOption, ObjectUuid, InquiryContext) {
        result := DllCall("RPCRT4.dll\RpcMgmtEpEltInqBegin", "ptr", EpBinding, "uint", InquiryType, "ptr", IfId, "uint", VersOption, "ptr", ObjectUuid, "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcMgmtEpEltInqDone function deletes the inquiry context for viewing the elements in an endpoint map.
     * @remarks
     * The 
     * <b>RpcMgmtEpEltInqDone</b> function deletes an inquiry context created by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin">RpcMgmtEpEltInqBegin</a>. An application calls this function after viewing local endpoint-map elements using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a>.
     * @param {Pointer<Void>} InquiryContext Inquiry context to delete and returns the value <b>NULL</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqdone
     * @since windows5.0
     */
    static RpcMgmtEpEltInqDone(InquiryContext) {
        result := DllCall("RPCRT4.dll\RpcMgmtEpEltInqDone", "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcMgmtEpEltInqNext function returns one element from an endpoint map. (RpcMgmtEpEltInqNextA)
     * @remarks
     * The 
     * <b>RpcMgmtEpEltInqNext</b> function returns one element from the endpoint map. Elements selected depend on the inquiry context. The selection criteria are determined by <i>InquiryType</i> of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin">RpcMgmtEpEltInqBegin</a> function that returned <i>InquiryContext</i>.
     * 
     * An application can view all the selected endpoint-map elements by repeatedly calling 
     * <b>RpcMgmtEpEltInqNext</b>. When all the elements have been viewed, this function returns an RPC_X_NO_MORE_ENTRIES status. The returned elements are unordered.
     * 
     * When the respective arguments are non-NULL, the RPC run-time function library allocates memory for <i>Binding</i> and <i>Annotation</i> on each call to this function. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> for each returned <i>Binding</i> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> for each returned <i>Annotation</i>.
     * 
     * After viewing the endpoint-map elements, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqdone">RpcMgmtEpEltInqDone</a> to delete the inquiry context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcMgmtEpEltInqNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InquiryContext Specifies an inquiry context. The inquiry context is returned from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin">RpcMgmtEpEltInqBegin</a>.
     * @param {Pointer<RPC_IF_ID>} IfId Returns the interface identifier of the endpoint-map element.
     * @param {Pointer<Void>} Binding Optional. Returns the binding handle from the endpoint-map element.
     * @param {Pointer<Guid>} ObjectUuid Optional. Returns the object UUID from the endpoint-map element.
     * @param {Pointer<Byte>} Annotation Optional. Returns the annotation string for the endpoint-map element. When there is no annotation string in the endpoint-map element, the empty string ("") is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnexta
     * @since windows5.0
     */
    static RpcMgmtEpEltInqNextA(InquiryContext, IfId, Binding, ObjectUuid, Annotation) {
        result := DllCall("RPCRT4.dll\RpcMgmtEpEltInqNextA", "ptr", InquiryContext, "ptr", IfId, "ptr", Binding, "ptr", ObjectUuid, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcMgmtEpEltInqNextW (Unicode) function (rpcdce.h) returns one element from an endpoint map.
     * @remarks
     * The 
     * <b>RpcMgmtEpEltInqNext</b> function returns one element from the endpoint map. Elements selected depend on the inquiry context. The selection criteria are determined by <i>InquiryType</i> of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin">RpcMgmtEpEltInqBegin</a> function that returned <i>InquiryContext</i>.
     * 
     * An application can view all the selected endpoint-map elements by repeatedly calling 
     * <b>RpcMgmtEpEltInqNext</b>. When all the elements have been viewed, this function returns an RPC_X_NO_MORE_ENTRIES status. The returned elements are unordered.
     * 
     * When the respective arguments are non-NULL, the RPC run-time function library allocates memory for <i>Binding</i> and <i>Annotation</i> on each call to this function. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> for each returned <i>Binding</i> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> for each returned <i>Annotation</i>.
     * 
     * After viewing the endpoint-map elements, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqdone">RpcMgmtEpEltInqDone</a> to delete the inquiry context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcMgmtEpEltInqNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InquiryContext Specifies an inquiry context. The inquiry context is returned from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin">RpcMgmtEpEltInqBegin</a>.
     * @param {Pointer<RPC_IF_ID>} IfId Returns the interface identifier of the endpoint-map element.
     * @param {Pointer<Void>} Binding Optional. Returns the binding handle from the endpoint-map element.
     * @param {Pointer<Guid>} ObjectUuid Optional. Returns the object UUID from the endpoint-map element.
     * @param {Pointer<Char>} Annotation Optional. Returns the annotation string for the endpoint-map element. When there is no annotation string in the endpoint-map element, the empty string ("") is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnextw
     * @since windows5.0
     */
    static RpcMgmtEpEltInqNextW(InquiryContext, IfId, Binding, ObjectUuid, Annotation) {
        result := DllCall("RPCRT4.dll\RpcMgmtEpEltInqNextW", "ptr", InquiryContext, "ptr", IfId, "ptr", Binding, "ptr", ObjectUuid, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcMgmtEpUnregister function removes server address information from an endpoint map.
     * @remarks
     * The 
     * <b>RpcMgmtEpUnregister</b> function unregisters an element from the endpoint map. A management program calls this function to remove addresses of servers that are no longer available, or to remove addresses of servers that support objects that are no longer offered.
     * 
     * The <i>EpBinding</i> parameter must be a full binding. The object UUID associated with the <i>EpBinding</i> parameter must be a nil UUID. Specifying a non-nil UUID causes the function to fail with the status code EPT_S_CANT_PERFORM_OP. Other than the host information and object UUID, all information in this argument is ignored.
     * 
     * An application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a> to view local endpoint-map elements. The application can then remove the elements using 
     * <b>RpcMgmtEpUnregister</b>.
     * 
     * <div class="alert"><b>Note</b>  Use this function with caution. Removing elements from the local endpoint map may make servers unavailable to client applications that do not already have a fully-bound binding handle to the server.</div>
     * <div> </div>
     * @param {Pointer<Void>} EpBinding Host whose endpoint-map elements are to be unregistered. To remove elements from the same host as the calling application, the application specifies a value of <b>NULL</b>. To remove elements from another host, the application specifies a server binding handle for any server residing on that host. Note that the application can specify the same binding handle it is using to make other remote procedure calls.
     * @param {Pointer<RPC_IF_ID>} IfId Interface identifier to remove from the endpoint map.
     * @param {Pointer<Void>} Binding Binding handle to remove.
     * @param {Pointer<Guid>} ObjectUuid Optional object UUID to remove. The value <b>NULL</b> indicates there is no object UUID to remove.
     * @returns {Integer} <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANT_PERFORM_OP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Cannot perform the requested operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtepunregister
     */
    static RpcMgmtEpUnregister(EpBinding, IfId, Binding, ObjectUuid) {
        result := DllCall("RPCRT4.dll\RpcMgmtEpUnregister", "ptr", EpBinding, "ptr", IfId, "ptr", Binding, "ptr", ObjectUuid, "int")
        return result
    }

    /**
     * The RpcMgmtSetAuthorizationFn function establishes an authorization function for processing remote calls to a server's management functions.
     * @remarks
     * Server applications call the 
     * <b>RpcMgmtSetAuthorizationFn</b> function to establish an authorization function that controls access to the server's remote management functions. When a server has not called 
     * <b>RpcMgmtSetAuthorizationFn</b>, or calls with a <b>null</b> value for <i>AuthorizationFn</i>, the server run-time library uses the following default authorizations.
     * 
     * <table>
     * <tr>
     * <th>Remote function</th>
     * <th>Default authorization</th>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtinqifids">RpcMgmtInqIfIds</a>
     * </td>
     * <td>Enabled</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtinqserverprincname">RpcMgmtInqServerPrincName</a>
     * </td>
     * <td>Enabled</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtinqstats">RpcMgmtInqStats</a>
     * </td>
     * <td>Enabled</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtisserverlistening">RpcMgmtIsServerListening</a>
     * </td>
     * <td>Enabled</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtstopserverlistening">RpcMgmtStopServerListening</a>
     * </td>
     * <td>Disabled</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * <div> </div>
     * 
     * 
     * In the preceding table, "Enabled" indicates that all clients can execute the remote function, and "Disabled" indicates that all clients are prevented from executing the remote function.
     * @param {Pointer<RPC_MGMT_AUTHORIZATION_FN>} AuthorizationFn Specifies an authorization function. The RPC server run-time library automatically calls this function whenever the server run-time receives a client request to execute one of the remote management functions. The server must implement this function. Applications specify a value of <b>NULL</b> to unregister a previously registered authorization function. After such a call, default authorizations are used.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtsetauthorizationfn
     * @since windows5.0
     */
    static RpcMgmtSetAuthorizationFn(AuthorizationFn) {
        result := DllCall("RPCRT4.dll\RpcMgmtSetAuthorizationFn", "ptr", AuthorizationFn, "int")
        return result
    }

    /**
     * A default exception filter that determines whether an exception is fatal or non-fatal.
     * @remarks
     * The recommended usage of <b>RpcExceptionFilter</b> is:
     * 
     * 
     * ```cpp
     * 
     * RpcTry
     * {
     *     … RPC calls here …
     * RpcExcept(RpcExceptionFilter(RpcExceptionCode()))
     * {
     *     … error handling here …
     * }
     * RpcEndExcept
     * ```
     * @param {Integer} ExceptionCode Value of an exception. Any of the following exception values will return <b>EXCEPTION_CONTINUE_SEARCH</b>:
     * 
     * <a id="STATUS_ACCESS_VIOLATION"></a>
     * <a id="status_access_violation"></a>
     * @returns {Integer} A value that specifies whether the exception was fatal or non-fatal.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>EXCEPTION_CONTINUE_SEARCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The exception is fatal and must be handled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>EXCEPTION_EXECUTE_HANDLER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The exception is not fatal.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcexceptionfilter
     * @since windows6.0.6000
     */
    static RpcExceptionFilter(ExceptionCode) {
        result := DllCall("RPCRT4.dll\RpcExceptionFilter", "uint", ExceptionCode, "int")
        return result
    }

    /**
     * The RpcServerInterfaceGroupCreateW (Unicode) function (rpcdce.h) creates an RPC server interface group for the server application.
     * @remarks
     * A server application can optionally be notified when an interface group becomes idle.  Though any application can take advantage of this functionality, it is targeted towards service developers who would like to enable their service to idle stop.
     * 
     * <i>IdlePeriod</i> prevents the RPC runtime from producing a large number of notifications if the idle state rapidly changes, and in the case of triggered services, helps the service avoid needlessly starting and stopping.  Developers should consider the cost of service initialization and shutdown, the expected frequency with which new activity will occur, and the cost of keeping the service sitting idle when selecting this value.   A low idle period will cause the service to frequently start and stop as new client activity takes place, whereas a high idle period will cause the service to consume resources without performing meaningful work.
     * 
     * Interfaces in an interface group can only be called over endpoints of the same group.  Interfaces that are not part of an interface group cannot be called over endpoints that are part of a group.
     * 
     * RPC server activity is not always visible to the server application.  In some cases, simply having a client with an open connection to the server may keep it active even if no calls have been dispatched for a long period of time.  Server applications must not rely on any correlation between the RPC runtime declaring that the group is idle and the time since the last call was dispatched.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerInterfaceGroupCreate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_INTERFACE_TEMPLATEW>} Interfaces A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_interface_template">RPC_INTERFACE_TEMPLATE</a> structures that define the interfaces exposed by the interface group.
     * @param {Integer} NumIfs The number of elements in <i>Interfaces</i>.
     * @param {Pointer<RPC_ENDPOINT_TEMPLATEW>} Endpoints A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_endpoint_template">RPC_ENDPOINT_TEMPLATE</a> structures that define the endpoints used by the interface group.
     * @param {Integer} NumEndpoints The number of elements in <i>Endpoints</i>.
     * @param {Integer} IdlePeriod The length of time in seconds after the interface group becomes idle that the RPC runtime should wait before invoking the idle callback.  0 means the callback is invoked immediately. <b>INFINITE</b> means the server application does not care about the interface group’s idle state.
     * @param {Pointer<RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN>} IdleCallbackFn A <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_interface_group_idle_callback_fn">RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN</a> callback that the RPC runtime will invoke once the interface group is idle for the length of time given in <i>IdlePeriod</i>.  Can be <b>NULL</b> only if <i>IdlePeriod</i> is <b>INFINITE</b>.
     * @param {Pointer<Void>} IdleCallbackContext A user-defined pointer to be passed to the idle callback in <i>IdleCallbackFn</i>.
     * @param {Pointer<Void>} IfGroup If successful, a pointer to an <b>RPC_INTERFACE_GROUP</b> buffer that receives the handle to the newly created interface group.  If this function fails, <i>IfGroup</i> is undefined.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreatew
     * @since windows8.0
     */
    static RpcServerInterfaceGroupCreateW(Interfaces, NumIfs, Endpoints, NumEndpoints, IdlePeriod, IdleCallbackFn, IdleCallbackContext, IfGroup) {
        result := DllCall("RPCRT4.dll\RpcServerInterfaceGroupCreateW", "ptr", Interfaces, "uint", NumIfs, "ptr", Endpoints, "uint", NumEndpoints, "uint", IdlePeriod, "ptr", IdleCallbackFn, "ptr", IdleCallbackContext, "ptr", IfGroup, "int")
        return result
    }

    /**
     * The RpcServerInterfaceGroupCreate function creates an RPC server interface group for the server application. (RpcServerInterfaceGroupCreateA)
     * @remarks
     * A server application can optionally be notified when an interface group becomes idle.  Though any application can take advantage of this functionality, it is targeted towards service developers who would like to enable their service to idle stop.
     * 
     * <i>IdlePeriod</i> prevents the RPC runtime from producing a large number of notifications if the idle state rapidly changes, and in the case of triggered services, helps the service avoid needlessly starting and stopping.  Developers should consider the cost of service initialization and shutdown, the expected frequency with which new activity will occur, and the cost of keeping the service sitting idle when selecting this value.   A low idle period will cause the service to frequently start and stop as new client activity takes place, whereas a high idle period will cause the service to consume resources without performing meaningful work.
     * 
     * Interfaces in an interface group can only be called over endpoints of the same group.  Interfaces that are not part of an interface group cannot be called over endpoints that are part of a group.
     * 
     * RPC server activity is not always visible to the server application.  In some cases, simply having a client with an open connection to the server may keep it active even if no calls have been dispatched for a long period of time.  Server applications must not rely on any correlation between the RPC runtime declaring that the group is idle and the time since the last call was dispatched.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcdce.h header defines RpcServerInterfaceGroupCreate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<RPC_INTERFACE_TEMPLATEA>} Interfaces A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_interface_template">RPC_INTERFACE_TEMPLATE</a> structures that define the interfaces exposed by the interface group.
     * @param {Integer} NumIfs The number of elements in <i>Interfaces</i>.
     * @param {Pointer<RPC_ENDPOINT_TEMPLATEA>} Endpoints A pointer to an array of <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/ns-rpcdce-rpc_endpoint_template">RPC_ENDPOINT_TEMPLATE</a> structures that define the endpoints used by the interface group.
     * @param {Integer} NumEndpoints The number of elements in <i>Endpoints</i>.
     * @param {Integer} IdlePeriod The length of time in seconds after the interface group becomes idle that the RPC runtime should wait before invoking the idle callback.  0 means the callback is invoked immediately. <b>INFINITE</b> means the server application does not care about the interface group’s idle state.
     * @param {Pointer<RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN>} IdleCallbackFn A <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nc-rpcdce-rpc_interface_group_idle_callback_fn">RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN</a> callback that the RPC runtime will invoke once the interface group is idle for the length of time given in <i>IdlePeriod</i>.  Can be <b>NULL</b> only if <i>IdlePeriod</i> is <b>INFINITE</b>.
     * @param {Pointer<Void>} IdleCallbackContext A user-defined pointer to be passed to the idle callback in <i>IdleCallbackFn</i>.
     * @param {Pointer<Void>} IfGroup If successful, a pointer to an <b>RPC_INTERFACE_GROUP</b> buffer that receives the handle to the newly created interface group.  If this function fails, <i>IfGroup</i> is undefined.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreatea
     * @since windows8.0
     */
    static RpcServerInterfaceGroupCreateA(Interfaces, NumIfs, Endpoints, NumEndpoints, IdlePeriod, IdleCallbackFn, IdleCallbackContext, IfGroup) {
        result := DllCall("RPCRT4.dll\RpcServerInterfaceGroupCreateA", "ptr", Interfaces, "uint", NumIfs, "ptr", Endpoints, "uint", NumEndpoints, "uint", IdlePeriod, "ptr", IdleCallbackFn, "ptr", IdleCallbackContext, "ptr", IfGroup, "int")
        return result
    }

    /**
     * The RpcServerInterfaceGroupClose function is used to free an interface group.
     * @remarks
     * If the given interface group is still active, <b>RpcServerInterfaceGroupClose</b> performs a forced deactivation before closing the group.
     * 
     * This function must not be called from an interface group’s idle callback or deadlock can occur.
     * @param {Pointer<Void>} IfGroup A <b>RPC_INTERFACE_GROUP</b> from <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreate">RpcServerInterfaceGroupCreate</a> that defines the interface group to close.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>IfGroup</i> is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupclose
     * @since windows8.0
     */
    static RpcServerInterfaceGroupClose(IfGroup) {
        result := DllCall("RPCRT4.dll\RpcServerInterfaceGroupClose", "ptr", IfGroup, "int")
        return result
    }

    /**
     * The RpcServerInterfaceGroupActivate function tells the RPC server runtime to register the interface group’s interfaces and endpoints and begin listening for calls.
     * @remarks
     * <b>RpcServerInterfaceGroupActivate</b> does the bulk of the initialization work that the RPC server applications need to do.  It performs the following operations:<ul>
     * <li>Instructs the RPC runtime to begin listening for calls.</li>
     * <li>Registers the endpoints with the server runtime.</li>
     * <li>Registers the interfaces with the server runtime.</li>
     * <li>Registers the endpoints and interfaces with the RPC endpoint mapper.</li>
     * </ul>
     * 
     * 
     * <b>RpcServerInterfaceGroupActivate</b> is atomic.  If at any point the operation fails, any items that were previously registered are undone.  
     * 
     * Calls may be dispatched to the server application before this function returns.
     * @param {Pointer<Void>} IfGroup A <b>RPC_INTERFACE_GROUP</b> from <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreate">RpcServerInterfaceGroupCreate</a> that defines the interface group to activate.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_PROTSEQ_NOT_SUPPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is not supported on this host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_RPC_PROTSEQ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol sequence is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ENDPOINT_FORMAT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The endpoint format is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_SECURITY_DESC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The security descriptor for an endpoint or interface is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupactivate
     * @since windows8.0
     */
    static RpcServerInterfaceGroupActivate(IfGroup) {
        result := DllCall("RPCRT4.dll\RpcServerInterfaceGroupActivate", "ptr", IfGroup, "int")
        return result
    }

    /**
     * The RpcServerInterfaceGroupDeactivate function tells the RPC runtime to attempt to close the given interface group, optionally aborting the operation if there is outstanding client activity.
     * @remarks
     * <b>RpcServerInterfaceGroupDeactivate</b> is used by server applications to unregister the interfaces and endpoints in an interface group.  It does the bulk of the shutdown work that RPC server applications need to do.  It performs the following operations:<ul>
     * <li>Unregisters the endpoints and interfaces from the RPC endpoint mapper.</li>
     * <li>Unregisters the endpoints from the server runtime.</li>
     * <li>Unregisters the interfaces from the server runtime.  </li>
     * <li>Tells the runtime to stop listening for calls if no other interfaces are present.</li>
     * </ul>
     * 
     * 
     * If <i>ForceDeactivation</i> is <b>FALSE</b>, <b>RpcServerInterfaceGroupDeactivate</b> will only deactivate the interface group if there is no outstanding client activity.  If new activity arrives during the deactivation process, <b>RPC_S_SERVER_TOO_BUSY</b> is returned.  In this case, the operation is rolled back and the interface group will continue to receive and dispatch calls.
     * 
     * If <i>ForceDeactivation</i> is <b>TRUE</b>, <b>RpcServerInterfaceGroupDeactivate</b> does not fail.
     * 
     * Service applications can call <b>RpcServerInterfaceGroupDeactivate</b> with <i>ForceDeactivation</i> set to <b>FALSE</b> from their idle callback function <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreate">RpcServerInterfaceGroupCreate</a>.  When used in conjunction with RPC service start triggers, this enables them to safely idle stop without missing calls from potential clients.
     * @param {Pointer<Void>} IfGroup A <b>RPC_INTERFACE_GROUP</b> from <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreate">RpcServerInterfaceGroupCreate</a> that defines the interface group to deactivate
     * @param {Integer} ForceDeactivation If <b>TRUE</b>, the RPC runtime should ignore client activity and unconditionally deactivate the interface group.  If <b>FALSE</b>, the operation should be aborted if new activity takes place.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_SERVER_TOO_BUSY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>ForceDeactivation</i> is <b>FALSE</b> and there is outstanding client activity.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupdeactivate
     * @since windows8.0
     */
    static RpcServerInterfaceGroupDeactivate(IfGroup, ForceDeactivation) {
        result := DllCall("RPCRT4.dll\RpcServerInterfaceGroupDeactivate", "ptr", IfGroup, "uint", ForceDeactivation, "int")
        return result
    }

    /**
     * The RpcServerInterfaceGroupInqBindings function returns the binding handles over which remote procedure calls can be received for the given interface group.
     * @remarks
     * A server application calls <b>RpcServerInterfaceGroupInqBindings</b> to obtain a vector of server binding handles for the given interface group. The RPC run-time library creates binding handles for an interface group when a server application calls the <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupactivate">RpcServerInterfaceGroupActivate</a> function.
     * 
     * The returned binding vector can contain binding handles with dynamic endpoints or binding handles with well-known endpoints, depending on the interface group’s endpoint specification.
     * 
     * A server uses the vector of binding handles for exporting to the name service or for conversion to string bindings.  If there are no binding handles (no registered protocol sequences), <b>RpcServerInterfaceGroupInqBindings</b> returns <b>RPC_S_NO_BINDINGS</b> and <i>BindingVector</i> is <b>NULL</b>. The server is responsible for calling <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingvectorfree">RpcBindingVectorFree</a> to release the vector's memory.
     * @param {Pointer<Void>} IfGroup A <b>RPC_INTERFACE_GROUP</b> from <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupcreate">RpcServerInterfaceGroupCreate</a> that defines the interface group for which the bindings should be queried.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVector Returns a pointer to a pointer to a vector of server binding handles.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are no bindings.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdce/nf-rpcdce-rpcserverinterfacegroupinqbindings
     * @since windows8.0
     */
    static RpcServerInterfaceGroupInqBindings(IfGroup, BindingVector) {
        result := DllCall("RPCRT4.dll\RpcServerInterfaceGroupInqBindings", "ptr", IfGroup, "ptr", BindingVector, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcNegotiateTransferSyntax(Message) {
        result := DllCall("RPCRT4.dll\I_RpcNegotiateTransferSyntax", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcGetBuffer(Message) {
        result := DllCall("RPCRT4.dll\I_RpcGetBuffer", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @param {Pointer<Guid>} ObjectUuid 
     * @returns {Integer} 
     */
    static I_RpcGetBufferWithObject(Message, ObjectUuid) {
        result := DllCall("RPCRT4.dll\I_RpcGetBufferWithObject", "ptr", Message, "ptr", ObjectUuid, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcSendReceive(Message) {
        result := DllCall("RPCRT4.dll\I_RpcSendReceive", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcFreeBuffer(Message) {
        result := DllCall("RPCRT4.dll\I_RpcFreeBuffer", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcSend(Message) {
        result := DllCall("RPCRT4.dll\I_RpcSend", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @param {Integer} Size 
     * @returns {Integer} 
     */
    static I_RpcReceive(Message, Size) {
        result := DllCall("RPCRT4.dll\I_RpcReceive", "ptr", Message, "uint", Size, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcFreePipeBuffer(Message) {
        result := DllCall("RPCRT4.dll\I_RpcFreePipeBuffer", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @param {Integer} NewSize 
     * @returns {Integer} 
     */
    static I_RpcReallocPipeBuffer(Message, NewSize) {
        result := DllCall("RPCRT4.dll\I_RpcReallocPipeBuffer", "ptr", Message, "uint", NewSize, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Mutex 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcRequestMutex(Mutex) {
        DllCall("RPCRT4.dll\I_RpcRequestMutex", "ptr", Mutex)
    }

    /**
     * 
     * @param {Pointer<Void>} Mutex 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcClearMutex(Mutex) {
        DllCall("RPCRT4.dll\I_RpcClearMutex", "ptr", Mutex)
    }

    /**
     * 
     * @param {Pointer<Void>} Mutex 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcDeleteMutex(Mutex) {
        DllCall("RPCRT4.dll\I_RpcDeleteMutex", "ptr", Mutex)
    }

    /**
     * 
     * @param {Integer} Size 
     * @returns {Pointer<Void>} 
     */
    static I_RpcAllocate(Size) {
        result := DllCall("RPCRT4.dll\I_RpcAllocate", "uint", Size, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Object 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcFree(Object) {
        DllCall("RPCRT4.dll\I_RpcFree", "ptr", Object)
    }

    /**
     * 
     * @param {Integer} Milliseconds 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcPauseExecution(Milliseconds) {
        DllCall("RPCRT4.dll\I_RpcPauseExecution", "uint", Milliseconds)
    }

    /**
     * 
     * @returns {Integer} 
     */
    static I_RpcGetExtendedError() {
        result := DllCall("RPCRT4.dll\I_RpcGetExtendedError", "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Integer} ActualType 
     * @param {Integer} IdlType 
     * @param {Integer} MarshalDirection 
     * @returns {Integer} 
     */
    static I_RpcSystemHandleTypeSpecificWork(Handle, ActualType, IdlType, MarshalDirection) {
        result := DllCall("RPCRT4.dll\I_RpcSystemHandleTypeSpecificWork", "ptr", Handle, "char", ActualType, "char", IdlType, "int", MarshalDirection, "int")
        return result
    }

    /**
     * 
     * @returns {Pointer<Void>} 
     */
    static I_RpcGetCurrentCallHandle() {
        result := DllCall("RPCRT4.dll\I_RpcGetCurrentCallHandle", "ptr")
        return result
    }

    /**
     * 
     * @param {Integer} EntryNameSyntax 
     * @param {Pointer<UInt16>} EntryName 
     * @param {Pointer<RPC_SERVER_INTERFACE>} RpcInterfaceInformation 
     * @returns {Integer} 
     */
    static I_RpcNsInterfaceExported(EntryNameSyntax, EntryName, RpcInterfaceInformation) {
        result := DllCall("RPCRT4.dll\I_RpcNsInterfaceExported", "uint", EntryNameSyntax, "ushort*", EntryName, "ptr", RpcInterfaceInformation, "int")
        return result
    }

    /**
     * 
     * @param {Integer} EntryNameSyntax 
     * @param {Pointer<UInt16>} EntryName 
     * @param {Pointer<RPC_SERVER_INTERFACE>} RpcInterfaceInformation 
     * @returns {Integer} 
     */
    static I_RpcNsInterfaceUnexported(EntryNameSyntax, EntryName, RpcInterfaceInformation) {
        result := DllCall("RPCRT4.dll\I_RpcNsInterfaceUnexported", "uint", EntryNameSyntax, "ushort*", EntryName, "ptr", RpcInterfaceInformation, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<UInt16>} StringBinding 
     * @returns {Integer} 
     */
    static I_RpcBindingToStaticStringBindingW(Binding, StringBinding) {
        result := DllCall("RPCRT4.dll\I_RpcBindingToStaticStringBindingW", "ptr", Binding, "ptr", StringBinding, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Void>} SecurityContextHandle 
     * @returns {Integer} 
     */
    static I_RpcBindingInqSecurityContext(Binding, SecurityContextHandle) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqSecurityContext", "ptr", Binding, "ptr", SecurityContextHandle, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Void>} KeyInfo 
     * @returns {Integer} 
     */
    static I_RpcBindingInqSecurityContextKeyInfo(Binding, KeyInfo) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqSecurityContextKeyInfo", "ptr", Binding, "ptr", KeyInfo, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Byte>} WireId 
     * @returns {Integer} 
     */
    static I_RpcBindingInqWireIdForSnego(Binding, WireId) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqWireIdForSnego", "ptr", Binding, "char*", WireId, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<UInt32>} MarshalledTargetInfoSize 
     * @param {Pointer<Byte>} MarshalledTargetInfo 
     * @returns {Integer} 
     */
    static I_RpcBindingInqMarshalledTargetInfo(Binding, MarshalledTargetInfoSize, MarshalledTargetInfo) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqMarshalledTargetInfo", "ptr", Binding, "uint*", MarshalledTargetInfoSize, "ptr", MarshalledTargetInfo, "int")
        return result
    }

    /**
     * Obtains a client process ID.
     * @remarks
     * The client process ID is only returned in <i>ClientBinding</i> when the "ncalrpc" protocol sequence is used. Until the process terminates, the process ID value uniquely identifies it on the client. When the process terminates, the process ID can be used by new processes.
     * @param {Pointer<Void>} Binding <b>RPC_BINDING_HANDLE</b> that specifies the binding handle for an explicit RPC binding from the client to a server application.
     * @param {Pointer<UInt32>} Pid Contains the process ID of the client that issued the call upon return.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function call was successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_CALL_ACTIVE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The current thread does not have an active RPC call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The RPC binding handle is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcdcep/nf-rpcdcep-i_rpcbindinginqlocalclientpid
     * @since windows5.1.2600
     */
    static I_RpcBindingInqLocalClientPID(Binding, Pid) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqLocalClientPID", "ptr", Binding, "uint*", Pid, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Void>} AsyncHandle 
     * @returns {Integer} 
     */
    static I_RpcBindingHandleToAsyncHandle(Binding, AsyncHandle) {
        result := DllCall("RPCRT4.dll\I_RpcBindingHandleToAsyncHandle", "ptr", Binding, "ptr", AsyncHandle, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Integer} EntryNameSyntax 
     * @param {Pointer<Char>} EntryName 
     * @returns {Integer} 
     */
    static I_RpcNsBindingSetEntryNameW(Binding, EntryNameSyntax, EntryName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCRT4.dll\I_RpcNsBindingSetEntryNameW", "ptr", Binding, "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Integer} EntryNameSyntax 
     * @param {Pointer<Byte>} EntryName 
     * @returns {Integer} 
     */
    static I_RpcNsBindingSetEntryNameA(Binding, EntryNameSyntax, EntryName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCRT4.dll\I_RpcNsBindingSetEntryNameA", "ptr", Binding, "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} NetworkAddress 
     * @param {Pointer<Byte>} Protseq 
     * @param {Integer} MaxCalls 
     * @param {Pointer<Byte>} Endpoint 
     * @param {Pointer<Void>} SecurityDescriptor 
     * @param {Pointer<Void>} Policy 
     * @returns {Integer} 
     */
    static I_RpcServerUseProtseqEp2A(NetworkAddress, Protseq, MaxCalls, Endpoint, SecurityDescriptor, Policy) {
        NetworkAddress := NetworkAddress is String? StrPtr(NetworkAddress) : NetworkAddress
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint

        result := DllCall("RPCRT4.dll\I_RpcServerUseProtseqEp2A", "ptr", NetworkAddress, "ptr", Protseq, "uint", MaxCalls, "ptr", Endpoint, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} NetworkAddress 
     * @param {Pointer<Char>} Protseq 
     * @param {Integer} MaxCalls 
     * @param {Pointer<Char>} Endpoint 
     * @param {Pointer<Void>} SecurityDescriptor 
     * @param {Pointer<Void>} Policy 
     * @returns {Integer} 
     */
    static I_RpcServerUseProtseqEp2W(NetworkAddress, Protseq, MaxCalls, Endpoint, SecurityDescriptor, Policy) {
        NetworkAddress := NetworkAddress is String? StrPtr(NetworkAddress) : NetworkAddress
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint

        result := DllCall("RPCRT4.dll\I_RpcServerUseProtseqEp2W", "ptr", NetworkAddress, "ptr", Protseq, "uint", MaxCalls, "ptr", Endpoint, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} NetworkAddress 
     * @param {Pointer<Char>} Protseq 
     * @param {Integer} MaxCalls 
     * @param {Pointer<Void>} SecurityDescriptor 
     * @param {Pointer<Void>} Policy 
     * @returns {Integer} 
     */
    static I_RpcServerUseProtseq2W(NetworkAddress, Protseq, MaxCalls, SecurityDescriptor, Policy) {
        NetworkAddress := NetworkAddress is String? StrPtr(NetworkAddress) : NetworkAddress
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\I_RpcServerUseProtseq2W", "ptr", NetworkAddress, "ptr", Protseq, "uint", MaxCalls, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Byte>} NetworkAddress 
     * @param {Pointer<Byte>} Protseq 
     * @param {Integer} MaxCalls 
     * @param {Pointer<Void>} SecurityDescriptor 
     * @param {Pointer<Void>} Policy 
     * @returns {Integer} 
     */
    static I_RpcServerUseProtseq2A(NetworkAddress, Protseq, MaxCalls, SecurityDescriptor, Policy) {
        NetworkAddress := NetworkAddress is String? StrPtr(NetworkAddress) : NetworkAddress
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq

        result := DllCall("RPCRT4.dll\I_RpcServerUseProtseq2A", "ptr", NetworkAddress, "ptr", Protseq, "uint", MaxCalls, "ptr", SecurityDescriptor, "ptr", Policy, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} Protseq 
     * @param {Pointer<Char>} Endpoint 
     * @param {Pointer<Void>} IfSpec 
     * @returns {Integer} 
     */
    static I_RpcServerStartService(Protseq, Endpoint, IfSpec) {
        Protseq := Protseq is String? StrPtr(Protseq) : Protseq
        Endpoint := Endpoint is String? StrPtr(Endpoint) : Endpoint

        result := DllCall("RPCRT4.dll\I_RpcServerStartService", "ptr", Protseq, "ptr", Endpoint, "ptr", IfSpec, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Char>} DynamicEndpoint 
     * @returns {Integer} 
     */
    static I_RpcBindingInqDynamicEndpointW(Binding, DynamicEndpoint) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqDynamicEndpointW", "ptr", Binding, "ptr", DynamicEndpoint, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Byte>} DynamicEndpoint 
     * @returns {Integer} 
     */
    static I_RpcBindingInqDynamicEndpointA(Binding, DynamicEndpoint) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqDynamicEndpointA", "ptr", Binding, "ptr", DynamicEndpoint, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Context 
     * @returns {Integer} 
     */
    static I_RpcServerCheckClientRestriction(Context) {
        result := DllCall("RPCRT4.dll\I_RpcServerCheckClientRestriction", "ptr", Context, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<UInt32>} Type 
     * @returns {Integer} 
     */
    static I_RpcBindingInqTransportType(Binding, Type) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqTransportType", "ptr", Binding, "uint*", Type, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} RpcIfHandle 
     * @param {Pointer<RPC_TRANSFER_SYNTAX>} TransferSyntaxes 
     * @param {Integer} TransferSyntaxSize 
     * @param {Pointer<UInt32>} TransferSyntaxCount 
     * @returns {Integer} 
     */
    static I_RpcIfInqTransferSyntaxes(RpcIfHandle, TransferSyntaxes, TransferSyntaxSize, TransferSyntaxCount) {
        result := DllCall("RPCRT4.dll\I_RpcIfInqTransferSyntaxes", "ptr", RpcIfHandle, "ptr", TransferSyntaxes, "uint", TransferSyntaxSize, "uint*", TransferSyntaxCount, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} Uuid 
     * @returns {Integer} 
     */
    static I_UuidCreate(Uuid) {
        result := DllCall("RPCRT4.dll\I_UuidCreate", "ptr", Uuid, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} SourceBinding 
     * @param {Pointer<Void>} DestinationBinding 
     * @returns {Integer} 
     */
    static I_RpcBindingCopy(SourceBinding, DestinationBinding) {
        result := DllCall("RPCRT4.dll\I_RpcBindingCopy", "ptr", SourceBinding, "ptr", DestinationBinding, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} BindingHandle 
     * @param {Pointer<UInt32>} ClientLocalFlag 
     * @returns {Integer} 
     */
    static I_RpcBindingIsClientLocal(BindingHandle, ClientLocalFlag) {
        result := DllCall("RPCRT4.dll\I_RpcBindingIsClientLocal", "ptr", BindingHandle, "uint*", ClientLocalFlag, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Char>} ServerName 
     * @param {Pointer<Char>} ServiceName 
     * @param {Pointer<Char>} NetworkOptions 
     * @param {Pointer<Void>} Binding 
     * @returns {Integer} 
     */
    static I_RpcBindingCreateNP(ServerName, ServiceName, NetworkOptions, Binding) {
        ServerName := ServerName is String? StrPtr(ServerName) : ServerName
        ServiceName := ServiceName is String? StrPtr(ServiceName) : ServiceName
        NetworkOptions := NetworkOptions is String? StrPtr(NetworkOptions) : NetworkOptions

        result := DllCall("RPCRT4.dll\I_RpcBindingCreateNP", "ptr", ServerName, "ptr", ServiceName, "ptr", NetworkOptions, "ptr", Binding, "int")
        return result
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcSsDontSerializeContext() {
        DllCall("RPCRT4.dll\I_RpcSsDontSerializeContext")
    }

    /**
     * 
     * @param {Pointer<RPC_FORWARD_FUNCTION>} pForwardFunction 
     * @returns {Integer} 
     */
    static I_RpcServerRegisterForwardFunction(pForwardFunction) {
        result := DllCall("RPCRT4.dll\I_RpcServerRegisterForwardFunction", "ptr", pForwardFunction, "int")
        return result
    }

    /**
     * 
     * @returns {Pointer<RPC_ADDRESS_CHANGE_FN>} 
     */
    static I_RpcServerInqAddressChangeFn() {
        result := DllCall("RPCRT4.dll\I_RpcServerInqAddressChangeFn", "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_ADDRESS_CHANGE_FN>} pAddressChangeFn 
     * @returns {Integer} 
     */
    static I_RpcServerSetAddressChangeFn(pAddressChangeFn) {
        result := DllCall("RPCRT4.dll\I_RpcServerSetAddressChangeFn", "ptr", pAddressChangeFn, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} BufferSize 
     * @param {Pointer<UInt32>} AddressFormat 
     * @returns {Integer} 
     */
    static I_RpcServerInqLocalConnAddress(Binding, Buffer, BufferSize, AddressFormat) {
        result := DllCall("RPCRT4.dll\I_RpcServerInqLocalConnAddress", "ptr", Binding, "ptr", Buffer, "uint*", BufferSize, "uint*", AddressFormat, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Void>} Buffer 
     * @param {Pointer<UInt32>} BufferSize 
     * @param {Pointer<UInt32>} AddressFormat 
     * @returns {Integer} 
     */
    static I_RpcServerInqRemoteConnAddress(Binding, Buffer, BufferSize, AddressFormat) {
        result := DllCall("RPCRT4.dll\I_RpcServerInqRemoteConnAddress", "ptr", Binding, "ptr", Buffer, "uint*", BufferSize, "uint*", AddressFormat, "int")
        return result
    }

    /**
     * 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcSessionStrictContextHandle() {
        DllCall("RPCRT4.dll\I_RpcSessionStrictContextHandle")
    }

    /**
     * 
     * @returns {Integer} 
     */
    static I_RpcTurnOnEEInfoPropagation() {
        result := DllCall("RPCRT4.dll\I_RpcTurnOnEEInfoPropagation", "int")
        return result
    }

    /**
     * 
     * @param {Pointer<UInt32>} Type 
     * @returns {Integer} 
     */
    static I_RpcServerInqTransportType(Type) {
        result := DllCall("RPCRT4.dll\I_RpcServerInqTransportType", "uint*", Type, "int")
        return result
    }

    /**
     * 
     * @param {Integer} Status 
     * @returns {Integer} 
     */
    static I_RpcMapWin32Status(Status) {
        result := DllCall("RPCRT4.dll\I_RpcMapWin32Status", "int", Status, "int")
        return result
    }

    /**
     * 
     * @param {Integer} RpcStatus 
     * @param {Pointer<RDR_CALLOUT_STATE>} CallOutState 
     * @param {Pointer<UInt16>} DllName 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcRecordCalloutFailure(RpcStatus, CallOutState, DllName) {
        DllCall("RPCRT4.dll\I_RpcRecordCalloutFailure", "int", RpcStatus, "ptr", CallOutState, "ushort*", DllName)
    }

    /**
     * 
     * @returns {Integer} 
     */
    static I_RpcMgmtEnableDedicatedThreadPool() {
        result := DllCall("RPCRT4.dll\I_RpcMgmtEnableDedicatedThreadPool", "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} ppSecurityDescriptor 
     * @returns {Integer} 
     */
    static I_RpcGetDefaultSD(ppSecurityDescriptor) {
        result := DllCall("RPCRT4.dll\I_RpcGetDefaultSD", "ptr", ppSecurityDescriptor, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Integer} DesiredAccess 
     * @param {Pointer<Void>} ClientProcess 
     * @returns {Integer} 
     */
    static I_RpcOpenClientProcess(Binding, DesiredAccess, ClientProcess) {
        result := DllCall("RPCRT4.dll\I_RpcOpenClientProcess", "ptr", Binding, "uint", DesiredAccess, "ptr", ClientProcess, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<UInt32>} ServerLocalFlag 
     * @returns {Integer} 
     */
    static I_RpcBindingIsServerLocal(Binding, ServerLocalFlag) {
        result := DllCall("RPCRT4.dll\I_RpcBindingIsServerLocal", "ptr", Binding, "uint*", ServerLocalFlag, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} hBinding 
     * @param {Integer} option 
     * @param {Pointer} optionValue 
     * @returns {Integer} 
     */
    static I_RpcBindingSetPrivateOption(hBinding, option, optionValue) {
        result := DllCall("RPCRT4.dll\I_RpcBindingSetPrivateOption", "ptr", hBinding, "uint", option, "ptr", optionValue, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Void>} hEvent 
     * @returns {Integer} 
     */
    static I_RpcServerSubscribeForDisconnectNotification(Binding, hEvent) {
        result := DllCall("RPCRT4.dll\I_RpcServerSubscribeForDisconnectNotification", "ptr", Binding, "ptr", hEvent, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<UInt32>} AssociationID 
     * @returns {Integer} 
     */
    static I_RpcServerGetAssociationID(Binding, AssociationID) {
        result := DllCall("RPCRT4.dll\I_RpcServerGetAssociationID", "ptr", Binding, "uint*", AssociationID, "int")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     */
    static I_RpcServerDisableExceptionFilter() {
        result := DllCall("RPCRT4.dll\I_RpcServerDisableExceptionFilter", "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Void>} hEvent 
     * @param {Pointer<Guid>} SubscriptionId 
     * @returns {Integer} 
     */
    static I_RpcServerSubscribeForDisconnectNotification2(Binding, hEvent, SubscriptionId) {
        result := DllCall("RPCRT4.dll\I_RpcServerSubscribeForDisconnectNotification2", "ptr", Binding, "ptr", hEvent, "ptr", SubscriptionId, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<Guid>} SubscriptionId 
     * @returns {Integer} 
     */
    static I_RpcServerUnsubscribeForDisconnectNotification(Binding, SubscriptionId) {
        result := DllCall("RPCRT4.dll\I_RpcServerUnsubscribeForDisconnectNotification", "ptr", Binding, "ptr", SubscriptionId, "int")
        return result
    }

    /**
     * The RpcNsBindingExport function establishes a name service�database entry with multiple binding handles and multiple objects for a server. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsBindingExport</b> function allows a server application to publicly offer an interface in the name-service database for use by any client application.
     * 
     * Effective with Windows 2000, the RPC run-time environment uses the Active Directory as its name-service database. This means that authorized exported entries persist in the name service, and are visible even after rebooting. Unauthorized exports do not persist. See 
     * <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> in the Security section of the Platform Software Development Kit (SDK) for more information on authorization and Access Control Lists.
     * 
     * To export an interface, the server application calls the 
     * <b>RpcNsBindingExport</b> routine with an interface and the server binding handles a client can use to access the server. A server application also calls the 
     * <b>RpcNsBindingExport</b> function to publicly offer the object UUID(s) of resource(s) it offers, if any, in the name-service database.
     * 
     * A server can export interfaces and objects in a single call to 
     * <b>RpcNsBindingExport</b>, or it can export them separately.If the name-service database entry specified by <i>EntryName</i> does not exist, 
     * <b>RpcNsBindingExport</b> tries to create it. In this case, the server application must have the privilege to create the entry.In addition to calling 
     * <b>RpcNsBindingExport</b>, a server that called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a> or 
     * <b>RpcServerUseProtseq</b> function must also register with the local endpoint-map database by calling either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregisternoreplace">RpcEpRegisterNoReplace</a>.
     * 
     * A server is not required to export any of its interfaces to the name-service database. When a server does not export, only clients that privately know that server's binding information can access its interfaces. For example, a client that has the information needed to construct a string binding can call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfromstringbinding">RpcBindingFromStringBinding</a> to create a binding handle for making remote procedure calls to a server.
     * 
     * Before calling 
     * <b>RpcNsBindingExport</b>, a server must do the following:
     * 
     * <ul>
     * <li>Register one or more protocol sequences with the local RPC run-time library by calling one of the following functions: 
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsex">RpcServerUseAllProtseqsEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqex">RpcServerUseProtseqEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex">RpcServerUseAllProtseqsIfEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>
     * </li>
     * </ul>
     * </li>
     * <li>Obtain a list of server bindings by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function.</li>
     * </ul>
     * The vector returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function becomes the <i>Binding</i> parameter for 
     * <b>RpcNsBindingExport</b>. To prevent a binding from being exported, set the selected vector element to a null value.
     * 
     * If a server exports to the same name-service database entry multiple times, the second and subsequent calls to 
     * <b>RpcNsBindingExport</b> add the binding information and object UUIDs when that data is different from the binding information already in the server entry. Existing data is not removed from the entry.
     * 
     * To remove binding handles and object UUIDs from the name-service database, a server application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexporta">RpcNsBindingUnexport</a> function.
     * 
     * A server entry must have at least one binding handle to exist. As a result, exporting only UUIDs to a non-existing entry has no effect, and unexporting all binding handles deletes the entry.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingExport as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the entry name to which binding handles and object UUIDs are exported. You cannot provide a null or empty string. The client and the server must both use the same entry name.
     * @param {Pointer<Void>} IfSpec Stub-generated data structure specifying the interface to export. A null value indicates there are no binding handles to export (only object UUIDs are to be exported) and <i>BindingVec</i> is ignored.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVec Pointer to server bindings to export. A null value indicates there are no binding handles to export (only object UUIDs are to be exported).
     * @param {Pointer<UUID_VECTOR>} ObjectUuidVec Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector. A null value indicates there are no object UUIDs to export (only binding handles are to be exported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOTHING_TO_EXPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was nothing to export.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_NS_PRIVILEGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No privilege for name-service operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta
     * @since windows5.0
     */
    static RpcNsBindingExportA(EntryNameSyntax, EntryName, IfSpec, BindingVec, ObjectUuidVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingExportA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", BindingVec, "ptr", ObjectUuidVec, "int")
        return result
    }

    /**
     * The RpcNsBindingUnexport function removes the binding handles for an interface and objects from an entry in the name-service database. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsBindingUnexport</b> function allows a server application to remove the binding handles and object UUIDs of resources from a name service database entry. A server application can unexport the specified interface and objects in a single call to 
     * <b>RpcNsBindingUnexport</b>, or it can unexport them separately. Only the binding handles that match the interface UUID and the major and minor interface version numbers found in the <i>IfSpec</i> parameter are unexported. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtbindingunexporta">RpcNsMgmtBindingUnexport</a> function to remove multiple versions of an interface.
     * 
     * Effective with Windows 2000, the RPC run-time environment uses the Active Directory as its name-service database. This means that an authorized unexported entries will be removed both from the local cache and from the Active Directory. Unauthorized unexports will only be removed from the local cache. See 
     * <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> in the Security section of the Platform Software Development Kit (SDK) for more information on authorization and Access Control Lists.
     * 
     * If 
     * <b>RpcNsBindingUnexport</b> does not find any binding handles for the specified interface, the function returns an RPC_S_INTERFACE_NOT_FOUND status code and does not unexport the object UUIDs, if any were specified.
     * 
     * If one or more binding handles for the specified interface are found and unexported without error, 
     * <b>RpcNsBindingUnexport</b> unexports the specified object UUIDs, if any.
     * 
     * If any of the specified object UUIDs were not found, 
     * <b>RpcNsBindingUnexport</b> returns the RPC_S_NOT_ALL_OBJS_UNEXPORTED status code.
     * 
     * In addition to calling 
     * <b>RpcNsBindingUnexport</b>, a server should also call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepunregister">RpcEpUnregister</a> function to unregister the endpoints the server previously registered with the local endpoint-map database.
     * 
     * Once created, a server entry persists, even when all of the binding handles and UUIDs are removed. A server entry must have at least one binding handle to exist. As a result, exporting only UUIDs to a nonexisting entry has no effect, and unexporting all binding handles deletes the entry.
     * 
     * Use 
     * <b>RpcNsBindingUnexport</b> judiciously. To keep an automatically activated server available, you must leave its binding handles in the name-service database between the times when server processes are activated. However, with dynamic bindings, if you do not unexport binding handles, the Active Directory can become so large as to be unmanageable.
     * 
     * Therefore, before you call this function, keep in mind how long you expect the server to be unavailable, and the type of binding in use. If you are using static bindings, reserve this function for when you expect a server to be unavailable for an extended time—for example, when it is being permanently removed from service.
     * 
     * <div class="alert"><b>Note</b>  Name-service databases are designed to be relatively stable. In replicated name-service databases, frequent use of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> and 
     * <b>RpcNsBindingUnexport</b> functions causes the name-service database to repeatedly remove and replace the same entry and can cause performance problems.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingUnexport as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the entry name from which to remove binding handles and object UUIDs.
     * @param {Pointer<Void>} IfSpec Interface specification for the binding handles to be removed from the name service database. A null parameter value indicates not to unexport any binding handles (only object UUIDs are to be unexported).
     * @param {Pointer<UUID_VECTOR>} ObjectUuidVec Pointer to a vector of object UUIDs that the server no longer wants to offer. The application constructs this vector. A null value indicates there are no object UUIDs to unexport (only binding handles are to be unexported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INTERFACE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_ALL_OBJS_UNEXPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all objects unexported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexporta
     * @since windows5.0
     */
    static RpcNsBindingUnexportA(EntryNameSyntax, EntryName, IfSpec, ObjectUuidVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingUnexportA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjectUuidVec, "int")
        return result
    }

    /**
     * The RpcNsBindingExport function establishes a name service�database entry with multiple binding handles and multiple objects for a server. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsBindingExport</b> function allows a server application to publicly offer an interface in the name-service database for use by any client application.
     * 
     * Effective with Windows 2000, the RPC run-time environment uses the Active Directory as its name-service database. This means that authorized exported entries persist in the name service, and are visible even after rebooting. Unauthorized exports do not persist. See 
     * <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> in the Security section of the Platform Software Development Kit (SDK) for more information on authorization and Access Control Lists.
     * 
     * To export an interface, the server application calls the 
     * <b>RpcNsBindingExport</b> routine with an interface and the server binding handles a client can use to access the server. A server application also calls the 
     * <b>RpcNsBindingExport</b> function to publicly offer the object UUID(s) of resource(s) it offers, if any, in the name-service database.
     * 
     * A server can export interfaces and objects in a single call to 
     * <b>RpcNsBindingExport</b>, or it can export them separately.If the name-service database entry specified by <i>EntryName</i> does not exist, 
     * <b>RpcNsBindingExport</b> tries to create it. In this case, the server application must have the privilege to create the entry.In addition to calling 
     * <b>RpcNsBindingExport</b>, a server that called the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a> or 
     * <b>RpcServerUseProtseq</b> function must also register with the local endpoint-map database by calling either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregister">RpcEpRegister</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepregisternoreplace">RpcEpRegisterNoReplace</a>.
     * 
     * A server is not required to export any of its interfaces to the name-service database. When a server does not export, only clients that privately know that server's binding information can access its interfaces. For example, a client that has the information needed to construct a string binding can call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfromstringbinding">RpcBindingFromStringBinding</a> to create a binding handle for making remote procedure calls to a server.
     * 
     * Before calling 
     * <b>RpcNsBindingExport</b>, a server must do the following:
     * 
     * <ul>
     * <li>Register one or more protocol sequences with the local RPC run-time library by calling one of the following functions: 
     * 
     * 
     * <ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqs">RpcServerUseAllProtseqs</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsex">RpcServerUseAllProtseqsEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseq">RpcServerUseProtseq</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqex">RpcServerUseProtseqEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsif">RpcServerUseAllProtseqsIf</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseallprotseqsifex">RpcServerUseAllProtseqsIfEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqif">RpcServerUseProtseqIf</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserveruseprotseqep">RpcServerUseProtseqEp</a>
     * </li>
     * </ul>
     * </li>
     * <li>Obtain a list of server bindings by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function.</li>
     * </ul>
     * The vector returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcserverinqbindings">RpcServerInqBindings</a> function becomes the <i>Binding</i> parameter for 
     * <b>RpcNsBindingExport</b>. To prevent a binding from being exported, set the selected vector element to a null value.
     * 
     * If a server exports to the same name-service database entry multiple times, the second and subsequent calls to 
     * <b>RpcNsBindingExport</b> add the binding information and object UUIDs when that data is different from the binding information already in the server entry. Existing data is not removed from the entry.
     * 
     * To remove binding handles and object UUIDs from the name-service database, a server application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexporta">RpcNsBindingUnexport</a> function.
     * 
     * A server entry must have at least one binding handle to exist. As a result, exporting only UUIDs to a non-existing entry has no effect, and unexporting all binding handles deletes the entry.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingExport as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the entry name to which binding handles and object UUIDs are exported. You cannot provide a null or empty string. The client and the server must both use the same entry name.
     * @param {Pointer<Void>} IfSpec Stub-generated data structure specifying the interface to export. A null value indicates there are no binding handles to export (only object UUIDs are to be exported) and <i>BindingVec</i> is ignored.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVec Pointer to server bindings to export. A null value indicates there are no binding handles to export (only object UUIDs are to be exported).
     * @param {Pointer<UUID_VECTOR>} ObjectUuidVec Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector. A null value indicates there are no object UUIDs to export (only binding handles are to be exported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOTHING_TO_EXPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was nothing to export.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_NS_PRIVILEGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No privilege for name-service operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingexportw
     * @since windows5.0
     */
    static RpcNsBindingExportW(EntryNameSyntax, EntryName, IfSpec, BindingVec, ObjectUuidVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingExportW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", BindingVec, "ptr", ObjectUuidVec, "int")
        return result
    }

    /**
     * The RpcNsBindingUnexport function removes the binding handles for an interface and objects from an entry in the name-service database. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsBindingUnexport</b> function allows a server application to remove the binding handles and object UUIDs of resources from a name service database entry. A server application can unexport the specified interface and objects in a single call to 
     * <b>RpcNsBindingUnexport</b>, or it can unexport them separately. Only the binding handles that match the interface UUID and the major and minor interface version numbers found in the <i>IfSpec</i> parameter are unexported. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtbindingunexporta">RpcNsMgmtBindingUnexport</a> function to remove multiple versions of an interface.
     * 
     * Effective with Windows 2000, the RPC run-time environment uses the Active Directory as its name-service database. This means that an authorized unexported entries will be removed both from the local cache and from the Active Directory. Unauthorized unexports will only be removed from the local cache. See 
     * <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/access-control">Access Control</a> in the Security section of the Platform Software Development Kit (SDK) for more information on authorization and Access Control Lists.
     * 
     * If 
     * <b>RpcNsBindingUnexport</b> does not find any binding handles for the specified interface, the function returns an RPC_S_INTERFACE_NOT_FOUND status code and does not unexport the object UUIDs, if any were specified.
     * 
     * If one or more binding handles for the specified interface are found and unexported without error, 
     * <b>RpcNsBindingUnexport</b> unexports the specified object UUIDs, if any.
     * 
     * If any of the specified object UUIDs were not found, 
     * <b>RpcNsBindingUnexport</b> returns the RPC_S_NOT_ALL_OBJS_UNEXPORTED status code.
     * 
     * In addition to calling 
     * <b>RpcNsBindingUnexport</b>, a server should also call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcepunregister">RpcEpUnregister</a> function to unregister the endpoints the server previously registered with the local endpoint-map database.
     * 
     * Once created, a server entry persists, even when all of the binding handles and UUIDs are removed. A server entry must have at least one binding handle to exist. As a result, exporting only UUIDs to a nonexisting entry has no effect, and unexporting all binding handles deletes the entry.
     * 
     * Use 
     * <b>RpcNsBindingUnexport</b> judiciously. To keep an automatically activated server available, you must leave its binding handles in the name-service database between the times when server processes are activated. However, with dynamic bindings, if you do not unexport binding handles, the Active Directory can become so large as to be unmanageable.
     * 
     * Therefore, before you call this function, keep in mind how long you expect the server to be unavailable, and the type of binding in use. If you are using static bindings, reserve this function for when you expect a server to be unavailable for an extended time—for example, when it is being permanently removed from service.
     * 
     * <div class="alert"><b>Note</b>  Name-service databases are designed to be relatively stable. In replicated name-service databases, frequent use of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> and 
     * <b>RpcNsBindingUnexport</b> functions causes the name-service database to repeatedly remove and replace the same entry and can cause performance problems.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingUnexport as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the entry name from which to remove binding handles and object UUIDs.
     * @param {Pointer<Void>} IfSpec Interface specification for the binding handles to be removed from the name service database. A null parameter value indicates not to unexport any binding handles (only object UUIDs are to be unexported).
     * @param {Pointer<UUID_VECTOR>} ObjectUuidVec Pointer to a vector of object UUIDs that the server no longer wants to offer. The application constructs this vector. A null value indicates there are no object UUIDs to unexport (only binding handles are to be unexported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INTERFACE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_ALL_OBJS_UNEXPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all objects unexported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexportw
     * @since windows5.0
     */
    static RpcNsBindingUnexportW(EntryNameSyntax, EntryName, IfSpec, ObjectUuidVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingUnexportW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjectUuidVec, "int")
        return result
    }

    /**
     * The RpcNsBindingExportPnP function establishes a name-service database entry with multiple binding handles and multiple objects for a server that supports Plug and Play. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsBindingExportPnP</b> function allows a server application to publicly offer an interface in the name-service database that supports Plug and Play bindings for use by any client application.
     * 
     * Note that the server application should not explicitly supply the binding vector when exporting Plug and Play bindings. The bindings are automatically updated when there is a change in the bindings due to a Plug and Play event.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingExportPnP as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the entry name to which binding handles and object UUIDs are exported. You cannot provide a null or empty string. 
     * 
     * 
     * 
     * 
     * To use the entry name specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultEntry</b>, provide a null pointer or an empty string. In this case, the <i>EntryNameSyntax</i> parameter is ignored and the run-time library uses the default syntax.
     * @param {Pointer<Void>} IfSpec Stub-generated data structure specifying the interface to export. A null value indicates there are no binding handles to export (only object UUIDs are to be exported) and <i>BindingVec</i> is ignored.
     * @param {Pointer<UUID_VECTOR>} ObjectVector Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector. A null value indicates there are no object UUIDs to export (only binding handles are to be exported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOTHING_TO_EXPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was nothing to export.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_NS_PRIVILEGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No privilege for name-service operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingexportpnpa
     * @since windows5.0
     */
    static RpcNsBindingExportPnPA(EntryNameSyntax, EntryName, IfSpec, ObjectVector) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingExportPnPA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjectVector, "int")
        return result
    }

    /**
     * The RpcNsBindingUnexportPnP function removes the binding handles for Plug and Play interfaces and objects from an entry in the name-service database. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsBindingUnexportPnP</b> function allows a server application to remove the binding handles and object UUIDs of Plug and Play-compatible resources from a name service database entry. A server application can unexport the specified interface and objects in a single call to 
     * <b>RpcNsBindingUnexportPnP</b>, or it can unexport them separately. Only the binding handles that match the interface UUID and the major and minor interface version numbers found in the <i>IfSpec</i> parameter are unexported.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingUnexportPnP as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the entry name from which to remove binding handles and object UUIDs.
     * @param {Pointer<Void>} IfSpec Interface specification for the binding handles to be removed from the name service database. A null parameter value indicates not to unexport any binding handles (only object UUIDs are to be unexported).
     * @param {Pointer<UUID_VECTOR>} ObjectVector Pointer to a vector of object UUIDs that the server no longer wants to offer. The application constructs this vector. A null value indicates there are no object UUIDs to unexport (only binding handles are to be unexported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INTERFACE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_ALL_OBJS_UNEXPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all objects unexported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexportpnpa
     * @since windows5.0
     */
    static RpcNsBindingUnexportPnPA(EntryNameSyntax, EntryName, IfSpec, ObjectVector) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingUnexportPnPA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjectVector, "int")
        return result
    }

    /**
     * The RpcNsBindingExportPnP function establishes a name-service database entry with multiple binding handles and multiple objects for a server that supports Plug and Play. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsBindingExportPnP</b> function allows a server application to publicly offer an interface in the name-service database that supports Plug and Play bindings for use by any client application.
     * 
     * Note that the server application should not explicitly supply the binding vector when exporting Plug and Play bindings. The bindings are automatically updated when there is a change in the bindings due to a Plug and Play event.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingExportPnP as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the entry name to which binding handles and object UUIDs are exported. You cannot provide a null or empty string. 
     * 
     * 
     * 
     * 
     * To use the entry name specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultEntry</b>, provide a null pointer or an empty string. In this case, the <i>EntryNameSyntax</i> parameter is ignored and the run-time library uses the default syntax.
     * @param {Pointer<Void>} IfSpec Stub-generated data structure specifying the interface to export. A null value indicates there are no binding handles to export (only object UUIDs are to be exported) and <i>BindingVec</i> is ignored.
     * @param {Pointer<UUID_VECTOR>} ObjectVector Pointer to a vector of object UUIDs offered by the server. The server application constructs this vector. A null value indicates there are no object UUIDs to export (only binding handles are to be exported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOTHING_TO_EXPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was nothing to export.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The binding handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_WRONG_KIND_OF_BINDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This was the wrong kind of binding for the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_NS_PRIVILEGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No privilege for name-service operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingexportpnpw
     * @since windows5.0
     */
    static RpcNsBindingExportPnPW(EntryNameSyntax, EntryName, IfSpec, ObjectVector) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingExportPnPW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjectVector, "int")
        return result
    }

    /**
     * The RpcNsBindingUnexportPnP function removes the binding handles for Plug and Play interfaces and objects from an entry in the name-service database. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsBindingUnexportPnP</b> function allows a server application to remove the binding handles and object UUIDs of Plug and Play-compatible resources from a name service database entry. A server application can unexport the specified interface and objects in a single call to 
     * <b>RpcNsBindingUnexportPnP</b>, or it can unexport them separately. Only the binding handles that match the interface UUID and the major and minor interface version numbers found in the <i>IfSpec</i> parameter are unexported.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingUnexportPnP as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the entry name from which to remove binding handles and object UUIDs.
     * @param {Pointer<Void>} IfSpec Interface specification for the binding handles to be removed from the name service database. A null parameter value indicates not to unexport any binding handles (only object UUIDs are to be unexported).
     * @param {Pointer<UUID_VECTOR>} ObjectVector Pointer to a vector of object UUIDs that the server no longer wants to offer. The application constructs this vector. A null value indicates there are no object UUIDs to unexport (only binding handles are to be unexported).
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INTERFACE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_ALL_OBJS_UNEXPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all objects unexported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexportpnpw
     * @since windows5.0
     */
    static RpcNsBindingUnexportPnPW(EntryNameSyntax, EntryName, IfSpec, ObjectVector) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingUnexportPnPW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjectVector, "int")
        return result
    }

    /**
     * The RpcNsBindingLookupBegin function creates a lookup context for an interface and an object. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsBindingLookupBegin</b> function creates a lookup context for locating client-compatible binding handles to servers that offer the specified interface and object.
     * 
     * Before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a>, the client application must first call 
     * <b>RpcNsBindingLookupBegin</b> to create a lookup context. The parameters to this function control the operation of the 
     * <b>RpcNsBindingLookupNext</b> function.
     * 
     * Effective with Windows 2000, the RPC environment uses the Active Directory as its name-service database and the order in which the run-time environment performs the search is as follows:
     * 
     * <ul>
     * <li>Search in the local cache.</li>
     * <li>If entry not found in local cache, search that machine's Active Directory.</li>
     * <li>If entry not found on local machine, send broadcast requests to all other Active Directory services in the domain. 
     * 
     * 
     * Note that if the entry exists in the Active Directory, but there is no information associated with the entry, the run-time environment will not issue this broadcast request.
     * 
     * </li>
     * </ul>
     * When finished locating binding handles, the client application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupdone">RpcNsBindingLookupDone</a> function to delete the lookup context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingLookupBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of the <i>EntryName</i> parameter. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to an entry name at which the search for compatible bindings begins. 
     * 
     * 
     * 
     * 
     * To use the entry name specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultEntry</b>, provide a null pointer or an empty string. In this case, the <i>EntryNameSyntax</i> parameter is ignored and the run-time library uses the default syntax.
     * @param {Pointer<Void>} IfSpec Stub-generated structure indicating the interface to look up. If the interface specification has not been exported or is of no concern to the caller, specify a null value for this parameter. In this case, the bindings returned are only guaranteed to be of a compatible and supported protocol sequence and to contain the specified object UUID. The desired interface might not be supported by the contacted server.
     * @param {Pointer<Guid>} ObjUuid Pointer to an optional object UUID. 
     * 
     * 
     * 
     * 
     * For a nonzero UUID, compatible binding handles are returned from an entry only if the server has exported the specified object UUID.
     * 
     * For a null pointer value or a nil UUID for this parameter, the returned binding handles contain one of the object UUIDs exported by the compatible server. If the server did not export any object UUIDs, the returned compatible binding handles contain a nil object UUID.
     * @param {Integer} BindingMaxCount Maximum number of bindings to return in the <i>BindingVec</i> parameter from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a> function. 
     * 
     * 
     * 
     * 
     * Specify a value of zero to use the default count of RPC_C_BINDING_MAX_COUNT_DEFAULT.
     * @param {Pointer<Void>} LookupContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupdone">RpcNsBindingLookupDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_OBJECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid object.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina
     * @since windows5.0
     */
    static RpcNsBindingLookupBeginA(EntryNameSyntax, EntryName, IfSpec, ObjUuid, BindingMaxCount, LookupContext) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingLookupBeginA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjUuid, "uint", BindingMaxCount, "ptr", LookupContext, "int")
        return result
    }

    /**
     * The RpcNsBindingLookupBegin function creates a lookup context for an interface and an object. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsBindingLookupBegin</b> function creates a lookup context for locating client-compatible binding handles to servers that offer the specified interface and object.
     * 
     * Before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a>, the client application must first call 
     * <b>RpcNsBindingLookupBegin</b> to create a lookup context. The parameters to this function control the operation of the 
     * <b>RpcNsBindingLookupNext</b> function.
     * 
     * Effective with Windows 2000, the RPC environment uses the Active Directory as its name-service database and the order in which the run-time environment performs the search is as follows:
     * 
     * <ul>
     * <li>Search in the local cache.</li>
     * <li>If entry not found in local cache, search that machine's Active Directory.</li>
     * <li>If entry not found on local machine, send broadcast requests to all other Active Directory services in the domain. 
     * 
     * 
     * Note that if the entry exists in the Active Directory, but there is no information associated with the entry, the run-time environment will not issue this broadcast request.
     * 
     * </li>
     * </ul>
     * When finished locating binding handles, the client application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupdone">RpcNsBindingLookupDone</a> function to delete the lookup context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingLookupBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of the <i>EntryName</i> parameter. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to an entry name at which the search for compatible bindings begins. 
     * 
     * 
     * 
     * 
     * To use the entry name specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultEntry</b>, provide a null pointer or an empty string. In this case, the <i>EntryNameSyntax</i> parameter is ignored and the run-time library uses the default syntax.
     * @param {Pointer<Void>} IfSpec Stub-generated structure indicating the interface to look up. If the interface specification has not been exported or is of no concern to the caller, specify a null value for this parameter. In this case, the bindings returned are only guaranteed to be of a compatible and supported protocol sequence and to contain the specified object UUID. The desired interface might not be supported by the contacted server.
     * @param {Pointer<Guid>} ObjUuid Pointer to an optional object UUID. 
     * 
     * 
     * 
     * 
     * For a nonzero UUID, compatible binding handles are returned from an entry only if the server has exported the specified object UUID.
     * 
     * For a null pointer value or a nil UUID for this parameter, the returned binding handles contain one of the object UUIDs exported by the compatible server. If the server did not export any object UUIDs, the returned compatible binding handles contain a nil object UUID.
     * @param {Integer} BindingMaxCount Maximum number of bindings to return in the <i>BindingVec</i> parameter from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a> function. 
     * 
     * 
     * 
     * 
     * Specify a value of zero to use the default count of RPC_C_BINDING_MAX_COUNT_DEFAULT.
     * @param {Pointer<Void>} LookupContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupdone">RpcNsBindingLookupDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_OBJECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid object.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbeginw
     * @since windows5.0
     */
    static RpcNsBindingLookupBeginW(EntryNameSyntax, EntryName, IfSpec, ObjUuid, BindingMaxCount, LookupContext) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingLookupBeginW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjUuid, "uint", BindingMaxCount, "ptr", LookupContext, "int")
        return result
    }

    /**
     * The RpcNsBindingLookupNext function returns a list of compatible binding handles for a specified interface and optionally an object.
     * @remarks
     * The 
     * <b>RpcNsBindingLookupNext</b> function returns a vector of client-compatible server binding handles for a server offering the interface and object UUID specified by the <i>IfSpec</i> and <i>ObjUuid</i> parameters in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina">RpcNsBindingLookupBegin</a> function. (Compare this to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a>, which returns a single compatible server binding handle.)
     * 
     * The 
     * <b>RpcNsBindingLookupNext</b> function communicates only with the name-service database, not directly with servers.
     * 
     * Effective with Windows 2000, the RPC environment uses Active Directory as its name-service database and the order in which the run-time environment performs the search is as follows:
     * 
     * <ul>
     * <li>Search the local cache.</li>
     * <li>If entry not found in local cache, search that machine's Active Directory.</li>
     * <li>If entry not found on local machine, send broadcast requests to all other Active Directory services in the domain. 
     * 
     * 
     * Note that if the entry exists in the Active Directory, but there is no information associated with the entry, the run-time environment will not issue this broadcast request.
     * 
     * </li>
     * </ul>
     * On successive calls, the 
     * <b>RpcNsBindingLookupNext</b> function traverses name-service database entries, collecting client-compatible server binding handles from each entry.
     * 
     * When  Microsoft Active Directory is the name-service database, 
     * <b>RpcNsBindingLookupNext</b> traverses the database only if the given entry name is <b>null</b> and the default entry (in the registry) is undefined or empty. Also, since mixed entries are not permitted in the Active Directory, the function searches for server entry names only, not group or profile names.
     * 
     * When the DCE Cell Directory Service (CDS) is the name-service database, and the entry at which the search begins contains binding handles in addition to group or profile names, 
     * <b>RpcNsBindingLookupNext</b> returns the binding handles from <i>EntryName</i> before searching the group or profile. This means that the function can return a partially full vector before processing the members of the group or profile.
     * 
     * The compatible binding handle that is returned always contains an object UUID, the value of which depends on the <i>ObjUuid</i> parameter in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a> function. If a non-<b>null</b> object UUID was specified, the returned binding handle contains that object UUID. If, however, a <b>null</b> object UUID or <b>null</b> value was specified, the object UUID that is returned is a result of the following possibilities:
     * 
     * <ul>
     * <li>If the server did not export any object UUIDs, the returned binding handle contains a nil object UUID.</li>
     * <li>If the server exported one object UUID, the returned binding handle contains that object UUID.</li>
     * <li>If the server exported multiple object UUIDs, the returned binding handle contains one of the object UUIDs. The import-next operation selects the returned object UUID in a non-deterministic fashion. As a result, a different object UUID can be returned for each compatible binding handle from a single server entry.</li>
     * </ul>
     * From the returned vector of server binding handles, the client application can employ its own criteria for selecting individual binding handles, or the application can call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingselect">RpcNsBindingSelect</a> function to select a binding handle. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingtostringbinding">RpcBindingToStringBinding</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringbindingparse">RpcStringBindingParse</a> functions will be helpful to a client creating its own selection criteria.
     * 
     * The client application can use the selected binding handle to attempt to make a remote procedure call to the server. If the client fails to establish a relationship with the server, it can select another binding handle from the vector. When all of the binding handles in the vector have been used, the client application calls 
     * <b>RpcNsBindingLookupNext</b> again.
     * 
     * Each time the client calls 
     * <b>RpcNsBindingLookupNext</b>, the function returns another vector of binding handles. The binding handles returned in each vector are unordered. The vectors returned from multiple calls to this function are also unordered.
     * 
     * A client calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcnsbindinginqentryname">RpcNsBindingInqEntryName</a> function to obtain the name-service database server entry name that the binding came from.
     * 
     * When the search reaches the end of the name-service database, 
     * <b>RpcNsBindingLookupNext</b> returns a status of RPC_S_NO_MORE_BINDINGS and returns a <i>BindingVec</i> value of <b>NULL</b>.
     * 
     * The 
     * <b>RpcNsBindingLookupNext</b> function allocates storage for the data referenced by the returned <i>BindingVec</i> parameter. When a client application finishes with the vector, it must call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingvectorfree">RpcBindingVectorFree</a> function to deallocate the storage. Each call to 
     * <b>RpcNsBindingLookupNext</b> requires a corresponding call to 
     * <b>RpcBindingVectorFree</b>.
     * 
     * The client is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupdone">RpcNsBindingLookupDone</a> function to delete the lookup context, or if you want the application to start a new search for compatible servers.
     * @param {Pointer<Void>} LookupContext Name-service handle returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina">RpcNsBindingLookupBegin</a> function.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVec Returns the address of a pointer to a vector of client-compatible server binding handles.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more bindings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext
     * @since windows5.0
     */
    static RpcNsBindingLookupNext(LookupContext, BindingVec) {
        result := DllCall("RPCNS4.dll\RpcNsBindingLookupNext", "ptr", LookupContext, "ptr", BindingVec, "int")
        return result
    }

    /**
     * The RpcNsBindingLookupDone function signifies that a client has finished looking for compatible servers and deletes the lookup context.
     * @remarks
     * The 
     * <b>RpcNsBindingLookupDone</b> function frees a lookup context created by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina">RpcNsBindingLookupBegin</a> function.
     * 
     * Typically, a client application calls 
     * <b>RpcNsBindingLookupDone</b> after completing remote procedure calls to a server using a binding handle returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupnext">RpcNsBindingLookupNext</a> function. However, a client application is responsible for calling 
     * <b>RpcNsBindingLookupDone</b> for each created lookup context, regardless of the status returned from the 
     * <b>RpcNsBindingLookupNext</b> function or the success in making remote procedure calls.
     * @param {Pointer<Void>} LookupContext Pointer to the name-service handle to free. The name-service handle <i>LookupContext</i> points to is created by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupbegina">RpcNsBindingLookupBegin</a> function. 
     * 
     * 
     * 
     * 
     * An argument value of <b>NULL</b> is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindinglookupdone
     * @since windows5.0
     */
    static RpcNsBindingLookupDone(LookupContext) {
        result := DllCall("RPCNS4.dll\RpcNsBindingLookupDone", "ptr", LookupContext, "int")
        return result
    }

    /**
     * The RpcNsGroupDelete function deletes a group attribute. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsGroupDelete</b> function deletes the group attribute from the specified name service–database entry.
     * 
     * Neither the specified name service–database entry nor the group members are deleted.
     * 
     * <div class="alert"><b>Note</b>  This DCE function is not supported by Microsoft Locator. Windows NT and Windows 2000 both support the use of this function, but with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax 
     * @param {Pointer<Byte>} GroupName Pointer to the name of the name-service group to delete.
     * @returns {Integer} This function returns one of the following values:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupdeletea
     * @since windows5.0
     */
    static RpcNsGroupDeleteA(GroupNameSyntax, GroupName) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName

        result := DllCall("RPCNS4.dll\RpcNsGroupDeleteA", "uint", GroupNameSyntax, "ptr", GroupName, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrAdd function adds an entry name to a group. If necessary, it creates the entry. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrAdd</b> adds a name service–database entry name as a member to the RPC group attribute.
     * 
     * If the <i>GroupName</i> entry does not exist, 
     * <b>RpcNsGroupMbrAdd</b> tries to create the entry with a group attribute and adds the group member specified by <i>MemberName</i>. In this case, the application must have the privilege to create the entry. Otherwise, a management application with the necessary privilege should create the entry by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrycreatea">RpcNsMgmtEntryCreate</a> before the application is run.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrAdd as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax Syntax of <i>GroupName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} GroupName Pointer to the name of the RPC group to receive a new member.
     * @param {Integer} MemberNameSyntax Syntax to use in <i>MemberName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} MemberName Pointer to the name of the new RPC group member.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbradda
     * @since windows5.0
     */
    static RpcNsGroupMbrAddA(GroupNameSyntax, GroupName, MemberNameSyntax, MemberName) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsGroupMbrAddA", "uint", GroupNameSyntax, "ptr", GroupName, "uint", MemberNameSyntax, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrRemove function removes an entry name from a group. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrRemove</b> function removes a member from the RPC group attribute in the <i>GroupName</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrRemove as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax Syntax of <i>GroupName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} GroupName Pointer to the name of the RPC group from which to remove the member name.
     * @param {Integer} MemberNameSyntax Syntax to use in the <i>MemberName</i> parameter. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} MemberName Pointer to the name of the member to remove from the RPC group attribute in the entry <i>GroupName</i>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_GROUP_MEMBER_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The group member was not found.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrremovea
     * @since windows5.0
     */
    static RpcNsGroupMbrRemoveA(GroupNameSyntax, GroupName, MemberNameSyntax, MemberName) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsGroupMbrRemoveA", "uint", GroupNameSyntax, "ptr", GroupName, "uint", MemberNameSyntax, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrInqBegin function creates an inquiry context for viewing group members. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrInqBegin</b> function creates an inquiry context for viewing the members of an RPC group. Before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta">RpcNsGroupMbrInqNext</a>, the application must first call 
     * <b>RpcNsGroupMbrInqBegin</b> to create an inquiry context. When finished viewing the RPC group members, the application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqdone">RpcNsGroupMbrInqDone</a> to delete the inquiry context.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrInqBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax Syntax of <i>GroupName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} GroupName Pointer to the name of the RPC group to view.
     * @param {Integer} MemberNameSyntax Syntax of the return parameter, <i>MemberName</i>, in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta">RpcNsGroupMbrInqNext</a> function. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Void>} InquiryContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta">RpcNsGroupMbrInqNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqdone">RpcNsGroupMbrInqDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqbegina
     * @since windows5.0
     */
    static RpcNsGroupMbrInqBeginA(GroupNameSyntax, GroupName, MemberNameSyntax, InquiryContext) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName

        result := DllCall("RPCNS4.dll\RpcNsGroupMbrInqBeginA", "uint", GroupNameSyntax, "ptr", GroupName, "uint", MemberNameSyntax, "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrInqNext function returns one entry name from a group at a time. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrInqNext</b> function returns one member of the RPC group specified by the <i>GroupName</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqbegina">RpcNsGroupMbrInqBegin</a>. An application can view all the members of an RPC group set by repeatedly calling 
     * <b>RpcNsGroupMbrInqNext</b>. When all the group members have been viewed, this function returns an RPC_S_NO_MORE_MEMBERS status code. The returned group members are unordered.
     * 
     * On each call to 
     * <b>RpcNsGroupMbrInqNext</b> that returns a member name, the RPC run-time library allocates memory for the returned <i>MemberName</i>. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> for each returned <i>MemberName</i> string. After viewing the RPC group's members, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqdone">RpcNsGroupMbrInqDone</a> to release the inquiry context.
     * 
     * The order in which group members are returned can be different for each viewing of a group. This means that the order in which group members are returned to an application can be different each time the application is run.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrInqNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InquiryContext Name service handle.
     * @param {Pointer<Byte>} MemberName Returns the address of a pointer to an RPC group member name. The syntax of the returned name was specified by the <i>MemberNameSyntax</i> parameter in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqbegina">RpcNsGroupMbrInqBegin</a> function. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsGroupMbrInqNext</b> from returning the <i>MemberName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NS_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_MEMBERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more members.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta
     * @since windows5.0
     */
    static RpcNsGroupMbrInqNextA(InquiryContext, MemberName) {
        result := DllCall("RPCNS4.dll\RpcNsGroupMbrInqNextA", "ptr", InquiryContext, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsGroupDelete function deletes a group attribute. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsGroupDelete</b> function deletes the group attribute from the specified name service–database entry.
     * 
     * Neither the specified name service–database entry nor the group members are deleted.
     * 
     * <div class="alert"><b>Note</b>  This DCE function is not supported by Microsoft Locator. Windows NT and Windows 2000 both support the use of this function, but with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax 
     * @param {Pointer<Char>} GroupName Pointer to the name of the name-service group to delete.
     * @returns {Integer} This function returns one of the following values:
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupdeletew
     * @since windows5.0
     */
    static RpcNsGroupDeleteW(GroupNameSyntax, GroupName) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName

        result := DllCall("RPCNS4.dll\RpcNsGroupDeleteW", "uint", GroupNameSyntax, "ptr", GroupName, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrAdd function adds an entry name to a group. If necessary, it creates the entry. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrAdd</b> adds a name service–database entry name as a member to the RPC group attribute.
     * 
     * If the <i>GroupName</i> entry does not exist, 
     * <b>RpcNsGroupMbrAdd</b> tries to create the entry with a group attribute and adds the group member specified by <i>MemberName</i>. In this case, the application must have the privilege to create the entry. Otherwise, a management application with the necessary privilege should create the entry by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrycreatea">RpcNsMgmtEntryCreate</a> before the application is run.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrAdd as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax Syntax of <i>GroupName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} GroupName Pointer to the name of the RPC group to receive a new member.
     * @param {Integer} MemberNameSyntax Syntax to use in <i>MemberName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} MemberName Pointer to the name of the new RPC group member.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbraddw
     * @since windows5.0
     */
    static RpcNsGroupMbrAddW(GroupNameSyntax, GroupName, MemberNameSyntax, MemberName) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsGroupMbrAddW", "uint", GroupNameSyntax, "ptr", GroupName, "uint", MemberNameSyntax, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrRemove function removes an entry name from a group. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrRemove</b> function removes a member from the RPC group attribute in the <i>GroupName</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrRemove as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax Syntax of <i>GroupName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} GroupName Pointer to the name of the RPC group from which to remove the member name.
     * @param {Integer} MemberNameSyntax Syntax to use in the <i>MemberName</i> parameter. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} MemberName Pointer to the name of the member to remove from the RPC group attribute in the entry <i>GroupName</i>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_GROUP_MEMBER_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The group member was not found.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrremovew
     * @since windows5.0
     */
    static RpcNsGroupMbrRemoveW(GroupNameSyntax, GroupName, MemberNameSyntax, MemberName) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsGroupMbrRemoveW", "uint", GroupNameSyntax, "ptr", GroupName, "uint", MemberNameSyntax, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrInqBegin function creates an inquiry context for viewing group members. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrInqBegin</b> function creates an inquiry context for viewing the members of an RPC group. Before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta">RpcNsGroupMbrInqNext</a>, the application must first call 
     * <b>RpcNsGroupMbrInqBegin</b> to create an inquiry context. When finished viewing the RPC group members, the application calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqdone">RpcNsGroupMbrInqDone</a> to delete the inquiry context.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrInqBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} GroupNameSyntax Syntax of <i>GroupName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} GroupName Pointer to the name of the RPC group to view.
     * @param {Integer} MemberNameSyntax Syntax of the return parameter, <i>MemberName</i>, in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta">RpcNsGroupMbrInqNext</a> function. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Void>} InquiryContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta">RpcNsGroupMbrInqNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqdone">RpcNsGroupMbrInqDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqbeginw
     * @since windows5.0
     */
    static RpcNsGroupMbrInqBeginW(GroupNameSyntax, GroupName, MemberNameSyntax, InquiryContext) {
        GroupName := GroupName is String? StrPtr(GroupName) : GroupName

        result := DllCall("RPCNS4.dll\RpcNsGroupMbrInqBeginW", "uint", GroupNameSyntax, "ptr", GroupName, "uint", MemberNameSyntax, "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrInqNext function returns one entry name from a group at a time. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsGroupMbrInqNext</b> function returns one member of the RPC group specified by the <i>GroupName</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqbegina">RpcNsGroupMbrInqBegin</a>. An application can view all the members of an RPC group set by repeatedly calling 
     * <b>RpcNsGroupMbrInqNext</b>. When all the group members have been viewed, this function returns an RPC_S_NO_MORE_MEMBERS status code. The returned group members are unordered.
     * 
     * On each call to 
     * <b>RpcNsGroupMbrInqNext</b> that returns a member name, the RPC run-time library allocates memory for the returned <i>MemberName</i>. The application is responsible for calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> for each returned <i>MemberName</i> string. After viewing the RPC group's members, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqdone">RpcNsGroupMbrInqDone</a> to release the inquiry context.
     * 
     * The order in which group members are returned can be different for each viewing of a group. This means that the order in which group members are returned to an application can be different each time the application is run.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsGroupMbrInqNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InquiryContext Name service handle.
     * @param {Pointer<Char>} MemberName Returns the address of a pointer to an RPC group member name. The syntax of the returned name was specified by the <i>MemberNameSyntax</i> parameter in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqbegina">RpcNsGroupMbrInqBegin</a> function. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsGroupMbrInqNext</b> from returning the <i>MemberName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NS_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_MEMBERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more members.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnextw
     * @since windows5.0
     */
    static RpcNsGroupMbrInqNextW(InquiryContext, MemberName) {
        result := DllCall("RPCNS4.dll\RpcNsGroupMbrInqNextW", "ptr", InquiryContext, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsGroupMbrInqDone function deletes the inquiry context for a group.
     * @remarks
     * The 
     * <b>RpcNsGroupMbrInqDone</b> function frees an inquiry context created by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqbegina">RpcNsGroupMbrInqBegin</a> function. An application calls 
     * <b>RpcNsGroupMbrInqDone</b> after viewing RPC group members using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqnexta">RpcNsGroupMbrInqNext</a> function.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * @param {Pointer<Void>} InquiryContext Pointer to a name-service handle to free. A value of NULL is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NS_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service handle is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsgroupmbrinqdone
     * @since windows5.0
     */
    static RpcNsGroupMbrInqDone(InquiryContext) {
        result := DllCall("RPCNS4.dll\RpcNsGroupMbrInqDone", "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsProfileDelete function deletes a profile attribute. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsProfileDelete</b> function deletes the profile attribute from the specified name-service entry (<i>ProfileName</i>). Neither <i>ProfileName</i> nor the entry names included as members in each profile element are deleted.
     * 
     * <div class="alert"><b>Note</b>  Use 
     * <b>RpcNsProfileDelete</b> cautiously; deleting a profile can have the unwanted effect of breaking a hierarchy of profiles.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  This DCE function is not supported by Microsoft Locator. Windows NT and Windows 2000 support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Integer value indicating the syntax of the next parameter, <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} ProfileName Pointer to the name of the profile to delete.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofiledeletea
     * @since windows5.0
     */
    static RpcNsProfileDeleteA(ProfileNameSyntax, ProfileName) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName

        result := DllCall("RPCNS4.dll\RpcNsProfileDeleteA", "uint", ProfileNameSyntax, "ptr", ProfileName, "int")
        return result
    }

    /**
     * The RpcNsProfileEltAdd function adds an element to a profile. If necessary, it creates the entry. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsProfileEltAdd</b> function adds an element to the profile attribute of the name-service entry specified by <i>ProfileName</i>. If the <i>ProfileName</i> entry does not exist, 
     * <b>RpcNsProfileEltAdd</b> tries to create the entry with a profile attribute and adds the profile element specified by the <i>IfId</i>, <i>MemberName</i>, <i>Priority</i>, and <i>Annotation</i> parameters. In this case, the application must have the privilege to create the entry. Otherwise, a management application with the necessary privileges should create the entry by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrycreatea">RpcNsMgmtEntryCreate</a> function before the application is run.
     * 
     * If an element with the specified member name and interface identification is already in the profile, 
     * <b>RpcNsProfileEltAdd</b> updates the element's priority and annotation string using the values provided in the <i>Priority</i> and <i>Annotation</i> parameters.
     * 
     * <div class="alert"><b>Note</b>  The Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltAdd as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Syntax of <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} ProfileName Pointer to the name of the profile to receive a new element.
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to the interface identification of the new profile element. To add or replace the default profile element, specify a null value.
     * @param {Integer} MemberNameSyntax Syntax of <i>MemberName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} MemberName Pointer to a name service–entry name to include in the new profile element.
     * @param {Integer} Priority Integer value (0 through 7) that indicates the relative priority for using the new profile element during the import and lookup operations. A value of 0 is the highest priority; a value of 7 is the lowest priority. When adding a default profile member, use a value of 0.
     * @param {Pointer<Byte>} Annotation Pointer to an annotation string stored as part of the new profile element. Specify a null value or a null-terminated string if there is no annotation string. 
     * 
     * 
     * 
     * 
     * The string is used by applications for informational purposes only. For example, an application can use this string to store the interface-name string specified in the IDL file. RPC does not use the annotation string during lookup or import operations or for enumerating profile elements.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltadda
     * @since windows5.0
     */
    static RpcNsProfileEltAddA(ProfileNameSyntax, ProfileName, IfId, MemberNameSyntax, MemberName, Priority, Annotation) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName
        Annotation := Annotation is String? StrPtr(Annotation) : Annotation

        result := DllCall("RPCNS4.dll\RpcNsProfileEltAddA", "uint", ProfileNameSyntax, "ptr", ProfileName, "ptr", IfId, "uint", MemberNameSyntax, "ptr", MemberName, "uint", Priority, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcNsProfileEltRemove function removes an element from a profile. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsProfileEltRemove</b> function removes a profile element from the profile attribute in the <i>ProfileName</i> entry. This function requires an exact match of the <i>MemberName</i> and <i>IfId</i> parameters to remove a profile element. The entry (<i>MemberName</i>), included as a member in the profile element, is not deleted.
     * 
     * <div class="alert"><b>Note</b>  Use 
     * <b>RpcNsProfileEltRemove</b> cautiously: removing elements from a profile can have the unwanted effect of breaking a hierarchy of profiles.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltRemove as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Syntax of <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} ProfileName Pointer to the name of the profile from which to remove an element.
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to the interface identification of the profile element to be removed. 
     * 
     * 
     * 
     * 
     * Specify a null value to remove the default profile member.
     * @param {Integer} MemberNameSyntax Syntax of <i>MemberName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} MemberName Pointer to the name service–entry name in the profile element to remove.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltremovea
     * @since windows5.0
     */
    static RpcNsProfileEltRemoveA(ProfileNameSyntax, ProfileName, IfId, MemberNameSyntax, MemberName) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsProfileEltRemoveA", "uint", ProfileNameSyntax, "ptr", ProfileName, "ptr", IfId, "uint", MemberNameSyntax, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsProfileEltInqBegin function creates an inquiry context for viewing the elements in a profile. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsProfileEltInqBegin</b> function creates an inquiry context for viewing the elements in a profile.
     * 
     * Using the <i>InquiryType</i> parameter, an application specifies which of the following profile elements are to be returned from calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a>:
     * 
     * <ul>
     * <li>The default element</li>
     * <li>All elements</li>
     * <li>Elements with the specified interface identification</li>
     * <li>Elements with the specified member name</li>
     * <li>Elements with both the specified interface identification and member name</li>
     * </ul>
     * Before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a>, the application must first call 
     * <b>RpcNsProfileEltInqBegin</b> to create an inquiry context.
     * 
     * When finished viewing the profile elements, the application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqdone">RpcNsProfileEltInqDone</a> function to delete the inquiry context.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltInqBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Syntax of <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} ProfileName Pointer to the name of the profile to view.
     * @param {Integer} InquiryType Type of inquiry to perform on the profile. The following table lists valid inquiry types. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Inquiry type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_DEFAULT_ELT"></a><a id="rpc_c_profile_default_elt"></a><dl>
     * <dt><b>RPC_C_PROFILE_DEFAULT_ELT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for the default profile element, if any. The <i>IfId</i>, <i>VersOption</i>, and <i>MemberName</i> parameters are ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_ALL_ELTS"></a><a id="rpc_c_profile_all_elts"></a><dl>
     * <dt><b>RPC_C_PROFILE_ALL_ELTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns every element from the profile. The <i>IfId</i>, <i>VersOption</i>, and <i>MemberName</i> parameters are ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_MATCH_BY_IF"></a><a id="rpc_c_profile_match_by_if"></a><dl>
     * <dt><b>RPC_C_PROFILE_MATCH_BY_IF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for elements that contain the interface identification specified by <i>IfId</i> and <i>VersOption</i>. The <i>MemberName</i> parameter is ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_MATCH_BY_MBR"></a><a id="rpc_c_profile_match_by_mbr"></a><dl>
     * <dt><b>RPC_C_PROFILE_MATCH_BY_MBR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for elements that contain <i>MemberName</i>. The <i>IfId</i> and <i>VersOption</i> parameters are ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_MATCH_BY_BOTH"></a><a id="rpc_c_profile_match_by_both"></a><dl>
     * <dt><b>RPC_C_PROFILE_MATCH_BY_BOTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for elements that contain the interface identification and member identified by the <i>IfId</i>, <i>VersOption</i>, and <i>MemberName</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to the interface identification of the profile elements to be returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function. 
     * 
     * 
     * 
     * 
     * The <i>IfId</i> parameter is used only when specifying a value of RPC_C_PROFILE_MATCH_BY_IF or RPC_C_PROFILE_MATCH_BY_BOTH for the <i>InquiryType</i> parameter. Otherwise, <i>IfId</i> is ignored and a null value can be specified.
     * @param {Integer} VersOption Specifies how the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function uses the <i>IfId</i> parameter. This parameter is used only when specifying a value of RPC_C_PROFILE_MATCH_BY_IF or RPC_C_PROFILE_MATCH_BY_BOTH for <i>InquiryType</i>. Otherwise, this parameter is ignored and a 0 value can be specified. 
     * 
     * 
     * 
     * 
     * The following table describes valid values for <i>VersOption</i>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_ALL"></a><a id="rpc_c_vers_all"></a><dl>
     * <dt><b>RPC_C_VERS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the specified interface UUID, regardless of the version numbers. For this value, specify 0 for both the major and minor versions in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_COMPATIBLE"></a><a id="rpc_c_vers_compatible"></a><dl>
     * <dt><b>RPC_C_VERS_COMPATIBLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the same major version of the specified interface UUID and a minor version greater than or equal to the minor version of the specified interface UUID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_EXACT"></a><a id="rpc_c_vers_exact"></a><dl>
     * <dt><b>RPC_C_VERS_EXACT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the specified version of the specified interface UUID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_MAJOR_ONLY"></a><a id="rpc_c_vers_major_only"></a><dl>
     * <dt><b>RPC_C_VERS_MAJOR_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the same major version of the specified interface UUID (ignores the minor version). For this value, specify 0 for the minor version in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_UPTO"></a><a id="rpc_c_vers_upto"></a><dl>
     * <dt><b>RPC_C_VERS_UPTO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer a version of the specified interface UUID less than or equal to the specified major and minor version. (For example, if the <i>IfId</i> contained V2.0 and the profile contained elements with V1.3, V2.0, and V2.1, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function returns elements with V1.3 and V2.0.)
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} MemberNameSyntax Syntax of <i>MemberName</i>, and the return parameter <i>MemberName</i> in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} MemberName Pointer to the member name that the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function looks for in profile elements. The <i>MemberName</i> parameter is used only when specifying a value of RPC_C_PROFILE_MATCH_BY_MBR or RPC_C_PROFILE_MATCH_BY_BOTH for <i>InquiryType</i>. Otherwise, <i>MemberName</i> is ignored and a null value can be specified.
     * @param {Pointer<Void>} InquiryContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqdone">RpcNsProfileEltInqDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina
     * @since windows5.0
     */
    static RpcNsProfileEltInqBeginA(ProfileNameSyntax, ProfileName, InquiryType, IfId, VersOption, MemberNameSyntax, MemberName, InquiryContext) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsProfileEltInqBeginA", "uint", ProfileNameSyntax, "ptr", ProfileName, "uint", InquiryType, "ptr", IfId, "uint", VersOption, "uint", MemberNameSyntax, "ptr", MemberName, "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsProfileEltInqNext function returns one element at a time from a profile. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsProfileEltInqNext</b> function returns one element from the profile specified by the <i>ProfileName</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a>. Regardless of the value of <i>InquiryType</i> in 
     * <b>RpcNsProfileEltInqBegin</b>, 
     * <b>RpcNsProfileEltInqNext</b> returns all the components (interface identification, member name, priority, annotation string) of a profile element.
     * 
     * An application can view all the selected profile entries by repeatedly calling the 
     * <b>RpcNsProfileEltInqNext</b> function. When all the elements have been viewed, this function returns a RPC_S_NO_MORE_ELEMENTS status code. The returned elements are unordered.
     * 
     * On each call to 
     * <b>RpcNsProfileEltInqNext</b> that returns a profile element, the RPC run-time library allocates memory for the returned member name and annotation string. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for each returned member name and annotation string. After viewing the profile's elements, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqdone">RpcNsProfileEltInqDone</a> to release the inquiry context.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltInqNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InquiryContext Name-service handle returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a> function.
     * @param {Pointer<RPC_IF_ID>} IfId Returns a pointer to the interface identification of the profile element.
     * @param {Pointer<Byte>} MemberName Returns a pointer to a pointer to the profile element's member name.The syntax of the returned name was specified by the <i>MemberNameSyntax</i> parameter in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a> function. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsProfileEltInqNext</b> from returning the <i>MemberName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} Priority Returns a pointer to the profile-element priority.
     * @param {Pointer<Byte>} Annotation Returns a pointer to a pointer to the annotation string for the profile element. If there is no annotation string in the profile element, the string \0 is returned. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsProfileEltInqNext</b> from returning the <i>Annotation</i> parameter. In this case, the application does not need to call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_ELEMENTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more elements.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta
     * @since windows5.0
     */
    static RpcNsProfileEltInqNextA(InquiryContext, IfId, MemberName, Priority, Annotation) {
        result := DllCall("RPCNS4.dll\RpcNsProfileEltInqNextA", "ptr", InquiryContext, "ptr", IfId, "ptr", MemberName, "uint*", Priority, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcNsProfileDelete function deletes a profile attribute. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsProfileDelete</b> function deletes the profile attribute from the specified name-service entry (<i>ProfileName</i>). Neither <i>ProfileName</i> nor the entry names included as members in each profile element are deleted.
     * 
     * <div class="alert"><b>Note</b>  Use 
     * <b>RpcNsProfileDelete</b> cautiously; deleting a profile can have the unwanted effect of breaking a hierarchy of profiles.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  This DCE function is not supported by Microsoft Locator. Windows NT and Windows 2000 support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Integer value indicating the syntax of the next parameter, <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} ProfileName Pointer to the name of the profile to delete.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofiledeletew
     * @since windows5.0
     */
    static RpcNsProfileDeleteW(ProfileNameSyntax, ProfileName) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName

        result := DllCall("RPCNS4.dll\RpcNsProfileDeleteW", "uint", ProfileNameSyntax, "ptr", ProfileName, "int")
        return result
    }

    /**
     * The RpcNsProfileEltAdd function adds an element to a profile. If necessary, it creates the entry. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsProfileEltAdd</b> function adds an element to the profile attribute of the name-service entry specified by <i>ProfileName</i>. If the <i>ProfileName</i> entry does not exist, 
     * <b>RpcNsProfileEltAdd</b> tries to create the entry with a profile attribute and adds the profile element specified by the <i>IfId</i>, <i>MemberName</i>, <i>Priority</i>, and <i>Annotation</i> parameters. In this case, the application must have the privilege to create the entry. Otherwise, a management application with the necessary privileges should create the entry by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrycreatea">RpcNsMgmtEntryCreate</a> function before the application is run.
     * 
     * If an element with the specified member name and interface identification is already in the profile, 
     * <b>RpcNsProfileEltAdd</b> updates the element's priority and annotation string using the values provided in the <i>Priority</i> and <i>Annotation</i> parameters.
     * 
     * <div class="alert"><b>Note</b>  The Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltAdd as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Syntax of <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} ProfileName Pointer to the name of the profile to receive a new element.
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to the interface identification of the new profile element. To add or replace the default profile element, specify a null value.
     * @param {Integer} MemberNameSyntax Syntax of <i>MemberName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} MemberName Pointer to a name service–entry name to include in the new profile element.
     * @param {Integer} Priority Integer value (0 through 7) that indicates the relative priority for using the new profile element during the import and lookup operations. A value of 0 is the highest priority; a value of 7 is the lowest priority. When adding a default profile member, use a value of 0.
     * @param {Pointer<Char>} Annotation Pointer to an annotation string stored as part of the new profile element. Specify a null value or a null-terminated string if there is no annotation string. 
     * 
     * 
     * 
     * 
     * The string is used by applications for informational purposes only. For example, an application can use this string to store the interface-name string specified in the IDL file. RPC does not use the annotation string during lookup or import operations or for enumerating profile elements.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltaddw
     * @since windows5.0
     */
    static RpcNsProfileEltAddW(ProfileNameSyntax, ProfileName, IfId, MemberNameSyntax, MemberName, Priority, Annotation) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName
        Annotation := Annotation is String? StrPtr(Annotation) : Annotation

        result := DllCall("RPCNS4.dll\RpcNsProfileEltAddW", "uint", ProfileNameSyntax, "ptr", ProfileName, "ptr", IfId, "uint", MemberNameSyntax, "ptr", MemberName, "uint", Priority, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcNsProfileEltRemove function removes an element from a profile. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsProfileEltRemove</b> function removes a profile element from the profile attribute in the <i>ProfileName</i> entry. This function requires an exact match of the <i>MemberName</i> and <i>IfId</i> parameters to remove a profile element. The entry (<i>MemberName</i>), included as a member in the profile element, is not deleted.
     * 
     * <div class="alert"><b>Note</b>  Use 
     * <b>RpcNsProfileEltRemove</b> cautiously: removing elements from a profile can have the unwanted effect of breaking a hierarchy of profiles.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltRemove as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Syntax of <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} ProfileName Pointer to the name of the profile from which to remove an element.
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to the interface identification of the profile element to be removed. 
     * 
     * 
     * 
     * 
     * Specify a null value to remove the default profile member.
     * @param {Integer} MemberNameSyntax Syntax of <i>MemberName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} MemberName Pointer to the name service–entry name in the profile element to remove.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltremovew
     * @since windows5.0
     */
    static RpcNsProfileEltRemoveW(ProfileNameSyntax, ProfileName, IfId, MemberNameSyntax, MemberName) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsProfileEltRemoveW", "uint", ProfileNameSyntax, "ptr", ProfileName, "ptr", IfId, "uint", MemberNameSyntax, "ptr", MemberName, "int")
        return result
    }

    /**
     * The RpcNsProfileEltInqBegin function creates an inquiry context for viewing the elements in a profile. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsProfileEltInqBegin</b> function creates an inquiry context for viewing the elements in a profile.
     * 
     * Using the <i>InquiryType</i> parameter, an application specifies which of the following profile elements are to be returned from calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a>:
     * 
     * <ul>
     * <li>The default element</li>
     * <li>All elements</li>
     * <li>Elements with the specified interface identification</li>
     * <li>Elements with the specified member name</li>
     * <li>Elements with both the specified interface identification and member name</li>
     * </ul>
     * Before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a>, the application must first call 
     * <b>RpcNsProfileEltInqBegin</b> to create an inquiry context.
     * 
     * When finished viewing the profile elements, the application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqdone">RpcNsProfileEltInqDone</a> function to delete the inquiry context.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltInqBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} ProfileNameSyntax Syntax of <i>ProfileName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} ProfileName Pointer to the name of the profile to view.
     * @param {Integer} InquiryType Type of inquiry to perform on the profile. The following table lists valid inquiry types. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Inquiry type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_DEFAULT_ELT"></a><a id="rpc_c_profile_default_elt"></a><dl>
     * <dt><b>RPC_C_PROFILE_DEFAULT_ELT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for the default profile element, if any. The <i>IfId</i>, <i>VersOption</i>, and <i>MemberName</i> parameters are ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_ALL_ELTS"></a><a id="rpc_c_profile_all_elts"></a><dl>
     * <dt><b>RPC_C_PROFILE_ALL_ELTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns every element from the profile. The <i>IfId</i>, <i>VersOption</i>, and <i>MemberName</i> parameters are ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_MATCH_BY_IF"></a><a id="rpc_c_profile_match_by_if"></a><dl>
     * <dt><b>RPC_C_PROFILE_MATCH_BY_IF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for elements that contain the interface identification specified by <i>IfId</i> and <i>VersOption</i>. The <i>MemberName</i> parameter is ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_MATCH_BY_MBR"></a><a id="rpc_c_profile_match_by_mbr"></a><dl>
     * <dt><b>RPC_C_PROFILE_MATCH_BY_MBR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for elements that contain <i>MemberName</i>. The <i>IfId</i> and <i>VersOption</i> parameters are ignored.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_PROFILE_MATCH_BY_BOTH"></a><a id="rpc_c_profile_match_by_both"></a><dl>
     * <dt><b>RPC_C_PROFILE_MATCH_BY_BOTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Searches the profile for elements that contain the interface identification and member identified by the <i>IfId</i>, <i>VersOption</i>, and <i>MemberName</i> parameters.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to the interface identification of the profile elements to be returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function. 
     * 
     * 
     * 
     * 
     * The <i>IfId</i> parameter is used only when specifying a value of RPC_C_PROFILE_MATCH_BY_IF or RPC_C_PROFILE_MATCH_BY_BOTH for the <i>InquiryType</i> parameter. Otherwise, <i>IfId</i> is ignored and a null value can be specified.
     * @param {Integer} VersOption Specifies how the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function uses the <i>IfId</i> parameter. This parameter is used only when specifying a value of RPC_C_PROFILE_MATCH_BY_IF or RPC_C_PROFILE_MATCH_BY_BOTH for <i>InquiryType</i>. Otherwise, this parameter is ignored and a 0 value can be specified. 
     * 
     * 
     * 
     * 
     * The following table describes valid values for <i>VersOption</i>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_ALL"></a><a id="rpc_c_vers_all"></a><dl>
     * <dt><b>RPC_C_VERS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the specified interface UUID, regardless of the version numbers. For this value, specify 0 for both the major and minor versions in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_COMPATIBLE"></a><a id="rpc_c_vers_compatible"></a><dl>
     * <dt><b>RPC_C_VERS_COMPATIBLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the same major version of the specified interface UUID and a minor version greater than or equal to the minor version of the specified interface UUID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_EXACT"></a><a id="rpc_c_vers_exact"></a><dl>
     * <dt><b>RPC_C_VERS_EXACT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the specified version of the specified interface UUID.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_MAJOR_ONLY"></a><a id="rpc_c_vers_major_only"></a><dl>
     * <dt><b>RPC_C_VERS_MAJOR_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer the same major version of the specified interface UUID (ignores the minor version). For this value, specify 0 for the minor version in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_UPTO"></a><a id="rpc_c_vers_upto"></a><dl>
     * <dt><b>RPC_C_VERS_UPTO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns profile elements that offer a version of the specified interface UUID less than or equal to the specified major and minor version. (For example, if the <i>IfId</i> contained V2.0 and the profile contained elements with V1.3, V2.0, and V2.1, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function returns elements with V1.3 and V2.0.)
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} MemberNameSyntax Syntax of <i>MemberName</i>, and the return parameter <i>MemberName</i> in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} MemberName Pointer to the member name that the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function looks for in profile elements. The <i>MemberName</i> parameter is used only when specifying a value of RPC_C_PROFILE_MATCH_BY_MBR or RPC_C_PROFILE_MATCH_BY_BOTH for <i>InquiryType</i>. Otherwise, <i>MemberName</i> is ignored and a null value can be specified.
     * @param {Pointer<Void>} InquiryContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqdone">RpcNsProfileEltInqDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbeginw
     * @since windows5.0
     */
    static RpcNsProfileEltInqBeginW(ProfileNameSyntax, ProfileName, InquiryType, IfId, VersOption, MemberNameSyntax, MemberName, InquiryContext) {
        ProfileName := ProfileName is String? StrPtr(ProfileName) : ProfileName
        MemberName := MemberName is String? StrPtr(MemberName) : MemberName

        result := DllCall("RPCNS4.dll\RpcNsProfileEltInqBeginW", "uint", ProfileNameSyntax, "ptr", ProfileName, "uint", InquiryType, "ptr", IfId, "uint", VersOption, "uint", MemberNameSyntax, "ptr", MemberName, "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsProfileEltInqNext function returns one element at a time from a profile. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsProfileEltInqNext</b> function returns one element from the profile specified by the <i>ProfileName</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a>. Regardless of the value of <i>InquiryType</i> in 
     * <b>RpcNsProfileEltInqBegin</b>, 
     * <b>RpcNsProfileEltInqNext</b> returns all the components (interface identification, member name, priority, annotation string) of a profile element.
     * 
     * An application can view all the selected profile entries by repeatedly calling the 
     * <b>RpcNsProfileEltInqNext</b> function. When all the elements have been viewed, this function returns a RPC_S_NO_MORE_ELEMENTS status code. The returned elements are unordered.
     * 
     * On each call to 
     * <b>RpcNsProfileEltInqNext</b> that returns a profile element, the RPC run-time library allocates memory for the returned member name and annotation string. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for each returned member name and annotation string. After viewing the profile's elements, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqdone">RpcNsProfileEltInqDone</a> to release the inquiry context.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsProfileEltInqNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Void>} InquiryContext Name-service handle returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a> function.
     * @param {Pointer<RPC_IF_ID>} IfId Returns a pointer to the interface identification of the profile element.
     * @param {Pointer<Char>} MemberName Returns a pointer to a pointer to the profile element's member name.The syntax of the returned name was specified by the <i>MemberNameSyntax</i> parameter in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a> function. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsProfileEltInqNext</b> from returning the <i>MemberName</i> parameter. In this case, the application does not call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @param {Pointer<UInt32>} Priority Returns a pointer to the profile-element priority.
     * @param {Pointer<Char>} Annotation Returns a pointer to a pointer to the annotation string for the profile element. If there is no annotation string in the profile element, the string \0 is returned. 
     * 
     * 
     * 
     * 
     * Specify a null value to prevent 
     * <b>RpcNsProfileEltInqNext</b> from returning the <i>Annotation</i> parameter. In this case, the application does not need to call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_ELEMENTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more elements.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnextw
     * @since windows5.0
     */
    static RpcNsProfileEltInqNextW(InquiryContext, IfId, MemberName, Priority, Annotation) {
        result := DllCall("RPCNS4.dll\RpcNsProfileEltInqNextW", "ptr", InquiryContext, "ptr", IfId, "ptr", MemberName, "uint*", Priority, "ptr", Annotation, "int")
        return result
    }

    /**
     * The RpcNsProfileEltInqDone function deletes the inquiry context for viewing the elements in a profile.
     * @remarks
     * The 
     * <b>RpcNsProfileEltInqDone</b> function frees an inquiry context created by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a>.
     * 
     * An application calls 
     * <b>RpcNsProfileEltInqDone</b> after viewing profile elements using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqnexta">RpcNsProfileEltInqNext</a> function.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * @param {Pointer<Void>} InquiryContext Pointer to a name-service handle to free. The name-service handle that <i>InquiryContext</i> points to is created by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqbegina">RpcNsProfileEltInqBegin</a> function. 
     * 
     * 
     * 
     * 
     * An argument value of NULL is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsprofileeltinqdone
     * @since windows5.0
     */
    static RpcNsProfileEltInqDone(InquiryContext) {
        result := DllCall("RPCNS4.dll\RpcNsProfileEltInqDone", "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsEntryObjectInqBegin function creates an inquiry context for the objects of a name-service database entry. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsEntryObjectInqBegin</b> function creates an inquiry context for viewing the object UUIDs exported to <i>EntryName</i>.
     * 
     * Before calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqnext">RpcNsEntryObjectInqNext</a> function, the application must first call 
     * <b>RpcNsEntryObjectInqBegin</b> to create an inquiry context.
     * 
     * When finished viewing the object UUIDs, the application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqdone">RpcNsEntryObjectInqDone</a> function to delete the inquiry context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsEntryObjectInqBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax to use in <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the name-service database entry name for which object UUIDs are to be viewed.
     * @param {Pointer<Void>} InquiryContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqnext">RpcNsEntryObjectInqNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqdone">RpcNsEntryObjectInqDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqbegina
     * @since windows5.0
     */
    static RpcNsEntryObjectInqBeginA(EntryNameSyntax, EntryName, InquiryContext) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsEntryObjectInqBeginA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsEntryObjectInqBegin function creates an inquiry context for the objects of a name-service database entry. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsEntryObjectInqBegin</b> function creates an inquiry context for viewing the object UUIDs exported to <i>EntryName</i>.
     * 
     * Before calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqnext">RpcNsEntryObjectInqNext</a> function, the application must first call 
     * <b>RpcNsEntryObjectInqBegin</b> to create an inquiry context.
     * 
     * When finished viewing the object UUIDs, the application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqdone">RpcNsEntryObjectInqDone</a> function to delete the inquiry context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsEntryObjectInqBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax to use in <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the name-service database entry name for which object UUIDs are to be viewed.
     * @param {Pointer<Void>} InquiryContext Returns a pointer to a name-service handle for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqnext">RpcNsEntryObjectInqNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqdone">RpcNsEntryObjectInqDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqbeginw
     * @since windows5.0
     */
    static RpcNsEntryObjectInqBeginW(EntryNameSyntax, EntryName, InquiryContext) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsEntryObjectInqBeginW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsEntryObjectInqNext function returns one object at a time from a name-service database entry.
     * @remarks
     * The 
     * <b>RpcNsEntryObjectInqNext</b> function returns one of the object UUIDs exported to the name-service database entry specified by the <i>EntryName</i> parameter in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqbegina">RpcNsEntryObjectInqBegin</a> function.
     * 
     * An application can view all of the exported object UUIDs by repeatedly calling 
     * <b>RpcNsEntryObjectInqNext</b>. When all the object UUIDs have been viewed, this function returns an RPC_S_NO_MORE_MEMBERS status code. The returned object UUIDs are unordered.
     * 
     * The application supplies the memory for the object UUID returned in the <i>ObjUuid</i> parameter.
     * 
     * After viewing the object UUIDs, the application must call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqdone">RpcNsEntryObjectInqDone</a> function to release the inquiry context.
     * 
     * The order in which object UUIDs are returned can be different for each viewing of an entry. This means that the order in which object UUIDs are returned to an application can be different each time the application is run.
     * @param {Pointer<Void>} InquiryContext Name-service handle that indicates the object UUIDs for a name-service database entry.
     * @param {Pointer<Guid>} ObjUuid Returns a pointer to an exported object UUID.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_MEMBERS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more members.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqnext
     * @since windows5.0
     */
    static RpcNsEntryObjectInqNext(InquiryContext, ObjUuid) {
        result := DllCall("RPCNS4.dll\RpcNsEntryObjectInqNext", "ptr", InquiryContext, "ptr", ObjUuid, "int")
        return result
    }

    /**
     * The RpcNsEntryObjectInqDone function deletes the inquiry context for a name-service database entry's objects.
     * @remarks
     * The 
     * <b>RpcNsEntryObjectInqDone</b> function frees an inquiry context created by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqbegina">RpcNsEntryObjectInqBegin</a> function.
     * 
     * An application calls 
     * <b>RpcNsEntryObjectInqDone</b> after viewing exported object UUIDs using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqnext">RpcNsEntryObjectInqNext</a> function.
     * @param {Pointer<Void>} InquiryContext Pointer to a name-service handle specifying the object UUIDs exported to the <i>EntryName</i> parameter specified in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqbegina">RpcNsEntryObjectInqBegin</a> function. 
     * 
     * 
     * 
     * 
     * An argument value of <b>NULL</b> is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsentryobjectinqdone
     * @since windows5.0
     */
    static RpcNsEntryObjectInqDone(InquiryContext) {
        result := DllCall("RPCNS4.dll\RpcNsEntryObjectInqDone", "ptr", InquiryContext, "int")
        return result
    }

    /**
     * The RpcNsEntryExpandName function expands a name-service entry name. This function is supported by Active Directory. (ANSI)
     * @remarks
     * An application calls the 
     * <b>RpcNsEntryExpandName</b> function to obtain a fully expanded entry name.
     * 
     * The RPC run-time library allocates memory for the returned <i>ExpandedName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for that returned string.
     * 
     * The returned expanded entry name accounts for local name translations and for differences in locally defined naming schema.
     * 
     * <div class="alert"><b>Note</b>  This function requires Active Directory support.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsEntryExpandName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of <b>RPC_C_NS_SYNTAX_DEFAULT</b>.
     * @param {Pointer<Byte>} EntryName Pointer to the entry name to expand.
     * @param {Pointer<Byte>} ExpandedName Returns a pointer to a pointer to the expanded version of <i>EntryName</i>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsentryexpandnamea
     * @since windows5.0
     */
    static RpcNsEntryExpandNameA(EntryNameSyntax, EntryName, ExpandedName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsEntryExpandNameA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", ExpandedName, "int")
        return result
    }

    /**
     * The RpcNsMgmtBindingUnexport function removes multiple binding handles and objects from an entry in the name-service database. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsMgmtBindingUnexport</b> function allows a management application to remove one of the following from a name service–database entry:
     * 
     * <ul>
     * <li>All the binding handles for a specified interface UUID, qualified by the interface version numbers (major and minor)</li>
     * <li>One or more object UUIDs of resources</li>
     * <li>Both binding handles and object UUIDs of resources</li>
     * </ul>
     * A management application can unexport interfaces and objects in a single call to 
     * <b>RpcNsMgmtBindingUnexport</b>, or it can unexport them separately. If 
     * <b>RpcNsMgmtBindingUnexport</b> does not find any binding handles for the specified interface, the function returns an RPC_S_INTERFACE_NOT_FOUND status code and does not unexport the object UUIDs, if any were specified.
     * 
     * If one or more binding handles for the specified interface are found and unexported without error, 
     * <b>RpcNsMgmtBindingUnexport</b> unexports any specified object UUIDs. If any of the specified object UUIDs were not found, 
     * <b>RpcNsMgmtBindingUnexport</b> returns RPC_S_NOT_ALL_OBJS_UNEXPORTED.
     * 
     * In addition to calling 
     * <b>RpcNsMgmtBindingUnexport</b>, a management application should also call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepunregister">RpcMgmtEpUnregister</a> function to unregister the servers that have registered with the endpoint-map database.
     * 
     * <div class="alert"><b>Note</b>  Name-service databases are designed to be relatively stable. In replicated name services, frequent use of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexporta">RpcNsBindingUnexport</a> functions causes the name service to repeatedly remove and replace the same entry, which can cause performance problems.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtBindingUnexport as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the name of the entry from which to remove binding handles and object UUIDs.
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to an interface identification. A null parameter value indicates that binding handles are not to be unexported—only object UUIDs are to be unexported.
     * @param {Integer} VersOption Specifies how the 
     * <b>RpcNsMgmtBindingUnexport</b> function uses the <b>VersMajor</b> and <b>VersMinor</b> members of the structure pointed to by the <i>IfId</i> parameter. 
     * 
     * 
     * 
     * 
     * The following table describes valid values for the <i>VersOption</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>VersOption values</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_ALL"></a><a id="rpc_c_vers_all"></a><dl>
     * <dt><b>RPC_C_VERS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports all bindings for the interface UUID in <i>IfId</i>, regardless of the version numbers. For this value, specify 0 for both the major and minor versions in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_IF_ID"></a><a id="rpc_c_vers_if_id"></a><dl>
     * <dt><b>RPC_C_VERS_IF_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings for the compatible interface UUID in <i>IfId</i> with the same major version and with a minor version greater than or equal to the minor version in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_EXACT"></a><a id="rpc_c_vers_exact"></a><dl>
     * <dt><b>RPC_C_VERS_EXACT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings for the interface UUID in <i>IfId</i> with the same major and minor versions as in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_MAJOR_ONLY"></a><a id="rpc_c_vers_major_only"></a><dl>
     * <dt><b>RPC_C_VERS_MAJOR_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings for the interface UUID in <i>IfId</i> with the same major version as in <i>IfId</i> (ignores the minor version). For this value, specify 0 for the minor version in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_UPTO"></a><a id="rpc_c_vers_upto"></a><dl>
     * <dt><b>RPC_C_VERS_UPTO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings that offer a version of the specified interface UUID less than or equal to the specified major and minor version. (For example, if the <i>IfId</i> contained V2.0 and the name service–database entry contained binding handles with the versions 1.3, 2.0, and 2.1, the 
     * <b>RpcNsMgmtBindingUnexport</b> function would unexport the binding handles with versions 1.3 and 2.0.)
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UUID_VECTOR>} ObjectUuidVec Pointer to a vector of object UUIDs that the server no longer wants to offer. The application constructs this vector. A null value indicates there are no object UUIDs to unexport—only binding handles are to be unexported.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INTERFACE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_ALL_OBJS_UNEXPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all objects unexported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtbindingunexporta
     * @since windows5.0
     */
    static RpcNsMgmtBindingUnexportA(EntryNameSyntax, EntryName, IfId, VersOption, ObjectUuidVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtBindingUnexportA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfId, "uint", VersOption, "ptr", ObjectUuidVec, "int")
        return result
    }

    /**
     * The RpcNsMgmtEntryCreate function creates a name service�database entry. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsMgmtEntryCreate</b> function creates an entry in the name-service database. A management application can call 
     * <b>RpcNsMgmtEntryCreate</b> to create a name service–database entry for use by another application that does not itself have the necessary name service–database privileges to create an entry.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtEntryCreate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the name of the entry to create.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrycreatea
     * @since windows5.0
     */
    static RpcNsMgmtEntryCreateA(EntryNameSyntax, EntryName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtEntryCreateA", "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * The RpcNsMgmtEntryDelete function deletes a name service�database entry. (ANSI)
     * @remarks
     * Management applications use the 
     * <b>RpcNsMgmtEntryDelete</b> function only when an entry is no longer needed—for example, when a server is being permanently removed from service.
     * 
     * Because name-service databases are designed to be relatively stable, frequent use of 
     * <b>RpcNsMgmtEntryDelete</b> in client or server applications can result in performance problems. Creating and deleting entries in client or server applications causes the name-service database to repeatedly remove and replace the same entry. This can lead to performance problems in replicated name-service databases.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtEntryDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the name of the entry to delete.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_RPC_ENTRY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not an RPC entry.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrydeletea
     * @since windows5.0
     */
    static RpcNsMgmtEntryDeleteA(EntryNameSyntax, EntryName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtEntryDeleteA", "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * The RpcNsMgmtEntryInqIfIds function returns the list of interfaces exported to a name service�database entry. (ANSI)
     * @remarks
     * The 
     * <b>RpcNsMgmtEntryInqIfIds</b> function returns an interface-identification vector containing the interfaces of binding handles exported by a server to <i>EntryName</i>. This function uses an expiration age of 0, causing an immediate update of the local copy of name-service data. The calling application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcifidvectorfree">RpcIfIdVectorFree</a> function to release memory used by the vector.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtEntryInqIfIds as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to the name service–database entry name for which an interface-identification vector is returned.
     * @param {Pointer<RPC_IF_ID_VECTOR>} IfIdVec Returns an address of a pointer to the interface-identification vector.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentryinqifidsa
     * @since windows5.0
     */
    static RpcNsMgmtEntryInqIfIdsA(EntryNameSyntax, EntryName, IfIdVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtEntryInqIfIdsA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfIdVec, "int")
        return result
    }

    /**
     * The RpcNsMgmtHandleSetExpAge function sets the expiration age of a name-service handle for local copies of name-service data.
     * @remarks
     * The 
     * <b>RpcNsMgmtHandleSetExpAge</b> function sets a handle-expiration age for a specified name–service handle (<i>NsHandle</i>). The expiration age is the amount of time that a local copy of data from a name-service attribute can exist before a request from the application for the attribute requires updating the local copy. When an application begins running, the RPC run-time library specifies a default expiration age of two hours. The default is global to the application. A handle-expiration age applies only to a specific name-service handle and temporarily overrides the current global expiration age.
     * 
     * A handle-expiration age is used exclusively by Pointer next operations (which read data from name-service attributes). A next operation typically starts by looking for a local copy of the attribute data being requested by an application. In the absence of a local copy, the next operation creates one with fresh attribute data from the name-service database. If a local copy already exists, the operation compares its actual age to the expiration age being used by the application (which, in this case, is the expiration age set for the name-service handle). If the actual age exceeds the handle-expiration age, the operation automatically tries to update the local copy with fresh attribute data. If updating is impossible, the old local data remains in place and the next operation fails, returning the RPC_S_NAME_SERVICE_UNAVAILABLE status code.
     * 
     * The scope of a handle-expiration age is a single series of next operations. The 
     * <b>RpcNsMgmtHandleSetExpAge</b> function operates within the following context:
     * 
     * <ul>
     * <li>A begin operation creates a name-service handle.</li>
     * <li>A call to the 
     * <b>RpcNsMgmtHandleSetExpAge</b> function creates an expiration age for the handle.</li>
     * <li>A series of next operations for the name-service handle uses the handle expiration age.</li>
     * <li>A done operation for the name-service handle deletes both the handle and its expiration age.</li>
     * </ul>
     * <div class="alert"><b>Note</b>  Typically, you should avoid using 
     * <b>RpcNsMgmtHandleSetExpAge</b>. Instead, you should rely on the application's global expiration age. Setting the handle-expiration age to a small value causes the name service next operations to frequently update local data for any name-service attribute requested by your application. For example, setting the expiration age to 0 forces the next operation to update local data for the name-service attribute requested by your application. Therefore, setting a small handle-expiration age can create performance problems for your application. Furthermore, if your application is using a remote name-service server, a small expiration age can adversely affect network performance for all applications.</div>
     * <div> </div>
     * Limit use of 
     * <b>RpcNsMgmtHandleSetExpAge</b> to the following situations:
     * 
     * <ul>
     * <li>When you must always get accurate name-service data. 
     * 
     * 
     * For example, during management operations to update a profile, you may need to always see the profile's current contents. In this case, before beginning to inquire about a profile, your application should call the 
     * <b>RpcNsMgmtHandleSetExpAge</b> function and specify 0 for the <i>ExpirationAge</i> parameter.
     * 
     * </li>
     * <li>When a request using the default expiration age has failed, and your application needs to retry the operation. 
     * 
     * 
     * For example, a client application using name service import operations should first try to obtain bindings using the application's default expiration age. However, sometimes the import-next operation returns either no binding handles or an insufficient number of them. In this case, the client could retry the import operation and, after the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a> call, include an 
     * <b>RpcNsMgmtHandleSetExpAge</b> call and specify 0 for the <i>ExpirationAge</i> parameter. When the client calls the import-next function again, the small handle-expiration age causes the import-next operation to update the local attribute data.
     * 
     * </li>
     * </ul>
     * @param {Pointer<Void>} NsHandle Name-service handle for which an expiration age is set. A name-service handle is returned from a name service begin operation.
     * @param {Integer} ExpirationAge Integer value, in seconds, that sets the expiration age of local name-service data read by all next routines using the specified <i>NsHandle</i> parameter. 
     * 
     * 
     * 
     * 
     * An expiration age of 0 causes an immediate update of the local name-service data.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmthandlesetexpage
     * @since windows5.0
     */
    static RpcNsMgmtHandleSetExpAge(NsHandle, ExpirationAge) {
        result := DllCall("RPCNS4.dll\RpcNsMgmtHandleSetExpAge", "ptr", NsHandle, "uint", ExpirationAge, "int")
        return result
    }

    /**
     * The RpcNsMgmtInqExpAge function returns the global expiration age for local copies of name-service data.
     * @remarks
     * The 
     * <b>RpcNsMgmtInqExpAge</b> function returns the expiration age that the application is using. The expiration age is the amount of time in seconds that a local copy of data from a name-service attribute can exist before a request from the application for the attribute requires updating the local copy. When an application begins running, the RPC run-time library specifies a default expiration age of two hours. The default is global to the application.
     * 
     * An expiration age is used by Pointer next operations (which read data from name-service attributes). A next operation typically starts by looking for a local copy of the attribute data being requested by an application. In the absence of a local copy, the next operation creates one with fresh attribute data from the name-service database. If a local copy already exists, the operation compares its actual age to the expiration age being used by the application. If the actual age exceeds the expiration age, the operation automatically tries to update the local copy with fresh attribute data. If updating is impossible, the old local data remains in place and the next operation fails.
     * 
     * Applications typically should use only the default expiration age. For special cases, however, an application can substitute a user-supplied global expiration age for the default by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmtsetexpage">RpcNsMgmtSetExpAge</a>. The 
     * <b>RpcNsMgmtInqExpAge</b> function returns the current global expiration age, whether a default or a user-supplied value. An application can also override the global expiration age temporarily by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsmgmthandlesetexpage">RpcNsMgmtHandleSetExpAge</a> function.
     * @param {Pointer<UInt32>} ExpirationAge Pointer to the default expiration age, in seconds. This value is used by all name service next operations.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtinqexpage
     * @since windows5.0
     */
    static RpcNsMgmtInqExpAge(ExpirationAge) {
        result := DllCall("RPCNS4.dll\RpcNsMgmtInqExpAge", "uint*", ExpirationAge, "int")
        return result
    }

    /**
     * The RpcNsMgmtSetExpAge function modifies the application's global expiration age for local copies of name-service data.
     * @remarks
     * The 
     * <b>RpcNsMgmtSetExpAge</b> function modifies the global expiration age of an application. The expiration age is the amount of time that a local copy of data from a name-service attribute can exist before a request from the application for the attribute requires updating the local copy. When an application begins running, the RPC run-time library specifies a default expiration age of two hours. The default is global to the application. Typically, you should avoid using 
     * <b>RpcNsMgmtSetExpAge</b>. Instead, you should rely on the default expiration age.
     * 
     * An expiration age is used by Pointer next operations (which read data from name-service attributes). A next operation typically starts by looking for a local copy of the attribute data being requested by an application. In the absence of a local copy, the next operation creates one with fresh attribute data from the name-service database. If a local copy already exists, the operation compares its actual age to the expiration age being used by the application. If the actual age exceeds the expiration age, the operation automatically tries to update the local copy with fresh attribute data. If updating is impossible, the old local data remains in place and the next operation fails, returning the RPC_S_NAME_SERVICE_UNAVAILABLE status code.
     * 
     * Setting the expiration age to a small value causes the Pointer next operations to frequently update local data for any name-service attribute requested by your application. For example, setting the expiration age to 0 forces all next operations to update local data for the name-service attribute requested by your application. Therefore, setting small expiration ages can create performance problems for your application and increase network traffic. Furthermore, if your application is using a remote name-service server, a small expiration age can adversely affect network performance for all applications.
     * @param {Integer} ExpirationAge Pointer to the default expiration age, in seconds. This value is used by all name service–next operations. An expiration age of 0 causes an immediate update of the local name-service data. 
     * 
     * 
     * 
     * 
     * To reset the expiration age to an RPC-assigned default value of two hours, specify a value of RPC_C_NS_DEFAULT_EXP_AGE.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtsetexpage
     * @since windows5.0
     */
    static RpcNsMgmtSetExpAge(ExpirationAge) {
        result := DllCall("RPCNS4.dll\RpcNsMgmtSetExpAge", "uint", ExpirationAge, "int")
        return result
    }

    /**
     * The RpcNsEntryExpandName function expands a name-service entry name. This function is supported by Active Directory. (Unicode)
     * @remarks
     * An application calls the 
     * <b>RpcNsEntryExpandName</b> function to obtain a fully expanded entry name.
     * 
     * The RPC run-time library allocates memory for the returned <i>ExpandedName</i> parameter. The application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> function for that returned string.
     * 
     * The returned expanded entry name accounts for local name translations and for differences in locally defined naming schema.
     * 
     * <div class="alert"><b>Note</b>  This function requires Active Directory support.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsEntryExpandName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of <b>RPC_C_NS_SYNTAX_DEFAULT</b>.
     * @param {Pointer<Char>} EntryName Pointer to the entry name to expand.
     * @param {Pointer<Char>} ExpandedName Returns a pointer to a pointer to the expanded version of <i>EntryName</i>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsentryexpandnamew
     * @since windows5.0
     */
    static RpcNsEntryExpandNameW(EntryNameSyntax, EntryName, ExpandedName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsEntryExpandNameW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", ExpandedName, "int")
        return result
    }

    /**
     * The RpcNsMgmtBindingUnexport function removes multiple binding handles and objects from an entry in the name-service database. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsMgmtBindingUnexport</b> function allows a management application to remove one of the following from a name service–database entry:
     * 
     * <ul>
     * <li>All the binding handles for a specified interface UUID, qualified by the interface version numbers (major and minor)</li>
     * <li>One or more object UUIDs of resources</li>
     * <li>Both binding handles and object UUIDs of resources</li>
     * </ul>
     * A management application can unexport interfaces and objects in a single call to 
     * <b>RpcNsMgmtBindingUnexport</b>, or it can unexport them separately. If 
     * <b>RpcNsMgmtBindingUnexport</b> does not find any binding handles for the specified interface, the function returns an RPC_S_INTERFACE_NOT_FOUND status code and does not unexport the object UUIDs, if any were specified.
     * 
     * If one or more binding handles for the specified interface are found and unexported without error, 
     * <b>RpcNsMgmtBindingUnexport</b> unexports any specified object UUIDs. If any of the specified object UUIDs were not found, 
     * <b>RpcNsMgmtBindingUnexport</b> returns RPC_S_NOT_ALL_OBJS_UNEXPORTED.
     * 
     * In addition to calling 
     * <b>RpcNsMgmtBindingUnexport</b>, a management application should also call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtepunregister">RpcMgmtEpUnregister</a> function to unregister the servers that have registered with the endpoint-map database.
     * 
     * <div class="alert"><b>Note</b>  Name-service databases are designed to be relatively stable. In replicated name services, frequent use of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingexporta">RpcNsBindingExport</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingunexporta">RpcNsBindingUnexport</a> functions causes the name service to repeatedly remove and replace the same entry, which can cause performance problems.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtBindingUnexport as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the name of the entry from which to remove binding handles and object UUIDs.
     * @param {Pointer<RPC_IF_ID>} IfId Pointer to an interface identification. A null parameter value indicates that binding handles are not to be unexported—only object UUIDs are to be unexported.
     * @param {Integer} VersOption Specifies how the 
     * <b>RpcNsMgmtBindingUnexport</b> function uses the <b>VersMajor</b> and <b>VersMinor</b> members of the structure pointed to by the <i>IfId</i> parameter. 
     * 
     * 
     * 
     * 
     * The following table describes valid values for the <i>VersOption</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>VersOption values</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_ALL"></a><a id="rpc_c_vers_all"></a><dl>
     * <dt><b>RPC_C_VERS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports all bindings for the interface UUID in <i>IfId</i>, regardless of the version numbers. For this value, specify 0 for both the major and minor versions in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_IF_ID"></a><a id="rpc_c_vers_if_id"></a><dl>
     * <dt><b>RPC_C_VERS_IF_ID</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings for the compatible interface UUID in <i>IfId</i> with the same major version and with a minor version greater than or equal to the minor version in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_EXACT"></a><a id="rpc_c_vers_exact"></a><dl>
     * <dt><b>RPC_C_VERS_EXACT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings for the interface UUID in <i>IfId</i> with the same major and minor versions as in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_MAJOR_ONLY"></a><a id="rpc_c_vers_major_only"></a><dl>
     * <dt><b>RPC_C_VERS_MAJOR_ONLY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings for the interface UUID in <i>IfId</i> with the same major version as in <i>IfId</i> (ignores the minor version). For this value, specify 0 for the minor version in <i>IfId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RPC_C_VERS_UPTO"></a><a id="rpc_c_vers_upto"></a><dl>
     * <dt><b>RPC_C_VERS_UPTO</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unexports the bindings that offer a version of the specified interface UUID less than or equal to the specified major and minor version. (For example, if the <i>IfId</i> contained V2.0 and the name service–database entry contained binding handles with the versions 1.3, 2.0, and 2.1, the 
     * <b>RpcNsMgmtBindingUnexport</b> function would unexport the binding handles with versions 1.3 and 2.0.)
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UUID_VECTOR>} ObjectUuidVec Pointer to a vector of object UUIDs that the server no longer wants to offer. The application constructs this vector. A null value indicates there are no object UUIDs to unexport—only binding handles are to be unexported.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_VERS_OPTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version option is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INTERFACE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The interface was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_ALL_OBJS_UNEXPORTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not all objects unexported.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtbindingunexportw
     * @since windows5.0
     */
    static RpcNsMgmtBindingUnexportW(EntryNameSyntax, EntryName, IfId, VersOption, ObjectUuidVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtBindingUnexportW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfId, "uint", VersOption, "ptr", ObjectUuidVec, "int")
        return result
    }

    /**
     * The RpcNsMgmtEntryCreate function creates a name service�database entry. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsMgmtEntryCreate</b> function creates an entry in the name-service database. A management application can call 
     * <b>RpcNsMgmtEntryCreate</b> to create a name service–database entry for use by another application that does not itself have the necessary name service–database privileges to create an entry.
     * 
     * <div class="alert"><b>Note</b>  Windows 2000 Active Directory supports this function. Earlier versions of Windows NT support the use of this function with Cell Directory Service (CDS) only.</div>
     * <div> </div>
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtEntryCreate as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the name of the entry to create.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_ALREADY_EXISTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry already exists.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrycreatew
     * @since windows5.0
     */
    static RpcNsMgmtEntryCreateW(EntryNameSyntax, EntryName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtEntryCreateW", "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * The RpcNsMgmtEntryDelete function deletes a name service�database entry. (Unicode)
     * @remarks
     * Management applications use the 
     * <b>RpcNsMgmtEntryDelete</b> function only when an entry is no longer needed—for example, when a server is being permanently removed from service.
     * 
     * Because name-service databases are designed to be relatively stable, frequent use of 
     * <b>RpcNsMgmtEntryDelete</b> in client or server applications can result in performance problems. Creating and deleting entries in client or server applications causes the name-service database to repeatedly remove and replace the same entry. This can lead to performance problems in replicated name-service databases.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtEntryDelete as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the name of the entry to delete.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NOT_RPC_ENTRY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not an RPC entry.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentrydeletew
     * @since windows5.0
     */
    static RpcNsMgmtEntryDeleteW(EntryNameSyntax, EntryName) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtEntryDeleteW", "uint", EntryNameSyntax, "ptr", EntryName, "int")
        return result
    }

    /**
     * The RpcNsMgmtEntryInqIfIds function returns the list of interfaces exported to a name service�database entry. (Unicode)
     * @remarks
     * The 
     * <b>RpcNsMgmtEntryInqIfIds</b> function returns an interface-identification vector containing the interfaces of binding handles exported by a server to <i>EntryName</i>. This function uses an expiration age of 0, causing an immediate update of the local copy of name-service data. The calling application is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcifidvectorfree">RpcIfIdVectorFree</a> function to release memory used by the vector.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsMgmtEntryInqIfIds as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, provide a value of RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to the name service–database entry name for which an interface-identification vector is returned.
     * @param {Pointer<RPC_IF_ID_VECTOR>} IfIdVec Returns an address of a pointer to the interface-identification vector.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsmgmtentryinqifidsw
     * @since windows5.0
     */
    static RpcNsMgmtEntryInqIfIdsW(EntryNameSyntax, EntryName, IfIdVec) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsMgmtEntryInqIfIdsW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfIdVec, "int")
        return result
    }

    /**
     * The RpcNsBindingImportBegin function creates an import context for importing client-compatible binding handles for servers that offer the specified interface and object. (ANSI)
     * @remarks
     * Before calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a> function, the client application must first call 
     * <b>RpcNsBindingImportBegin</b> to create an import context. The parameters to this function control the operation of the 
     * <b>RpcNsBindingImportNext</b> function.
     * 
     * When finished importing binding handles, the client application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportdone">RpcNsBindingImportDone</a> function to delete the import context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingImportBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, specify RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Byte>} EntryName Pointer to an entry name at which the search for compatible binding handles begins. 
     * 
     * 
     * 
     * 
     * To use the entry name specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultEntry</b>, provide a null pointer or an empty string. In this case, the <i>EntryNameSyntax</i> parameter is ignored and the run-time library uses the default syntax.
     * @param {Pointer<Void>} IfSpec Stub-generated data structure indicating the interface to import. If the interface specification has not been exported or is of no concern to the caller, specify a null value for this parameter. In this case, the bindings returned are only guaranteed to be of a compatible and supported protocol sequence and to contain the specified object UUID. The contacted server might not support the desired interface.
     * @param {Pointer<Guid>} ObjUuid Pointer to an optional object UUID. 
     * 
     * 
     * 
     * 
     * For a nonzero UUID, compatible binding handles are returned from an entry only if the server has exported the specified object UUID.
     * 
     * When <i>ObjUuid</i> has a null pointer value or a nil UUID, the returned binding handles contain one of the object UUIDs exported by the compatible server. If the server did not export any object UUIDs, the returned compatible binding handles contain a nil object UUID.
     * @param {Pointer<Void>} ImportContext Name-service handle returned for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportdone">RpcNsBindingImportDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name exceeds the maximum length.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_OBJECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid object.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina
     * @since windows5.0
     */
    static RpcNsBindingImportBeginA(EntryNameSyntax, EntryName, IfSpec, ObjUuid, ImportContext) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingImportBeginA", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjUuid, "ptr", ImportContext, "int")
        return result
    }

    /**
     * The RpcNsBindingImportBegin function creates an import context for importing client-compatible binding handles for servers that offer the specified interface and object. (Unicode)
     * @remarks
     * Before calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a> function, the client application must first call 
     * <b>RpcNsBindingImportBegin</b> to create an import context. The parameters to this function control the operation of the 
     * <b>RpcNsBindingImportNext</b> function.
     * 
     * When finished importing binding handles, the client application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportdone">RpcNsBindingImportDone</a> function to delete the import context.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcnsi.h header defines RpcNsBindingImportBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} EntryNameSyntax Syntax of <i>EntryName</i>. 
     * 
     * 
     * 
     * 
     * To use the syntax specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultSyntax</b>, specify RPC_C_NS_SYNTAX_DEFAULT.
     * @param {Pointer<Char>} EntryName Pointer to an entry name at which the search for compatible binding handles begins. 
     * 
     * 
     * 
     * 
     * To use the entry name specified in the registry value entry <b>HKEY_LOCAL_MACHINE\Software\Microsoft\Rpc\NameService\DefaultEntry</b>, provide a null pointer or an empty string. In this case, the <i>EntryNameSyntax</i> parameter is ignored and the run-time library uses the default syntax.
     * @param {Pointer<Void>} IfSpec Stub-generated data structure indicating the interface to import. If the interface specification has not been exported or is of no concern to the caller, specify a null value for this parameter. In this case, the bindings returned are only guaranteed to be of a compatible and supported protocol sequence and to contain the specified object UUID. The contacted server might not support the desired interface.
     * @param {Pointer<Guid>} ObjUuid Pointer to an optional object UUID. 
     * 
     * 
     * 
     * 
     * For a nonzero UUID, compatible binding handles are returned from an entry only if the server has exported the specified object UUID.
     * 
     * When <i>ObjUuid</i> has a null pointer value or a nil UUID, the returned binding handles contain one of the object UUIDs exported by the compatible server. If the server did not export any object UUIDs, the returned compatible binding handles contain a nil object UUID.
     * @param {Pointer<Void>} ImportContext Name-service handle returned for use with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportdone">RpcNsBindingImportDone</a> functions.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name exceeds the maximum length.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_NAME_SYNTAX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name syntax is unsupported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INCOMPLETE_NAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name is incomplete.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ENTRY_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name-service entry was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_OBJECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Invalid object.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbeginw
     * @since windows5.0
     */
    static RpcNsBindingImportBeginW(EntryNameSyntax, EntryName, IfSpec, ObjUuid, ImportContext) {
        EntryName := EntryName is String? StrPtr(EntryName) : EntryName

        result := DllCall("RPCNS4.dll\RpcNsBindingImportBeginW", "uint", EntryNameSyntax, "ptr", EntryName, "ptr", IfSpec, "ptr", ObjUuid, "ptr", ImportContext, "int")
        return result
    }

    /**
     * The RpcNsBindingImportNext function looks up an interface (and optionally an object from a name-service database) and returns a binding handle of a compatible server, if found.
     * @remarks
     * The 
     * <b>RpcNsBindingImportNext</b> function returns one client-compatible server binding handle for a server that offers the interface and object UUID specified by the <i>IfSpec</i> and <i>ObjUuid</i> parameters in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a> function. The function communicates only with the name-service database, not directly with servers.
     * 
     * Effective with Windows 2000, the RPC environment uses the Active Directory as its name-service database and the order in which the run-time environment performs the search is as follows:
     * 
     * <ul>
     * <li>Search in the local cache. If there is no entry,</li>
     * <li>Search in the Active Directory. If there is no entry,</li>
     * <li>Send broadcast requests to all other directory services in the domain. 
     * 
     * 
     * Note that if the entry exists in the Active Directory, but there is no information associated with the entry, the run-time environment does not issue this broadcast request.
     * 
     * </li>
     * </ul>
     * The compatible binding handle that is returned always contains an object UUID, the value of which depends on the <i>ObjUuid</i> parameter in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a> function. If a non-<b>null</b> object UUID was specified, the returned binding handle contains that object UUID. If, however, a <b>null</b> object UUID or <b>null</b> value was specified, the object UUID that is returned is a result of the following possibilities:
     * 
     * <ul>
     * <li>If the server did not export any object UUIDs, the returned binding handle contains a nil object UUID.</li>
     * <li>If the server exported one object UUID, the returned binding handle contains that object UUID.</li>
     * <li>If the server exported multiple object UUIDs, the returned binding handle contains one of the object UUIDs. The import-next operation selects the returned object UUID in a non-deterministic fashion. As a result, a different object UUID can be returned for each compatible binding handle from a single server entry.</li>
     * </ul>
     * The 
     * <b>RpcNsBindingImportNext</b> function selects and returns one server binding handle from the compatible binding handles found. The client application can use that binding handle to attempt a remote procedure call to the server. If the client fails to establish a relationship with the server, it can call 
     * <b>RpcNsBindingImportNext</b> again.
     * 
     * Each time the client calls 
     * <b>RpcNsBindingImportNext</b>, the function returns another server binding handle. The returned binding handles are unordered. A client application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcnsbindinginqentryname">RpcNsBindingInqEntryName</a> function to obtain the name-service database in the entry name from which the binding handle came.When the search reaches the end of the name-service database, 
     * <b>RpcNsBindingInqEntryName</b> returns a status of RPC_S_NO_MORE_BINDINGS and returns a binding parameter value of <b>NULL</b>.
     * 
     * The 
     * <b>RpcNsBindingImportNext</b> function allocates storage for the data referenced by the returned <i>Binding</i> parameter. When a client application finishes with the binding handle, it must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> to deallocate the storage. Each call to 
     * <b>RpcNsBindingImportNext</b> requires a corresponding call to 
     * <b>RpcBindingFree</b>.
     * 
     * The client is responsible for calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportdone">RpcNsBindingImportDone</a> function, which deletes the import context. The client also calls 
     * <b>RpcNsBindingImportDone</b> before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a> to start a new search for compatible servers. Because the order of binding handles returned is different for each new search, the order in which binding handles are returned to an application can be different each time the application is run.
     * @param {Pointer<Void>} ImportContext Name-service handle returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a> function.
     * @param {Pointer<Void>} Binding Returns a pointer to a client-compatible server binding handle for a server.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more bindings.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NAME_SERVICE_UNAVAILABLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name service is unavailable.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext
     * @since windows5.0
     */
    static RpcNsBindingImportNext(ImportContext, Binding) {
        result := DllCall("RPCNS4.dll\RpcNsBindingImportNext", "ptr", ImportContext, "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcNsBindingImportDone function signals that a client has finished looking for a compatible server and deletes the import context.
     * @remarks
     * Typically, a client application calls 
     * <b>RpcNsBindingImportDone</b> after completing remote procedure calls to a server using a binding handle returned from the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportnext">RpcNsBindingImportNext</a> function. However, a client application is responsible for calling 
     * <b>RpcNsBindingImportDone</b> for each import context that was created by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a>, regardless of the status returned from 
     * <b>RpcNsBindingImportNext</b> or the success in making remote procedure calls.
     * @param {Pointer<Void>} ImportContext Pointer to a name-service handle to free. The name-service handle <i>ImportContext</i> points to is created by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina">RpcNsBindingImportBegin</a> function. 
     * 
     * 
     * 
     * 
     * An argument value of <b>NULL</b> is returned.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingimportdone
     * @since windows5.0
     */
    static RpcNsBindingImportDone(ImportContext) {
        result := DllCall("RPCNS4.dll\RpcNsBindingImportDone", "ptr", ImportContext, "int")
        return result
    }

    /**
     * The RpcNsBindingSelect function returns a binding handle from a list of compatible binding handles.
     * @remarks
     * Each time the client calls the 
     * <b>RpcNsBindingSelect</b> function, the function operation returns another binding handle from the vector.
     * 
     * When all of the binding handles have been returned from the vector, the function returns a status of RPC_S_NO_MORE_BINDINGS and returns a <i>Binding</i> value of <b>NULL</b>.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a> 
     * 	  operation allocates storage for the data referenced by the returned <i>Binding</i> parameter. When a client finishes with the binding handle, it should call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a> function to deallocate the storage. Each call to 
     * <b>RpcNsBindingSelect</b> requires a corresponding call to the 
     * <b>RpcBindingFree</b> function.
     * 
     * Clients can create their own select routines implementing application-specific selection criteria. In this case, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringbindingparse">RpcStringBindingParse</a> provides access to the fields of a binding.
     * @param {Pointer<RPC_BINDING_VECTOR>} BindingVec Pointer to the vector of client-compatible server binding handles from which a binding handle is selected. The returned binding vector no longer references the selected binding handle, which is returned separately in the <i>Binding</i> parameter.
     * @param {Pointer<Void>} Binding Pointer to a selected binding handle.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_MORE_BINDINGS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more bindings.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcnsi/nf-rpcnsi-rpcnsbindingselect
     * @since windows5.0
     */
    static RpcNsBindingSelect(BindingVec, Binding) {
        result := DllCall("RPCNS4.dll\RpcNsBindingSelect", "ptr", BindingVec, "ptr", Binding, "int")
        return result
    }

    /**
     * The RpcAsyncRegisterInfo function is obsolete.
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync TBD
     * @returns {Integer} This function does not return a value.
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcasyncregisterinfo
     * @since windows5.0
     */
    static RpcAsyncRegisterInfo(pAsync) {
        result := DllCall("RPCRT4.dll\RpcAsyncRegisterInfo", "ptr", pAsync, "int")
        return result
    }

    /**
     * The client calls the RpcAsyncInitializeHandle function to initialize the RPC_ASYNC_STATE structure to be used to make an asynchronous call.
     * @remarks
     * The client creates a new 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure and a pointer to that structure and calls 
     * <b>RpcAsyncInitializeHandle</b> with the pointer as an input parameter. The 
     * <b>RpcAsyncInitializeHandle</b> function initializes the fields that it uses to maintain the state of an asynchronous remote call. When the call to 
     * <b>RpcAsyncInitializeHandle</b> returns successfully, the client can set the notification type and any fields related to that notification type in the 
     * <b>RPC_ASYNC_STATE</b> structure. The client application uses a pointer to this structure to make an asynchronous call.
     * 
     * The client should not attempt to alter the <b>Size</b>, <b>Signature</b>, <b>Lock</b>, and <b>StubInfo</b> members of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure; doing so will invalidate the handle.
     * 
     * <div class="alert"><b>Note</b>  In Windows 2000, after an asynchronous call is completed, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure must be reinitialized prior to being used for another asynchronous call. In Windows XP and later, the 
     * <b>RPC_ASYNC_STATE</b> structure is ready for immediate re-use subsequent to a completed asynchronous call.</div>
     * <div> </div>
     * @param {Pointer} pAsync Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure that contains asynchronous call information.
     * @param {Integer} Size Size of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The size is either too small or too large.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ASYNC_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <i>pAsync</i> points to invalid memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcasyncinitializehandle
     * @since windows5.0
     */
    static RpcAsyncInitializeHandle(pAsync, Size) {
        result := DllCall("RPCRT4.dll\RpcAsyncInitializeHandle", "ptr", pAsync, "uint", Size, "int")
        return result
    }

    /**
     * The client calls the RpcAsyncGetCallStatus function to determine the current status of an asynchronous remote call.
     * @remarks
     * This client-side function returns the current status of the asynchronous call. Note that if the return value is anything other than RPC_S_ASYNC_CALL_PENDING the call is complete.
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure that contains asynchronous call information.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call was completed successfully.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ASYNC_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The asynchronous call handle is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ASYNC_CALL_PENDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call has not yet completed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other error codes</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call failed. The client application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasynccompletecall">RpcAsyncCompleteCall</a> to receive the application-specific error code.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcasyncgetcallstatus
     * @since windows5.0
     */
    static RpcAsyncGetCallStatus(pAsync) {
        result := DllCall("RPCRT4.dll\RpcAsyncGetCallStatus", "ptr", pAsync, "int")
        return result
    }

    /**
     * The client and the server call the RpcAsyncCompleteCall function to complete an asynchronous remote procedure call.
     * @remarks
     * Completes the asynchronous RPC call. Both client and server call this function.
     * 
     * Client: <i>Reply</i> points to a buffer that will receive the reply. If the client calls this function before the reply has arrived, the call returns RPC_S_ASYNC_CALL_PENDING. The buffer must be valid and it must be big enough to receive the return value. If this call is successful, the 
     * 				<a href="https://docs.microsoft.com/windows/desktop/Midl/out-idl">[out]</a> and the 
     * 				<a href="https://docs.microsoft.com/windows/desktop/Midl/in">[in,</a> <b>out]</b> parameters are valid. If the call does not return RPC_S_ASYNC_CALL_PENDING, this 
     * <b>RpcAsyncCompleteCall</b> invocation is final for the RPC call. After this function call, regardless of success or failure, all resources allocated by the RPC runtime are freed. Subsequent calls to the 
     * <b>RpcAsyncCompleteCall</b> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasynccancelcall">RpcAsyncCancelCall</a> functions have undefined results until a new call on the RPC_ASYNC_STATE structure is initiated.
     * 
     * Server: <i>Reply</i> points to a buffer that contains the return value that needs to be sent to the client. You only need to set a valid buffer for <i>Reply</i> if your function is declared with a return type.  Before a call to 
     * <b>RpcAsyncCompleteCall</b> is made, the <a href="https://docs.microsoft.com/windows/desktop/Midl/out-idl">[out]</a> and 
     * 				<a href="https://docs.microsoft.com/windows/desktop/Midl/in">[in,</a> <b>out]</b> parameters must be updated. These parameters, and the asynchronous handle, should not be touched after the call to 
     * <b>RpcAsyncCompleteCall</b> returns. The invocation of <b>RpcAsyncCompleteCall</b> on the server is final. If the  <b>RpcAsyncCompleteCall</b> function call fails, the RPC runtime frees the parameters.
     * 
     * Any <a href="https://docs.microsoft.com/windows/desktop/Midl/out-idl">[out]</a> parameters, including 
     * 				<a href="https://docs.microsoft.com/windows/desktop/Midl/comm-status">[comm_status]</a> and 
     * 				<a href="https://msdn.microsoft.com/">[fault_status]</a> parameters, are only valid if the return value of 
     * <b>RpcAsyncCompleteCall</b> is RPC_S_OK.
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure that contains asynchronous call information.
     * @param {Pointer<Void>} Reply Pointer to a buffer containing the return value of the remote procedure call.
     * @returns {Integer} In addition to the following values, 
     * <b>RpcAsyncCompleteCall</b> can also return any general RPC or application-specific error. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call was completed successfully.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ASYNC_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The asynchronous call handle is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_ASYNC_CALL_PENDING</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call has not yet completed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CALL_CANCELLED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call was canceled.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcasynccompletecall
     * @since windows5.0
     */
    static RpcAsyncCompleteCall(pAsync, Reply) {
        result := DllCall("RPCRT4.dll\RpcAsyncCompleteCall", "ptr", pAsync, "ptr", Reply, "int")
        return result
    }

    /**
     * The server calls RpcAsyncAbortCall to abort an asynchronous call.
     * @remarks
     * The server calls 
     * <b>RpcAsyncAbortCall</b> when circumstances require it to abort an asynchronous call before completion. For example, the caller may not have the necessary permissions to make the request, or the server may be too busy to process the call. Use the <i>ExceptionCode</i> parameter to specify the reason for the abort. The run-time environment propagates the exception code to the client as a fault.
     * 
     * When an asynchronous call is aborted with 
     * <b>RpcAsyncAbortCall</b>, no marshaling of the output arguments is performed, and all input arguments are freed by RPC. When 
     * <b>RpcAsyncAbortCall</b> is called, a call to the 
     * <b>RpcAsyncCompleteCall</b> function is not necessary. The 
     * <b>RpcAsyncAbortCall</b> function should be called only once for any asynchronous call; a second call may crash the process or fail in other unexpected ways.
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure that contains asynchronous call information.
     * @param {Integer} ExceptionCode A nonzero application-specific exception code. Can be an application-defined error code, or a standard RPC error code. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Call cancelation successful.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ASYNC_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Asynchronous handle is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcasyncabortcall
     * @since windows5.0
     */
    static RpcAsyncAbortCall(pAsync, ExceptionCode) {
        result := DllCall("RPCRT4.dll\RpcAsyncAbortCall", "ptr", pAsync, "uint", ExceptionCode, "int")
        return result
    }

    /**
     * The client calls the RpcAsyncCancelCall function to cancel an asynchronous call.
     * @remarks
     * There are two ways for a client to request cancellation of an asynchronous call—<b>abortive</b> and <b>nonabortive</b>. In an abortive cancel (<i>fAbortCall</i> is <b>TRUE</b>), the 
     * <b>RpcAsyncCancelCall</b> function sends a cancel notification to the server and client side and the asynchronous call is canceled immediately, without waiting for a response from the server. Note that in a multithreaded application, an async call can only be canceled by the client after the thread that originated the call has returned from it with success.  This is necessary to ensure that the call will not be canceled asynchronously by another thread after it has failed synchronously while being issued.  In general, if an async call fails synchronously it should not be canceled asynchronously.  The client application must ensure this behavior if calls may be issued and canceled on different threads.
     * 
     * The server checks for cancel requests from the client by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcservertestcancel">RpcServerTestCancel</a>. Depending on the state of the call at the time the cancel request was issued and how often the server checks for cancels, the call may or may not complete normally. The client application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasynccompletecall">RpcAsyncCompleteCall</a> to complete the call and the return value will indicate whether the call completed, failed, or was canceled. However, the client must still wait for the original call to complete before calling <b>RpcAsyncCompleteCall</b>.
     * 
     * In a nonabortive cancel (<i>fAbortCall</i> is <b>FALSE</b>) the 
     * <b>RpcAsyncCancelCall</b> function notifies the server of the cancel and the client waits for the server to complete the call. There is no built-in time-out mechanism. If you want the call to time out, the client should first issue a nonabortive cancel using its own time-out mechanism. If the call times out, then the client can issue an abortive cancel.
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure that contains asynchronous call information.
     * @param {Integer} fAbort If <b>TRUE</b>, the call is canceled immediately. If <b>FALSE</b>, wait for the server to complete the call.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The cancellation request was processed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ASYNC_HANDLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The asynchronous handle is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcasynccancelcall
     * @since windows5.0
     */
    static RpcAsyncCancelCall(pAsync, fAbort) {
        result := DllCall("RPCRT4.dll\RpcAsyncCancelCall", "ptr", pAsync, "int", fAbort, "int")
        return result
    }

    /**
     * The RpcErrorStartEnumeration function begins enumeration of extended error information.
     * @remarks
     * The RpcErrorStartEnumeration function call should be made immediately after the call that returned the error. Otherwise, extended error information may be overwritten by subsequent calls. Enumeration handles must be freed with the RpcErrorEndEnumeration function.
     * 
     * Once 
     * <b>RpcErrorStartEnumeration</b> is called, it is safe to use the enumeration handle from a different thread. The 
     * <b>RpcErrorStartEnumeration</b> function takes a snapshot of the extended error information, and the returning enumeration handle operates on the snapshot. However, enumeration functions are not synchronized between threads by RPC, and so the caller is responsible for doing so. Subsequent calls to 
     * <b>RpcErrorStartEnumeration</b> begins a new enumeration, and does not create a second enumeration for the same extended error information.
     * 
     * The RpcErrorStartEnumeration function may fail if there is not enough memory to begin the enumeration. The enumeration handle can be passed only to <b>RpcError</b>* functions, and cannot be used with other functions, such as <b>DuplicateHandle</b>.
     * 
     * Advancing the enumeration pointer on one enumeration has no effect on independently started enumerations.
     * @param {Pointer<RPC_ERROR_ENUM_HANDLE>} EnumHandle Pointer to the enumeration handle, in the form of an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_error_enum_handle">RPC_ERROR_ENUM_HANDLE</a> structure. The structure must be allocated by the caller, and cannot be freed until the operation is complete. All members are ignored on input.
     * @returns {Integer} Successful completion returns RPC_S_OK.
     * 
     * Returns RPC_S_ENTRY_NOT_FOUND if no extended error information is on the thread. If an enumeration is in progress, starting a second enumeration starts from the beginning.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorstartenumeration
     * @since windows5.1.2600
     */
    static RpcErrorStartEnumeration(EnumHandle) {
        result := DllCall("RPCRT4.dll\RpcErrorStartEnumeration", "ptr", EnumHandle, "int")
        return result
    }

    /**
     * The RpcErrorGetNextRecord function retrieves the next extended error information record for an enumeration handle.
     * @remarks
     * Upon input, the following fields must be set in <i>ErrorInfo</i>:
     * 
     * <ul>
     * <li><b>Version</b> must be set to RPC_EEINFO_VERSION.</li>
     * <li><b>NumberOfParameters</b> must be set to a value between zero and MaxNumberOfEEInfoParams. Callers are free to provide space for any number of parameters. If the number of parameters provided by the caller is smaller than the number of parameters in the extended error record, RPC_S_BUFFER_TOO_SMALL is returned.</li>
     * <li><b>Flags</b> must be zero, or <b>EEInfoUseFileTime</b> must be specified. If <b>Flags</b> is zero, the <b>SystemTime</b> member of the u union is used. If <b>EEInfoUseFileTime</b> is specified, the <b>FileTime</b> member of the u union is used.</li>
     * </ul>
     * Other fields of <i>ErrorInfo</i> are ignored on input.
     * 
     * Upon output, the fields in <i>ErrorInfo</i> are filled as follows:
     * 
     * <ul>
     * <li><b>Version</b> is unchanged.</li>
     * <li><b>ComputerName</b> is <b>NULL</b> if there is no computer name in the record, or a Unicode string if a computer name does exist in the extended error information record. If <b>NULL</b>, the last record with a computer name can be assumed, however, the computer name may have been dropped for insufficient memory. <b>ComputerName</b> is a non-qualified DNS name.</li>
     * <li><b>ProcessID</b> is the PID of the process where the record originated.</li>
     * <li><b>SystemTime</b> or <b>FileTime</b> is the time the record was generated, expressed in UCT, for the machine on which the record was generated. Either <b>FileTime</b> or <b>SystemTime</b> is valid, based on whether <b>EEInfoUseFileTime</b> is used.</li>
     * <li><b>GeneratingComponent</b> is the code for the generating component.</li>
     * <li><b>Status</b> is the status code for the record.</li>
     * <li><b>DetectionLocation</b> is the code for the detection location.</li>
     * <li><b>Flags</b> specifies whether records are missing. If one or more records is missing after the current record is missing, <b>EEInfoNextRecordsMissing</b> is set. If one or more record before the current record is missing, <b>EEInfoPreviousRecordsMissing</b> is set.</li>
     * <li><b>NumberOfParameters</b> specifies the true number of parameters. If the caller specified space for more parameters on input than there are in the record, this field contains the number of parameters used.</li>
     * <li><b>Parameters</b> is the actual parameters, provided as an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_ee_info_param">RPC_EE_INFO_PARAM</a> structures with <b>NumberOfParameters</b> structures.</li>
     * </ul>
     * @param {Pointer<RPC_ERROR_ENUM_HANDLE>} EnumHandle Pointer to the enumeration handle, in the form of an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_error_enum_handle">RPC_ERROR_ENUM_HANDLE</a> structure. The structure must be allocated by the caller, and cannot be freed until the operation is complete. All members are ignored on input.
     * @param {Integer} CopyStrings Specifies whether the string fields in <i>ErrorInfo</i> are copied to the default system heap, at which point ownership of those buffers is transferred to the caller. 
     * 
     * 
     * 
     * 
     * TRUE indicates the strings are to be copied to the system heap.
     * 
     * FALSE indicates the strings in <i>ErrorInfo</i> point to internal RPC data structures; the caller cannot free or write to them, and they become invalid once the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerrorendenumeration">RpcErrorEndEnumeration</a> function is called.
     * @param {Pointer<RPC_EXTENDED_ERROR_INFO>} ErrorInfo Pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_extended_error_info">RPC_EXTENDED_ERROR_INFO</a> structure. See Remarks.
     * @returns {Integer} If <i>CopyStrings</i> is false the function call cannot fail unless its parameters are invalid. When the last extended error record is retrieved, 
     * <b>RpcErrorGetNextRecord</b> returns RPC_S_OK. Any subsequent calls return RPC_S_ENTRY_NOT_FOUND.
     * 
     * Upon any error, the enumeration position is not advanced.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorgetnextrecord
     * @since windows5.1.2600
     */
    static RpcErrorGetNextRecord(EnumHandle, CopyStrings, ErrorInfo) {
        result := DllCall("RPCRT4.dll\RpcErrorGetNextRecord", "ptr", EnumHandle, "int", CopyStrings, "ptr", ErrorInfo, "int")
        return result
    }

    /**
     * The RpcErrorEndEnumeration function ends enumeration of extended error information and frees all resources allocated by RPC for the enumeration.
     * @remarks
     * The 
     * <b>RpcErrorEndEnumeration</b> function zeros out the enumeration handle to prevent further usage. If the CopyStrings option was not used during a previous call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerrorgetnextrecord">RpcErrorGetNextRecord</a> function, all non-empty <b>ComputerName</b> fields and <b>AnsiString</b> or <b>UnicodeString</b> values are invalid after this function is called.
     * @param {Pointer<RPC_ERROR_ENUM_HANDLE>} EnumHandle Pointer to the enumeration handle.
     * @returns {Integer} Successful completion returns RPC_S_OK. The 
     * <b>RpcErrorEndEnumeration</b> function call cannot fail unless its parameters are invalid.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorendenumeration
     * @since windows5.1.2600
     */
    static RpcErrorEndEnumeration(EnumHandle) {
        result := DllCall("RPCRT4.dll\RpcErrorEndEnumeration", "ptr", EnumHandle, "int")
        return result
    }

    /**
     * The RpcErrorResetEnumeration function resets an enumeration cursor for any in-process enumeration, resetting the process such that a subsequent call to the RpcErrorGetNextRecord retrieves the first extended error information record.
     * @remarks
     * The 
     * <b>RpcErrorResetEnumeration</b> function call can reset an enumeration of extended error information even if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerrorgetnextrecord">RpcErrorGetNextRecord</a> function reaches the end of enumerations and returns RPC_S_SNTRY_NOT_FOUND.
     * @param {Pointer<RPC_ERROR_ENUM_HANDLE>} EnumHandle Pointer to the enumeration handle.
     * @returns {Integer} Successful completion returns RPC_S_OK. The 
     * <b>RpcErrorResetEnumeration</b> function call cannot fail unless its parameters are invalid.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorresetenumeration
     * @since windows5.1.2600
     */
    static RpcErrorResetEnumeration(EnumHandle) {
        result := DllCall("RPCRT4.dll\RpcErrorResetEnumeration", "ptr", EnumHandle, "int")
        return result
    }

    /**
     * The RpcErrorGetNumberOfRecords function returns the number of records in the extended error information.
     * @remarks
     * The 
     * <b>RpcErrorGetNumberOfRecords</b> function returns the total number of records in the extended error information, not the number of records from the current cursor location.
     * @param {Pointer<RPC_ERROR_ENUM_HANDLE>} EnumHandle Pointer to the enumeration handle.
     * @param {Pointer<Int32>} Records Number of records for the extended error information.
     * @returns {Integer} Successful completion returns RPC_S_OK. The <b>RpcErrorGetNumberOfRecords</b> function call cannot fail unless its parameters are invalid.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorgetnumberofrecords
     * @since windows5.1.2600
     */
    static RpcErrorGetNumberOfRecords(EnumHandle, Records) {
        result := DllCall("RPCRT4.dll\RpcErrorGetNumberOfRecords", "ptr", EnumHandle, "int*", Records, "int")
        return result
    }

    /**
     * The RpcErrorSaveErrorInfo function returns all error information for an enumeration handle as a BLOB.
     * @remarks
     * The BLOB is allocated on the system heap, and the caller is the owner of the buffer. The block allocated on the system heap may be larger than <i>BlobSize</i>, but only <i>BlobSize</i> is used. The 
     * <b>RpcErrorSaveErrorInfo</b> function saves the entire chain of extended error information records associated with the enumeration handle, regardless of cursor position, and does not change the cursor position for the enumeration.
     * 
     * The BLOB may be saved and later retrieved using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerrorloaderrorinfo">RpcErrorLoadErrorInfo</a> function.
     * @param {Pointer<RPC_ERROR_ENUM_HANDLE>} EnumHandle Pointer to the enumeration handle.
     * @param {Pointer<Void>} ErrorBlob Pointer to the BLOB containing the error information.
     * @param {Pointer<UIntPtr>} BlobSize Size of <i>ErrorBlob</i>, in bytes.
     * @returns {Integer} Successful completion returns RPC_S_OK. The 
     * <b>RpcErrorSaveErrorInfo</b> function call may fail if not enough memory is available.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorsaveerrorinfo
     * @since windows5.1.2600
     */
    static RpcErrorSaveErrorInfo(EnumHandle, ErrorBlob, BlobSize) {
        result := DllCall("RPCRT4.dll\RpcErrorSaveErrorInfo", "ptr", EnumHandle, "ptr", ErrorBlob, "ptr*", BlobSize, "int")
        return result
    }

    /**
     * The RpcErrorLoadErrorInfo function converts a BLOB obtained by a call to RpcErrorSaveErrorInfo into extended error information.
     * @remarks
     * The BLOB pointed to in <i>ErrorBlob</i> remains the responsibility of the caller. The resulting enumeration is ready for enumeration. EnumHandle is subject to the same requirements of the <i>EnumHandle</i> parameter for 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerrorstartenumeration">RpcErrorStartEnumeration</a>. Once enumeration is completed, resources allocated by the enumeration should be freed using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerrorendenumeration">RpcErrorEndEnumeration</a> function.
     * @param {Pointer} ErrorBlob Pointer to the BLOB containing the error information.
     * @param {Pointer} BlobSize Size of <i>ErrorBlob</i>, in bytes.
     * @param {Pointer<RPC_ERROR_ENUM_HANDLE>} EnumHandle Pointer to the enumeration handle associated with the extended error information.
     * @returns {Integer} Successful completion returns RPC_S_OK. The <b>RpcErrorLoadInfo</b> function call can fail if not enough memory is available.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorloaderrorinfo
     * @since windows5.1.2600
     */
    static RpcErrorLoadErrorInfo(ErrorBlob, BlobSize, EnumHandle) {
        result := DllCall("RPCRT4.dll\RpcErrorLoadErrorInfo", "ptr", ErrorBlob, "ptr", BlobSize, "ptr", EnumHandle, "int")
        return result
    }

    /**
     * The RpcErrorAddRecord function adds extended error information to a chain of extended error information records.
     * @remarks
     * The 
     * <b>RpcErrorAddRecord</b> function enables applications or servers other than the RPC Runtime to add extended error information to a chain of extended error information records.
     * 
     * Responsibility for the strings pointed to by <i>ErrorInfo</i> belong to the caller; the 
     * <b>RpcErrorAddRecord</b> function makes a copy of those strings, if necessary. The following restrictions on the members of <i>ErrorInfo</i> must be observed:
     * 
     * <b>Version</b> must be set to a valid version, such as RPC_EEINFO_VERSION.
     * 
     * <b>ComputerName</b> must be set to <b>NULL</b>. Any other value results in ERROR_INVALID_PARAMETER.
     * 
     * <b>ProcessID</b> must be set to zero. Any other value results in ERROR_INVALID_PARAMETER.
     * 
     * <b>SystemTime</b> or <b>FileTime</b> is ignored on input, and is set by the RPC Runtime.
     * 
     * <b>GeneratingComponent</b> must be set to zero. Any other value results in ERROR_INVALID_PARAMETER. The RPC Runtime sets this to EEInfoGCApplication.
     * 
     * <b>Status</b> can be set to the error code the caller wants to add to the chain.
     * 
     * <b>DetectionLocation</b> must be set to zero. Any other value results in ERROR_INVALID_PARAMETER.
     * 
     * <b>NumberOfParameters</b> indicates the number of parameters in the Parameters array. This value must be equal or greater than zero or MaxNumberOfEEInfoParams. The RPC Runtime does not use any memory after the specified number of parameters, so callers can safely allocate memory for less than MaxNumberOfEEInfoParams parameters.
     * 
     * <b>Parameters</b> represents the parameters for the extended error information record. The only restriction on Parameters is that <b>Pval</b> is used to represent pointers, and is always 64 bits. Use <b>Pval</b> regardless of whether the system used is 32 bits or 64 bits. Do not use <b>Lval</b>.
     * @param {Pointer<RPC_EXTENDED_ERROR_INFO>} ErrorInfo Error information to be added, in the form of an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_extended_error_info">RPC_EXTENDED_ERROR_INFO</a> structure.
     * @returns {Integer} Successful completion returns RPC_S_OK.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerroraddrecord
     * @since windows5.1.2600
     */
    static RpcErrorAddRecord(ErrorInfo) {
        result := DllCall("RPCRT4.dll\RpcErrorAddRecord", "ptr", ErrorInfo, "int")
        return result
    }

    /**
     * The RpcErrorClearInformation function clears all extended error information on the current thread.
     * @remarks
     * The RPC Runtime usually handles the clearing of extended error information. In only two cases should callers use 
     * <b>RpcErrorClearInformation</b>:
     * 
     * <ul>
     * <li>If the calling component adds records to the thread using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerroraddrecord">RpcErrorAddRecord</a> function, then decides it has not encountered a fatal error and continues processing the original, or the error is not connected to the records is has added. In this case, the calling component needs to clear the error information from the thread to prevent the propagation of potentially misleading error information.</li>
     * <li>If the calling component attempts multiple retries of an operation that returns extended error information. When an RPC call starts, the RPC Runtime clears any extended error information on the thread. However, if the calling component calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcerroraddrecord">RpcErrorAddRecord</a> in a loop with many iterations, it may want to clear the error information, as the extended error information accumulates over time and can exhaust available memory.</li>
     * </ul>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcerrorclearinformation
     * @since windows5.1.2600
     */
    static RpcErrorClearInformation() {
        DllCall("RPCRT4.dll\RpcErrorClearInformation")
    }

    /**
     * The RpcGetAuthorizationContextForClient function returns the Authz context for an RPC client that can be used with Authz functions for high-performance authentication. Supported for ncalrpc and ncacn_* protocol sequences only.
     * @remarks
     * The 
     * <b>RpcGetAuthorizationContextForClient</b> function can be called in the same context as the 
     * <b>RpcImpersonateClient</b> function. All functions that impersonate check to determine whether the caller has the SeImpersonatePrivilege privilege. If the caller has the SeImpersonatePrivilege, or if the authenticated identity is the same as the caller, the requested impersonation is allowed. Otherwise, the impersonation succeeds at Identify level only.
     * 
     * <b>Note</b>  The SeImpersonatePrivilege privilege is not supported until Windows XP with Service Pack 2 (SP2).
     * 
     * The 
     * <b>RpcGetAuthorizationContextForClient</b> function is supported for ncalrpc and ncacn_* protocol sequences only, and is not supported on named pipes that only implement transport security.
     * 
     * The 
     * <b>RpcGetAuthorizationContextForClient</b> function is thread-safe, and can be called from multiple threads. The context returned in <i>pAuthzClientContext</i> is independent of the function call, and can be used subsequent to its completion. The caller is responsible for freeing the context with a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcfreeauthorizationcontext">RpcFreeAuthorizationContext</a> function.
     * 
     * Performance improvement observed by using the 
     * <b>RpcGetAuthorizationContextForClient</b> function, when compared to previous methods of impersonation or access check or revert to self, depend on the following factors:
     * 
     * <ul>
     * <li>How many times the function is called for a given client identity.</li>
     * <li>Protocol sequence and identity tracking in effect for the function call.</li>
     * </ul>
     * Subsequent calls to the 
     * <b>RpcGetAuthorizationContextForClient</b> function for the same client identity have an extremely low cost. This efficiency is achieved by results from previous inquiries being cached, and responses being returned from the cache whenever possible.
     * 
     * Calls over ncalrpc with static identity tracking execute the 
     * <b>RpcGetAuthorizationContextForClient</b> function faster than calls over ncalrpc with dynamic identity tracking. Calls over ncacn_* execute with approximately the same speed for a given protocol sequence, regardless of whether identity tracking is static or dynamic.
     * @param {Pointer<Void>} ClientBinding Binding handle on the server that represents a binding to a client. The server impersonates the client indicated by this handle. If a value of zero is specified, the server impersonates the client that is being served by this server thread.
     * @param {Integer} ImpersonateOnReturn Directs the function to impersonate the client on return, and then return an <b>AUTHZ_CLIENT_CONTEXT_HANDLE</b> structure. Set this parameter to nonzero to impersonate the client. See Remarks.
     * @param {Pointer<Void>} Reserved1 Reserved. Must be null.
     * @param {Pointer<Int64>} pExpirationTime Pointer to the expiration date and time of the token. If no value is passed, the token never expires. Expiration time is not currently enforced.
     * @param {Pointer} Reserved2 Reserved. Must be a <b>LUID</b> structure with each member set to zero.
     * @param {Integer} Reserved3 Reserved. Must be zero.
     * @param {Pointer<Void>} Reserved4 Reserved. Must be null.
     * @param {Pointer<Void>} pAuthzClientContext Pointer to an <b>AUTHZ_CLIENT_CONTEXT_HANDLE</b> structure that can be passed directly to Authz functions. If the function fails, the content of this parameter is undefined.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A reserved parameter is different than its prescribed value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_NO_CONTEXT_AVAILABLE </b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The RPC client has not been authenticated successfully.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Failure returns an RPC_S_* error code, or a Windows error code. Extended error information is available through standard RPC or Windows error code retrieval mechanisms. For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcgetauthorizationcontextforclient
     * @since windows5.1.2600
     */
    static RpcGetAuthorizationContextForClient(ClientBinding, ImpersonateOnReturn, Reserved1, pExpirationTime, Reserved2, Reserved3, Reserved4, pAuthzClientContext) {
        result := DllCall("RPCRT4.dll\RpcGetAuthorizationContextForClient", "ptr", ClientBinding, "int", ImpersonateOnReturn, "ptr", Reserved1, "int64*", pExpirationTime, "ptr", Reserved2, "uint", Reserved3, "ptr", Reserved4, "ptr", pAuthzClientContext, "int")
        return result
    }

    /**
     * The RpcFreeAuthorizationContext function frees an Authz context obtained by a previous call to the RpcGetAuthorizationContextForClient function.
     * @remarks
     * The <i>pAuthzClientContext</i> parameter is a pointer to the Authz context, not the context itself. To prevent accidental reuse of the Authz context freed by this function call, RPC run-time zeros out the context upon return.
     * @param {Pointer<Void>} pAuthzClientContext Pointer to the previously obtained Authz client context to be freed.
     * @returns {Integer} Successful completion returns RPC_S_OK. This function does not fail unless an invalid parameter is provided.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcfreeauthorizationcontext
     * @since windows5.1.2600
     */
    static RpcFreeAuthorizationContext(pAuthzClientContext) {
        result := DllCall("RPCRT4.dll\RpcFreeAuthorizationContext", "ptr", pAuthzClientContext, "int")
        return result
    }

    /**
     * The RpcSsContextLockExclusive function enables an application to begin using a context handle in exclusive mode.
     * @remarks
     * Modifying whether a context handle is serialized or nonserialized can be useful to applications that determine whether to close a context handle based on conditions detected upon execution. To change a context handle from serialized (exclusive) to nonserialized (shared), use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcsscontextlockshared">RpcSsContextLockShared</a> function.
     * 
     * For the <i>UserContext</i> parameter, if the manager routine receives a pointer to a context handle, it must pass the 
     * <b>RpcSsContextLockExclusive</b> function the same pointer it received from RPC. If the manager routine receives the context handle itself, which is typical for [in] only context handles, it must pass the context handle itself to the 
     * <b>RpcSsContextLockExclusive</b> function. The following code example demonstrates this:
     * 
     * 
     * ```cpp
     * void _UseShared(
     *     // [in]  handle_t Binding,
     *     //...
     *     // [in]  TestContextHandleShared *Ctx,
     *     //...
     *     )
     * {
     *     //...
     *     RpcStatus = RpcSsContextLockExclusive(Binding, Ctx);
     *     //...
     * }
     * 
     * ```
     * 
     * 
     * If a manager routine takes multiple [in, out] context handles as an argument, RPC gives the manager routine a pointer to the context handle, not the context handle itself. The pointer is guaranteed to be unique, and therefore passing it to the 
     * <b>RpcSsContextLockExclusive</b> function is unambiguous. However, if a function takes multiple [in] only context handles, RPC gives the manager routine the context handle itself. Therefore, the context handle may not be unique. In this case, RPC executes this function on the first context handle with the given value.
     * 
     * Methods should not modify a context handle when in shared mode. Calling the 
     * <b>RpcSsContextLockExclusive</b> function does not eliminate a reader lock on the specified context handle; this ensures an unchanged context handle for applications that do not modify context handles in shared mode. If two threads attempt to obtain an exclusive lock on the same context handle by calling the 
     * <b>RpcSsContextLockExclusive</b> function at the same time, one arbitrarily chosen thread is returned RPC_S_OK, and the other is returned ERROR_MORE_WRITES. The thread that is returned ERROR_MORE_WRITES receives an exclusive lock, but its reader lock on the context handle is lost upon return. A caller receiving ERROR_MORE_WRITES must assume nothing about the context handle upon return of the 
     * <b>RpcSsContextLockExclusive</b> function, as it may have been destroyed.
     * 
     * Asynchronous calls must not use the 
     * <b>RpcSsContextLockExclusive</b> function on the same call object from more than one thread at a time.
     * 
     * The 
     * <b>RpcSsContextLockExclusive</b> function can fail due to out-of-memory conditions, and RPC servers must therefore be prepared to handle such errors.
     * @param {Pointer<Void>} ServerBindingHandle Binding handle on the server that represents a binding to a client. The server impersonates the client indicated by this handle. If a value of zero is specified, the server impersonates the client that is being served by this server thread.
     * @param {Pointer<Void>} UserContext Pointer passed to the manager or server routine by RPC. See Remarks. 
     * 
     * 
     * 
     * 
     * For out-only context handles, the 
     * <b>RpcSsContextLockExclusive</b> function performs no operation.
     * @returns {Integer} Returns RPC_S_OK upon successful execution, indicating the thread now has access to the context handle in exclusive mode. Returns ERROR_MORE_WRITES when multiple threads attempt an exclusive lock on the context handle. See Remarks.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcsscontextlockexclusive
     * @since windows5.1.2600
     */
    static RpcSsContextLockExclusive(ServerBindingHandle, UserContext) {
        result := DllCall("RPCRT4.dll\RpcSsContextLockExclusive", "ptr", ServerBindingHandle, "ptr", UserContext, "int")
        return result
    }

    /**
     * The RpcSsContextLockShared function enables an application to begin using a context handle in shared mode.
     * @remarks
     * Modifying whether a context handle is serialized or nonserialized can be useful to applications that determine whether to close a context handle based on conditions detected upon execution. To change a context handle from nonserialized (shared) to serialized (exclusive), use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcsscontextlockexclusive">RpcSsContextLockExclusive</a> function.
     * 
     * For the <i>UserContext</i> parameter, if the manager routine receives a pointer to a context handle, it must pass the 
     * <b>RpcSsContextLockShared</b> function the same pointer it received from RPC. If the manager routine receives the context handle itself, which is typical for [in] only context handles, it must pass the context handle itself to the 
     * <b>RpcSsContextLockShared</b> function. The following code example demonstrates this:
     * 
     * 
     * ``` syntax
     * UseExclusive (..., // [in]  TestContextHandleExclusive *Ctx, ...)
     * {
     *     ...
     *     // we decided that we're done changing the context handle exclusively
     *     // and that we have extensive processing ahead - downgrade the exclusive
     *     // lock to shared, and do the processing allowing other readers in
     *     RpcSsContextLockShared (NULL,    // use the explicit context
     *         Ctx
     *         );
     *     ...
     * }
     * ```
     * 
     * If a manager routine takes multiple [in, out] context handles as an argument, RPC gives the manager routine a pointer to the context handle, not the context handle itself. The pointer is guaranteed to be unique, and therefore passing it to the 
     * <b>RpcSsContextLockShared</b> function is unambiguous. However, if a function takes multiple [in] only context handles, RPC gives the manager routine the context handle itself. Therefore, the context handle may not be unique. In this case, RPC executes this function on the first context handle with the given value.
     * 
     * Methods should not modify a context handle when in shared mode. Calling the 
     * <b>RpcSsContextLockShared</b> function does not eliminate a writer lock on the specified context handle; this ensures the context handle will not be changed by another thread.
     * 
     * Asynchronous calls must not use the 
     * <b>RpcSsContextLockShared</b> function on the same call object from more than one thread at a time.
     * 
     * The 
     * <b>RpcSsContextLockShared</b> function can fail due to out-of-memory conditions, and RPC servers must therefore be prepared to handle such errors.
     * @param {Pointer<Void>} ServerBindingHandle Binding handle on the server that represents a binding to a client. The server impersonates the client indicated by this handle. If a value of zero is specified, the server impersonates the client that is being served by this server thread.
     * @param {Pointer<Void>} UserContext Pointer passed to the manager or server routine by RPC. See Remarks for more information. 
     * 
     * 
     * 
     * 
     * For [out] only context handles, the 
     * <b>RpcSsContextLockShared</b> function performs no operation.
     * @returns {Integer} Returns RPC_S_OK upon successful execution, indicating the thread now has access to the context handle in shared mode.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcsscontextlockshared
     * @since windows5.1.2600
     */
    static RpcSsContextLockShared(ServerBindingHandle, UserContext) {
        result := DllCall("RPCRT4.dll\RpcSsContextLockShared", "ptr", ServerBindingHandle, "ptr", UserContext, "int")
        return result
    }

    /**
     * The RpcServerInqCallAttributes function is an RPC server call that obtains client security context attributes. (Unicode)
     * @remarks
     * The 
     * <b>RpcServerInqCallAttributes</b> function uses a versioning scheme to incorporate new capabilities without having to introduce new functions with suffix identifiers. For example, a second version of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_call_attributes_v2_a">RPC_CALL_ATTRIBUTES_V2</a>, identified with a simple #define in the header, can add new members to facilitate new functionality built into future versions of the 
     * <b>RpcServerInqCallAttributes</b> function, without having to release a function called RpcServerInqCallAttributesEx.
     * 
     * If the 
     * <b>RpcServerInqCallAttributes</b> function is called outside a server routine, and if the function call queries the security context attributes for an asynchronous RPC call, <i>ClientBinding</i> can be retrieved by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasyncgetcallhandle">RpcAsyncGetCallHandle</a> function from the asynchronous handle.
     * 
     * The 
     * <b>RpcServerInqCallAttributes</b> function is not supported for datagram protocol sequences, such as ncadg_*. If invoked on a call that executes on a datagram protocol sequence, RPC_S_CANNOT_SUPPORT is returned.
     * 
     * The 
     * <b>RpcServerInqCallAttributes</b> function is thread-safe.
     * @param {Pointer<Void>} ClientBinding Optional. For explicit binding within a server routine, <i>ClientBinding</i> is the binding handle with which the manager routine was called. See Remarks.
     * @param {Pointer<Void>} RpcCallAttributes <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_call_attributes_v2_a">RPC_CALL_ATTRIBUTES_V2</a> structure that receives call attributes.
     * @returns {Integer} Returns RPC_S_OK upon success, and <i>RpcCallAttributes</i> is filled. If ERROR_MORE_DATA is returned, one or more fields in <i>RpcCallAttributes</i> was of insufficient length and could not be filled. See Remarks in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_call_attributes_v2_a">RPC_CALL_ATTRIBUTES_V2</a> for details on handling ERROR_MORE_DATA.
     * 
     * Upon failure, the contents of <i>RpcCallAttributes</i> is undefined and may be partially modified by RPC.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcserverinqcallattributesw
     * @since windows5.1.2600
     */
    static RpcServerInqCallAttributesW(ClientBinding, RpcCallAttributes) {
        result := DllCall("RPCRT4.dll\RpcServerInqCallAttributesW", "ptr", ClientBinding, "ptr", RpcCallAttributes, "int")
        return result
    }

    /**
     * The RpcServerInqCallAttributes function is an RPC server call that obtains client security context attributes. (ANSI)
     * @remarks
     * The 
     * <b>RpcServerInqCallAttributes</b> function uses a versioning scheme to incorporate new capabilities without having to introduce new functions with suffix identifiers. For example, a second version of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_call_attributes_v2_a">RPC_CALL_ATTRIBUTES_V2</a>, identified with a simple #define in the header, can add new members to facilitate new functionality built into future versions of the 
     * <b>RpcServerInqCallAttributes</b> function, without having to release a function called RpcServerInqCallAttributesEx.
     * 
     * If the 
     * <b>RpcServerInqCallAttributes</b> function is called outside a server routine, and if the function call queries the security context attributes for an asynchronous RPC call, <i>ClientBinding</i> can be retrieved by calling the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasyncgetcallhandle">RpcAsyncGetCallHandle</a> function from the asynchronous handle.
     * 
     * The 
     * <b>RpcServerInqCallAttributes</b> function is not supported for datagram protocol sequences, such as ncadg_*. If invoked on a call that executes on a datagram protocol sequence, RPC_S_CANNOT_SUPPORT is returned.
     * 
     * The 
     * <b>RpcServerInqCallAttributes</b> function is thread-safe.
     * @param {Pointer<Void>} ClientBinding Optional. For explicit binding within a server routine, <i>ClientBinding</i> is the binding handle with which the manager routine was called. See Remarks.
     * @param {Pointer<Void>} RpcCallAttributes <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_call_attributes_v2_a">RPC_CALL_ATTRIBUTES_V2</a> structure that receives call attributes.
     * @returns {Integer} Returns RPC_S_OK upon success, and <i>RpcCallAttributes</i> is filled. If ERROR_MORE_DATA is returned, one or more fields in <i>RpcCallAttributes</i> was of insufficient length and could not be filled. See Remarks in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_call_attributes_v2_a">RPC_CALL_ATTRIBUTES_V2</a> for details on handling ERROR_MORE_DATA.
     * 
     * Upon failure, the contents of <i>RpcCallAttributes</i> is undefined and may be partially modified by RPC.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcserverinqcallattributesa
     * @since windows5.1.2600
     */
    static RpcServerInqCallAttributesA(ClientBinding, RpcCallAttributes) {
        result := DllCall("RPCRT4.dll\RpcServerInqCallAttributesA", "ptr", ClientBinding, "ptr", RpcCallAttributes, "int")
        return result
    }

    /**
     * Subscribes the server for RPC notifications.
     * @remarks
     * If the caller specifies any notification type other than <b>RpcNotificationTypeEvent</b>, it can subscribe to both the <b>RpcNotificationClientDisconnect</b> and <b>RpcNotificationCallCancel</b> notifications with a single call. For events, two separate calls to this API are required.
     * 
     * The server application must unsubscribe for notification before the RPC call is completed. If the RPC call is synchronous, it is completed when the server sends a return value to RPC. If the RPC call is asynchronous, it is completed  when the server calls <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasynccompletecall">RpcAsyncCompleteCall</a> or <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasyncabortcall">RpcAsyncAbortCall</a>, or throws an exception from the manager routine. If the server fails to unsubscribe for call status change notifications, the results are undefined, and the server may crash at a later time. Note that the subscription applies for one RPC call only. If the server application needs to monitor more than one call, it needs to subscribe for each call specifically.
     * 
     * The server application can expect that it will not be signaled for notifications that it hasn't subscribed for. If it has subscribed for more than one notification, each notification is communicated to the completion method if the selected completion method permits it. If it doesn't permit the communication of notifications, the server application can call on of the RPC server APIs to test whether or not the client has canceled or disconnected. The table below indicates how notification type (call cancel or client disconnect) is communicated to each notification method: 
     * 
     * 
     * <table>
     * <tr>
     * <th>Notification Method</th>
     * <th>Event/Notification Type</th>
     * </tr>
     * <tr>
     * <td>RpcNotificationTypeNone</td>
     * <td>Not allowed for subscription.</td>
     * </tr>
     * <tr>
     * <td>RpcNotificationTypeEvent</td>
     * <td>The notification type is not available.</td>
     * </tr>
     * <tr>
     * <td>RpcNotificationTypeApc</td>
     * <td>The notification type is found in the <i>Event</i> parameter of the APC function.</td>
     * </tr>
     * <tr>
     * <td>RpcNotificationTypeIoc</td>
     * <td>The notification type is not available.</td>
     * </tr>
     * <tr>
     * <td>RpcNotificationTypeCallback</td>
     * <td>The notification type is found in the <i>Event</i> parameter of the callback function.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * Note that the table does not imply whether or not a caller can subscribe for notifications using the given notification method; rather, it simply states  the information the caller can obtain when the notification is received, such as the notification type.
     * 
     * The caller must synchronize between <b>RpcServerSubscribeForNotification</b> and <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcserverunsubscribefornotification">RpcServerUnsubscribeForNotification</a> on the same binding handle. If they are called simultaneously, the results are undefined and could incur lost notifications, extra notifications, an incorrect notification count, process crashes, data corruption, and memory leaks. The same concern applies for threads calling <b>RpcServerSubscribeForNotification</b> on the same binding handle.
     * 
     * Calling <b>RpcServerSubscribeForNotification</b> and <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcserverunsubscribefornotification">RpcServerUnsubscribeForNotification</a> on the same binding handle is thread safe. For current notifications, RPC  will notify the server no more than once per call.
     * @param {Pointer<Void>} Binding <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-binding-handle">RPC_BINDING_HANDLE</a> structure that contains the binding handle for the current call. If this function is called on the same thread that RPC has dispatched a call on, this parameter can be set to <b>NULL</b>; otherwise, an explicit binding handle must be passed in this parameter.
     * @param {Integer} Notification Bitwise combination of the <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ne-rpcasync-rpc_notifications">RPC_NOTIFICATIONS</a> enumeration values that specifies the type of notification requested from RPC by the server.
     * 
     * <b>Windows Vista:  </b>Currently, only <b>RpcNotificationClientDisconnect</b> and <b>RpcNotificationCallCancel</b> are supported. If any other value is specified for this parameter, the RPC_S_CANNOT_SUPPORT error code is returned.
     * @param {Integer} NotificationType <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ne-rpcasync-rpc_notification_types">RPC_NOTIFICATION_TYPES</a> enumeration value that specifies the method by which RPC will notify the server.
     * 
     * <b>Windows Vista:  </b><b>RpcNotificationTypeNone</b> is not supported. If this value is specified, the RPC_S_INVALID_ARG error code is returned.
     * @param {Pointer<RPC_ASYNC_NOTIFICATION_INFO>} NotificationInfo Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_notification_info">RPC_ASYNC_NOTIFICATION_INFO</a> union that contains the specific information necessary for RPC to contact the server for notification. The data contained in this union is specific to the method passed to the <i>NotificationType</i> parameter. 
     * 
     * If the <b>RpcNotificationTypeCallback</b> method is specified in <i>NotificationTypes</i>, the <b>NotificationRoutine</b> member of the corresponding branch of the union is set to the binding handle for synchronous calls and the async handle for asynchronous calls.
     * 
     * RPC makes a copy of this parameter during a successful call to this function. The caller can free or update this parameter when the API returns.
     * @returns {Integer} This function returns RPC_S_OK on success; otherwise, an RPC_S_* error code is returned. 
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcserversubscribefornotification
     * @since windows6.0.6000
     */
    static RpcServerSubscribeForNotification(Binding, Notification, NotificationType, NotificationInfo) {
        result := DllCall("RPCRT4.dll\RpcServerSubscribeForNotification", "ptr", Binding, "int", Notification, "int", NotificationType, "ptr", NotificationInfo, "int")
        return result
    }

    /**
     * Unsubscribes the server from RPC notifications.
     * @remarks
     * <b>RpcServerUnsubscribeForNotification</b> must be called for every RPC binding handle that has also had <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcserversubscribefornotification">RpcServerSubscribeForNotification</a> called on it for the associated RPC call. This API must be called before the associated RPC call is completed; otherwise, the results are undefined and could lead to application instability.
     * 
     * Unretrieved notifications may be retrieved after this API returns.
     * @param {Pointer<Void>} Binding <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-binding-handle">RPC_BINDING_HANDLE</a> structure that contains the binding handle for the current RPC call specified in a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcserversubscribefornotification">RpcServerSubscribeForNotification</a>. If this function is called on the same thread that RPC has dispatched a call on, this parameter can be set to <b>NULL</b>; otherwise, an explicit binding handle must be passed in this parameter.
     * @param {Integer} Notification A value from the <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ne-rpcasync-rpc_notifications">RPC_NOTIFICATIONS</a> enumeration that specifies the type of notification requested from RPC by the server.  Notifications must be unsubscribed individually, multiple values are not supported.
     * 
     * <b>Windows Vista:  </b>Currently, only <b>RpcNotificationClientDisconnect</b> and <b>RpcNotificationCallCancel</b> are supported. If any other value is specified for this parameter, the RPC_S_CANNOT_SUPPORT error code is returned.
     * @param {Pointer<UInt32>} NotificationsQueued A required pointer to a value that receives the number of notifications that the RPC runtime queued for the specified RPC call. The pointer must be supplied; it is not optional.
     * 
     * Your code should keep track of the number of notifications that it receives. When you unsubscribe from RPC notifications, you should check if the number of notifications that the RPC runtime queued matches the number of notifications that you received. If the numbers do not match, some notifications could still be incoming on another thread.  You should delay cleaning up the notification state until you receive all incoming notifications.
     * @returns {Integer} This function returns RPC_S_OK on success; otherwise, an RPC_S_* error code is returned.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcserverunsubscribefornotification
     * @since windows6.0.6000
     */
    static RpcServerUnsubscribeForNotification(Binding, Notification, NotificationsQueued) {
        result := DllCall("RPCRT4.dll\RpcServerUnsubscribeForNotification", "ptr", Binding, "int", Notification, "uint*", NotificationsQueued, "int")
        return result
    }

    /**
     * The RpcBindingBind function contacts an RPC server and binds to it.
     * @remarks
     * <b>RpcBindingBind</b> contacts the RPC server and binds to it using the binding handle returned by a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingcreatea">RpcBindingCreate</a>. Binding handles established using this method are referred to as "fast" binding handles.
     * 
     * If the value of the <i>pAsync</i> parameter is not <b>NULL</b>, then the bind will be asynchronous and calls to <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasynccancelcall">RpcAsyncCancelCall</a> and <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcasyncgetcallstatus">RpcAsyncGetCallStatus</a> can be made on the supplied async state. The completion method specified in the async state information wis used to signal the caller that the bind is complete. Upon notification of completion, calls can be made using the newly-bound binding handle.
     * 
     * The bind method does not determine what calls can be made using the binding handle — if the bind is synchronous, asynchronous calls can still be made on the binding handle, and vice versa. The bind method determines how notification for a successful bind is signaled, specifically in the case of asynchronous binds.
     * 
     * Since this API exchanges messages with the RPC server, bind operations can take a long time based on a number of independent factors including network traffic and server blocking. If the binding is synchronous, the bind operation can block if the server is blocked.
     * 
     * After the bind is complete, the semantics of calls made on the binding handle are the same as calls made on any other type of binding handle, but with four notable differences, listed below:
     * 
     * 
     * <ul>
     * <li>All calls on this binding handle must be made on the interface specified in <i>IfSpec</i>. The binding handle is uniquely tied to this interface. The interface itself can be unloaded before the binding handle is destroyed, but extensive information about the interface is cached in the binding handle, and if a call is made on the same binding handle for a different interface, the results are undefined.</li>
     * <li>RPC callbacks are not allowed on a binding handle. If the RPC server attempts to make a callback using a method with the [callback] attribute, the call is rejected with the RPC_S_CANNOT_SUPPORT error status code.</li>
     * <li>With classic binding handles, RPC will attempt to transparently reconnect with the server  if the connection is dropped. For fast binding handles, RPC will not attempt to transparently reconnect to the server; instead, it  will return one of the following errors: RPC_S_SERVER_UNAVAILABLE, RPC_S_CALL_FAILED, and RPC_C_CALL_FAILED_DNE.  If the connection is dropped due to rejected credentials, RPC_S_ACCESS_DENIED is returned; and if the server encounters a transient error due to a lack of memory, RPC_S_OUT_OF_MEMORY is returned. Any other connectivity errors are the result of marshaling or unmarshaling errors returned by server routines.In the case of a lost connection, the called must unbind by calling <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcbindingunbind">RpcBindingUnbind</a> and then rebind with another call to <b>RpcBindingBind</b>.
     * 
     * </li>
     * </ul>
     * 
     * 
     * If the call to <b>RpcBindingBind</b> fails, then the binding handle is not bound to the server and the caller can attempt to bind again with another call to the same API, or it can free the binding handle. Since a failed bind operation does not move the binding handle to the bound state, <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/nf-rpcasync-rpcbindingunbind">RpcBindingUnbind</a> must not be called on it.
     * 
     * Certain functions must not be called until the bind operation has signaled completion, specifically:<ul>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingreset">RpcBindingReset</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">RpcBindingSetAuthInfo</a> and <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa">RpcBindingSetAuthInfoEx</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetobject">RpcBindingSetObject</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetoption">RpcBindingSetOption</a>
     * </li>
     * <li>
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcmgmtsetcomtimeout">RpcMgmtSetComTimeout</a>
     * </li>
     * </ul>
     * 
     * 
     * <div class="alert"><b>Note</b>  Currently, this function supports only the <b>ncalrpc</b> protocol sequence.</div>
     * <div> </div>
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcasync/ns-rpcasync-rpc_async_state">RPC_ASYNC_STATE</a> structure that contains asynchronous call information. This state information contains the completion method used to signal when the bind operation is complete.
     * @param {Pointer<Void>} Binding <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-binding-handle">RPC_BINDING_HANDLE</a> structure that contains the binding handle created with a previous call to <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingcreatea">RpcBindingCreate</a>.
     * @param {Pointer<Void>} IfSpec <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-if-handle">RPC_IF_HANDLE</a> value that specifies the interface on which calls for this binding handle will be made.
     * @returns {Integer} This function returns RPC_S_OK on success; otherwise, an RPC_S_* error code is returned. For information on these error codes, see <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The RPC is successfully bound to the server and remote calls can be made.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_CANNOT_SUPPORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An obsolete feature of RPC was requested for this binding operation.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcbindingbind
     * @since windows6.0.6000
     */
    static RpcBindingBind(pAsync, Binding, IfSpec) {
        result := DllCall("RPCRT4.dll\RpcBindingBind", "ptr", pAsync, "ptr", Binding, "ptr", IfSpec, "int")
        return result
    }

    /**
     * Unbinds a binding handle previously bound by RpcBindingBind.
     * @remarks
     * <b>RpcBindingUnbind</b> unbinds a previously bound binding handle from an RPC server. An unbound handle can be modified with calls like <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetoption">RpcBindingSetOption</a> and <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa">RpcBindingSetAuthInfoEx</a>. A binding handle in the unbound state can be bound again and re-used to make calls.
     * 
     * The results of an unbind operation are undefined if it is called on a binding handle that currently has RPC calls in progress at the time of unbinding. It is the responsibility of the caller to ensure that no calls are in progress at the time an unbind operation is attempted.
     * 
     * Note that calling <b>RpcBindingUnbind</b> does not necessarily disconnect the client from the server. It will invalidate any cached information used by the binding handle, but actually disconnection is not ensured. To ensure disconnection, free the binding handle with <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcbindingfree">RpcBindingFree</a>.
     * 
     * <b>Windows Vista:  </b>Currently, this function supports only the <b>ncalrpc</b> protocol sequence.
     * @param {Pointer<Void>} Binding <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-binding-handle">RPC_BINDING_HANDLE</a> structure that contains the binding handle to unbind from the RPC server.
     * @returns {Integer} This function returns RPC_S_OK on success; otherwise, an RPC_S_* error code is returned.
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-rpcbindingunbind
     * @since windows6.0.6000
     */
    static RpcBindingUnbind(Binding) {
        result := DllCall("RPCRT4.dll\RpcBindingUnbind", "ptr", Binding, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync 
     * @returns {Integer} 
     */
    static I_RpcAsyncSetHandle(Message, pAsync) {
        result := DllCall("RPCRT4.dll\I_RpcAsyncSetHandle", "ptr", Message, "ptr", pAsync, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_ASYNC_STATE>} pAsync 
     * @param {Integer} ExceptionCode 
     * @returns {Integer} 
     */
    static I_RpcAsyncAbortCall(pAsync, ExceptionCode) {
        result := DllCall("RPCRT4.dll\I_RpcAsyncAbortCall", "ptr", pAsync, "uint", ExceptionCode, "int")
        return result
    }

    /**
     * Determines whether an exception is fatal or non-fatal
     * @param {Integer} ExceptionCode Value of an exception. Any of the following exception values will return EXCEPTION_CONTINUE_SEARCH:
     * 
     * - STATUS_ACCESS_VIOLATION
     * - STATUS_POSSIBLE_DEADLOCK
     * - STATUS_INSTRUCTION_MISALIGNMENT
     * - STATUS_DATATYPE_MISALIGNMENT
     * - STATUS_PRIVILEGED_INSTRUCTION
     * - STATUS_ILLEGAL_INSTRUCTION
     * - STATUS_BREAKPOINT
     * - STATUS_STACK_OVERFLOW
     * - STATUS_HANDLE_NOT_CLOSABLE
     * - STATUS_IN_PAGE_ERROR
     * - STATUS_ASSERTION_FAILURE
     * - STATUS_STACK_BUFFER_OVERRUN
     * - STATUS_GUARD_PAGE_VIOLATION
     * - STATUS_REG_NAT_CONSUMPTION
     * @returns {Integer} A value that specifies whether the exception was fatal or non-fatal.
     * 
     * | Return code | Description
     * |-------------|------------|
     * | EXCEPTION_CONTINUE_SEARCH | The exception is fatal and must be handled. |
     * | EXCEPTION_EXECUTE_HANDLER | The exception is not fatal. |
     * @see https://learn.microsoft.com/windows/win32/api/rpcasync/nf-rpcasync-i_rpcexceptionfilter
     */
    static I_RpcExceptionFilter(ExceptionCode) {
        result := DllCall("RPCRT4.dll\I_RpcExceptionFilter", "uint", ExceptionCode, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Binding 
     * @param {Pointer<LUID>} TokenId 
     * @param {Pointer<LUID>} AuthenticationId 
     * @param {Pointer<LUID>} ModifiedId 
     * @returns {Integer} 
     */
    static I_RpcBindingInqClientTokenAttributes(Binding, TokenId, AuthenticationId, ModifiedId) {
        result := DllCall("RPCRT4.dll\I_RpcBindingInqClientTokenAttributes", "ptr", Binding, "ptr", TokenId, "ptr", AuthenticationId, "ptr", ModifiedId, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcNsGetBuffer(Message) {
        result := DllCall("RPCNS4.dll\I_RpcNsGetBuffer", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @param {Pointer<Void>} Handle 
     * @returns {Integer} 
     */
    static I_RpcNsSendReceive(Message, Handle) {
        result := DllCall("RPCNS4.dll\I_RpcNsSendReceive", "ptr", Message, "ptr", Handle, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @param {Integer} Status 
     * @returns {String} Nothing - always returns an empty string
     */
    static I_RpcNsRaiseException(Message, Status) {
        DllCall("RPCNS4.dll\I_RpcNsRaiseException", "ptr", Message, "int", Status)
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} Message 
     * @returns {Integer} 
     */
    static I_RpcReBindBuffer(Message) {
        result := DllCall("RPCNS4.dll\I_RpcReBindBuffer", "ptr", Message, "int")
        return result
    }

    /**
     * 
     * @param {Pointer} CContext 
     * @returns {Pointer<Void>} 
     */
    static NDRCContextBinding(CContext) {
        result := DllCall("RPCRT4.dll\NDRCContextBinding", "ptr", CContext, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer} CContext 
     * @param {Pointer<Void>} pBuff 
     * @returns {String} Nothing - always returns an empty string
     */
    static NDRCContextMarshall(CContext, pBuff) {
        DllCall("RPCRT4.dll\NDRCContextMarshall", "ptr", CContext, "ptr", pBuff)
    }

    /**
     * 
     * @param {Pointer<IntPtr>} pCContext 
     * @param {Pointer<Void>} hBinding 
     * @param {Pointer<Void>} pBuff 
     * @param {Integer} DataRepresentation 
     * @returns {String} Nothing - always returns an empty string
     */
    static NDRCContextUnmarshall(pCContext, hBinding, pBuff, DataRepresentation) {
        DllCall("RPCRT4.dll\NDRCContextUnmarshall", "ptr*", pCContext, "ptr", hBinding, "ptr", pBuff, "uint", DataRepresentation)
    }

    /**
     * 
     * @param {Pointer<NDR_SCONTEXT>} CContext 
     * @param {Pointer<Void>} pBuff 
     * @param {Pointer<NDR_RUNDOWN>} userRunDownIn 
     * @returns {String} Nothing - always returns an empty string
     */
    static NDRSContextMarshall(CContext, pBuff, userRunDownIn) {
        DllCall("RPCRT4.dll\NDRSContextMarshall", "ptr", CContext, "ptr", pBuff, "ptr", userRunDownIn)
    }

    /**
     * 
     * @param {Pointer<Void>} pBuff 
     * @param {Integer} DataRepresentation 
     * @returns {Pointer<NDR_SCONTEXT>} 
     */
    static NDRSContextUnmarshall(pBuff, DataRepresentation) {
        result := DllCall("RPCRT4.dll\NDRSContextUnmarshall", "ptr", pBuff, "uint", DataRepresentation, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} BindingHandle 
     * @param {Pointer<NDR_SCONTEXT>} CContext 
     * @param {Pointer<Void>} pBuff 
     * @param {Pointer<NDR_RUNDOWN>} userRunDownIn 
     * @returns {String} Nothing - always returns an empty string
     */
    static NDRSContextMarshallEx(BindingHandle, CContext, pBuff, userRunDownIn) {
        DllCall("RPCRT4.dll\NDRSContextMarshallEx", "ptr", BindingHandle, "ptr", CContext, "ptr", pBuff, "ptr", userRunDownIn)
    }

    /**
     * 
     * @param {Pointer<Void>} BindingHandle 
     * @param {Pointer<NDR_SCONTEXT>} CContext 
     * @param {Pointer<Void>} pBuff 
     * @param {Pointer<NDR_RUNDOWN>} userRunDownIn 
     * @param {Pointer<Void>} CtxGuard 
     * @param {Integer} Flags 
     * @returns {String} Nothing - always returns an empty string
     */
    static NDRSContextMarshall2(BindingHandle, CContext, pBuff, userRunDownIn, CtxGuard, Flags) {
        DllCall("RPCRT4.dll\NDRSContextMarshall2", "ptr", BindingHandle, "ptr", CContext, "ptr", pBuff, "ptr", userRunDownIn, "ptr", CtxGuard, "uint", Flags)
    }

    /**
     * 
     * @param {Pointer<Void>} BindingHandle 
     * @param {Pointer<Void>} pBuff 
     * @param {Integer} DataRepresentation 
     * @returns {Pointer<NDR_SCONTEXT>} 
     */
    static NDRSContextUnmarshallEx(BindingHandle, pBuff, DataRepresentation) {
        result := DllCall("RPCRT4.dll\NDRSContextUnmarshallEx", "ptr", BindingHandle, "ptr", pBuff, "uint", DataRepresentation, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} BindingHandle 
     * @param {Pointer<Void>} pBuff 
     * @param {Integer} DataRepresentation 
     * @param {Pointer<Void>} CtxGuard 
     * @param {Integer} Flags 
     * @returns {Pointer<NDR_SCONTEXT>} 
     */
    static NDRSContextUnmarshall2(BindingHandle, pBuff, DataRepresentation, CtxGuard, Flags) {
        result := DllCall("RPCRT4.dll\NDRSContextUnmarshall2", "ptr", BindingHandle, "ptr", pBuff, "uint", DataRepresentation, "ptr", CtxGuard, "uint", Flags, "ptr")
        return result
    }

    /**
     * The RpcSsDestroyClientContext function destroys a context handle no longer needed by the client, without contacting the server.
     * @remarks
     * <b>RpcSsDestroyClientContext</b> is used by the client application to reclaim the memory resources used to maintain a context handle on the client. This function is used when <i>ContextHandle</i> is no longer valid, such as when a communication failure has occurred and the server is no longer available. The context handle is set to <b>NULL</b>. The 
     * <b>RpcSsDestroyClientContext</b> function provides the same functionality as the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmdestroyclientcontext">RpcSmDestroyClientContext</a> function. This function does not invoke the server's context handle run-down process.
     * 
     * Do not use 
     * <b>RpcSsDestroyClientContext</b> to replace a server function that closes the context handle.
     * 
     * The 
     * <b>RpcSsDestroyClientContext</b> function can throw an RPC_X_SS_CONTEXT_MISMATCH exception if the context handle passed to it is invalid. Applications should never pass an invalid context handle to this function. If an exception is thrown, it indicates an error in the calling code, and should therefore be investigated and fixed.
     * @param {Pointer<Void>} ContextHandle Context handle to be destroyed. The handle is set to <b>NULL</b> before 
     * <b>RpcSsDestroyClientContext</b> returns.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcssdestroyclientcontext
     * @since windows5.0
     */
    static RpcSsDestroyClientContext(ContextHandle) {
        DllCall("RPCRT4.dll\RpcSsDestroyClientContext", "ptr", ContextHandle)
    }

    /**
     * The NdrSimpleTypeMarshall function marshalls a simple type.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to the simple type to be marshalled.
     * @param {Integer} FormatChar Simple type format character.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrsimpletypemarshall
     * @since windows5.0
     */
    static NdrSimpleTypeMarshall(pStubMsg, pMemory, FormatChar) {
        DllCall("RPCRT4.dll\NdrSimpleTypeMarshall", "ptr", pStubMsg, "char*", pMemory, "char", FormatChar)
    }

    /**
     * The NdrPointerMarshall function marshalls a top level pointer to anything. Pointers embedded in structures, arrays, or unions call NdrPointerMarshall directly.
     * @remarks
     * This function is used for FC_RP, FC_UP, FC_FP, FC_OP format strings.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to the pointer to be marshalled.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {Pointer<Byte>} Returns <b>NULL</b> upon success. If an error occurs, the function throws one of the following exception codes. 
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrpointermarshall
     * @since windows5.0
     */
    static NdrPointerMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrPointerMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * The NdrSimpleStructMarshall function marshals the simple structure into a network buffer.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the simple structure to be marshaled.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {Pointer<Byte>} Returns null upon success. Raises one of the following exceptions upon failure.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrsimplestructmarshall
     * @since windows5.0
     */
    static NdrSimpleStructMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrSimpleStructMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrConformantStructMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantStructMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrConformantVaryingStructMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantVaryingStructMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * The NdrComplexStructMarshall function marshals the complex structure into a network buffer.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the complex structure to be marshaled.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {Pointer<Byte>} Returns null upon success. Raises one of the following exceptions upon failure.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcomplexstructmarshall
     * @since windows5.0
     */
    static NdrComplexStructMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrComplexStructMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrFixedArrayMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrFixedArrayMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * The NdrConformantArrayMarshall function marshals the conformant array into a network buffer.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the conformant array to be marshaled.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {Pointer<Byte>} Returns null upon success. Raises one of the following exceptions upon failure.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrconformantarraymarshall
     */
    static NdrConformantArrayMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantArrayMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrConformantVaryingArrayMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantVaryingArrayMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrVaryingArrayMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrVaryingArrayMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * The NdrComplexArrayMarshall function marshals the complex array into a network buffer.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the complex array to be marshaled.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {Pointer<Byte>} Returns null upon success. Raises one of the following exceptions  upon failure.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcomplexarraymarshall
     * @since windows5.0
     */
    static NdrComplexArrayMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrComplexArrayMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrNonConformantStringMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrNonConformantStringMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * The NdrConformantStringMarshall function marshals the conformant string into a network buffer to be sent to the server.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the null-terminated conformant string to be marshaled.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {Pointer<Byte>} Returns null upon success. If an error occurs, the function throws one of the following exception codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrconformantstringmarshall
     * @since windows5.0
     */
    static NdrConformantStringMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantStringMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrEncapsulatedUnionMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrEncapsulatedUnionMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrNonEncapsulatedUnionMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrNonEncapsulatedUnionMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrByteCountPointerMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrByteCountPointerMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<Byte>} 
     */
    static NdrXmitOrRepAsMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrXmitOrRepAsMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * The NdrUserMarshalMarshall function marshals the supplied data buffer.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to user data object to be marshaled.
     * @param {Pointer<Byte>} pFormat Pointer's format string description.
     * @returns {Pointer<Byte>} Returns <b>NULL</b> upon success. If an error occurs, the function throws one of the following exception codes. 
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrusermarshalmarshall
     * @since windows5.0
     */
    static NdrUserMarshalMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrUserMarshalMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * The NdrInterfacePointerMarshall function marshals the interface pointer into a network buffer to be sent to the server.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the interface pointer to be marshaled.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {Pointer<Byte>} Returns null upon success. If an error occurs, the function throws one of the following exception codes. In addition, the function can throw exception codes from <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface">CoMarshalInterface</a>.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrinterfacepointermarshall
     * @since windows5.0
     */
    static NdrInterfacePointerMarshall(pStubMsg, pMemory, pFormat) {
        result := DllCall("RPCRT4.dll\NdrInterfacePointerMarshall", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer} ContextHandle 
     * @param {Integer} fCheck 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrClientContextMarshall(pStubMsg, ContextHandle, fCheck) {
        DllCall("RPCRT4.dll\NdrClientContextMarshall", "ptr", pStubMsg, "ptr", ContextHandle, "int", fCheck)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<NDR_SCONTEXT>} ContextHandle 
     * @param {Pointer<NDR_RUNDOWN>} RundownRoutine 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrServerContextMarshall(pStubMsg, ContextHandle, RundownRoutine) {
        DllCall("RPCRT4.dll\NdrServerContextMarshall", "ptr", pStubMsg, "ptr", ContextHandle, "ptr", RundownRoutine)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<NDR_SCONTEXT>} ContextHandle 
     * @param {Pointer<NDR_RUNDOWN>} RundownRoutine 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrServerContextNewMarshall(pStubMsg, ContextHandle, RundownRoutine, pFormat) {
        DllCall("RPCRT4.dll\NdrServerContextNewMarshall", "ptr", pStubMsg, "ptr", ContextHandle, "ptr", RundownRoutine, "char*", pFormat)
    }

    /**
     * The NdrSimpleTypeUnmarshall function unmarshalls a simple type.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to memory to unmarshall.
     * @param {Integer} FormatChar Format string of the simple type.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrsimpletypeunmarshall
     * @since windows5.0
     */
    static NdrSimpleTypeUnmarshall(pStubMsg, pMemory, FormatChar) {
        DllCall("RPCRT4.dll\NdrSimpleTypeUnmarshall", "ptr", pStubMsg, "char*", pMemory, "char", FormatChar)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrRangeUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrRangeUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Void>} pMemory 
     * @param {Integer} CacheSize 
     * @param {Integer} flags 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrCorrelationInitialize(pStubMsg, pMemory, CacheSize, flags) {
        DllCall("RPCRT4.dll\NdrCorrelationInitialize", "ptr", pStubMsg, "ptr", pMemory, "uint", CacheSize, "uint", flags)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrCorrelationPass(pStubMsg) {
        DllCall("RPCRT4.dll\NdrCorrelationPass", "ptr", pStubMsg)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrCorrelationFree(pStubMsg) {
        DllCall("RPCRT4.dll\NdrCorrelationFree", "ptr", pStubMsg)
    }

    /**
     * The NdrPointerUnmarshall function unmarshalls a top level pointer to anything. Pointers embedded in structures, arrays, or unions call NdrPointerUnmarshall directly.
     * @remarks
     * This function is used for FC_RP, FC_UP, FC_FP, FC_OP format strings.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} ppMemory Pointer to memory where pointer will be unmarshalled. Please see MCCP Buffer Protection for information on buffer overrun protections in RPC: <a href="https://docs.microsoft.com/windows/desktop/Rpc/mccp-buffer-protection">http://msdn.microsoft.com/en-us/library/ff621497(VS.85).aspx</a>
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Integer} fMustAlloc Unused.
     * @returns {Pointer<Byte>} Returns <b>NULL</b> upon success. If an error occurs, the function throws one of the following exception codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>RPC_BAD_STUB_DATA or RPC_X_INVALID_BOUND  </td>
     * <td>The network  buffer is incorrect.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_OUT_OF_MEMORY</td>
     * <td>The system is out of memory.</td>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrpointerunmarshall
     * @since windows5.0
     */
    static NdrPointerUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrPointerUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * The NdrSimpleStructUnmarshall function unmarshals the simple structure from the network buffer to memory.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} ppMemory Address to a pointer to the unmarshalled simple structure. If set to null, or if the <i>fMustAlloc</i> parameter is set to <b>TRUE</b>, the stub will allocate the memory.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Integer} fMustAlloc Flag that specifies whether the stub must allocate the memory into which the simple structure is to be marshaled.  Specify <b>TRUE</b> if RPC must allocate <i>ppMemory</i>.
     * @returns {Pointer<Byte>} Returns null upon success. Raises one of the following exceptions upon failure.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>RPC_BAD_STUB_DATA or RPC_X_INVALID_BOUND</td>
     * <td>The network  is incorrect.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_OUT_OF_MEMORY</td>
     * <td>Out of memory.</td>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrsimplestructunmarshall
     * @since windows5.0
     */
    static NdrSimpleStructUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrSimpleStructUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrConformantStructUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrConformantStructUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrConformantVaryingStructUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrConformantVaryingStructUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * The NdrComplexStructUnmarshall function unmarshals the complex structure from the network buffer to memory.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} ppMemory Address to a pointer to the unmarshalled complex structure. If set to null, or if the <i>fMustAlloc</i> parameter is set to <b>TRUE</b>, the stub will allocate the memory.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Integer} fMustAlloc Flag that specifies whether the stub must allocate the memory into which the complex structure is to be marshaled.  Specify <b>TRUE</b> if RPC must allocate <i>ppMemory</i>.
     * @returns {Pointer<Byte>} Returns null upon success. Raises one of the following exceptions upon failure.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>RPC_BAD_STUB_DATA or RPC_X_INVALID_BOUND</td>
     * <td>The network  is incorrect.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_OUT_OF_MEMORY</td>
     * <td>Out of memory.</td>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcomplexstructunmarshall
     * @since windows5.0
     */
    static NdrComplexStructUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrComplexStructUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrFixedArrayUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrFixedArrayUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * The NdrConformantArrayUnmarshall function unmarshals a conformant array.
     * @remarks
     * The <b>NdrConformantArrayUnmarshall</b> function is used by both the client- and server-side stub to unmarshall a conformant array. The stub might allocate memory as necessary. For example, pArray in the sample on this page points to a conformant array. 
     * 
     * <b>NdrConformantArrayUnmarshall</b> should only be called in the context of an RPC stub, after the client or server stub has been initialized.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} ppMemory Address to a pointer to the buffer where the conformant array is unmarshalled. If set to <b>null</b>, or if the <i>fMustAlloc</i> is set to <b>TRUE</b>, the stub will allocate the memory.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Integer} fMustAlloc Flag that specifies whether the stub must allocate the memory into which the conformant array is to be marshalled. Specify <b>TRUE</b> if RPC must allocate <i>ppMemory</i>.
     * @returns {Pointer<Byte>} Returns <b>null</b> upon success. If an error occurs, the function throws one of the following exception codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_BAD_STUB_DATA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network  is incorrect.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_X_INVALID_BOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network  is incorrect.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_ACCESS_VIOLATION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An access violation occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INTERNAL_ERROR</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An error occurred in RPC.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrconformantarrayunmarshall
     * @since windows5.0
     */
    static NdrConformantArrayUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrConformantArrayUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrConformantVaryingArrayUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrConformantVaryingArrayUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrVaryingArrayUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrVaryingArrayUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * The NdrComplexArrayUnmarshall function unmarshals the complex array from the network buffer to memory.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} ppMemory Address to a pointer to the unmarshalled complex array. If set to null, or if the <i>fMustAlloc</i> parameter is set to <b>TRUE</b>, the stub will allocate the memory.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Integer} fMustAlloc Flag that specifies whether the stub must allocate the memory into which the complex array is to be marshaled.  Specify <b>TRUE</b> if RPC must allocate <i>ppMemory</i>.
     * @returns {Pointer<Byte>} Returns null upon success. Raises one of the following exceptions  upon failure.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>RPC_BAD_STUB_DATA or RPC_X_INVALID_BOUND</td>
     * <td>The network  is incorrect.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_OUT_OF_MEMORY</td>
     * <td>Out of memory.</td>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcomplexarrayunmarshall
     * @since windows5.0
     */
    static NdrComplexArrayUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrComplexArrayUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrNonConformantStringUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrNonConformantStringUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * The NdrConformantStringUnmarshall function unmarshals the conformant string from the network buffer to memory.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} ppMemory Address to a pointer to the unmarshalled conformant string. If set to null, or if the <i>fMustAlloc</i> is set to <b>TRUE</b>, the stub will allocate the memory.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Integer} fMustAlloc Flag that specifies whether the stub must allocate the memory into which the conformant string is to be marshaled.  Specify <b>TRUE</b> if RPC must allocate <i>ppMemory</i>.
     * @returns {Pointer<Byte>} Returns null upon success. If an error occurs, the function throws one of the following exception codes.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>RPC_BAD_STUB_DATA or RPC_X_INVALID_BOUND</td>
     * <td>The network  is incorrect.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_OUT_OF_MEMORY</td>
     * <td>Out of memory.</td>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrconformantstringunmarshall
     * @since windows5.0
     */
    static NdrConformantStringUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrConformantStringUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrEncapsulatedUnionUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrEncapsulatedUnionUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrNonEncapsulatedUnionUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrNonEncapsulatedUnionUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrByteCountPointerUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrByteCountPointerUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} fMustAlloc 
     * @returns {Pointer<Byte>} 
     */
    static NdrXmitOrRepAsUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrXmitOrRepAsUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * The NdrUserMarshalUnmarshall function calls a user-defined unmarshal routine to unmarshal data with the attribute.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The  <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} ppMemory Pointer to user data object to be unmarshalled.
     * @param {Pointer<Byte>} pFormat Format string description of the pointer.
     * @param {Integer} fMustAlloc Flag that specifies whether the stub must allocate the memory into which the user data object is to be unmarshalled.  Specify <b>TRUE</b> if RPC must allocate <i>ppMemory</i>.
     * @returns {Pointer<Byte>} Returns <b>NULL</b> upon success. Returns one of the following exception codes upon error.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrusermarshalunmarshall
     * @since windows5.0
     */
    static NdrUserMarshalUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrUserMarshalUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * The NdrInterfacePointerUnmarshall function unmarshalls the data referenced by the interface pointer from the network buffer to memory.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} ppMemory Pointer to a pointer to the unmarshalled interface pointer.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Integer} fMustAlloc Unused.
     * @returns {Pointer<Byte>} Returns NULL upon success. If an error occurs, the function throws one of the following exception codes. In addition, the function can throw exception codes from <a href="https://docs.microsoft.com/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface">CoUnmarshalInterface</a>.
     * 
     * <table>
     * <tr>
     * <th>Error</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>RPC_BAD_STUB_DATA  </td>
     * <td>The network  buffer is incorrect.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_OUT_OF_MEMORY</td>
     * <td>The system is out of memory.</td>
     * </tr>
     * <tr>
     * <td>STATUS_ACCESS_VIOLATION</td>
     * <td>An access violation occurred.</td>
     * </tr>
     * <tr>
     * <td>RPC_S_INTERNAL_ERROR</td>
     * <td>An error occurred in RPC.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrinterfacepointerunmarshall
     * @since windows5.0
     */
    static NdrInterfacePointerUnmarshall(pStubMsg, ppMemory, pFormat, fMustAlloc) {
        result := DllCall("RPCRT4.dll\NdrInterfacePointerUnmarshall", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat, "char", fMustAlloc, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<IntPtr>} pContextHandle 
     * @param {Pointer<Void>} BindHandle 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrClientContextUnmarshall(pStubMsg, pContextHandle, BindHandle) {
        DllCall("RPCRT4.dll\NdrClientContextUnmarshall", "ptr", pStubMsg, "ptr*", pContextHandle, "ptr", BindHandle)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @returns {Pointer<NDR_SCONTEXT>} 
     */
    static NdrServerContextUnmarshall(pStubMsg) {
        result := DllCall("RPCRT4.dll\NdrServerContextUnmarshall", "ptr", pStubMsg, "ptr")
        return result
    }

    /**
     * Initializes a new RPC context handle.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that contains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pFormat Pointer to a <b>FORMAT_STRING</b> structure that contains the format of the new context handle.
     * @returns {Pointer<NDR_SCONTEXT>} Returns a NDR_SCONTEXT structure that provides a newly initialized context on return or raises exception upon error.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcontexthandleinitialize
     * @since windows5.1.2600
     */
    static NdrContextHandleInitialize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrContextHandleInitialize", "ptr", pStubMsg, "char*", pFormat, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Pointer<NDR_SCONTEXT>} 
     */
    static NdrServerContextNewUnmarshall(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrServerContextNewUnmarshall", "ptr", pStubMsg, "char*", pFormat, "ptr")
        return result
    }

    /**
     * The NdrPointerBufferSize function computes the needed buffer size, in bytes, for a top-level pointer to anything.
     * @remarks
     * Pointers embedded in structures, arrays, or unions call 
     *     <b>NdrPointerBufferSize</b> directly. 
     * 
     * Used for FC_RP, FC_UP, FC_FP, FC_OP format strings.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the data being sized.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrpointerbuffersize
     * @since windows5.0
     */
    static NdrPointerBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrPointerBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrSimpleStructBufferSize function calculates the required buffer size, in bytes, to marshal the simple structure.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. The <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the simple structure to be calculated.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrsimplestructbuffersize
     * @since windows5.0
     */
    static NdrSimpleStructBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrSimpleStructBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConformantStructBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantStructBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConformantVaryingStructBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantVaryingStructBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrComplexStructBufferSize function calculates the required buffer size, in bytes, to marshal the complex structure.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. The <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the complex structure to be calculated.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcomplexstructbuffersize
     * @since windows5.0
     */
    static NdrComplexStructBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrComplexStructBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrFixedArrayBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrFixedArrayBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrConformantArrayBufferSize function calculates the required buffer size, in bytes, to marshal the conformant array.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. The <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the conformant array to be calculated.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrconformantarraybuffersize
     */
    static NdrConformantArrayBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantArrayBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConformantVaryingArrayBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantVaryingArrayBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrVaryingArrayBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrVaryingArrayBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrComplexArrayBufferSize function calculates the required buffer size, in bytes, to marshal the complex array.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. The <b>MIDL_STUB_MESSAGE</b> structure is for internal use only, and must not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the  complex array to be calculated.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcomplexarraybuffersize
     * @since windows5.0
     */
    static NdrComplexArrayBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrComplexArrayBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrConformantStringBufferSize function calculates the size of the buffer, in bytes, needed to marshal the conformant string.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to the null-terminated conformant string to be calculated.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrconformantstringbuffersize
     * @since windows5.0
     */
    static NdrConformantStringBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantStringBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrNonConformantStringBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrNonConformantStringBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrEncapsulatedUnionBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrEncapsulatedUnionBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrNonEncapsulatedUnionBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrNonEncapsulatedUnionBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrByteCountPointerBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrByteCountPointerBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrXmitOrRepAsBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrXmitOrRepAsBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrUserMarshalBufferSize function calculates the size of the buffer, in bytes, needed to marshal the user marshal object.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to the user marshal object to be calculated.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrusermarshalbuffersize
     * @since windows5.0
     */
    static NdrUserMarshalBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrUserMarshalBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrInterfacePointerBufferSize function calculates the size of the buffer, in bytes, needed to marshal the interface pointer.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the buffer. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the interface pointer to be calculated.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrinterfacepointerbuffersize
     * @since windows5.0
     */
    static NdrInterfacePointerBufferSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrInterfacePointerBufferSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrContextHandleSize function returns the size of the supplied RPC context handle.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that contains the current status of the RPC stub. The <b>BufferLength</b> member contains the size of the context handle, in bytes. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to a string buffer that contains an RPC context handle.
     * @param {Pointer<Byte>} pFormat Pointer to a <b>FORMAT_STRING</b> structure that contains the format of the context handle specified in <i>pMemory</i>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrcontexthandlesize
     * @since windows5.1.2600
     */
    static NdrContextHandleSize(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrContextHandleSize", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrPointerMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrPointerMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrSimpleStructMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrSimpleStructMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrConformantStructMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantStructMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrConformantVaryingStructMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantVaryingStructMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrComplexStructMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrComplexStructMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrFixedArrayMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrFixedArrayMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrConformantArrayMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantArrayMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrConformantVaryingArrayMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantVaryingArrayMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrVaryingArrayMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrVaryingArrayMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrComplexArrayMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrComplexArrayMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrConformantStringMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrConformantStringMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrNonConformantStringMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrNonConformantStringMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrEncapsulatedUnionMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrEncapsulatedUnionMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrNonEncapsulatedUnionMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrNonEncapsulatedUnionMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrXmitOrRepAsMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrXmitOrRepAsMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrUserMarshalMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrUserMarshalMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @returns {Integer} 
     */
    static NdrInterfacePointerMemorySize(pStubMsg, pFormat) {
        result := DllCall("RPCRT4.dll\NdrInterfacePointerMemorySize", "ptr", pStubMsg, "char*", pFormat, "uint")
        return result
    }

    /**
     * The NdrPointerFree function frees memory.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub.  This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to memory to be freed.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrpointerfree
     * @since windows5.0
     */
    static NdrPointerFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrPointerFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrSimpleStructFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrSimpleStructFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConformantStructFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantStructFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConformantVaryingStructFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantVaryingStructFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrComplexStructFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrComplexStructFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrFixedArrayFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrFixedArrayFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConformantArrayFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantArrayFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConformantVaryingArrayFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrConformantVaryingArrayFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrVaryingArrayFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrVaryingArrayFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrComplexArrayFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrComplexArrayFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrEncapsulatedUnionFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrEncapsulatedUnionFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrNonEncapsulatedUnionFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrNonEncapsulatedUnionFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrByteCountPointerFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrByteCountPointerFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrXmitOrRepAsFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrXmitOrRepAsFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrUserMarshalFree function frees the user marshal object.
     * @remarks
     * You should never free the top level object, it is freed by the system.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. Structure is for internal use only; do not modify.
     * @param {Pointer<Byte>} pMemory Pointer to be freed.
     * @param {Pointer<Byte>} pFormat Pointer's format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrusermarshalfree
     * @since windows5.0
     */
    static NdrUserMarshalFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrUserMarshalFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * The NdrInterfacePointerFree function releases the interface pointer.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pMemory Pointer to the interface pointer to be released.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrinterfacepointerfree
     * @since windows5.0
     */
    static NdrInterfacePointerFree(pStubMsg, pMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrInterfacePointerFree", "ptr", pStubMsg, "char*", pMemory, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pFormat 
     * @param {Integer} NumberParams 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrConvert2(pStubMsg, pFormat, NumberParams) {
        DllCall("RPCRT4.dll\NdrConvert2", "ptr", pStubMsg, "char*", pFormat, "int", NumberParams)
    }

    /**
     * The NdrConvert function converts the network buffer from the data representation of the sender to the data representation of the receiver if they are different.
     * @remarks
     * The <b>NdrConvert</b> function is used by all <a href="https://docs.microsoft.com/windows/desktop/Midl/-oi">/Oi</a>, <b>/Oic</b>, and <a href="https://docs.microsoft.com/windows/desktop/Midl/-os">/Os</a> mode  stubs.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The <b>pRpcMsg</b> member points to a structure whose <b>Buffer</b> member contains the data to convert. This structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pFormat Pointer to type format  of the data to convert.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrconvert
     * @since windows5.0
     */
    static NdrConvert(pStubMsg, pFormat) {
        DllCall("RPCRT4.dll\NdrConvert", "ptr", pStubMsg, "char*", pFormat)
    }

    /**
     * 
     * @param {Pointer<UInt32>} pFlags 
     * @param {Pointer<Byte>} pBuffer 
     * @param {Integer} FormatChar 
     * @returns {Pointer<Byte>} 
     */
    static NdrUserMarshalSimpleTypeConvert(pFlags, pBuffer, FormatChar) {
        result := DllCall("RPCRT4.dll\NdrUserMarshalSimpleTypeConvert", "uint*", pFlags, "char*", pBuffer, "char", FormatChar, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor 
     * @param {Integer} ProcNum 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrClientInitializeNew(pRpcMsg, pStubMsg, pStubDescriptor, ProcNum) {
        DllCall("RPCRT4.dll\NdrClientInitializeNew", "ptr", pRpcMsg, "ptr", pStubMsg, "ptr", pStubDescriptor, "uint", ProcNum)
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor 
     * @returns {Pointer<Byte>} 
     */
    static NdrServerInitializeNew(pRpcMsg, pStubMsg, pStubDescriptor) {
        result := DllCall("RPCRT4.dll\NdrServerInitializeNew", "ptr", pRpcMsg, "ptr", pStubMsg, "ptr", pStubDescriptor, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor 
     * @param {Integer} RequestedBufferSize 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrServerInitializePartial(pRpcMsg, pStubMsg, pStubDescriptor, RequestedBufferSize) {
        DllCall("RPCRT4.dll\NdrServerInitializePartial", "ptr", pRpcMsg, "ptr", pStubMsg, "ptr", pStubDescriptor, "uint", RequestedBufferSize)
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor 
     * @param {Integer} ProcNum 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrClientInitialize(pRpcMsg, pStubMsg, pStubDescriptor, ProcNum) {
        DllCall("RPCRT4.dll\NdrClientInitialize", "ptr", pRpcMsg, "ptr", pStubMsg, "ptr", pStubDescriptor, "uint", ProcNum)
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor 
     * @returns {Pointer<Byte>} 
     */
    static NdrServerInitialize(pRpcMsg, pStubMsg, pStubDescriptor) {
        result := DllCall("RPCRT4.dll\NdrServerInitialize", "ptr", pRpcMsg, "ptr", pStubMsg, "ptr", pStubDescriptor, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @returns {Pointer<Byte>} 
     */
    static NdrServerInitializeUnmarshall(pStubMsg, pStubDescriptor, pRpcMsg) {
        result := DllCall("RPCRT4.dll\NdrServerInitializeUnmarshall", "ptr", pStubMsg, "ptr", pStubDescriptor, "ptr", pRpcMsg, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrServerInitializeMarshall(pRpcMsg, pStubMsg) {
        DllCall("RPCRT4.dll\NdrServerInitializeMarshall", "ptr", pRpcMsg, "ptr", pStubMsg)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Integer} BufferLength 
     * @param {Pointer<Void>} Handle 
     * @returns {Pointer<Byte>} 
     */
    static NdrGetBuffer(pStubMsg, BufferLength, Handle) {
        result := DllCall("RPCRT4.dll\NdrGetBuffer", "ptr", pStubMsg, "uint", BufferLength, "ptr", Handle, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Integer} BufferLength 
     * @param {Pointer<Void>} Handle 
     * @returns {Pointer<Byte>} 
     */
    static NdrNsGetBuffer(pStubMsg, BufferLength, Handle) {
        result := DllCall("RPCRT4.dll\NdrNsGetBuffer", "ptr", pStubMsg, "uint", BufferLength, "ptr", Handle, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pBufferEnd 
     * @returns {Pointer<Byte>} 
     */
    static NdrSendReceive(pStubMsg, pBufferEnd) {
        result := DllCall("RPCRT4.dll\NdrSendReceive", "ptr", pStubMsg, "char*", pBufferEnd, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Byte>} pBufferEnd 
     * @param {Pointer<Void>} pAutoHandle 
     * @returns {Pointer<Byte>} 
     */
    static NdrNsSendReceive(pStubMsg, pBufferEnd, pAutoHandle) {
        result := DllCall("RPCRT4.dll\NdrNsSendReceive", "ptr", pStubMsg, "char*", pBufferEnd, "ptr", pAutoHandle, "char*")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrFreeBuffer(pStubMsg) {
        DllCall("RPCRT4.dll\NdrFreeBuffer", "ptr", pStubMsg)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<RPC_VERSION>} pVersion 
     * @returns {HRESULT} 
     */
    static NdrGetDcomProtocolVersion(pStubMsg, pVersion) {
        result := DllCall("RPCRT4.dll\NdrGetDcomProtocolVersion", "ptr", pStubMsg, "ptr", pVersion, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * The NdrClientCall2 function is the client-side entry point for the /Oicf mode stub.
     * @remarks
     * The <b>NdrClientCall2</b> function is used by all <a href="https://docs.microsoft.com/windows/desktop/Midl/-oi">/Oicf</a> mode client-side stubs. The <b>NdrClientCall2</b> function transmits all [in] data to the remote server, and upon receipt of the response packet, returns the [out] value to the client-side application.
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor Pointer to the MIDL-generated <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_desc">MIDL_STUB_DESC</a> structure that contains information about the description of the remote interface.
     * @param {Pointer<Byte>} pFormat Pointer to the MIDL-generated procedure format string that describes the method and parameters.
     * @returns {Pointer} Return value of the remote call. The maximum size of a return value is equivalent to the register size of the system. MIDL switches to the <a href="https://docs.microsoft.com/windows/desktop/Midl/-os">/Os</a> mode stub if the return value size is larger than the register size.
     * 
     * Depending on the method definition, this function can throw an exception if there is a network or server failure.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrclientcall2
     * @since windows5.0
     */
    static NdrClientCall2(pStubDescriptor, pFormat) {
        result := DllCall("RPCRT4.dll\NdrClientCall2", "ptr", pStubDescriptor, "char*", pFormat, "CDecl ptr")
        return result
    }

    /**
     * The NdrAsyncClientCall function is the asynchronous client-side entry point for the /Oi and /Oic mode stub.
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor Pointer to the MIDL-generated <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_desc">MIDL_STUB_DESC</a> structure that contains information about the description of the remote interface.
     * @param {Pointer<Byte>} pFormat Pointer to the MIDL-generated procedure format string that describes the method and parameters.
     * @returns {Pointer} Return value of the remote call. The maximum size of a return value is equivalent to the register size of the system. MIDL switches to the <a href="https://docs.microsoft.com/windows/desktop/Midl/-os">/Os</a> mode stub if the return value size is larger than the register size.
     * 
     * Depending on the method definition, this function can throw an exception if there is a network or server failure.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrasyncclientcall
     * @since windows5.0
     */
    static NdrAsyncClientCall(pStubDescriptor, pFormat) {
        result := DllCall("RPCRT4.dll\NdrAsyncClientCall", "ptr", pStubDescriptor, "char*", pFormat, "CDecl ptr")
        return result
    }

    /**
     * NdrDcomAsyncClientCall may be altered or unavailable.
     * @param {Pointer<MIDL_STUB_DESC>} pStubDescriptor Reserved.
     * @param {Pointer<Byte>} pFormat Reserved.
     * @returns {Pointer} Reserved.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrdcomasyncclientcall
     * @since windows5.0
     */
    static NdrDcomAsyncClientCall(pStubDescriptor, pFormat) {
        result := DllCall("RPCRT4.dll\NdrDcomAsyncClientCall", "ptr", pStubDescriptor, "char*", pFormat, "CDecl ptr")
        return result
    }

    /**
     * NdrAsyncServerCall is not intended to be directly called by applications.
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg Reserved.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrasyncservercall
     * @since windows5.0
     */
    static NdrAsyncServerCall(pRpcMsg) {
        DllCall("RPCRT4.dll\NdrAsyncServerCall", "ptr", pRpcMsg)
    }

    /**
     * 
     * @param {Pointer<IRpcStubBuffer>} pThis 
     * @param {Pointer<IRpcChannelBuffer>} pChannel 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<UInt32>} pdwStubPhase 
     * @returns {Integer} 
     */
    static NdrDcomAsyncStubCall(pThis, pChannel, pRpcMsg, pdwStubPhase) {
        result := DllCall("RPCRT4.dll\NdrDcomAsyncStubCall", "ptr", pThis, "ptr", pChannel, "ptr", pRpcMsg, "uint*", pdwStubPhase, "int")
        return result
    }

    /**
     * The NdrStubCall2 function is the server-side entry point for /Oicf mode stubs.
     * @remarks
     * The RPC run-time or OLE run-time calls <b>NdrStubCall2</b> to invoke the server manager routine. The [out] parameters are marshalled and returned to RPC run-time or OLE run-time to send back to the client.
     * 
     * The <i>pdwStubPhase</i> parameter is used by the object interface to determine exception handling behavior. The following table describes possible values for the <i>pdwStubPhase</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>STUB_UNMARSHAL</td>
     * <td>The stub is in marshalling phase.</td>
     * </tr>
     * <tr>
     * <td>STUB_CALL_SERVER</td>
     * <td>The stub is calling a server manager routine.</td>
     * </tr>
     * <tr>
     * <td>STUB_MARSHAL</td>
     * <td>The stub is in unmarshalling phase.</td>
     * </tr>
     * <tr>
     * <td>STUB_CALL_SERVER_NO_HRESULT</td>
     * <td>Obsolete. For deprecated stubs only.</td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pThis Pointer to an instance of the CStdStubBuffer object, implementing  <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-irpcstubbuffer">IRpcStubBuffer</a>, for the DCOM interface.  Set to <b>NULL</b> for nonobject RPC interfaces.
     * @param {Pointer<Void>} pChannel Pointer to <a href="https://docs.microsoft.com/windows/desktop/api/objidl/nn-objidl-irpcchannelbuffer">IRpcChannelBuffer</a> for the DCOM interface, often provided by OLE. Set to <b>NULL</b> for nonobject interfaces.
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg Pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/rpcdcep/ns-rpcdcep-rpc_message">RPC_MESSAGE</a> structure that  contains information about the RPC request. In nonobject interfaces, <i>pRpcMsg</i> also contains information about the remoting method.
     * @param {Pointer<UInt32>} pdwStubPhase Pointer to a flag that tracks the current interpreter call's activity.
     * @returns {Integer} Returns S_OK upon success. Raises an exception upon error.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrstubcall2
     * @since windows5.0
     */
    static NdrStubCall2(pThis, pChannel, pRpcMsg, pdwStubPhase) {
        result := DllCall("RPCRT4.dll\NdrStubCall2", "ptr", pThis, "ptr", pChannel, "ptr", pRpcMsg, "uint*", pdwStubPhase, "int")
        return result
    }

    /**
     * NdrServerCall2 is not intended to be directly called by applications.
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg Reserved.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrservercall2
     * @since windows5.0
     */
    static NdrServerCall2(pRpcMsg) {
        DllCall("RPCRT4.dll\NdrServerCall2", "ptr", pRpcMsg)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<UInt32>} pCommStatus 
     * @param {Pointer<UInt32>} pFaultStatus 
     * @param {Integer} Status 
     * @returns {Integer} 
     */
    static NdrMapCommAndFaultStatus(pStubMsg, pCommStatus, pFaultStatus, Status) {
        result := DllCall("RPCRT4.dll\NdrMapCommAndFaultStatus", "ptr", pStubMsg, "uint*", pCommStatus, "uint*", pFaultStatus, "int", Status, "int")
        return result
    }

    /**
     * The RpcSsAllocate function allocates memory within the RPC stub memory-management function, and returns a pointer to the allocated memory or NULL.
     * @remarks
     * The 
     * <b>RpcSsAllocate</b> function allows an application to allocate memory within the RPC stub memory–management function. Prior to calling 
     * <b>RpcSsAllocate</b>, the memory-management environment must already be established. For memory management called within the stub, the stub itself usually establishes the necessary environment. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/memory-management">Memory Management</a>. When using 
     * <b>RpcSsAllocate</b> to allocate memory not called from the stub, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssenableallocate">RpcSsEnableAllocate</a> to establish the required memory-management environment.
     * 
     * The 
     * <b>RpcSsAllocate</b> routine returns a pointer to the allocated memory, if the call was successful. Otherwise, it raises an exception.
     * 
     * When the stub establishes the memory management, it frees any memory allocated by 
     * <b>RpcSsAllocate</b>. The application can free such memory before returning to the calling stub by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssfree">RpcSsFree</a>.
     * 
     * By contrast, when the application establishes the memory management, it must free any allocated memory. It does so by calling either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssfree">RpcSsFree</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssdisableallocate">RpcSsDisableAllocate</a>.
     * 
     * To manage the same memory within the stub memory–management environment, multiple threads can call 
     * <b>RpcSsAllocate</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssfree">RpcSsFree</a>. In this case, the threads must share the same stub memory management–thread handle. Applications pass thread handles from thread-to-thread by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsssetthreadhandle">RPCSsSetThreadHandle</a>.
     * 
     * <div class="alert"><b>Note</b>  The 
     * <b>RpcSsAllocate</b> routine raises exceptions, unlike 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a>, which returns the error code.</div>
     * <div> </div>
     * @param {Pointer} Size Size of memory to allocate, in bytes.
     * @returns {Pointer<Void>} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcssallocate
     * @since windows5.0
     */
    static RpcSsAllocate(Size) {
        result := DllCall("RPCRT4.dll\RpcSsAllocate", "ptr", Size, "ptr")
        return result
    }

    /**
     * The RpcSsDisableAllocate function frees resources and memory within the stub memory�management environment.
     * @remarks
     * <b>RpcSsDisableAllocate</b> frees all the resources used by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssenableallocate">RpcSsEnableAllocate</a>. It also releases memory that was allocated by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a> after the call to 
     * <b>RpcSsEnableAllocate</b>.
     * 
     * 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssenableallocate">RpcSsEnableAllocate</a> and 
     * <b>RpcSsDisableAllocate</b> must be used together as matching pairs.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcssdisableallocate
     * @since windows5.0
     */
    static RpcSsDisableAllocate() {
        DllCall("RPCRT4.dll\RpcSsDisableAllocate")
    }

    /**
     * The RpcSsEnableAllocate function establishes the stub memory�management environment.
     * @remarks
     * In cases where the stub memory management is not enabled by the stub itself, an application calls 
     * <b>RpcSsEnableAllocate</b> to establish the stub memory–management environment. This environment must be established prior to making a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a>. For server manager code called from the stub, the memory-management environment is usually established by the stub itself. Otherwise, call 
     * <b>RpcSsEnableAllocate</b> before calling 
     * <b>RpcSsAllocate</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/memory-management">Memory Management</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsssetthreadhandle">RpcSsSetThreadHandle</a>.
     * 
     * <div class="alert"><b>Note</b>  The 
     * <b>RpcSsEnableAllocate</b> function raises exceptions, while the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmenableallocate">RpcSmEnableAllocate</a> function returns the error code.</div>
     * <div> </div>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcssenableallocate
     * @since windows5.0
     */
    static RpcSsEnableAllocate() {
        DllCall("RPCRT4.dll\RpcSsEnableAllocate")
    }

    /**
     * The RpcSsFree function releases memory allocated by RpcSsAllocate.
     * @remarks
     * An application uses 
     * <b>RpcSsFree</b> to free memory that was allocated with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a>. In cases where the stub allocates the memory for the environment, 
     * <b>RpcSsFree</b> can also be used to release memory. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/memory-management">Memory Management</a>.
     * 
     * Note that the handle of the thread calling 
     * <b>RpcSsFree</b> must match the handle of the thread that allocated the memory by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a>. Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsssetthreadhandle">RpcSsSetThreadHandle</a> to pass handles from thread to thread.
     * @param {Pointer<Void>} NodeToFree Pointer to memory allocated by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcssfree
     * @since windows5.0
     */
    static RpcSsFree(NodeToFree) {
        DllCall("RPCRT4.dll\RpcSsFree", "ptr", NodeToFree)
    }

    /**
     * The RpcSsGetThreadHandle function returns a thread handle for the stub memory�management environment.
     * @remarks
     * An application calls 
     * <b>RpcSsGetThreadHandle</b> to obtain a thread handle for the stub memory–management environment. A thread used to manage memory for the stub memory–management environment uses 
     * <b>RpcSsGetThreadHandle</b> to receive a handle for its memory environment. In this way, another thread that calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsssetthreadhandle">RpcSsSetThreadHandle</a> by using this handle can then use the same memory-management environment.
     * 
     * The same thread handle must be used by multiple threads calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssfree">RpcSsFree</a> to manage the same memory. Before spawning new threads to manage the same memory, the thread that established the memory-management environment (parent thread) calls 
     * <b>RpcSsGetThreadHandle</b> to obtain a thread handle for this environment. Then, the spawned threads call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsssetthreadhandle">RpcSsSetThreadHandle</a> with the handle provided by the parent thread.
     * 
     * Typically, a server manager procedure calls 
     * <b>RpcSsGetThreadHandle</b> before additional threads are spawned. The stub sets up the memory-management environment for the manager procedure, and the manager calls 
     * <b>RpcSsGetThreadHandle</b> to make this environment available to the other threads.
     * 
     * A thread can also call 
     * <b>RpcSsGetThreadHandle</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsssetthreadhandle">RpcSsSetThreadHandle</a> to save and restore its memory-management environment.
     * 
     * <div class="alert"><b>Note</b>  <b>RpcSsGetThreadHandle</b> raises exceptions, while 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> returns the error code.</div>
     * <div> </div>
     * @returns {Pointer<Void>} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle
     * @since windows5.0
     */
    static RpcSsGetThreadHandle() {
        result := DllCall("RPCRT4.dll\RpcSsGetThreadHandle", "ptr")
        return result
    }

    /**
     * The RpcSsSetClientAllocFree function enables the memory allocation and release mechanisms used by the client stubs.
     * @remarks
     * By overriding the default routines used by the client stub to manage memory, 
     * <b>RpcSsSetClientAllocFree</b> establishes the memory allocation and memory freeing mechanisms. Note that the default routines are free and malloc, unless the remote call occurs within manager code. In this case, the default memory–management routines are 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssfree">RpcSsFree</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a>.
     * 
     * Note that when 
     * <b>RpcSsSetClientAllocFree</b> reclaims the memory resources, it also makes the context handle <b>NULL</b>.
     * 
     * <div class="alert"><b>Note</b>  <b>RpcSsSetClientAllocFree</b> raises exceptions, unlike 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetclientallocfree">RpcSmSetClientAllocFree</a>, which returns the error code.</div>
     * <div> </div>
     * @param {Pointer<RPC_CLIENT_ALLOC>} ClientAlloc Memory-allocation function.
     * @param {Pointer<RPC_CLIENT_FREE>} ClientFree Memory-releasing function used with the memory-allocation function specified by <i>pfnAllocate</i>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsssetclientallocfree
     * @since windows5.0
     */
    static RpcSsSetClientAllocFree(ClientAlloc, ClientFree) {
        DllCall("RPCRT4.dll\RpcSsSetClientAllocFree", "ptr", ClientAlloc, "ptr", ClientFree)
    }

    /**
     * The RpcSsSetThreadHandle function sets a thread handle for the stub memory–management environment.
     * @remarks
     * An application calls 
     * <b>RpcSsSetThreadHandle</b> to set a thread handle for the stub memory–management environment. A thread used to manage memory for the stub memory–management environment calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a> to obtain a handle for its memory environment. In this way, another thread that calls 
     * <b>RpcSsSetThreadHandle</b> by using this handle can then use the same memory-management environment.
     * 
     * The same thread handle must be used by multiple threads calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssfree">RpcSsFree</a> in order to manage the same memory. Before spawning new threads to manage the same memory, the thread that established the memory-management environment (parent thread) calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a> to obtain a thread handle for this environment. Then, the spawned threads call 
     * <b>RpcSsSetThreadHandle</b> with the handle provided by the parent thread.
     * 
     * Typically, a thread spawned by a server manager procedure calls 
     * <b>RpcSsSetThreadHandle</b>. The stub sets up the memory-management environment for the manager procedure, and the manager calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a> to obtain a thread handle. Then, each spawned thread calls 
     * <b>RpcSsGetThreadHandle</b> to get access to the manager's memory-management environment.
     * 
     * A thread can also call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a> and 
     * <b>RpcSsSetThreadHandle</b> to save and restore its memory-management environment.
     * 
     * <div class="alert"><b>Note</b>  The 
     * <b>RpcSsSetThreadHandle</b> routine raises exceptions, while the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a> routine returns the error code.</div>
     * <div> </div>
     * @param {Pointer<Void>} Id Thread handle returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssgetthreadhandle">RpcSsGetThreadHandle</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsssetthreadhandle
     * @since windows5.0
     */
    static RpcSsSetThreadHandle(Id) {
        DllCall("RPCRT4.dll\RpcSsSetThreadHandle", "ptr", Id)
    }

    /**
     * The RpcSsSwapClientAllocFree function exchanges the memory allocation and release mechanisms used by the client stubs with those supplied by the client.
     * @remarks
     * <b>RpcSsSwapClientAllocFree</b> exchanges the current memory allocation and memory freeing mechanisms with those supplied by the client.
     * 
     * <div class="alert"><b>Note</b>  <b>RpcSsSwapClientAllocFree</b> raises exceptions, unlike 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmswapclientallocfree">RpcSmSwapClientAllocFree</a>, which returns the error code.</div>
     * <div> </div>
     * @param {Pointer<RPC_CLIENT_ALLOC>} ClientAlloc New function to allocate memory.
     * @param {Pointer<RPC_CLIENT_FREE>} ClientFree New function to release memory.
     * @param {Pointer<RPC_CLIENT_ALLOC>} OldClientAlloc Returns the previous memory-allocation function.
     * @param {Pointer<RPC_CLIENT_FREE>} OldClientFree Returns the previous memory-freeing function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcssswapclientallocfree
     * @since windows5.0
     */
    static RpcSsSwapClientAllocFree(ClientAlloc, ClientFree, OldClientAlloc, OldClientFree) {
        DllCall("RPCRT4.dll\RpcSsSwapClientAllocFree", "ptr", ClientAlloc, "ptr", ClientFree, "ptr", OldClientAlloc, "ptr", OldClientFree)
    }

    /**
     * The RpcSmAllocate function allocates memory within the RPC stub memory management function and returns a pointer to the allocated memory or NULL.
     * @remarks
     * The 
     * <b>RpcSmAllocate</b> routine allows an application to allocate memory within the RPC stub memory–management environment. Prior to calling 
     * <b>RpcSmAllocate</b>, the memory-management environment must already be established. For memory management called within the stub, the server stub itself may establish the necessary environment. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmenableallocate">RpcSmEnableAllocate</a>. When using 
     * <b>RpcSmAllocate</b> to allocate memory not called from the stub, the application must call 
     * <b>RpcSmEnableAllocate</b> to establish the required memory-management environment.
     * 
     * The 
     * <b>RpcSmAllocate</b> routine returns a pointer to the allocated memory if the call is successful. Otherwise, a <b>NULL</b> is returned.
     * 
     * When the stub establishes the memory management, it frees any memory allocated by 
     * <b>RpcSmAllocate</b>. The application can free such memory before returning to the calling stub by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmfree">RpcSmFree</a>.
     * 
     * By contrast, when the application establishes the memory management, it must free any memory allocated. It does so by calling either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmfree">RpcSmFree</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmdisableallocate">RpcSmDisableAllocate</a>.
     * 
     * To manage the same memory within the stub memory–management environment, multiple threads can call 
     * <b>RpcSmAllocate</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmfree">RpcSmFree</a>. In this case, the threads must share the same stub memory management thread handle. Applications pass thread handles from thread to thread by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a>.
     * 
     * For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/memory-management">Memory Management</a>.
     * @param {Pointer} Size Size of memory to allocate, in bytes.
     * @param {Pointer<Int32>} pStatus Pointer to the returned status.
     * @returns {Pointer<Void>} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmallocate
     * @since windows5.0
     */
    static RpcSmAllocate(Size, pStatus) {
        result := DllCall("RPCRT4.dll\RpcSmAllocate", "ptr", Size, "int*", pStatus, "ptr")
        return result
    }

    /**
     * The RpcSmClientFree function frees memory returned from a client stub.
     * @remarks
     * The 
     * <b>RpcSmClientFree</b> function releases memory allocated and returned from a client stub. The memory management handle of the thread calling this function must match the handle of the thread that made the RPC call. Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a> to pass handles from thread to thread.
     * 
     * Note that using 
     * <b>RpcSmClientFree</b> allows a function to free dynamically-allocated memory returned by an RPC call without knowing the memory-management environment from which it was called.
     * @param {Pointer<Void>} pNodeToFree Pointer to memory returned from a client stub.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmclientfree
     * @since windows5.0
     */
    static RpcSmClientFree(pNodeToFree) {
        result := DllCall("RPCRT4.dll\RpcSmClientFree", "ptr", pNodeToFree, "int")
        return result
    }

    /**
     * The RpcSmDestroyClientContext function reclaims the client memory resources for a context handle and makes the context handle NULL.
     * @remarks
     * Client applications use 
     * <b>RpcSmDestroyClientContext</b> to reclaim resources from an inactive context handle. Applications can call 
     * <b>RpcSmDestroyClientContext</b> after a communications error makes the context handle unusable. The 
     * <b>RpcSmDestroyClientContext</b> function provides the same functionality as the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssdestroyclientcontext">RpcSsDestroyClientContext</a> function.
     * 
     * This function does not invoke the server's context handle run-down process.
     * 
     * When 
     * <b>RpcSmDestroyClientContext</b> reclaims the memory resources, it also makes the context handle <b>NULL</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/using-context-handles">Using Context Handles</a>.
     * @param {Pointer<Void>} ContextHandle Context handle that can no longer be used. The handle is set to <b>NULL</b> before <b>RpcSMDestroyClientContext</b> returns.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_X_SS_CONTEXT_MISMATCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmdestroyclientcontext
     * @since windows5.0
     */
    static RpcSmDestroyClientContext(ContextHandle) {
        result := DllCall("RPCRT4.dll\RpcSmDestroyClientContext", "ptr", ContextHandle, "int")
        return result
    }

    /**
     * The RpcSmDisableAllocate function frees resources and memory within the stub memory�management environment.
     * @remarks
     * The 
     * <b>RpcSmDisableAllocate</b> function frees all the resources used by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmenableallocate">RpcSmEnableAllocate</a>. It also releases memory allocated by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a> after the call to 
     * <b>RpcSmEnableAllocate</b> and marked for deletion by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmfree">RpcSmFree</a> function.
     * 
     * Note that 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmenableallocate">RpcSmEnableAllocate</a> and 
     * <b>RpcSmDisableAllocate</b> must be used together as matching pairs.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmdisableallocate
     * @since windows5.0
     */
    static RpcSmDisableAllocate() {
        result := DllCall("RPCRT4.dll\RpcSmDisableAllocate", "int")
        return result
    }

    /**
     * The RpcSmEnableAllocate function establishes the stub memory�management environment.
     * @remarks
     * In cases where the stub memory management is not enabled by the server stub itself, applications call 
     * <b>RpcSmEnableAllocate</b> to establish the stub memory–management environment. This environment must be established prior to making a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a>. In OSF-compatibility (<b>/osf</b>) mode, for server manager code called from the stub, the memory-management environment may be established by the server stub itself by using pointer manipulation or the 
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/enable-allocate">enable_allocate</a> attribute. In default (Microsoft-extended) mode, the environment is established only upon request by using the 
     * <a href="https://docs.microsoft.com/windows/desktop/Midl/enable-allocate">enable_allocate</a> attribute. Otherwise, call 
     * <b>RpcSmEnableAllocate</b> before calling 
     * <b>RpcSmAllocate</b>. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/memory-management">Memory Management</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmenableallocate
     * @since windows5.0
     */
    static RpcSmEnableAllocate() {
        result := DllCall("RPCRT4.dll\RpcSmEnableAllocate", "int")
        return result
    }

    /**
     * The RpcSmFree function releases memory allocated by RpcSmAllocate.
     * @remarks
     * Applications use 
     * <b>RpcSmFree</b> to free memory allocated by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a>. In cases where the stub allocates the memory for the application, 
     * <b>RpcSmFree</b> can also be used to release memory. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/memory-management">Memory Management</a>.
     * 
     * To improve performance, the 
     * <b>RpcSmFree</b> function only marks memory for release. Memory is not actually released until your application calls the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmdisableallocate">RpcSmDisableAllocate</a> function. To release memory immediately, invoke the 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/the-midl-user-free-function">midl_user_free</a> function.
     * 
     * Note that the handle of the thread calling 
     * <b>RpcSmFree</b> must match the handle of the thread that allocated the memory by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate.</a>. Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a> to pass handles from thread to thread.
     * @param {Pointer<Void>} NodeToFree Pointer to memory allocated by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcssallocate">RpcSsAllocate</a>.
     * @returns {Integer} The function 
     * <b>RpcSmFree</b> returns the following value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmfree
     * @since windows5.0
     */
    static RpcSmFree(NodeToFree) {
        result := DllCall("RPCRT4.dll\RpcSmFree", "ptr", NodeToFree, "int")
        return result
    }

    /**
     * The RpcSmGetThreadHandle function returns a thread handle, or NULL, for the stub memory�management environment.
     * @remarks
     * Applications call 
     * <b>RpcSmGetThreadHandle</b> to obtain a thread handle for the stub memory–management environment. A thread used to manage memory for the stub memory–management environment uses 
     * <b>RpcSmGetThreadHandle</b> to receive a handle for its memory environment. In this way, another thread that calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a> by using this handle can then use the same memory-management environment.
     * 
     * The same memory management thread handle must be used by multiple threads calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmfree">RpcSmFree</a> in order to manage the same memory. Before spawning new threads to manage the same memory, the thread that established the memory-management environment (parent thread) calls 
     * <b>RpcSmGetThreadHandle</b> to obtain a thread handle for this environment. Then, the spawned threads call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a> with the new manager handle provided by the parent thread.
     * 
     * Typically a server manager procedure calls 
     * <b>RpcSmGetThreadHandle</b> before additional threads are spawned. The stub sets up the memory-management environment for the manager procedure, and the manager calls 
     * <b>RpcSmGetThreadHandle</b> to make this environment available to the other threads.
     * 
     * A thread can also call 
     * <b>RpcSmGetThreadHandle</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle">RpcSmSetThreadHandle</a> to save and restore its memory-management environment.
     * @param {Pointer<Int32>} pStatus Pointer to the returned status.
     * @returns {Pointer<Void>} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle
     * @since windows5.0
     */
    static RpcSmGetThreadHandle(pStatus) {
        result := DllCall("RPCRT4.dll\RpcSmGetThreadHandle", "int*", pStatus, "ptr")
        return result
    }

    /**
     * The RpcSmSetClientAllocFree function enables the memory allocation and release mechanisms used by the client stubs.
     * @remarks
     * By overriding the default routines used by the client stub to manage memory, 
     * <b>RpcSmSetClientAllocFree</b> establishes the memory allocation and memory-freeing mechanisms. Note that the default routines are <a href="https://docs.microsoft.com/windows/desktop/Rpc/pointers-and-memory-allocation">free</a> and <b>malloc</b>, unless the remote call occurs within manager code. In this case, the default memory–management functions are 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmfree">RpcSmFree</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a>.
     * @param {Pointer<RPC_CLIENT_ALLOC>} ClientAlloc Function used to allocate memory.
     * @param {Pointer<RPC_CLIENT_FREE>} ClientFree Function used to release memory and used with the function specified by <i>pfnAllocate</i>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system is out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmsetclientallocfree
     * @since windows5.0
     */
    static RpcSmSetClientAllocFree(ClientAlloc, ClientFree) {
        result := DllCall("RPCRT4.dll\RpcSmSetClientAllocFree", "ptr", ClientAlloc, "ptr", ClientFree, "int")
        return result
    }

    /**
     * The RpcSmSetThreadHandle function sets a thread handle for the stub memory�management environment.
     * @remarks
     * An application calls 
     * <b>RpcSmSetThreadHandle</b> to set a thread handle for the stub memory–management environment. A thread used to manage memory for the stub memory–management environment calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> to obtain a handle for its memory environment. In this way, another thread that calls 
     * <b>RpcSmSetThreadHandle</b> by using this handle can then use the same memory-management environment.
     * 
     * The same memory management–thread handle must be used by multiple threads calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmallocate">RpcSmAllocate</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmfree">RpcSmFree</a> to manage the same memory. Before spawning new threads to manage the same memory, the thread that established the memory-management environment (parent thread) calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> to obtain a thread handle for this environment. Then, the spawned threads call 
     * <b>RpcSmSetThreadHandle</b> with the new manager handle provided by the parent thread.
     * 
     * Note that 
     * <b>RpcSmSetThreadHandle</b> is usually called by a thread spawned by a server-manager procedure. The stub sets up the memory-management environment for the manager procedure, and the manager calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> to obtain a thread handle. Then, each spawned thread calls 
     * <b>RpcSmGetThreadHandle</b> to get access to the manager's memory-management environment.
     * 
     * A thread can also call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a> and 
     * <b>RpcSmSetThreadHandle</b> to save and restore its memory-management environment.
     * @param {Pointer<Void>} Id Thread handle returned by a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/nf-rpcndr-rpcsmgetthreadhandle">RpcSmGetThreadHandle</a>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmsetthreadhandle
     * @since windows5.0
     */
    static RpcSmSetThreadHandle(Id) {
        result := DllCall("RPCRT4.dll\RpcSmSetThreadHandle", "ptr", Id, "int")
        return result
    }

    /**
     * The RpcSmSwapClientAllocFree function exchanges the client stub's memory-allocation and memory-freeing mechanisms with those supplied by the client.
     * @param {Pointer<RPC_CLIENT_ALLOC>} ClientAlloc New memory-allocation function.
     * @param {Pointer<RPC_CLIENT_FREE>} ClientFree New memory-releasing function.
     * @param {Pointer<RPC_CLIENT_ALLOC>} OldClientAlloc Returns the previous memory-allocation function before the call to this function.
     * @param {Pointer<RPC_CLIENT_FREE>} OldClientFree Returns the previous memory-releasing function before the call to this function.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument is invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcsmswapclientallocfree
     * @since windows5.0
     */
    static RpcSmSwapClientAllocFree(ClientAlloc, ClientFree, OldClientAlloc, OldClientFree) {
        result := DllCall("RPCRT4.dll\RpcSmSwapClientAllocFree", "ptr", ClientAlloc, "ptr", ClientFree, "ptr", OldClientAlloc, "ptr", OldClientFree, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pMessage 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrRpcSsEnableAllocate(pMessage) {
        DllCall("RPCRT4.dll\NdrRpcSsEnableAllocate", "ptr", pMessage)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pMessage 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrRpcSsDisableAllocate(pMessage) {
        DllCall("RPCRT4.dll\NdrRpcSsDisableAllocate", "ptr", pMessage)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pMessage 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrRpcSmSetClientToOsf(pMessage) {
        DllCall("RPCRT4.dll\NdrRpcSmSetClientToOsf", "ptr", pMessage)
    }

    /**
     * 
     * @param {Pointer} Size 
     * @returns {Pointer<Void>} 
     */
    static NdrRpcSmClientAllocate(Size) {
        result := DllCall("RPCRT4.dll\NdrRpcSmClientAllocate", "ptr", Size, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} NodeToFree 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrRpcSmClientFree(NodeToFree) {
        DllCall("RPCRT4.dll\NdrRpcSmClientFree", "ptr", NodeToFree)
    }

    /**
     * 
     * @param {Pointer} Size 
     * @returns {Pointer<Void>} 
     */
    static NdrRpcSsDefaultAllocate(Size) {
        result := DllCall("RPCRT4.dll\NdrRpcSsDefaultAllocate", "ptr", Size, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} NodeToFree 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrRpcSsDefaultFree(NodeToFree) {
        DllCall("RPCRT4.dll\NdrRpcSsDefaultFree", "ptr", NodeToFree)
    }

    /**
     * 
     * @param {Integer} NumberOfPointers 
     * @param {Integer} XlatSide 
     * @returns {Pointer<FULL_PTR_XLAT_TABLES>} 
     */
    static NdrFullPointerXlatInit(NumberOfPointers, XlatSide) {
        result := DllCall("RPCRT4.dll\NdrFullPointerXlatInit", "uint", NumberOfPointers, "int", XlatSide, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<FULL_PTR_XLAT_TABLES>} pXlatTables 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrFullPointerXlatFree(pXlatTables) {
        DllCall("RPCRT4.dll\NdrFullPointerXlatFree", "ptr", pXlatTables)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer} Len 
     * @returns {Pointer<Void>} 
     */
    static NdrAllocate(pStubMsg, Len) {
        result := DllCall("RPCRT4.dll\NdrAllocate", "ptr", pStubMsg, "ptr", Len, "ptr")
        return result
    }

    /**
     * The NdrClearOutParameters function frees resources of the out parameter and clears its memory if the RPC call to the server fails.
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg Pointer to <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-midl_stub_message">MIDL_STUB_MESSAGE</a> structure that maintains the current status of the RPC stub. The structure is for internal use only and should not be modified.
     * @param {Pointer<Byte>} pFormat Pointer to the format string description.
     * @param {Pointer<Void>} ArgAddr Pointer to the out parameter to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrclearoutparameters
     * @since windows5.0
     */
    static NdrClearOutParameters(pStubMsg, pFormat, ArgAddr) {
        DllCall("RPCRT4.dll\NdrClearOutParameters", "ptr", pStubMsg, "char*", pFormat, "ptr", ArgAddr)
    }

    /**
     * The NdrOleAllocate function is used by RPC to allocate memory for an object interface. This function is a wrapper for the CoTaskMemAlloc function.
     * @remarks
     * To return a pointer other than a void, use a type cast on the return value. The memory pointed to by the return value is guaranteed to be suitably aligned for the storage of any type of object. If the <i>Size</i> parameter is zero, <b>NdrOleAllocate</b> allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return value from <b>NdrOleAllocate</b>, even if the amount of memory requested is small.
     * @param {Pointer} Size Memory to allocate, in bytes.
     * @returns {Pointer<Void>} Returns a void pointer to the allocated space upon success. Returns null upon failure due to insufficient memory.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndroleallocate
     * @since windows5.0
     */
    static NdrOleAllocate(Size) {
        result := DllCall("RPCRT4.dll\NdrOleAllocate", "ptr", Size, "ptr")
        return result
    }

    /**
     * The NdrOleFree function is a wrapper for the CoTaskMemFree function.
     * @param {Pointer<Void>} NodeToFree Pointer to the memory to be freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrolefree
     * @since windows5.0
     */
    static NdrOleFree(NodeToFree) {
        DllCall("RPCRT4.dll\NdrOleFree", "ptr", NodeToFree)
    }

    /**
     * The NdrGetUserMarshalInfo function provides additional information to wire_marshal and user_marshal helper functions.
     * @remarks
     * The 
     * <b>NdrGetUserMarshalInfo</b> function is called by the <b>wire_marshal</b> or <b>user_marshal</b> helper functions (provided by the application) &lt;<i>type</i>&gt;<b>_UserSize</b>, &lt;<i>type</i>&gt;<b>_UserMarshal</b>, &lt;<i>type</i>&gt;<b>_UserUnmarshal</b>, and &lt;<i>type</i>&gt;<b>_UserFree</b> to receive extra information about the state of the call. A common use for this function is to obtain the size of the marshaling buffer for the purpose of checking for end of buffer conditions. Sending incorrectly sized data is a commonly used method of breaching system security.
     * 
     * For a full listing of the information returned by 
     * <b>NdrGetUserMarshalInfo</b>, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcndr/ns-rpcndr-ndr_user_marshal_info">NDR_USER_MARSHAL_INFO</a>.
     * @param {Pointer<UInt32>} pFlags Pointer by the same name that RPC passed to the helper function.
     * @param {Integer} InformationLevel Desired level of detail to be received. Different levels imply different sets of information fields. Only level 1 is currently defined.
     * @param {Pointer<NDR_USER_MARSHAL_INFO>} pMarshalInfo Address of a memory buffer, supplied by the application, to receive the requested information. The buffer must be at least as large as the information structure indicated by <i>InformationLevel</i>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * At least one of the arguments was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_X_INVALID_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Current marshaling buffer was not valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrgetusermarshalinfo
     * @since windows5.0
     */
    static NdrGetUserMarshalInfo(pFlags, InformationLevel, pMarshalInfo) {
        result := DllCall("RPCRT4.dll\NdrGetUserMarshalInfo", "uint*", pFlags, "uint", InformationLevel, "ptr", pMarshalInfo, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<IRpcStubBuffer>} pStub 
     * @param {Pointer<RPC_SERVER_INTERFACE>} pServerIf 
     * @returns {Integer} 
     */
    static NdrCreateServerInterfaceFromStub(pStub, pServerIf) {
        result := DllCall("RPCRT4.dll\NdrCreateServerInterfaceFromStub", "ptr", pStub, "ptr", pServerIf, "int")
        return result
    }

    /**
     * NdrClientCall3 may be altered or unavailable.
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo Reserved.
     * @param {Integer} nProcNum Reserved.
     * @param {Pointer<Void>} pReturnValue Reserved.
     * @returns {Pointer} Reserved.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrclientcall3
     * @since windows5.0
     */
    static NdrClientCall3(pProxyInfo, nProcNum, pReturnValue) {
        result := DllCall("RPCRT4.dll\NdrClientCall3", "ptr", pProxyInfo, "uint", nProcNum, "ptr", pReturnValue, "CDecl ptr")
        return result
    }

    /**
     * Ndr64AsyncClientCall is not intended to be directly called by applications.
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo Reserved.
     * @param {Integer} nProcNum Reserved.
     * @param {Pointer<Void>} pReturnValue Reserved.
     * @returns {Pointer} Reserved.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndr64asyncclientcall
     * @since windows5.1.2600
     */
    static Ndr64AsyncClientCall(pProxyInfo, nProcNum, pReturnValue) {
        result := DllCall("RPCRT4.dll\Ndr64AsyncClientCall", "ptr", pProxyInfo, "uint", nProcNum, "ptr", pReturnValue, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Integer} nProcNum 
     * @param {Pointer<Void>} pReturnValue 
     * @returns {Pointer} 
     */
    static Ndr64DcomAsyncClientCall(pProxyInfo, nProcNum, pReturnValue) {
        result := DllCall("RPCRT4.dll\Ndr64DcomAsyncClientCall", "ptr", pProxyInfo, "uint", nProcNum, "ptr", pReturnValue, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @returns {String} Nothing - always returns an empty string
     */
    static Ndr64AsyncServerCall64(pRpcMsg) {
        DllCall("RPCRT4.dll\Ndr64AsyncServerCall64", "ptr", pRpcMsg)
    }

    /**
     * Ndr64AsyncServerCallAll is not intended to be directly called by applications.
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg Reserved.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndr64asyncservercallall
     * @since windows5.1.2600
     */
    static Ndr64AsyncServerCallAll(pRpcMsg) {
        DllCall("RPCRT4.dll\Ndr64AsyncServerCallAll", "ptr", pRpcMsg)
    }

    /**
     * 
     * @param {Pointer<IRpcStubBuffer>} pThis 
     * @param {Pointer<IRpcChannelBuffer>} pChannel 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @param {Pointer<UInt32>} pdwStubPhase 
     * @returns {Integer} 
     */
    static Ndr64DcomAsyncStubCall(pThis, pChannel, pRpcMsg, pdwStubPhase) {
        result := DllCall("RPCRT4.dll\Ndr64DcomAsyncStubCall", "ptr", pThis, "ptr", pChannel, "ptr", pRpcMsg, "uint*", pdwStubPhase, "int")
        return result
    }

    /**
     * NdrStubCall3 is not intended to be directly called by applications.
     * @param {Pointer<Void>} pThis Reserved.
     * @param {Pointer<Void>} pChannel Reserved.
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg Reserved.
     * @param {Pointer<UInt32>} pdwStubPhase Reserved.
     * @returns {Integer} Reserved.
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrstubcall3
     * @since windows5.1.2600
     */
    static NdrStubCall3(pThis, pChannel, pRpcMsg, pdwStubPhase) {
        result := DllCall("RPCRT4.dll\NdrStubCall3", "ptr", pThis, "ptr", pChannel, "ptr", pRpcMsg, "uint*", pdwStubPhase, "int")
        return result
    }

    /**
     * NdrServerCallAll is not intended to be directly called by applications.
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg Reserved.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-ndrservercallall
     * @since windows5.1.2600
     */
    static NdrServerCallAll(pRpcMsg) {
        DllCall("RPCRT4.dll\NdrServerCallAll", "ptr", pRpcMsg)
    }

    /**
     * 
     * @param {Pointer<RPC_MESSAGE>} pRpcMsg 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrServerCallNdr64(pRpcMsg) {
        DllCall("RPCRT4.dll\NdrServerCallNdr64", "ptr", pRpcMsg)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Void>} pMemory 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrPartialIgnoreClientMarshall(pStubMsg, pMemory) {
        DllCall("RPCRT4.dll\NdrPartialIgnoreClientMarshall", "ptr", pStubMsg, "ptr", pMemory)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Void>} ppMemory 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrPartialIgnoreServerUnmarshall(pStubMsg, ppMemory) {
        DllCall("RPCRT4.dll\NdrPartialIgnoreServerUnmarshall", "ptr", pStubMsg, "ptr", ppMemory)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Void>} pMemory 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrPartialIgnoreClientBufferSize(pStubMsg, pMemory) {
        DllCall("RPCRT4.dll\NdrPartialIgnoreClientBufferSize", "ptr", pStubMsg, "ptr", pMemory)
    }

    /**
     * 
     * @param {Pointer<MIDL_STUB_MESSAGE>} pStubMsg 
     * @param {Pointer<Void>} ppMemory 
     * @param {Pointer<Byte>} pFormat 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrPartialIgnoreServerInitialize(pStubMsg, ppMemory, pFormat) {
        DllCall("RPCRT4.dll\NdrPartialIgnoreServerInitialize", "ptr", pStubMsg, "ptr", ppMemory, "char*", pFormat)
    }

    /**
     * RpcUserFree may be altered or unavailable.
     * @param {Pointer<Void>} AsyncHandle Reserved.
     * @param {Pointer<Void>} pBuffer Reserved.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/rpcndr/nf-rpcndr-rpcuserfree
     * @since windows5.1.2600
     */
    static RpcUserFree(AsyncHandle, pBuffer) {
        DllCall("RPCRT4.dll\RpcUserFree", "ptr", AsyncHandle, "ptr", pBuffer)
    }

    /**
     * The MesEncodeIncrementalHandleCreate function creates an encoding and then initializes it for the incremental style of serialization.
     * @remarks
     * The 
     * <b>MesEncodeIncrementalHandleCreate</b> function is used by applications to create and initialize the handle for the incremental style of encoding or decoding. When using the incremental style of encoding, the user supplies an <b>Alloc</b> function to provide an empty buffer into which the encoded data is placed, and a <b>Write</b> function to call when the buffer is full or the encoding is complete. For additional information on the user-supplied <b>Alloc</b>, <b>Write</b>, and <b>Read</b> functions, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/serialization-services">Serialization Services</a>.
     * 
     * When a stub is compiled using <b>-protocol all</b> or <b>-protocol ndr64</b> and the buffer is to be encoded using the NDR64 transfer syntax, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/midles/nf-midles-mesbufferhandlereset">MesIncrementalHandleReset</a> function must be called with its <i>OpCode</i> parameter set to MES_ENCODE_NDR64.
     * @param {Pointer<Void>} UserState Pointer to the user-supplied state object that coordinates the user-supplied <b>Alloc</b>, <b>Write</b>, and <b>Read</b> functions.
     * @param {Pointer<MIDL_ES_ALLOC>} AllocFn Pointer to the user-supplied <b>Alloc</b> function.
     * @param {Pointer<MIDL_ES_WRITE>} WriteFn Pointer to the user-supplied <b>Write</b> function.
     * @param {Pointer<Void>} pHandle Pointer to the newly created handle.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesencodeincrementalhandlecreate
     * @since windows5.0
     */
    static MesEncodeIncrementalHandleCreate(UserState, AllocFn, WriteFn, pHandle) {
        result := DllCall("RPCRT4.dll\MesEncodeIncrementalHandleCreate", "ptr", UserState, "ptr", AllocFn, "ptr", WriteFn, "ptr", pHandle, "int")
        return result
    }

    /**
     * The MesDecodeIncrementalHandleCreate function creates a decoding handle for the incremental style of serialization.
     * @remarks
     * The 
     * <b>MesDecodeIncrementalHandleCreate</b> function is used by applications to create the handle and initialize it for the incremental style of decoding. When using the incremental style of decoding, the user supplies a <b>Read</b> function to provide a buffer containing the next part of the data to be decoded. The buffer must be aligned at 8, and the size of the buffer must be a multiple of 8. For additional information on the user-supplied <b>Alloc</b>, <b>Write</b>, and <b>Read</b> functions, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/serialization-services">Serialization Services</a>.
     * @param {Pointer<Void>} UserState Pointer to the user-supplied state object that coordinates the user-supplied <b>Alloc</b>, <b>Write</b>, and <b>Read</b> functions.
     * @param {Pointer<MIDL_ES_READ>} ReadFn Pointer to the <b>Read</b> function.
     * @param {Pointer<Void>} pHandle Pointer to the newly created handle.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesdecodeincrementalhandlecreate
     * @since windows5.0
     */
    static MesDecodeIncrementalHandleCreate(UserState, ReadFn, pHandle) {
        result := DllCall("RPCRT4.dll\MesDecodeIncrementalHandleCreate", "ptr", UserState, "ptr", ReadFn, "ptr", pHandle, "int")
        return result
    }

    /**
     * The MesIncrementalHandleReset function re-initializes the handle for incremental serialization.
     * @remarks
     * The 
     * <b>MesIncrementalHandleReset</b> routine is used by applications to re-initialize the handle for the incremental style of encoding or decoding. For additional information on the user-supplied <b>Alloc</b>, <b>Write</b>, and <b>Read</b> functions, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/serialization-services">Serialization Services</a>.
     * @param {Pointer<Void>} Handle Handle to be re-initialized.
     * @param {Pointer<Void>} UserState Depending on the function, pointer to the user-supplied block that coordinates successive calls to the user-supplied <b>Alloc</b>, <b>Write</b>, and <b>Read</b> functions.
     * @param {Pointer<MIDL_ES_ALLOC>} AllocFn Pointer to the user-supplied <b>Alloc</b> function. This parameter can be <b>NULL</b> if the operation does not require it, or if the handle was previously initiated with the pointer.
     * @param {Pointer<MIDL_ES_WRITE>} WriteFn Pointer to the user-supplied <b>Write</b> function. This parameter can be <b>NULL</b> if the operation does not require it, or if the handle was previously initiated with the pointer.
     * @param {Pointer<MIDL_ES_READ>} ReadFn Pointer to the user-supplied <b>Read</b> function. This parameter can be <b>NULL</b> if the operation does not require it, or if the handle was previously initiated with the pointer.
     * @param {Integer} Operation Specifies the operation. Valid operations are <b>MES_ENCODE</b>, <b>MES_ENCODE_NDR64</b>, or <b>MES_DECODE</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesincrementalhandlereset
     * @since windows5.0
     */
    static MesIncrementalHandleReset(Handle, UserState, AllocFn, WriteFn, ReadFn, Operation) {
        result := DllCall("RPCRT4.dll\MesIncrementalHandleReset", "ptr", Handle, "ptr", UserState, "ptr", AllocFn, "ptr", WriteFn, "ptr", ReadFn, "int", Operation, "int")
        return result
    }

    /**
     * The MesEncodeFixedBufferHandleCreate function creates an encoding handle and then initializes it for a fixed buffer style of serialization.
     * @remarks
     * The 
     * <b>MesEncodeFixedBufferHandleCreate</b> routine is used by applications to create and initialize the handle for the fixed buffer style of encoding. When using the fixed buffer style of encoding, the user supplies a single buffer into which all the encoded data is placed. This buffer must have an address which is aligned at 8, and must be a multiple of 8 bytes in size. Further, it must be large enough to hold an encoding of all the data, along with an encoding header for each routine being encoded.
     * 
     * When the handle is used for multiple encoding operations, the encoded size is cumulative.
     * 
     * When a stub is compiled using <b>-protocol all</b> or <b>-protocol ndr64</b> and the buffer is to be encoded using the NDR64 transfer syntax, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/midles/nf-midles-mesbufferhandlereset">MesBufferHandleReset</a> function must be called with its <i>OpCode</i> parameter set to MES_ENCODE_NDR64.
     * @param {Pointer} pBuffer Pointer to the user-supplied buffer.
     * @param {Integer} BufferSize Size of the user-supplied buffer, in bytes.
     * @param {Pointer<UInt32>} pEncodedSize Pointer to the size of the completed encoding. The size will be written to the pointee by the subsequent encoding operation(s).
     * @param {Pointer<Void>} pHandle Pointer to the newly created handle.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesencodefixedbufferhandlecreate
     * @since windows5.0
     */
    static MesEncodeFixedBufferHandleCreate(pBuffer, BufferSize, pEncodedSize, pHandle) {
        result := DllCall("RPCRT4.dll\MesEncodeFixedBufferHandleCreate", "ptr", pBuffer, "uint", BufferSize, "uint*", pEncodedSize, "ptr", pHandle, "int")
        return result
    }

    /**
     * The MesEncodeDynBufferHandleCreate function creates an encoding handle and then initializes it for a dynamic buffer style of serialization.
     * @remarks
     * The 
     * <b>MesEncodeDynBufferHandleCreate</b> routine is used by applications to allocate the memory and initialize the handle for the dynamic buffer style of encoding. When using the dynamic buffer style of encoding, the buffer into which all the encoded data will be placed is supplied by the stub. This buffer will be allocated by the current client memory-management mechanism.
     * 
     * There can be performance implications when using this style for multiple encodings with the same handle. A single buffer is returned from an encoding and data is copied from intermediate buffers. The buffers are released when necessary.
     * 
     * When a stub is compiled using -protocol all or -protocol ndr64 and the buffer is to be encoded using the NDR64 transfer syntax, the 
     * MesBufferHandleReset function must be called with its <i>OpCode</i> parameter set to MES_ENCODE_NDR64.
     * @param {Pointer<SByte>} pBuffer Pointer to a pointer to the stub-supplied buffer containing the encoding after serialization is complete.
     * @param {Pointer<UInt32>} pEncodedSize Pointer to the size of the completed encoding. The size will be written to the memory location pointed to by <i>pEncodedSize</i> by subsequent encoding operations.
     * @param {Pointer<Void>} pHandle Pointer to the address to which the handle will be written.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesencodedynbufferhandlecreate
     * @since windows5.0
     */
    static MesEncodeDynBufferHandleCreate(pBuffer, pEncodedSize, pHandle) {
        result := DllCall("RPCRT4.dll\MesEncodeDynBufferHandleCreate", "ptr", pBuffer, "uint*", pEncodedSize, "ptr", pHandle, "int")
        return result
    }

    /**
     * The MesDecodeBufferHandleCreate function creates a decoding handle and initializes it for a (fixed) buffer style of serialization.
     * @remarks
     * The 
     * <b>MesDecodeBufferHandleCreate</b> routine is used by applications to create a serialization handle and initialize the handle for the (fixed) buffer style of decoding. When using the fixed buffer style of decoding, the user supplies a single buffer containing all the encoded data. This buffer must have an address which is aligned at 8, and must be a multiple of 8 bytes in size. Further, it must be large enough to hold all of the data to decode.
     * @param {Pointer} Buffer Pointer to the buffer containing the data to decode.
     * @param {Integer} BufferSize Bytes of data to decode in the buffer.
     * @param {Pointer<Void>} pHandle Pointer to the address to which the handle will be written.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_X_INVALID_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer was not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesdecodebufferhandlecreate
     * @since windows5.0
     */
    static MesDecodeBufferHandleCreate(Buffer, BufferSize, pHandle) {
        result := DllCall("RPCRT4.dll\MesDecodeBufferHandleCreate", "ptr", Buffer, "uint", BufferSize, "ptr", pHandle, "int")
        return result
    }

    /**
     * The MesBufferHandleReset function re-initializes the handle for buffer serialization.
     * @remarks
     * The 
     * <b>MesBufferHandleReset</b> routine is used by applications to re-initialize a buffer style handle and save memory allocations.
     * @param {Pointer<Void>} Handle Handle to be initialized.
     * @param {Integer} HandleStyle Style of <i>Handle</i>. Valid styles are <b>MES_FIXED_BUFFER_HANDLE</b> or <b>MES_DYNAMIC_BUFFER_HANDLE</b>.
     * @param {Integer} Operation Operation code. Valid codes are <b>MES_ENCODE</b>, <b>MES_ENCODE_NDR64</b>, or <b>MES_DECODE</b>.
     * @param {Pointer} pBuffer For <b>MES_DECODE</b>, pointer to a pointer to the buffer containing the data to be decoded. 
     * 
     * 
     * 
     * 
     * For <b>MES_ENCODE</b>, pointer to a pointer to the buffer for 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/fixed-buffer-serialization">fixed buffer style</a>, and pointer to a pointer to return the buffer address for 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/dynamic-buffer-serialization">dynamic buffer style of serialization</a>.
     * 
     * For <b>MES_ENCODE_NDR64</b>, pointer to a pointer to the buffer for fixed buffer style, and pointer to a pointer to return the buffer address for dynamic buffer style of serialization, but explicitly uses NDR64 to encode the buffer. The user-provided buffer must be aligned to 16.
     * @param {Integer} BufferSize Bytes of data to be decoded in the buffer. Note that this is used only for the fixed buffer style of serialization.
     * @param {Pointer<UInt32>} pEncodedSize Pointer to the size of the completed encoding. Note that this is used only when the operation is <b>MES_ENCODE</b> or <b>MES_ENCODE_NDR64</b>.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was invalid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesbufferhandlereset
     * @since windows5.0
     */
    static MesBufferHandleReset(Handle, HandleStyle, Operation, pBuffer, BufferSize, pEncodedSize) {
        result := DllCall("RPCRT4.dll\MesBufferHandleReset", "ptr", Handle, "uint", HandleStyle, "int", Operation, "ptr", pBuffer, "uint", BufferSize, "uint*", pEncodedSize, "int")
        return result
    }

    /**
     * The MesHandleFree function frees the memory allocated by the serialization handle.
     * @remarks
     * The 
     * <b>MesHandleFree</b> routine is used by applications to free the resources of the handle after encoding or decoding data.
     * @param {Pointer<Void>} Handle Handle to be freed.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-meshandlefree
     * @since windows5.0
     */
    static MesHandleFree(Handle) {
        result := DllCall("RPCRT4.dll\MesHandleFree", "ptr", Handle, "int")
        return result
    }

    /**
     * The MesInqProcEncodingId function provides the identity of an encoding.
     * @remarks
     * The 
     * <b>MesInqProcEncodingId</b> function is used by applications to obtain the identity of the function used to encode the data before calling a function to decode it. When called with an encoding handle, it returns the identity of the last encoding operation. When called with a decoding handle, it returns the identity of the next decoding operation by pre-reading the buffer.
     * 
     * This function can only be used to check the identity of a procedure encoding; it cannot be used to check the identity for a type encoding.
     * @param {Pointer<Void>} Handle An encoding or decoding handle.
     * @param {Pointer<RPC_SYNTAX_IDENTIFIER>} pInterfaceId Pointer to the address in which the identity of the interface used to encode the data will be written. The <i>pInterfaceId</i> consists of the interface universally unique identifier 
     * <a href="https://docs.microsoft.com/windows/win32/rpc/rpcdce/ns-rpcdce-uuid">UUID</a> and the version number.
     * @param {Pointer<UInt32>} pProcNum Number of the function used to encode the data.
     * @returns {Integer} <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The call succeeded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_INVALID_ARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The argument was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_OUT_OF_MEMORY</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Out of memory.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNKNOWN_IF</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Unknown interface.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_S_UNSUPPORTED_TRANS_SYN</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Transfer syntax not supported by server.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_X_INVALID_ES_ACTION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Operation for a given handle was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_X_WRONG_ES_VERSION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Incompatible version of the serializing package.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>RPC_X_SS_INVALID_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Buffer not valid.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  For a list of valid error codes, see 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/rpc-return-values">RPC Return Values</a>.</div>
     * <div> </div>
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-mesinqprocencodingid
     * @since windows5.0
     */
    static MesInqProcEncodingId(Handle, pInterfaceId, pProcNum) {
        result := DllCall("RPCRT4.dll\MesInqProcEncodingId", "ptr", Handle, "ptr", pInterfaceId, "uint*", pProcNum, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} param0 
     * @returns {Pointer} 
     */
    static NdrMesSimpleTypeAlignSize(param0) {
        result := DllCall("RPCRT4.dll\NdrMesSimpleTypeAlignSize", "ptr", param0, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<Void>} pObject 
     * @param {Integer} Size 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesSimpleTypeDecode(Handle, pObject, Size) {
        DllCall("RPCRT4.dll\NdrMesSimpleTypeDecode", "ptr", Handle, "ptr", pObject, "short", Size)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Void>} pObject 
     * @param {Integer} Size 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesSimpleTypeEncode(Handle, pStubDesc, pObject, Size) {
        DllCall("RPCRT4.dll\NdrMesSimpleTypeEncode", "ptr", Handle, "ptr", pStubDesc, "ptr", pObject, "short", Size)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @param {Pointer<Void>} pObject 
     * @returns {Pointer} 
     */
    static NdrMesTypeAlignSize(Handle, pStubDesc, pFormatString, pObject) {
        result := DllCall("RPCRT4.dll\NdrMesTypeAlignSize", "ptr", Handle, "ptr", pStubDesc, "char*", pFormatString, "ptr", pObject, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeEncode(Handle, pStubDesc, pFormatString, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeEncode", "ptr", Handle, "ptr", pStubDesc, "char*", pFormatString, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeDecode(Handle, pStubDesc, pFormatString, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeDecode", "ptr", Handle, "ptr", pStubDesc, "char*", pFormatString, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @param {Pointer<Void>} pObject 
     * @returns {Pointer} 
     */
    static NdrMesTypeAlignSize2(Handle, pPicklingInfo, pStubDesc, pFormatString, pObject) {
        result := DllCall("RPCRT4.dll\NdrMesTypeAlignSize2", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pStubDesc, "char*", pFormatString, "ptr", pObject, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeEncode2(Handle, pPicklingInfo, pStubDesc, pFormatString, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeEncode2", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pStubDesc, "char*", pFormatString, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeDecode2(Handle, pPicklingInfo, pStubDesc, pFormatString, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeDecode2", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pStubDesc, "char*", pFormatString, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeFree2(Handle, pPicklingInfo, pStubDesc, pFormatString, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeFree2", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pStubDesc, "char*", pFormatString, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc 
     * @param {Pointer<Byte>} pFormatString 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesProcEncodeDecode(Handle, pStubDesc, pFormatString) {
        DllCall("RPCRT4.dll\NdrMesProcEncodeDecode", "ptr", Handle, "ptr", pStubDesc, "char*", pFormatString, "CDecl ")
    }

    /**
     * NdrMesProcEncodeDecode2 may be altered or unavailable.
     * @param {Pointer<Void>} Handle Reserved.
     * @param {Pointer<MIDL_STUB_DESC>} pStubDesc Reserved.
     * @param {Pointer<Byte>} pFormatString Reserved.
     * @returns {Pointer} Reserved.
     * @see https://learn.microsoft.com/windows/win32/api/midles/nf-midles-ndrmesprocencodedecode2
     * @since windows5.0
     */
    static NdrMesProcEncodeDecode2(Handle, pStubDesc, pFormatString) {
        result := DllCall("RPCRT4.dll\NdrMesProcEncodeDecode2", "ptr", Handle, "ptr", pStubDesc, "char*", pFormatString, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Pointer<UInt32>} ArrTypeOffset 
     * @param {Integer} nTypeIndex 
     * @param {Pointer<Void>} pObject 
     * @returns {Pointer} 
     */
    static NdrMesTypeAlignSize3(Handle, pPicklingInfo, pProxyInfo, ArrTypeOffset, nTypeIndex, pObject) {
        result := DllCall("RPCRT4.dll\NdrMesTypeAlignSize3", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pProxyInfo, "ptr", ArrTypeOffset, "uint", nTypeIndex, "ptr", pObject, "ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Pointer<UInt32>} ArrTypeOffset 
     * @param {Integer} nTypeIndex 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeEncode3(Handle, pPicklingInfo, pProxyInfo, ArrTypeOffset, nTypeIndex, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeEncode3", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pProxyInfo, "ptr", ArrTypeOffset, "uint", nTypeIndex, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Pointer<UInt32>} ArrTypeOffset 
     * @param {Integer} nTypeIndex 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeDecode3(Handle, pPicklingInfo, pProxyInfo, ArrTypeOffset, nTypeIndex, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeDecode3", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pProxyInfo, "ptr", ArrTypeOffset, "uint", nTypeIndex, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_TYPE_PICKLING_INFO>} pPicklingInfo 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Pointer<UInt32>} ArrTypeOffset 
     * @param {Integer} nTypeIndex 
     * @param {Pointer<Void>} pObject 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesTypeFree3(Handle, pPicklingInfo, pProxyInfo, ArrTypeOffset, nTypeIndex, pObject) {
        DllCall("RPCRT4.dll\NdrMesTypeFree3", "ptr", Handle, "ptr", pPicklingInfo, "ptr", pProxyInfo, "ptr", ArrTypeOffset, "uint", nTypeIndex, "ptr", pObject)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Integer} nProcNum 
     * @param {Pointer<Void>} pReturnValue 
     * @returns {Pointer} 
     */
    static NdrMesProcEncodeDecode3(Handle, pProxyInfo, nProcNum, pReturnValue) {
        result := DllCall("RPCRT4.dll\NdrMesProcEncodeDecode3", "ptr", Handle, "ptr", pProxyInfo, "uint", nProcNum, "ptr", pReturnValue, "CDecl ptr")
        return result
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Pointer<Void>} pObject 
     * @param {Integer} Size 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesSimpleTypeDecodeAll(Handle, pProxyInfo, pObject, Size) {
        DllCall("RPCRT4.dll\NdrMesSimpleTypeDecodeAll", "ptr", Handle, "ptr", pProxyInfo, "ptr", pObject, "short", Size)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @param {Pointer<Void>} pObject 
     * @param {Integer} Size 
     * @returns {String} Nothing - always returns an empty string
     */
    static NdrMesSimpleTypeEncodeAll(Handle, pProxyInfo, pObject, Size) {
        DllCall("RPCRT4.dll\NdrMesSimpleTypeEncodeAll", "ptr", Handle, "ptr", pProxyInfo, "ptr", pObject, "short", Size)
    }

    /**
     * 
     * @param {Pointer<Void>} Handle 
     * @param {Pointer<MIDL_STUBLESS_PROXY_INFO>} pProxyInfo 
     * @returns {Pointer} 
     */
    static NdrMesSimpleTypeAlignSizeAll(Handle, pProxyInfo) {
        result := DllCall("RPCRT4.dll\NdrMesSimpleTypeAlignSizeAll", "ptr", Handle, "ptr", pProxyInfo, "ptr")
        return result
    }

    /**
     * The RpcCertGeneratePrincipalNameW (Unicode) function (rpcssl.h) is used by server programs to generate principal names for security certificates.
     * @remarks
     * By default, the principal name that the 
     * <b>RpcCertGeneratePrincipalName</b> function passes back is in msstd format. To generate a name in fullsic format, pass RPC_C_FULL_CERT_CHAIN as the value for the <i>Flags</i> parameter.
     * 
     * Your application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> to release the memory for the string which contains the principal name.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcssl.h header defines RpcCertGeneratePrincipalName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CERT_CONTEXT>} Context Pointer to the security-certificate context.
     * @param {Integer} Flags Currently, the only valid flag for this parameter is RPC_C_FULL_CERT_CHAIN. Using this flag causes the principal name to be generated in fullsic format.
     * @param {Pointer<Char>} pBuffer Pointer to a pointer. The 
     * <b>RpcCertGeneratePrincipalName</b> function sets this to point at a null-terminated string that contains the 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">principal name</a>.
     * @returns {Integer} This function does not return a value.
     * @see https://learn.microsoft.com/windows/win32/api/rpcssl/nf-rpcssl-rpccertgenerateprincipalnamew
     * @since windows5.0
     */
    static RpcCertGeneratePrincipalNameW(Context, Flags, pBuffer) {
        result := DllCall("RPCRT4.dll\RpcCertGeneratePrincipalNameW", "ptr", Context, "uint", Flags, "ptr", pBuffer, "int")
        return result
    }

    /**
     * Server programs use the RpcCertGeneratePrincipalName function to generate principal names for security certificates. (RpcCertGeneratePrincipalNameA)
     * @remarks
     * By default, the principal name that the 
     * <b>RpcCertGeneratePrincipalName</b> function passes back is in msstd format. To generate a name in fullsic format, pass RPC_C_FULL_CERT_CHAIN as the value for the <i>Flags</i> parameter.
     * 
     * Your application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/rpcdce/nf-rpcdce-rpcstringfree">RpcStringFree</a> to release the memory for the string which contains the principal name.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The rpcssl.h header defines RpcCertGeneratePrincipalName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<CERT_CONTEXT>} Context Pointer to the security-certificate context.
     * @param {Integer} Flags Currently, the only valid flag for this parameter is RPC_C_FULL_CERT_CHAIN. Using this flag causes the principal name to be generated in fullsic format.
     * @param {Pointer<Byte>} pBuffer Pointer to a pointer. The 
     * <b>RpcCertGeneratePrincipalName</b> function sets this to point at a null-terminated string that contains the 
     * <a href="https://docs.microsoft.com/windows/desktop/Rpc/principal-names">principal name</a>.
     * @returns {Integer} This function does not return a value.
     * @see https://learn.microsoft.com/windows/win32/api/rpcssl/nf-rpcssl-rpccertgenerateprincipalnamea
     * @since windows5.0
     */
    static RpcCertGeneratePrincipalNameA(Context, Flags, pBuffer) {
        result := DllCall("RPCRT4.dll\RpcCertGeneratePrincipalNameA", "ptr", Context, "uint", Flags, "ptr", pBuffer, "int")
        return result
    }

;@endregion Methods
}
