#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\..\Win32ComInterface.ahk
#Include ..\..\..\..\Guid.ahk
#Include .\IEnumOleUndoUnits.ahk
#Include ..\..\Foundation\BSTR.ahk
#Include ..\Com\IUnknown.ahk

/**
 * The IOleUndoManager interface enables containers to implement multi-level undo and redo operations for actions that occur within contained controls.
 * @remarks
 * 
 * The control must create an undo unit with the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleundounit">IOleUndoUnit</a> interface or a parent undo unit with the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleparentundounit">IOleParentUndoUnit</a> interface derived from <b>IOleUndoUnit</b>. Both of these interfaces perform the undo action and the parent undo unit additionally can contain nested undo units.
 * 
 * The undo manager provides a centralized undo and redo service. It manages parent undo units and simple undo units on the undo and redo stacks. Whether an object is UI-active or not, it can deposit undo units on these stacks by calling methods in the undo manager.
 * 
 * The centralized undo manager then has the data necessary to support the undo and redo user interface for the host application and can discard undo information gradually as the stack becomes full.
 * 
 * The undo manager is implemented as a service and objects obtain a pointer to <b>IOleUndoManger</b> from the <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678965(v=vs.85)">IServiceProvider</a> interface. It is usually implemented by the container. The service manages two stacks, the undo stack and the redo stack, each of which contains undo units generated by embedded objects or by the container application itself.
 * 
 * Undo units are typically generated in response to actions taken by the end user. An object does not generate undo actions for programmatic events. In fact, programmatic events should clear the undo stack since the programmatic event can possibly invalidate assumptions made by the undo units on the stack.
 * 
 * When the object's state changes, it creates an undo unit encapsulating all the information needed to undo that change. The object calls methods in the undo manager to place its undo units on the stack. Then, when the end user selects an Undo operation, the undo manager takes the top undo unit off the stack, invokes its action by calling its <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-ioleundounit-do">IOleUndoUnit::Do</a> method, and then releases it. When an end user selects a Redo operation, the undo manager takes the top redo unit off the stack, invokes its action by calling its <b>IOleUndoUnit::Do</b> method, and then releases it.
 * 
 * The undo manager has three states: the base state, the undo state, and the redo state. It begins in the base state. To perform an action from the undo stack, it puts itself into the undo state, calls <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-ioleundounit-do">IOleUndoUnit::Do</a> on the undo unit, and goes back to the base state. To perform an action from the redo stack, it puts itself into the redo state, calls <b>IOleUndoUnit::Do</b> on the undo unit, and goes back to the base state.
 * 
 * If the undo manager receives a new undo unit while in the base state, it places the unit on the undo stack and discards the entire redo stack. While it is in the undo state, it puts incoming units on the redo stack. While it is in the redo state, it places them on the undo stack without flushing the redo stack.
 * 
 * The undo manager also allows objects to discard the undo or redo stack starting from any object in either stack.
 * 
 * The host application determines the scope of an undo manager. For example, in one application, the scope might be at the document level; a separate undo manager is maintained for each document; and undo is managed independently for each document. However, another application maintain one undo manager, and therefore one undo scope, for the entire application.
 * 
 * 
 * 
 * @see https://docs.microsoft.com/windows/win32/api//ocidl/nn-ocidl-ioleundomanager
 * @namespace Windows.Win32.System.Ole
 * @version v4.0.30319
 */
class IOleUndoManager extends IUnknown{

    static sizeof => A_PtrSize
    /**
     * The interface identifier for IOleUndoManager
     * @type {Guid}
     */
    static IID => Guid("{d001f200-ef97-11ce-9bc9-00aa00608e01}")

    /**
     * The offset into the COM object's virtual function table at which this interface's methods begin.
     * @type {Integer}
     */
    static vTableOffset => 3

    /**
     * @readonly used when implementing interfaces to order function pointers
     * @type {Array<String>}
     */
    static VTableNames => ["Open", "Close", "Add", "GetOpenParentState", "DiscardFrom", "UndoTo", "RedoTo", "EnumUndoable", "EnumRedoable", "GetLastUndoDescription", "GetLastRedoDescription", "Enable"]

    /**
     * Opens a new parent undo unit, which becomes part of its containing unit's undo stack.
     * @param {IOleParentUndoUnit} pPUU An <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleparentundounit">IOleParentUndoUnit</a> pointer to the parent undo unit to be opened.
     * @returns {HRESULT} This method returns S_OK if the parent undo unit was successfully opened or if a currently open unit is blocked. If the undo manager is currently disabled, it will return S_OK and do nothing else.
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-open
     */
    Open(pPUU) {
        result := ComCall(3, this, "ptr", pPUU, "HRESULT")
        return result
    }

    /**
     * Closes the specified parent undo unit.
     * @param {IOleParentUndoUnit} pPUU A pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleparentundounit">IOleParentUndoUnit</a> interface for the currently open parent unit to be closed.
     * @param {BOOL} fCommit Indicates whether to keep or discard the unit. If <b>TRUE</b>, the unit is kept in the collection. If <b>FALSE</b>, the unit is discarded. This parameter is used to allow the client to discard an undo unit under construction if an error or a cancellation occurs.
     * @returns {HRESULT} This method returns S_OK if the undo manager had an open parent undo unit and it was successfully closed. If the undo manager is disabled, it should immediately return S_OK and do nothing else. Other possible return values include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>S_FALSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The parent undo unit did not have an open child and it was successfully closed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If <i>pPUU</i> does not match the currently open parent undo unit, then implementations of this method should return E_INVALIDARG without changing any internal state unless the parent unit is blocked.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-close
     */
    Close(pPUU, fCommit) {
        result := ComCall(4, this, "ptr", pPUU, "int", fCommit, "int")
        return result
    }

    /**
     * Adds a simple undo unit to the collection. While a parent undo unit is open, the undo manager adds undo units to it by calling IOleParentUndoUnit::Add.
     * @param {IOleUndoUnit} pUU An <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleundounit">IOleUndoUnit</a> pointer to the undo unit to be added.
     * @returns {HRESULT} This method returns S_OK if the specified unit was successfully added, the parent unit was blocked, or the undo manager is disabled.
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-add
     */
    Add(pUU) {
        result := ComCall(5, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * Retrieves state information about the innermost open parent undo unit.
     * @returns {Integer} A pointer to a variable that receives the state information. This information is a value taken from the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/ne-ocidl-uasflags">UASFLAGS</a> enumeration.
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-getopenparentstate
     */
    GetOpenParentState() {
        result := ComCall(6, this, "uint*", &pdwState := 0, "HRESULT")
        return pdwState
    }

    /**
     * Instructs the undo manager to discard the specified undo unit and all undo units below it on the undo or redo stack.
     * @param {IOleUndoUnit} pUU An <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleundounit">IOleUndoUnit</a> pointer to the undo unit to be discarded. This parameter can be <b>NULL</b> to discard the entire undo or redo stack. If the parameter is not <b>NULL</b> then the stack will not be discarded.
     * @returns {HRESULT} This method returns S_OK on success. Other possible return values include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified undo unit was not found in the stacks.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_UNEXPECTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The undo manager is disabled.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-discardfrom
     */
    DiscardFrom(pUU) {
        result := ComCall(7, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * Instructs the undo manager to invoke undo actions back through the undo stack, down to and including the specified undo unit.
     * @param {IOleUndoUnit} pUU Pointer to the top level unit to undo. If this parameter is <b>NULL</b>, the most recently added top level unit is used.
     * @returns {HRESULT} This method returns S_OK on success. Other possible return values include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified undo unit is not on the undo stack.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ABORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Both the undo attempt and the rollback attempt failed. The undo manager should never propagate the E_ABORT obtained from a contained undo unit. Instead, it should map any E_ABORT values returned from other undo units to E_FAIL. The undo manager should map any E_ABORT value returned from other undo units to E_FAIL because the caller of <a href="/windows/desktop/api/ocidl/nf-ocidl-ioleundomanager-undoto">IOleUndoManager::UndoTo</a> knows that the undo attempt and the rollback attempt failed and this is the only reason for the return value of E_ABORT. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_UNEXPECTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The undo manager is disabled.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-undoto
     */
    UndoTo(pUU) {
        result := ComCall(8, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * Instructs the undo manager to invoke undo actions back through the redo stack, down to and including the specified undo unit.
     * @param {IOleUndoUnit} pUU An <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleundounit">IOleUndoUnit</a> pointer to the top level unit to redo. If this parameter is <b>NULL</b>, the most recently added top level unit is used.
     * @returns {HRESULT} This method returns S_OK on success. Other possible return values include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_INVALIDARG</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified undo unit is not on the redo stack.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_ABORT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Both the undo attempt and the rollback attempt failed. The undo manager should never propagate the E_ABORT obtained from a contained undo unit. Instead, it should map any E_ABORT values returned from other undo units to E_FAIL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_UNEXPECTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The undo manager is disabled.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-redoto
     */
    RedoTo(pUU) {
        result := ComCall(9, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * Creates an enumerator object that the caller can use to iterate through a series of top-level undo units from the undo stack.
     * @returns {IEnumOleUndoUnits} Address of <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ienumoleundounits">IEnumOleUndoUnits</a> pointer variable that receives the interface pointer to the enumerator object.
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-enumundoable
     */
    EnumUndoable() {
        result := ComCall(10, this, "ptr*", &ppEnum := 0, "HRESULT")
        return IEnumOleUndoUnits(ppEnum)
    }

    /**
     * Creates an enumerator object that the caller can use to iterate through a series of top-level undo units from the redo stack.
     * @returns {IEnumOleUndoUnits} Address of <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ienumoleundounits">IEnumOleUndoUnits</a> pointer variable that receives the interface pointer to the enumerator object.
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-enumredoable
     */
    EnumRedoable() {
        result := ComCall(11, this, "ptr*", &ppEnum := 0, "HRESULT")
        return IEnumOleUndoUnits(ppEnum)
    }

    /**
     * Retrieves the description for the top-level undo unit that is on top of the undo stack.
     * @returns {BSTR} A pointer to a string that contains a description of the top-level undo unit on the undo stack.
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-getlastundodescription
     */
    GetLastUndoDescription() {
        pBstr := BSTR()
        result := ComCall(12, this, "ptr", pBstr, "HRESULT")
        return pBstr
    }

    /**
     * Retrieves the description for the top-level undo unit that is on top of the redo stack.
     * @returns {BSTR} A pointer to a string that contains a description of the top-level undo unit on the redo stack.
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-getlastredodescription
     */
    GetLastRedoDescription() {
        pBstr := BSTR()
        result := ComCall(13, this, "ptr", pBstr, "HRESULT")
        return pBstr
    }

    /**
     * Enables or disables the undo manager.
     * @param {BOOL} fEnable Indicates whether to enable or disable the undo manager. If <b>TRUE</b>, the undo manager should be enabled. If <b>FALSE</b>, the undo manager should be disabled.
     * @returns {HRESULT} This method returns S_OK if the undo manager was successfully enabled or disabled. Other possible return values include the following.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>E_UNEXPECTED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is an open undo unit on the stack or the undo manager is currently performing an undo or a redo.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ocidl/nf-ocidl-ioleundomanager-enable
     */
    Enable(fEnable) {
        result := ComCall(14, this, "int", fEnable, "HRESULT")
        return result
    }
}
