#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\..\Win32ComInterface.ahk
#Include ..\..\..\..\Guid.ahk
#Include .\IEnumOleUndoUnits.ahk
#Include ..\..\Foundation\BSTR.ahk
#Include ..\Com\IUnknown.ahk

/**
 * The IOleUndoManager interface enables containers to implement multi-level undo and redo operations for actions that occur within contained controls.
 * @remarks
 * 
 * The control must create an undo unit with the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleundounit">IOleUndoUnit</a> interface or a parent undo unit with the <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nn-ocidl-ioleparentundounit">IOleParentUndoUnit</a> interface derived from <b>IOleUndoUnit</b>. Both of these interfaces perform the undo action and the parent undo unit additionally can contain nested undo units.
 * 
 * The undo manager provides a centralized undo and redo service. It manages parent undo units and simple undo units on the undo and redo stacks. Whether an object is UI-active or not, it can deposit undo units on these stacks by calling methods in the undo manager.
 * 
 * The centralized undo manager then has the data necessary to support the undo and redo user interface for the host application and can discard undo information gradually as the stack becomes full.
 * 
 * The undo manager is implemented as a service and objects obtain a pointer to <b>IOleUndoManger</b> from the <a href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678965(v=vs.85)">IServiceProvider</a> interface. It is usually implemented by the container. The service manages two stacks, the undo stack and the redo stack, each of which contains undo units generated by embedded objects or by the container application itself.
 * 
 * Undo units are typically generated in response to actions taken by the end user. An object does not generate undo actions for programmatic events. In fact, programmatic events should clear the undo stack since the programmatic event can possibly invalidate assumptions made by the undo units on the stack.
 * 
 * When the object's state changes, it creates an undo unit encapsulating all the information needed to undo that change. The object calls methods in the undo manager to place its undo units on the stack. Then, when the end user selects an Undo operation, the undo manager takes the top undo unit off the stack, invokes its action by calling its <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-ioleundounit-do">IOleUndoUnit::Do</a> method, and then releases it. When an end user selects a Redo operation, the undo manager takes the top redo unit off the stack, invokes its action by calling its <b>IOleUndoUnit::Do</b> method, and then releases it.
 * 
 * The undo manager has three states: the base state, the undo state, and the redo state. It begins in the base state. To perform an action from the undo stack, it puts itself into the undo state, calls <a href="https://docs.microsoft.com/windows/desktop/api/ocidl/nf-ocidl-ioleundounit-do">IOleUndoUnit::Do</a> on the undo unit, and goes back to the base state. To perform an action from the redo stack, it puts itself into the redo state, calls <b>IOleUndoUnit::Do</b> on the undo unit, and goes back to the base state.
 * 
 * If the undo manager receives a new undo unit while in the base state, it places the unit on the undo stack and discards the entire redo stack. While it is in the undo state, it puts incoming units on the redo stack. While it is in the redo state, it places them on the undo stack without flushing the redo stack.
 * 
 * The undo manager also allows objects to discard the undo or redo stack starting from any object in either stack.
 * 
 * The host application determines the scope of an undo manager. For example, in one application, the scope might be at the document level; a separate undo manager is maintained for each document; and undo is managed independently for each document. However, another application maintain one undo manager, and therefore one undo scope, for the entire application.
 * 
 * 
 * 
 * @see https://docs.microsoft.com/windows/win32/api//ocidl/nn-ocidl-ioleundomanager
 * @namespace Windows.Win32.System.Ole
 * @version v4.0.30319
 */
class IOleUndoManager extends IUnknown{

    static sizeof => A_PtrSize
    /**
     * The interface identifier for IOleUndoManager
     * @type {Guid}
     */
    static IID => Guid("{d001f200-ef97-11ce-9bc9-00aa00608e01}")

    /**
     * The offset into the COM object's virtual function table at which this interface's methods begin.
     * @type {Integer}
     */
    static vTableOffset => 3

    /**
     * @readonly used when implementing interfaces to order function pointers
     * @type {Array<String>}
     */
    static VTableNames => ["Open", "Close", "Add", "GetOpenParentState", "DiscardFrom", "UndoTo", "RedoTo", "EnumUndoable", "EnumRedoable", "GetLastUndoDescription", "GetLastRedoDescription", "Enable"]

    /**
     * 
     * @param {IOleParentUndoUnit} pPUU 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-open
     */
    Open(pPUU) {
        result := ComCall(3, this, "ptr", pPUU, "HRESULT")
        return result
    }

    /**
     * 
     * @param {IOleParentUndoUnit} pPUU 
     * @param {BOOL} fCommit 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-close
     */
    Close(pPUU, fCommit) {
        result := ComCall(4, this, "ptr", pPUU, "int", fCommit, "int")
        return result
    }

    /**
     * 
     * @param {IOleUndoUnit} pUU 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-add
     */
    Add(pUU) {
        result := ComCall(5, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-getopenparentstate
     */
    GetOpenParentState() {
        result := ComCall(6, this, "uint*", &pdwState := 0, "HRESULT")
        return pdwState
    }

    /**
     * 
     * @param {IOleUndoUnit} pUU 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-discardfrom
     */
    DiscardFrom(pUU) {
        result := ComCall(7, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * 
     * @param {IOleUndoUnit} pUU 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-undoto
     */
    UndoTo(pUU) {
        result := ComCall(8, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * 
     * @param {IOleUndoUnit} pUU 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-redoto
     */
    RedoTo(pUU) {
        result := ComCall(9, this, "ptr", pUU, "HRESULT")
        return result
    }

    /**
     * 
     * @returns {IEnumOleUndoUnits} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-enumundoable
     */
    EnumUndoable() {
        result := ComCall(10, this, "ptr*", &ppEnum := 0, "HRESULT")
        return IEnumOleUndoUnits(ppEnum)
    }

    /**
     * 
     * @returns {IEnumOleUndoUnits} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-enumredoable
     */
    EnumRedoable() {
        result := ComCall(11, this, "ptr*", &ppEnum := 0, "HRESULT")
        return IEnumOleUndoUnits(ppEnum)
    }

    /**
     * 
     * @returns {BSTR} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-getlastundodescription
     */
    GetLastUndoDescription() {
        pBstr := BSTR()
        result := ComCall(12, this, "ptr", pBstr, "HRESULT")
        return pBstr
    }

    /**
     * 
     * @returns {BSTR} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-getlastredodescription
     */
    GetLastRedoDescription() {
        pBstr := BSTR()
        result := ComCall(13, this, "ptr", pBstr, "HRESULT")
        return pBstr
    }

    /**
     * 
     * @param {BOOL} fEnable 
     * @returns {HRESULT} 
     * @see https://learn.microsoft.com/windows/win32/api/ocidl/nf-ocidl-ioleundomanager-enable
     */
    Enable(fEnable) {
        result := ComCall(14, this, "int", fEnable, "HRESULT")
        return result
    }
}
