#Requires AutoHotkey v2.0.0 64-bit

/**
 * @namespace Windows.Win32.Networking.WinSock
 * @version v4.0.30319
 */
class WinSock {

;@region Constants

    /**
     * @type {String}
     */
    static SOCKET_DEFAULT2_QM_POLICY => "{aec2ef9c-3a4d-4d3e-8842-239942e39a47}"

    /**
     * @type {String}
     */
    static REAL_TIME_NOTIFICATION_CAPABILITY => "{6b59819a-5cae-492d-a901-2a3c2c50164f}"

    /**
     * @type {String}
     */
    static REAL_TIME_NOTIFICATION_CAPABILITY_EX => "{6843da03-154a-4616-a508-44371295f96b}"

    /**
     * @type {String}
     */
    static ASSOCIATE_NAMERES_CONTEXT => "{59a38b67-d4fe-46e1-ba3c-87ea74ca3049}"

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL => 2550136833

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_MCAST => 2550136834

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_IGMPMCAST => 2550136835

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_KEEPALIVE_VALS => 2550136836

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ABSORB_RTRALERT => 2550136837

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_UCAST_IF => 2550136838

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_LIMIT_BROADCASTS => 2550136839

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_BIND => 2550136840

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_MCASTIF => 2550136841

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_ADD_MCAST => 2550136842

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_DEL_MCAST => 2550136843

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_MCAST_IF => 2550136845

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_IF => 2550136846

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_LOOPBACK_FAST_PATH => 2550136848

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_INITIAL_RTO => 2550136849

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_APPLY_TRANSPORT_SETTING => 2550136851

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_TRANSPORT_SETTING => 2550136852

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_SET_ICW => 2550136854

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_SET_ACK_FREQUENCY => 2550136855

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_PRIORITY_HINT => 2550136856

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_PRIORITY_HINT => 2550136856

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_INFO => 3623878695

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_CPU_AFFINITY => 2550136853

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TIMESTAMPING => 2550137067

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMPING_FLAG_RX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMPING_FLAG_TX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SO_TIMESTAMP => 12298

    /**
     * @type {Integer (UInt32)}
     */
    static SO_TIMESTAMP_ID => 12299

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_TX_TIMESTAMP => 2550137066

    /**
     * @type {Integer (UInt16)}
     */
    static TCP_INITIAL_RTO_UNSPECIFIED_MAX_SYN_RETRANSMISSIONS => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static TCP_INITIAL_RTO_DEFAULT_RTT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TCP_INITIAL_RTO_DEFAULT_MAX_SYN_RETRANSMISSIONS => 0

    /**
     * @type {Integer (UInt16)}
     */
    static TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS => 65534

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ACQUIRE_PORT_RESERVATION => 2550136932

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RELEASE_PORT_RESERVATION => 2550136933

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ASSOCIATE_PORT_RESERVATION => 2550136934

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_SECURITY => 2550137032

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_SECURITY => 3623878857

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_PEER_TARGET_NAME => 2550137034

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_DELETE_PEER_TARGET_NAME => 2550137035

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_WFP_CONNECTION_REDIRECT_RECORDS => 2550137052

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_WFP_CONNECTION_REDIRECT_CONTEXT => 2550137053

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_WFP_CONNECTION_REDIRECT_RECORDS => 2550137054

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SOCKET_USAGE_NOTIFICATION => 2550137036

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_GUARANTEE_ENCRYPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_ALLOW_INSECURE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_OPTIONAL_PEER_NAME_VERIFICATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_ALLOW_FIRST_INBOUND_PKT_UNENCRYPTED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_PEER_NAME_IS_RAW_FORMAT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_QUERY_IPSEC2_ABORT_CONNECTION_ON_FIELD_CHANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_QUERY_IPSEC2_FIELD_MASK_MM_SA_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_QUERY_IPSEC2_FIELD_MASK_QM_SA_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_INFO_CONNECTION_SECURED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_INFO_CONNECTION_ENCRYPTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_INFO_CONNECTION_IMPERSONATED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_WFP_ALE_ENDPOINT_HANDLE => 1476395213

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_RSS_SCALABILITY_INFO => 1476395218

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_LOOPBACK => 16777343

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_BROADCAST => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_LOOPBACKPREFIX_LENGTH => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_LINKLOCALPREFIX_LENGTH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_MULTICASTPREFIX_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_COMPATIBILITY_MODE => 2550137132

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_DONT_NOTIFY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_DEFER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_WAITALL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_COMMIT_ONLY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MAX_CQ_SIZE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_CORRUPT_CQ => 4294967295

    /**
     * @type {Integer (UInt16)}
     */
    static AF_UNIX => 1

    /**
     * @type {Integer (UInt16)}
     */
    static AF_IMPLINK => 3

    /**
     * @type {Integer (UInt16)}
     */
    static AF_PUP => 4

    /**
     * @type {Integer (UInt16)}
     */
    static AF_CHAOS => 5

    /**
     * @type {Integer (UInt16)}
     */
    static AF_NS => 6

    /**
     * @type {Integer (UInt16)}
     */
    static AF_IPX => 6

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ISO => 7

    /**
     * @type {Integer (UInt16)}
     */
    static AF_OSI => 7

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ECMA => 8

    /**
     * @type {Integer (UInt16)}
     */
    static AF_DATAKIT => 9

    /**
     * @type {Integer (UInt16)}
     */
    static AF_CCITT => 10

    /**
     * @type {Integer (UInt16)}
     */
    static AF_SNA => 11

    /**
     * @type {Integer (UInt16)}
     */
    static AF_DECnet => 12

    /**
     * @type {Integer (UInt16)}
     */
    static AF_DLI => 13

    /**
     * @type {Integer (UInt16)}
     */
    static AF_LAT => 14

    /**
     * @type {Integer (UInt16)}
     */
    static AF_HYLINK => 15

    /**
     * @type {Integer (UInt16)}
     */
    static AF_APPLETALK => 16

    /**
     * @type {Integer (UInt16)}
     */
    static AF_NETBIOS => 17

    /**
     * @type {Integer (UInt16)}
     */
    static AF_VOICEVIEW => 18

    /**
     * @type {Integer (UInt16)}
     */
    static AF_FIREFOX => 19

    /**
     * @type {Integer (UInt16)}
     */
    static AF_UNKNOWN1 => 20

    /**
     * @type {Integer (UInt16)}
     */
    static AF_BAN => 21

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ATM => 22

    /**
     * @type {Integer (UInt16)}
     */
    static AF_CLUSTER => 24

    /**
     * @type {Integer (UInt16)}
     */
    static AF_12844 => 25

    /**
     * @type {Integer (UInt16)}
     */
    static AF_IRDA => 26

    /**
     * @type {Integer (UInt16)}
     */
    static AF_NETDES => 28

    /**
     * @type {Integer (UInt16)}
     */
    static AF_MAX => 29

    /**
     * @type {Integer (UInt16)}
     */
    static AF_TCNPROCESS => 29

    /**
     * @type {Integer (UInt16)}
     */
    static AF_TCNMESSAGE => 30

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ICLFXBM => 31

    /**
     * @type {Integer (UInt16)}
     */
    static AF_LINK => 33

    /**
     * @type {Integer (UInt16)}
     */
    static AF_HYPERV => 34

    /**
     * @type {Integer (Int32)}
     */
    static SOL_SOCKET => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static SOL_IP => 65531

    /**
     * @type {Integer (UInt32)}
     */
    static SOL_IPV6 => 65530

    /**
     * @type {Integer (Int32)}
     */
    static SO_DEBUG => 1

    /**
     * @type {Integer (Int32)}
     */
    static SO_ACCEPTCONN => 2

    /**
     * @type {Integer (Int32)}
     */
    static SO_REUSEADDR => 4

    /**
     * @type {Integer (Int32)}
     */
    static SO_KEEPALIVE => 8

    /**
     * @type {Integer (Int32)}
     */
    static SO_DONTROUTE => 16

    /**
     * @type {Integer (Int32)}
     */
    static SO_BROADCAST => 32

    /**
     * @type {Integer (Int32)}
     */
    static SO_USELOOPBACK => 64

    /**
     * @type {Integer (Int32)}
     */
    static SO_LINGER => 128

    /**
     * @type {Integer (Int32)}
     */
    static SO_OOBINLINE => 256

    /**
     * @type {Integer (Int32)}
     */
    static SO_SNDBUF => 4097

    /**
     * @type {Integer (Int32)}
     */
    static SO_RCVBUF => 4098

    /**
     * @type {Integer (Int32)}
     */
    static SO_SNDLOWAT => 4099

    /**
     * @type {Integer (Int32)}
     */
    static SO_RCVLOWAT => 4100

    /**
     * @type {Integer (Int32)}
     */
    static SO_SNDTIMEO => 4101

    /**
     * @type {Integer (Int32)}
     */
    static SO_RCVTIMEO => 4102

    /**
     * @type {Integer (Int32)}
     */
    static SO_ERROR => 4103

    /**
     * @type {Integer (Int32)}
     */
    static SO_TYPE => 4104

    /**
     * @type {Integer (Int32)}
     */
    static SO_BSP_STATE => 4105

    /**
     * @type {Integer (Int32)}
     */
    static SO_GROUP_ID => 8193

    /**
     * @type {Integer (Int32)}
     */
    static SO_GROUP_PRIORITY => 8194

    /**
     * @type {Integer (Int32)}
     */
    static SO_MAX_MSG_SIZE => 8195

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONDITIONAL_ACCEPT => 12290

    /**
     * @type {Integer (UInt32)}
     */
    static SO_PAUSE_ACCEPT => 12291

    /**
     * @type {Integer (UInt32)}
     */
    static SO_COMPARTMENT_ID => 12292

    /**
     * @type {Integer (Int32)}
     */
    static SO_RANDOMIZE_PORT => 12293

    /**
     * @type {Integer (Int32)}
     */
    static SO_PORT_SCALABILITY => 12294

    /**
     * @type {Integer (Int32)}
     */
    static SO_REUSE_UNICASTPORT => 12295

    /**
     * @type {Integer (Int32)}
     */
    static SO_REUSE_MULTICASTPORT => 12296

    /**
     * @type {Integer (UInt32)}
     */
    static SO_ORIGINAL_DST => 12303

    /**
     * @type {Integer (UInt32)}
     */
    static IP6T_SO_ORIGINAL_DST => 12303

    /**
     * @type {Integer (UInt32)}
     */
    static WSK_SO_BASE => 16384

    /**
     * @type {Integer (Int32)}
     */
    static TCP_NODELAY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static _SS_MAXSIZE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_UNIX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_WS2 => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_PROTOCOL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_VENDOR => 402653184

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ASSOCIATE_HANDLE => 2281701377

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ENABLE_CIRCULAR_QUEUEING => 671088642

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_FIND_ROUTE => 1207959555

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_FLUSH => 671088644

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_BROADCAST_ADDRESS => 1207959557

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_EXTENSION_FUNCTION_POINTER => 3355443206

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_QOS => 3355443207

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_GROUP_QOS => 3355443208

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_MULTIPOINT_LOOPBACK => 2281701385

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_MULTICAST_SCOPE => 2281701386

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_QOS => 2281701387

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_GROUP_QOS => 2281701388

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TRANSLATE_HANDLE => 3355443213

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ROUTING_INTERFACE_QUERY => 3355443220

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ROUTING_INTERFACE_CHANGE => 2281701397

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ADDRESS_LIST_QUERY => 1207959574

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ADDRESS_LIST_CHANGE => 671088663

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_TARGET_PNP_HANDLE => 1207959576

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_RSS_PROCESSOR_INFO => 1207959589

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ADDRESS_LIST_SORT => 3355443225

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RESERVED_1 => 2281701402

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RESERVED_2 => 2281701409

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_MULTIPLE_EXTENSION_FUNCTION_POINTER => 3355443236

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TCPMUX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_ECHO => 7

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DISCARD => 9

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SYSTAT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DAYTIME => 13

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETSTAT => 15

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_QOTD => 17

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_MSP => 18

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_CHARGEN => 19

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_FTP_DATA => 20

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_FTP => 21

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TELNET => 23

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SMTP => 25

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TIMESERVER => 37

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NAMESERVER => 42

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_WHOIS => 43

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_MTP => 57

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TFTP => 69

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_RJE => 77

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_FINGER => 79

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TTYLINK => 87

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SUPDUP => 95

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_POP3 => 110

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NTP => 123

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_EPMAP => 135

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETBIOS_NS => 137

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETBIOS_DGM => 138

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETBIOS_SSN => 139

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_IMAP => 143

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SNMP => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SNMP_TRAP => 162

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_IMAP3 => 220

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_LDAP => 389

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_HTTPS => 443

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_MICROSOFT_DS => 445

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_EXECSERVER => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_LOGINSERVER => 513

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_CMDSERVER => 514

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_EFSSERVER => 520

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_BIFFUDP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_WHOSERVER => 513

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_ROUTESERVER => 520

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_RESERVED => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_REGISTERED_MIN => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_REGISTERED_MAX => 49151

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DYNAMIC_MIN => 49152

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DYNAMIC_MAX => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_NET => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_NSHIFT => 24

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_HOST => 16777215

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_MAX => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_NET => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_NSHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_HOST => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_MAX => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSC_NET => 4294967040

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSC_NSHIFT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSC_HOST => 255

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSD_NET => 4026531840

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSD_NSHIFT => 28

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSD_HOST => 268435455

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_LOOPBACK => 2130706433

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_NONE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static IOCPARM_MASK => 127

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_VOID => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_OUT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_IN => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_TRUNC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_CTRUNC => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_BCAST => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_MCAST => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_ERRQUEUE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static AI_PASSIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_CANONNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AI_NUMERICHOST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AI_NUMERICSERV => 8

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_ONLY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static AI_FORCE_CLEAR_TEXT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static AI_BYPASS_DNS_CACHE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RETURN_TTL => 128

    /**
     * @type {Integer (UInt32)}
     */
    static AI_ALL => 256

    /**
     * @type {Integer (UInt32)}
     */
    static AI_ADDRCONFIG => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static AI_V4MAPPED => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static AI_NON_AUTHORITATIVE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static AI_SECURE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RETURN_PREFERRED_NAMES => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static AI_FQDN => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static AI_FILESERVER => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DISABLE_IDN_ENCODING => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static AI_SECURE_WITH_FALLBACK => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static AI_EXCLUSIVE_CUSTOM_SERVERS => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RETURN_RESPONSE_FLAGS => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static AI_REQUIRE_SECURE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RESOLUTION_HANDLE => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static AI_EXTENDED => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_5 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_6 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_SERVER_TYPE_UDP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_SERVER_TYPE_DOH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_SERVER_UDP_FALLBACK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_RESPONSE_SECURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_RESPONSE_HOSTFILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NS_ALL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NS_SAP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NDS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NS_PEER_BROWSE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NS_SLP => 5

    /**
     * @type {Integer (UInt32)}
     */
    static NS_DHCP => 6

    /**
     * @type {Integer (UInt32)}
     */
    static NS_TCPIP_LOCAL => 10

    /**
     * @type {Integer (UInt32)}
     */
    static NS_TCPIP_HOSTS => 11

    /**
     * @type {Integer (UInt32)}
     */
    static NS_DNS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NETBT => 13

    /**
     * @type {Integer (UInt32)}
     */
    static NS_WINS => 14

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NLA => 15

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NBP => 20

    /**
     * @type {Integer (UInt32)}
     */
    static NS_MS => 30

    /**
     * @type {Integer (UInt32)}
     */
    static NS_STDA => 31

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NTDS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NS_EMAIL => 37

    /**
     * @type {Integer (UInt32)}
     */
    static NS_X500 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NIS => 41

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NISPLUS => 42

    /**
     * @type {Integer (UInt32)}
     */
    static NS_WRQ => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NETDES => 60

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NOFQDN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NUMERICHOST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NAMEREQD => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NUMERICSERV => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NI_DGRAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NI_MAXHOST => 1025

    /**
     * @type {Integer (UInt32)}
     */
    static NI_MAXSERV => 32

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_UP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_BROADCAST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_LOOPBACK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_POINTTOPOINT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_MULTICAST => 16

    /**
     * @type {Integer (Int32)}
     */
    static IP_OPTIONS => 1

    /**
     * @type {Integer (Int32)}
     */
    static IP_HDRINCL => 2

    /**
     * @type {Integer (Int32)}
     */
    static IP_TOS => 3

    /**
     * @type {Integer (Int32)}
     */
    static IP_TTL => 4

    /**
     * @type {Integer (Int32)}
     */
    static IP_MULTICAST_IF => 9

    /**
     * @type {Integer (Int32)}
     */
    static IP_MULTICAST_TTL => 10

    /**
     * @type {Integer (Int32)}
     */
    static IP_MULTICAST_LOOP => 11

    /**
     * @type {Integer (Int32)}
     */
    static IP_ADD_MEMBERSHIP => 12

    /**
     * @type {Integer (Int32)}
     */
    static IP_DROP_MEMBERSHIP => 13

    /**
     * @type {Integer (Int32)}
     */
    static IP_DONTFRAGMENT => 14

    /**
     * @type {Integer (Int32)}
     */
    static IP_ADD_SOURCE_MEMBERSHIP => 15

    /**
     * @type {Integer (Int32)}
     */
    static IP_DROP_SOURCE_MEMBERSHIP => 16

    /**
     * @type {Integer (Int32)}
     */
    static IP_BLOCK_SOURCE => 17

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNBLOCK_SOURCE => 18

    /**
     * @type {Integer (Int32)}
     */
    static IP_PKTINFO => 19

    /**
     * @type {Integer (Int32)}
     */
    static IP_HOPLIMIT => 21

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVTTL => 21

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECEIVE_BROADCAST => 22

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVIF => 24

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVDSTADDR => 25

    /**
     * @type {Integer (Int32)}
     */
    static IP_IFLIST => 28

    /**
     * @type {Integer (Int32)}
     */
    static IP_ADD_IFLIST => 29

    /**
     * @type {Integer (Int32)}
     */
    static IP_DEL_IFLIST => 30

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNICAST_IF => 31

    /**
     * @type {Integer (Int32)}
     */
    static IP_RTHDR => 32

    /**
     * @type {Integer (Int32)}
     */
    static IP_GET_IFLIST => 33

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVRTHDR => 38

    /**
     * @type {Integer (Int32)}
     */
    static IP_TCLASS => 39

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVTCLASS => 40

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVTOS => 40

    /**
     * @type {Integer (Int32)}
     */
    static IP_ORIGINAL_ARRIVAL_IF => 47

    /**
     * @type {Integer (Int32)}
     */
    static IP_ECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IP_PKTINFO_EX => 51

    /**
     * @type {Integer (Int32)}
     */
    static IP_WFP_REDIRECT_RECORDS => 60

    /**
     * @type {Integer (Int32)}
     */
    static IP_WFP_REDIRECT_CONTEXT => 70

    /**
     * @type {Integer (Int32)}
     */
    static IP_MTU_DISCOVER => 71

    /**
     * @type {Integer (Int32)}
     */
    static IP_MTU => 73

    /**
     * @type {Integer (Int32)}
     */
    static IP_NRT_INTERFACE => 74

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVERR => 75

    /**
     * @type {Integer (Int32)}
     */
    static IP_USER_MTU => 76

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNSPECIFIED_TYPE_OF_SERVICE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static IP_UNSPECIFIED_USER_MTU => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_LINKLOCALPREFIX_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_MULTICASTPREFIX_LENGTH => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH => 104

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_V4MAPPEDPREFIX_LENGTH => 96

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_6TO4PREFIX_LENGTH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_TEREDOPREFIX_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_JOIN_GROUP => 41

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_LEAVE_GROUP => 42

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_BLOCK_SOURCE => 43

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_UNBLOCK_SOURCE => 44

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_JOIN_SOURCE_GROUP => 45

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_LEAVE_SOURCE_GROUP => 46

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_HOPOPTS => 1

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_HDRINCL => 2

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_UNICAST_HOPS => 4

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MULTICAST_IF => 9

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MULTICAST_HOPS => 10

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MULTICAST_LOOP => 11

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_ADD_MEMBERSHIP => 12

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_JOIN_GROUP => 12

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_DROP_MEMBERSHIP => 13

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_LEAVE_GROUP => 13

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_DONTFRAG => 14

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_PKTINFO => 19

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_HOPLIMIT => 21

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_PROTECTION_LEVEL => 23

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVIF => 24

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVDSTADDR => 25

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_CHECKSUM => 26

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_V6ONLY => 27

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_IFLIST => 28

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_ADD_IFLIST => 29

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_DEL_IFLIST => 30

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_UNICAST_IF => 31

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RTHDR => 32

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_GET_IFLIST => 33

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVRTHDR => 38

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_TCLASS => 39

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVTCLASS => 40

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_ECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_PKTINFO_EX => 51

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_WFP_REDIRECT_RECORDS => 60

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_WFP_REDIRECT_CONTEXT => 70

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MTU_DISCOVER => 71

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MTU => 72

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_NRT_INTERFACE => 74

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVERR => 75

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_USER_MTU => 76

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNSPECIFIED_HOP_LIMIT => -1

    /**
     * @type {Integer (Int32)}
     */
    static IP_PROTECTION_LEVEL => 23

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_UNRESTRICTED => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_EDGERESTRICTED => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_RESTRICTED => 30

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_DEFAULT => 20

    /**
     * @type {Integer (UInt32)}
     */
    static INET_ADDRSTRLEN => 22

    /**
     * @type {Integer (UInt32)}
     */
    static INET6_ADDRSTRLEN => 65

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_NO_PREFERENCE => 0

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_NOT_PREFERRED => 1

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_PREFERRED => 2

    /**
     * @type {Integer (Int32)}
     */
    static TCP_EXPEDITED_1122 => 2

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPALIVE => 3

    /**
     * @type {Integer (Int32)}
     */
    static TCP_MAXSEG => 4

    /**
     * @type {Integer (Int32)}
     */
    static TCP_MAXRT => 5

    /**
     * @type {Integer (Int32)}
     */
    static TCP_STDURG => 6

    /**
     * @type {Integer (Int32)}
     */
    static TCP_NOURG => 7

    /**
     * @type {Integer (Int32)}
     */
    static TCP_ATMARK => 8

    /**
     * @type {Integer (Int32)}
     */
    static TCP_NOSYNRETRIES => 9

    /**
     * @type {Integer (Int32)}
     */
    static TCP_TIMESTAMPS => 10

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_PREFERENCE => 11

    /**
     * @type {Integer (Int32)}
     */
    static TCP_CONGESTION_ALGORITHM => 12

    /**
     * @type {Integer (Int32)}
     */
    static TCP_DELAY_FIN_ACK => 13

    /**
     * @type {Integer (Int32)}
     */
    static TCP_MAXRTMS => 14

    /**
     * @type {Integer (Int32)}
     */
    static TCP_FASTOPEN => 15

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPCNT => 16

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPIDLE => 3

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPINTVL => 17

    /**
     * @type {Integer (Int32)}
     */
    static TCP_FAIL_CONNECT_ON_ICMP_ERROR => 18

    /**
     * @type {Integer (Int32)}
     */
    static TCP_ICMP_ERROR_INFO => 19

    /**
     * @type {Integer (Int32)}
     */
    static UDP_SEND_MSG_SIZE => 2

    /**
     * @type {Integer (Int32)}
     */
    static UDP_RECV_MAX_COALESCED_SIZE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UDP_COALESCED_INFO => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WINDOWS_AF_IRDA => 26

    /**
     * @type {Integer (UInt32)}
     */
    static WINDOWS_PF_IRDA => 26

    /**
     * @type {Integer (UInt32)}
     */
    static WCE_AF_IRDA => 22

    /**
     * @type {Integer (UInt32)}
     */
    static WCE_PF_IRDA => 22

    /**
     * @type {Integer (UInt32)}
     */
    static IRDA_PROTO_SOCK_STREAM => 1

    /**
     * @type {Integer (UInt16)}
     */
    static PF_IRDA => 26

    /**
     * @type {Integer (Int32)}
     */
    static SOL_IRLMP => 255

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_ENUMDEVICES => 16

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_IAS_SET => 17

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_IAS_QUERY => 18

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_SEND_PDU_LEN => 19

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_EXCLUSIVE_MODE => 20

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_IRLPT_MODE => 21

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_9WIRE_MODE => 22

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_TINYTP_MODE => 23

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_PARAMETERS => 24

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_DISCOVERY_MODE => 25

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_SHARP_MODE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_NO_CLASS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_NO_ATTRIB => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_INT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_OCTETSEQ => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_STR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_USER_STRING => 256

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_OCTET_STRING => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_CLASSNAME => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_ATTRIBNAME => 256

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetASCII => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_5 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_6 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_7 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_8 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_9 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetUNICODE => 255

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_1200 => 1200

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_2400 => 2400

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_9600 => 9600

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_19200 => 19200

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_38400 => 38400

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_57600 => 57600

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_115200 => 115200

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_576K => 576000

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_1152K => 1152000

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_4M => 4000000

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_16M => 16000000

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNDATA => 28672

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNOPT => 28673

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCDATA => 28674

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCOPT => 28675

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNDATALEN => 28676

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNOPTLEN => 28677

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCDATALEN => 28678

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCOPTLEN => 28679

    /**
     * @type {Integer (Int32)}
     */
    static SO_OPENTYPE => 28680

    /**
     * @type {Integer (UInt32)}
     */
    static SO_SYNCHRONOUS_ALERT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SO_SYNCHRONOUS_NONALERT => 32

    /**
     * @type {Integer (Int32)}
     */
    static SO_MAXDG => 28681

    /**
     * @type {Integer (Int32)}
     */
    static SO_MAXPATHDG => 28682

    /**
     * @type {Integer (Int32)}
     */
    static SO_UPDATE_ACCEPT_CONTEXT => 28683

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNECT_TIME => 28684

    /**
     * @type {Integer (Int32)}
     */
    static SO_UPDATE_CONNECT_CONTEXT => 28688

    /**
     * @type {Integer (Int32)}
     */
    static TCP_BSDURGENT => 28672

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_UDP_CONNRESET => 2550136844

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SOCKET_CLOSE_NOTIFY => 2550136845

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_UDP_NETRESET => 2550136847

    /**
     * @type {Integer (UInt32)}
     */
    static TF_DISCONNECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TF_REUSE_SOCKET => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TF_WRITE_BEHIND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TF_USE_DEFAULT_WORKER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TF_USE_SYSTEM_THREAD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TF_USE_KERNEL_APC => 32

    /**
     * @type {String}
     */
    static WSAID_TRANSMITFILE => "{b5367df0-cbac-11cf-95ca-00805f48a192}"

    /**
     * @type {String}
     */
    static WSAID_ACCEPTEX => "{b5367df1-cbac-11cf-95ca-00805f48a192}"

    /**
     * @type {String}
     */
    static WSAID_GETACCEPTEXSOCKADDRS => "{b5367df2-cbac-11cf-95ca-00805f48a192}"

    /**
     * @type {Integer (UInt32)}
     */
    static TP_ELEMENT_MEMORY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TP_ELEMENT_FILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TP_ELEMENT_EOP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TP_DISCONNECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TP_REUSE_SOCKET => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TP_USE_DEFAULT_WORKER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TP_USE_SYSTEM_THREAD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TP_USE_KERNEL_APC => 32

    /**
     * @type {String}
     */
    static WSAID_TRANSMITPACKETS => "{d9689da0-1f90-11d3-9971-00c04f68c876}"

    /**
     * @type {String}
     */
    static WSAID_CONNECTEX => "{25a207b9-ddf3-4660-8ee9-76e58c74063e}"

    /**
     * @type {String}
     */
    static WSAID_DISCONNECTEX => "{7fda2e11-8630-436f-a031-f536a6eec157}"

    /**
     * @type {Integer (UInt32)}
     */
    static DE_REUSE_SOCKET => 2

    /**
     * @type {String}
     */
    static NLA_NAMESPACE_GUID => "{6642243a-3ba8-4aa6-baa5-2e0bd71fdd83}"

    /**
     * @type {String}
     */
    static NLA_SERVICE_CLASS_GUID => "{0037e515-b5c9-4a43-bada-8b48a87ad239}"

    /**
     * @type {Integer (UInt32)}
     */
    static NLA_ALLUSERS_NETWORK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NLA_FRIENDLY_NAME => 2

    /**
     * @type {String}
     */
    static WSAID_WSARECVMSG => "{f689d7c8-6f1f-436b-8a53-e54fe351c322}"

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BSP_HANDLE => 1207959579

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BSP_HANDLE_SELECT => 1207959580

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BSP_HANDLE_POLL => 1207959581

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BASE_HANDLE => 1207959586

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_EXT_SELECT => 3355443230

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_EXT_POLL => 3355443231

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_EXT_SENDMSG => 3355443232

    /**
     * @type {String}
     */
    static WSAID_WSASENDMSG => "{a441e712-754f-43ca-84a7-0dee44cf606d}"

    /**
     * @type {String}
     */
    static WSAID_WSAPOLL => "{18c76f85-dc66-4964-972e-23c27238312b}"

    /**
     * @type {String}
     */
    static WSAID_MULTIPLE_RIO => "{8509e081-96dd-4005-b165-9e2ee8c79e3f}"

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_RESOURCE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_SERVICE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_LOCAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_FLAG_DEFER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_FLAG_HARD => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_COMMENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_LOCALE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_DISPLAY_HINT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_VERSION => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_START_TIME => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_MACHINE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_ADDRESSES => 256

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_SD => 512

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_ALL => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_ADDRESS_FLAG_RPC_CN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_ADDRESS_FLAG_RPC_DG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_ADDRESS_FLAG_RPC_NB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NS_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NS_VNS => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_HIERARCHICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_DYNAMIC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_ENUMERABLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_WORKGROUP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static XP_CONNECTIONLESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static XP_GUARANTEED_DELIVERY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static XP_GUARANTEED_ORDER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static XP_MESSAGE_ORIENTED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static XP_PSEUDO_STREAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static XP_GRACEFUL_CLOSE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static XP_EXPEDITED_DATA => 64

    /**
     * @type {Integer (UInt32)}
     */
    static XP_CONNECT_DATA => 128

    /**
     * @type {Integer (UInt32)}
     */
    static XP_DISCONNECT_DATA => 256

    /**
     * @type {Integer (UInt32)}
     */
    static XP_SUPPORTS_BROADCAST => 512

    /**
     * @type {Integer (UInt32)}
     */
    static XP_SUPPORTS_MULTICAST => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static XP_BANDWIDTH_ALLOCATION => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static XP_FRAGMENTATION => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static XP_ENCRYPTS => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static RES_SOFT_SEARCH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RES_FIND_MULTIPLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RES_SERVICE => 4

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_SAPIDA => "SapId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_SAPIDW => "SapId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_CONNA => "ConnectionOriented"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_CONNW => "ConnectionOriented"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_TCPPORTA => "TcpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_TCPPORTW => "TcpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_UDPPORTA => "UdpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_UDPPORTW => "UdpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_SAPID => "SapId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_CONN => "ConnectionOriented"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_TCPPORT => "TcpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_UDPPORT => "UdpPort"

    /**
     * @type {Integer (UInt32)}
     */
    static SET_SERVICE_PARTIAL_SUCCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FD_SETSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IMPLINK_IP => 155

    /**
     * @type {Integer (UInt32)}
     */
    static IMPLINK_LOWEXPER => 156

    /**
     * @type {Integer (UInt32)}
     */
    static IMPLINK_HIGHEXPER => 158

    /**
     * @type {Integer (UInt32)}
     */
    static WSADESCRIPTION_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static WSASYS_STATUS_LEN => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IP_DEFAULT_MULTICAST_TTL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IP_DEFAULT_MULTICAST_LOOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IP_MAX_MEMBERSHIPS => 20

    /**
     * @type {Integer (Int32)}
     */
    static SOCKET_ERROR => -1

    /**
     * @type {Integer (UInt16)}
     */
    static PF_UNIX => 1

    /**
     * @type {Integer (UInt16)}
     */
    static PF_IMPLINK => 3

    /**
     * @type {Integer (UInt16)}
     */
    static PF_PUP => 4

    /**
     * @type {Integer (UInt16)}
     */
    static PF_CHAOS => 5

    /**
     * @type {Integer (UInt16)}
     */
    static PF_NS => 6

    /**
     * @type {Integer (UInt16)}
     */
    static PF_IPX => 6

    /**
     * @type {Integer (UInt16)}
     */
    static PF_ISO => 7

    /**
     * @type {Integer (UInt16)}
     */
    static PF_OSI => 7

    /**
     * @type {Integer (UInt16)}
     */
    static PF_ECMA => 8

    /**
     * @type {Integer (UInt16)}
     */
    static PF_DATAKIT => 9

    /**
     * @type {Integer (UInt16)}
     */
    static PF_CCITT => 10

    /**
     * @type {Integer (UInt16)}
     */
    static PF_SNA => 11

    /**
     * @type {Integer (UInt16)}
     */
    static PF_DECnet => 12

    /**
     * @type {Integer (UInt16)}
     */
    static PF_DLI => 13

    /**
     * @type {Integer (UInt16)}
     */
    static PF_LAT => 14

    /**
     * @type {Integer (UInt16)}
     */
    static PF_HYLINK => 15

    /**
     * @type {Integer (UInt16)}
     */
    static PF_APPLETALK => 16

    /**
     * @type {Integer (UInt16)}
     */
    static PF_VOICEVIEW => 18

    /**
     * @type {Integer (UInt16)}
     */
    static PF_FIREFOX => 19

    /**
     * @type {Integer (UInt16)}
     */
    static PF_UNKNOWN1 => 20

    /**
     * @type {Integer (UInt16)}
     */
    static PF_BAN => 21

    /**
     * @type {Integer (UInt16)}
     */
    static PF_MAX => 29

    /**
     * @type {Integer (UInt32)}
     */
    static SOMAXCONN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_MAXIOVLEN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_PARTIAL => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static MAXGETHOSTSTRUCT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static FD_READ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FD_WRITE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FD_OOB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ACCEPT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CONNECT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CLOSE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static INCL_WINSOCK_API_PROTOTYPES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INCL_WINSOCK_API_TYPEDEFS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ADDR_ANY => 0

    /**
     * @type {Integer (Int32)}
     */
    static FROM_PROTOCOL_INFO => -1

    /**
     * @type {Integer (Int32)}
     */
    static SO_PROTOCOL_INFOA => 8196

    /**
     * @type {Integer (Int32)}
     */
    static SO_PROTOCOL_INFOW => 8197

    /**
     * @type {Integer (Int32)}
     */
    static SO_PROTOCOL_INFO => 8197

    /**
     * @type {Integer (Int32)}
     */
    static PVD_CONFIG => 12289

    /**
     * @type {Integer (UInt16)}
     */
    static PF_ATM => 22

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_INTERRUPT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FD_READ_BIT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FD_WRITE_BIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FD_OOB_BIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ACCEPT_BIT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CONNECT_BIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CLOSE_BIT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static FD_QOS_BIT => 6

    /**
     * @type {Integer (UInt32)}
     */
    static FD_GROUP_QOS_BIT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ROUTING_INTERFACE_CHANGE_BIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ADDRESS_LIST_CHANGE_BIT => 9

    /**
     * @type {Integer (UInt32)}
     */
    static FD_MAX_EVENTS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_MAXIMUM_WAIT_EVENTS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_WAIT_FAILED => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_WAIT_TIMEOUT => 258

    /**
     * @type {Integer (UInt32)}
     */
    static CF_ACCEPT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CF_REJECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CF_DEFER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SG_UNCONSTRAINED_GROUP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SG_CONSTRAINED_GROUP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PROTOCOL_CHAIN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BASE_PROTOCOL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LAYERED_PROTOCOL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WSAPROTOCOL_LEN => 255

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_MULTIPLE_PROTO_ENTRIES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_RECOMMENDED_PROTO_ENTRY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_HIDDEN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_MATCHES_PROTOCOL_ZERO => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_NETWORKDIRECT_PROVIDER => 16

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_CONNECTIONLESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_GUARANTEED_DELIVERY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_GUARANTEED_ORDER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_MESSAGE_ORIENTED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_PSEUDO_STREAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_GRACEFUL_CLOSE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_EXPEDITED_DATA => 64

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_CONNECT_DATA => 128

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_DISCONNECT_DATA => 256

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_SUPPORT_BROADCAST => 512

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_SUPPORT_MULTIPOINT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_MULTIPOINT_CONTROL_PLANE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_MULTIPOINT_DATA_PLANE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_QOS_SUPPORTED => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_INTERRUPT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_UNI_SEND => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_UNI_RECV => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_IFS_HANDLES => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_PARTIAL_MESSAGE => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_SAN_SUPPORT_SDP => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static BIGENDIAN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LITTLEENDIAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SECURITY_PROTOCOL_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static JL_SENDER_ONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static JL_RECEIVER_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static JL_BOTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_OVERLAPPED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_C_ROOT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_C_LEAF => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_D_ROOT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_D_LEAF => 16

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_ACCESS_SYSTEM_SECURITY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_NO_HANDLE_INHERIT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_REGISTERED_IO => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_NSP_NOTIFY_CHANGE => 2281701401

    /**
     * @type {Integer (UInt32)}
     */
    static TH_NETDEV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TH_TAPI => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_MULTIPLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NS_LOCALNAME => 19

    /**
     * @type {Integer (UInt32)}
     */
    static RES_UNUSED_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RES_FLUSH_CACHE => 2

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_IPXPORTA => "IpxSocket"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_IPXPORTW => "IpxSocket"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_OBJECTIDA => "ObjectId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_OBJECTIDW => "ObjectId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_OBJECTID => "ObjectId"

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DEEP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_CONTAINERS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_NOCONTAINERS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_NEAREST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_NAME => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_TYPE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_VERSION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_COMMENT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_ADDR => 256

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_BLOB => 512

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_ALIASES => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_QUERY_STRING => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_ALL => 4080

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RES_SERVICE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FLUSHCACHE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FLUSHPREVIOUS => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_NON_AUTHORITATIVE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_SECURE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_PREFERRED_NAMES => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DNS_ONLY => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_RESPONSE_FLAGS => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_ADDRCONFIG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DUAL_ADDR => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FILESERVER => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DISABLE_IDN_ENCODING => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_API_ANSI => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_EXTENDED_QUERYSET => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_SECURE_WITH_FALLBACK => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_EXCLUSIVE_CUSTOM_SERVERS => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_REQUIRE_SECURE => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_TTL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FORCE_CLEAR_TEXT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RESOLUTION_HANDLE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_ALIAS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_ADDED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_CHANGED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_DELETED => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_IN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_OUT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_HANGUP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_IN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_OUT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_HANGUP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_ERR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_REMOVE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_ENABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_DISABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_REMOVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_ONESHOT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_PERSISTENT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_LEVEL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_EDGE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AALUSER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL34 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL5 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ABSENT => 4294967294

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ANY => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ANY_AESA_SEL => 4294967290

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ANY_AESA_REST => 4294967291

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_E164 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_NSAP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_AESA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_ADDR_SIZE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_ISO_1745 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_Q921 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_X25L => 6

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_X25M => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_ELAPB => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_HDLC_ARM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_HDLC_NRM => 10

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_HDLC_ABM => 11

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_LLC => 12

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_X75 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_Q922 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_USER_SPECIFIED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_ISO_7776 => 17

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_X25 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_ISO_8208 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_X223 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_SIO_8473 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_T70 => 10

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_ISO_TR9577 => 11

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_USER_SPECIFIED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_IPI_SNAP => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_IPI_IP => 204

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_ISO => 0

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_UserSpecific => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_HighLayerProfile => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_VendorSpecificAppId => 3

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_MODE_MESSAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_MODE_STREAMING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_NULL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_SSCOP_ASSURED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_SSCOP_NON_ASSURED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_FRAME_RELAY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BCOB_A => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCOB_C => 3

    /**
     * @type {Integer (UInt32)}
     */
    static BCOB_X => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TT_NOIND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TT_CBR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TT_VBR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TR_NOIND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TR_END_TO_END => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TR_NO_END_TO_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CLIP_NOT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLIP_SUS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static UP_P2P => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UP_P2MP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_MODE_NORMAL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_MODE_EXT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_MODE_NORMAL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_MODE_EXT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_16 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_32 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_64 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_128 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_256 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_512 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_1024 => 10

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_2048 => 11

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_4096 => 12

    /**
     * @type {Integer (UInt32)}
     */
    static PI_ALLOWED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PI_RESTRICTED => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PI_NUMBER_NOT_AVAILABLE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SI_USER_NOT_SCREENED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SI_USER_PASSED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SI_USER_FAILED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SI_NETWORK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_USER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PRIVATE_LOCAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PUBLIC_LOCAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_TRANSIT_NETWORK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PUBLIC_REMOTE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PRIVATE_REMOTE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_INTERNATIONAL_NETWORK => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_BEYOND_INTERWORKING => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNALLOCATED_NUMBER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_ROUTE_TO_DESTINATION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_VPI_VCI_UNACCEPTABLE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NORMAL_CALL_CLEARING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_USER_BUSY => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_USER_RESPONDING => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_CALL_REJECTED => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NUMBER_CHANGED => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_USER_REJECTS_CLIR => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_DESTINATION_OUT_OF_ORDER => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_NUMBER_FORMAT => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_STATUS_ENQUIRY_RESPONSE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NORMAL_UNSPECIFIED => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_VPI_VCI_UNAVAILABLE => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NETWORK_OUT_OF_ORDER => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_TEMPORARY_FAILURE => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_ACCESS_INFORMAION_DISCARDED => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_VPI_VCI_AVAILABLE => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_RESOURCE_UNAVAILABLE => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_QOS_UNAVAILABLE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_USER_CELL_RATE_UNAVAILABLE => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_BEARER_CAPABILITY_UNAUTHORIZED => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_BEARER_CAPABILITY_UNAVAILABLE => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_OPTION_UNAVAILABLE => 63

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED => 65

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS => 73

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_CALL_REFERENCE => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_CHANNEL_NONEXISTENT => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INCOMPATIBLE_DESTINATION => 88

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_ENDPOINT_REFERENCE => 89

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_TRANSIT_NETWORK_SELECTION => 91

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_TOO_MANY_PENDING_ADD_PARTY => 92

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_AAL_PARAMETERS_UNSUPPORTED => 93

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_MANDATORY_IE_MISSING => 96

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNIMPLEMENTED_MESSAGE_TYPE => 97

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNIMPLEMENTED_IE => 99

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_IE_CONTENTS => 100

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_STATE_FOR_MESSAGE => 101

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_RECOVERY_ON_TIMEOUT => 102

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INCORRECT_MESSAGE_LENGTH => 104

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_PROTOCOL_ERROR => 111

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_COND_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_COND_PERMANENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_COND_TRANSIENT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_REASON_USER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_REASON_IE_MISSING => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_REASON_IE_INSUFFICIENT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_PU_PROVIDER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_PU_USER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NA_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NA_ABNORMAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TNS_TYPE_NATIONAL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TNS_PLAN_CARRIER_ID_CODE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_NUMBER_OF_ATM_DEVICES => 1343619073

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_ATM_ADDRESS => 3491102722

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ASSOCIATE_PVC => 2417360899

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_ATM_CONNECTION_ID => 1343619076

    /**
     * @type {Integer (UInt32)}
     */
    static WSPDESCRIPTION_LEN => 255

    /**
     * @type {Integer (Int32)}
     */
    static WSS_OPERATION_IN_PROGRESS => 259

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_SYSTEM => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_INSPECTOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_REDIRECTOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_PROXY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_FIREWALL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_INBOUND_MODIFY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_OUTBOUND_MODIFY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_CRYPTO_COMPRESS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_LOCAL_CACHE => 128

    /**
     * @type {Integer (Int32)}
     */
    static UDP_NOCHECKSUM => 1

    /**
     * @type {Integer (Int32)}
     */
    static UDP_CHECKSUM_COVERAGE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static GAI_STRERROR_BUFFER_SIZE => 1024

    /**
     * @type {Integer (Int32)}
     */
    static IPX_PTYPE => 16384

    /**
     * @type {Integer (Int32)}
     */
    static IPX_FILTERPTYPE => 16385

    /**
     * @type {Integer (Int32)}
     */
    static IPX_STOPFILTERPTYPE => 16387

    /**
     * @type {Integer (Int32)}
     */
    static IPX_DSTYPE => 16386

    /**
     * @type {Integer (Int32)}
     */
    static IPX_EXTENDED_ADDRESS => 16388

    /**
     * @type {Integer (Int32)}
     */
    static IPX_RECVHDR => 16389

    /**
     * @type {Integer (Int32)}
     */
    static IPX_MAXSIZE => 16390

    /**
     * @type {Integer (Int32)}
     */
    static IPX_ADDRESS => 16391

    /**
     * @type {Integer (Int32)}
     */
    static IPX_GETNETINFO => 16392

    /**
     * @type {Integer (Int32)}
     */
    static IPX_GETNETINFO_NORIP => 16393

    /**
     * @type {Integer (Int32)}
     */
    static IPX_SPXGETCONNECTIONSTATUS => 16395

    /**
     * @type {Integer (Int32)}
     */
    static IPX_ADDRESS_NOTIFY => 16396

    /**
     * @type {Integer (Int32)}
     */
    static IPX_MAX_ADAPTER_NUM => 16397

    /**
     * @type {Integer (Int32)}
     */
    static IPX_RERIPNETNUMBER => 16398

    /**
     * @type {Integer (Int32)}
     */
    static IPX_RECEIVE_BROADCAST => 16399

    /**
     * @type {Integer (Int32)}
     */
    static IPX_IMMEDIATESPXACK => 16400

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MCAST_TTL => 255

    /**
     * @type {Integer (Int32)}
     */
    static RM_OPTIONSBASE => 1000

    /**
     * @type {Integer (Int32)}
     */
    static RM_RATE_WINDOW_SIZE => 1001

    /**
     * @type {Integer (Int32)}
     */
    static RM_SET_MESSAGE_BOUNDARY => 1002

    /**
     * @type {Integer (Int32)}
     */
    static RM_FLUSHCACHE => 1003

    /**
     * @type {Integer (Int32)}
     */
    static RM_SENDER_WINDOW_ADVANCE_METHOD => 1004

    /**
     * @type {Integer (Int32)}
     */
    static RM_SENDER_STATISTICS => 1005

    /**
     * @type {Integer (Int32)}
     */
    static RM_LATEJOIN => 1006

    /**
     * @type {Integer (Int32)}
     */
    static RM_SET_SEND_IF => 1007

    /**
     * @type {Integer (Int32)}
     */
    static RM_ADD_RECEIVE_IF => 1008

    /**
     * @type {Integer (Int32)}
     */
    static RM_DEL_RECEIVE_IF => 1009

    /**
     * @type {Integer (Int32)}
     */
    static RM_SEND_WINDOW_ADV_RATE => 1010

    /**
     * @type {Integer (Int32)}
     */
    static RM_USE_FEC => 1011

    /**
     * @type {Integer (Int32)}
     */
    static RM_SET_MCAST_TTL => 1012

    /**
     * @type {Integer (Int32)}
     */
    static RM_RECEIVER_STATISTICS => 1013

    /**
     * @type {Integer (Int32)}
     */
    static RM_HIGH_SPEED_INTRANET_OPT => 1014

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_DEFAULT_RATE_KBITS_PER_SEC => 56

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE => 15

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_WINDOW_INCREMENT_PERCENTAGE => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_DEFAULT_LATE_JOINER_PERCENTAGE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_MAX_LATE_JOINER_PERCENTAGE => 75

    /**
     * @type {Integer (UInt32)}
     */
    static BITS_PER_BYTE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOG2_BITS_PER_BYTE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UNIX_PATH_MAX => 108

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_AF_UNIX_GETPEERPID => 1476395264

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_AF_UNIX_SETBINDPARENTPATH => 2550137089

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_AF_UNIX_SETCONNPARENTPATH => 2550137090

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP0 => 25

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP1 => 26

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP2 => 27

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP3 => 28

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP4 => 29

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP => 29

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_CLTP => 30

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_CLNP => 31

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_X25 => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_INACT_NL => 33

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_ESIS => 34

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_INTRAISIS => 35

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_MAX_ADDR_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_HIERARCHICAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_NON_HIERARCHICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_EXP_DATA_USE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_EXP_DATA_NUSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NSPROTO_IPX => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static NSPROTO_SPX => 1256

    /**
     * @type {Integer (UInt32)}
     */
    static NSPROTO_SPXII => 1257

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_NAME_LENGTH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_UNIQUE_NAME => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_GROUP_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_TYPE_QUICK_UNIQUE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_TYPE_QUICK_GROUP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static VNSPROTO_IPC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static VNSPROTO_RELIABLE_IPC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static VNSPROTO_SPP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static _LITTLE_ENDIAN => 1234

    /**
     * @type {Integer (UInt32)}
     */
    static _BIG_ENDIAN => 4321

    /**
     * @type {Integer (UInt32)}
     */
    static _PDP_ENDIAN => 3412

    /**
     * @type {Integer (UInt32)}
     */
    static BYTE_ORDER => 1234

    /**
     * @type {Integer (UInt32)}
     */
    static DL_ADDRESS_LENGTH_MAXIMUM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DL_HEADER_LENGTH_MAXIMUM => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_DSAP => 170

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_SSAP => 170

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_CONTROL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_OUI => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ETH_LENGTH_OF_HEADER => 14

    /**
     * @type {Integer (UInt32)}
     */
    static ETH_LENGTH_OF_VLAN_HEADER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ETH_LENGTH_OF_SNAP_HEADER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_MINIMUM => 1536

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_IPV4 => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_ARP => 2054

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_IPV6 => 34525

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_802_1Q => 33024

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_802_1AD => 34984

    /**
     * @type {Integer (UInt32)}
     */
    static IP_VER_MASK => 240

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_VERSION => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IPV4_PACKET => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IPV4_HLEN => 60

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_MINIMUM_MTU => 576

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_MIN_MINIMUM_MTU => 352

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_MAX_MINIMUM_MTU => 576

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_ROUTING_HEADER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_TIMESTAMP_HEADER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_SECURITY => 11

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_STREAMIDENTIFIER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_ROUTERALERT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IP4_OFF_MASK => 65311

    /**
     * @type {Integer (UInt32)}
     */
    static ICMPV4_INVALID_PREFERENCE_LEVEL => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_QUERY_TYPE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_VERSION1_REPORT_TYPE => 18

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_VERSION2_REPORT_TYPE => 22

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_LEAVE_GROUP_TYPE => 23

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_VERSION3_REPORT_TYPE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_VERSION => 96

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_TRAFFIC_CLASS_MASK => 49167

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_FULL_TRAFFIC_CLASS_MASK => 61455

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_ECN_MASK => 12288

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_FLOW_LABEL_MASK => 4294905600

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IPV6_PAYLOAD => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_ECN_SHIFT => 12

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_MINIMUM_MTU => 1280

    /**
     * @type {Integer (UInt32)}
     */
    static IP6F_OFF_MASK => 63743

    /**
     * @type {Integer (UInt32)}
     */
    static IP6F_RESERVED_MASK => 1536

    /**
     * @type {Integer (UInt32)}
     */
    static IP6F_MORE_FRAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static EXT_LEN_UNIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_SKIP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_DISCARD => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_FORCEICMP => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_ICMP => 192

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_MUTABLE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_NOROUTE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_ADMIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_BEYONDSCOPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_ADDR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_NOPORT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_TIME_EXCEED_TRANSIT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_TIME_EXCEED_REASSEMBLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_HEADER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_NEXTHEADER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_OPTION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_FIRSTFRAGMENT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ICMPV6_ECHO_REQUEST_FLAG_REVERSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_MANAGED => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_OTHER => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_HOME_AGENT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_PREFERENCE => 24

    /**
     * @type {Integer (UInt32)}
     */
    static ND_NA_FLAG_ROUTER => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static ND_NA_FLAG_SOLICITED => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static ND_NA_FLAG_OVERRIDE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_ONLINK => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_AUTO => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_ROUTER_ADDR => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_SITE_PREFIX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_ROUTE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_RI_FLAG_PREFERENCE => 24

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_RDNSS_MIN_LEN => 24

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_DNSSL_MIN_LEN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN6_EMBEDDEDV4_UOCTET_POSITION => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN6_EMBEDDEDV4_BITS_IN_BYTE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TH_FIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TH_SYN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TH_RST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TH_PSH => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TH_ACK => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TH_URG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TH_ECE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TH_CWR => 128

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_EOL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_NOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_MSS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_WS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_SACK_PERMITTED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_SACK => 5

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_TS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_FASTOPEN => 34

    /**
     * @type {Integer (Int32)}
     */
    static INVALID_SOCKET => -1

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_INFINITE => 4294967295

    /**
     * @type {Integer (Int32)}
     */
    static WSA_INVALID_EVENT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_INOUT => 3221225472

    /**
     * @type {Integer (Int32)}
     */
    static FIONREAD => 1074030207

    /**
     * @type {Integer (Int32)}
     */
    static FIONBIO => -2147195266

    /**
     * @type {Integer (Int32)}
     */
    static FIOASYNC => -2147195267

    /**
     * @type {Integer (Int32)}
     */
    static SIOCSHIWAT => -2147192064

    /**
     * @type {Integer (Int32)}
     */
    static SIOCGHIWAT => 1074033409

    /**
     * @type {Integer (Int32)}
     */
    static SIOCSLOWAT => -2147192062

    /**
     * @type {Integer (Int32)}
     */
    static SIOCGLOWAT => 1074033411

    /**
     * @type {Integer (Int32)}
     */
    static SIOCATMARK => 1074033415

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_BROADCAST => 4294967295

    /**
     * @type {Integer (Int32)}
     */
    static SO_DONTLINGER => -129

    /**
     * @type {Integer (Int32)}
     */
    static SO_EXCLUSIVEADDRUSE => -5

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB_Extension => 128

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_PnP => 1

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_PDA_Palmtop => 2

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Computer => 4

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Printer => 8

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Modem => 16

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Fax => 32

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_LANAccess => 64

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB2_Telephony => 1

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB2_FileServer => 2
;@endregion Constants

;@region Methods
    /**
     * Retrieves information about available transport protocols.Note  This call is a strictly 32-bit version of WSCEnumProtocols for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs. .
     * @remarks
     * **WSCEnumProtocols32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * This function is used to discover information about the collection of transport protocols installed on the local computer. This function differs from its API counterpart (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a>) in that 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures for all installed protocols are returned. This includes protocols that the service provider has set the **PFL_HIDDEN** flag in the **dwProviderFlags** member of the **WSAPROTOCOL_INFOW** structure to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by **WSAEnumProtocols** function.  In addition, the **WSCEnumProtocols32** also returns data for **WSAPROTOCOL_INFOW** structures that have a chain length of zero ( a dummy LSP provider).   The **WSAEnumProtocols** only returns information on base protocols and protocol chains that lack the **PFL_HIDDEN** flag  and don't have a protocol chain length of zero. 
     * 
     * <div class="alert">**Note**  Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server 2012, use <a href="https://docs.microsoft.com/windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a>.</div>
     * <div> </div>
     * The <i>lpiProtocols</i> parameter can be used as a filter to constrain the amount of information provided. Typically, a NULL pointer is supplied so the function will return information on all available transport protocols.
     * 
     * A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structure is provided in the buffer pointed to by <i>lpProtocolBuffer</i> for each requested protocol. If the supplied buffer is not large enough (as indicated by the input value of <i>lpdwBufferLength</i>), the value pointed to by <i>lpdwBufferLength</i> will be updated to indicate the required buffer size. The Windows Sockets SPI client should then obtain a large enough buffer and call this function again. The 
     * **WSCEnumProtocols32** function cannot enumerate over multiple calls; the passed-in buffer must be large enough to hold all expected entries in order for the function to succeed. This reduces the complexity of the function and should not pose a problem because the number of protocols loaded on a computer is typically small.
     * 
     * The order in which the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider with the WS2_32.dll, or with any subsequent reordering that may have occurred through the Windows Sockets applet supplied for establishing default transport providers.
     * @param {Pointer<Int32>} lpiProtocols Null-terminated array of <i>iProtocol</i> values. This parameter is optional; if <i>lpiProtocols</i> is null, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolBuffer Buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, size of the <i>lpProtocolBuffer</i> buffer passed to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>, in bytes. On output, the minimum buffer size, in bytes, that can be passed to 
     * **WSCEnumProtocols** to retrieve all the requested information.
     * @param {Pointer<Int32>} lpErrno Pointer to the error code.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscenumprotocols32
     * @since windows6.0.6000
     */
    static WSCEnumProtocols32(lpiProtocols, lpProtocolBuffer, lpdwBufferLength, lpErrno) {
        DllCall("WS2_32.dll\WSCEnumProtocols32", "ptr", lpiProtocols, "ptr", lpProtocolBuffer, "ptr", lpdwBufferLength, "ptr", lpErrno)
    }

    /**
     * Removes the specified 32-bit transport provider from the system configuration database.
     * @remarks
     * **WSCDeinstallProvider32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscdeinstallprovider">WSCDeinstallProvider</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog.  Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The 
     * **WSCDeinstallProvider32** function removes the common Windows Sockets 2 configuration information for the specified 32-bit provider. After this routine completes successfully, the configuration information stored in the registry will be changed. However, any Ws2_32.dll instances currently in memory will not be able to recognize this change.
     * 
     * On success, **WSCDeinstallProvider32** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCDeinstallProvider32** function can only be called by a user logged on as a member of the Administrators group. If **WSCDeinstallProvider32** is called by a user that is not a member of the Administrators group, the function call will fail and **WSANO_RECOVERY** is returned in the <i>lpErrno</i> parameter. 
     *  
     * 
     * For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * 
     * The caller of this function must remove any additional files or service provider–specific configuration information that is needed to completely uninstall the service provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider. This value is stored within each 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscdeinstallprovider32
     * @since windows6.0.6000
     */
    static WSCDeinstallProvider32(lpProviderId, lpErrno) {
        DllCall("WS2_32.dll\WSCDeinstallProvider32", "ptr", lpProviderId, "ptr", lpErrno)
    }

    /**
     * Installs the specified transport service provider into the 32-bit and 64-bit system configuration databases on a 64-bit computer.
     * @remarks
     * **WSCInstallProvider64_32** is a basic version of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallproviderandchains64_32">WSCInstallProviderAndChains64_32</a> function that only installs a single transport service provider. **WSCInstallProvider64_32** can be used to install a base protocol, a layered protocol, or a protocol chain. If a layered service provider is being installed, then **WSCInstallProviderAndChains64_32** should be used because this function allows a layered protocol and one or more protocol chains to be installed with a single function call. To accomplish the same work using **WSCInstallProvider64_32** would require multiple function calls to install each service provider component.
     * 
     * Windows Sockets (Winsock) 2 accommodates the notion of a layered protocol. A layered protocol is one that implements only higher level communications functions while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol would be a security layer that adds  a protocol to the connection establishment process to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is fully capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * **WSCInstallProvider64_32** is the 64-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallprovider">WSCInstallProvider</a> that installs the provider into both the 32-bit and 64-bit catalogs on 64-bit platforms. That is, on 64-bit platforms, two Winsock catalogs are maintained, and both 32-bit and 64-bit processes are able to load the transport provider installed with this function. On 64-bit platforms, **WSCInstallProvider** installs only to the 64-bit Winsock catalog.
     * 
     * On a 64-bit computer, all calls not specifically designed for 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use **WSCInstallProvider64_32** to operate on both the 32-bit catalog as well as the 64-bit catalog, preserving compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * This routine creates the necessary common Winsock 2 configuration information for the specified provider. It is applicable to base protocols, layered protocols, and protocol chains.
     * 
     * The <i>lpProtocolInfoList</i> parameter contains a list of protocol entries to install. Callers of **WSCInstallProvider64_32**  are responsible for setting up the proper protocol entries. The <i>lpProtocolInfoList</i> parameter must not be **NULL**. 
     * 
     * After this routine completes successfully, the protocol information provided in <i>lpProtocolInfoList</i> will be returned by <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a>, <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a>. Be aware that in Windows, only instances of the Ws2_32.dll created by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> after a successful completion of this function will include the new entries in 
     * **WSAEnumProtocols**, **WSCEnumProtocols**, and **WSCEnumProtocols32**. <div class="alert">**Note**   The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function does not enumerate a layered protocol entry while <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> do.</div>
     * <div> </div>
     * 
     * 
     * On success, **WSCInstallProvider64_32** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCInstallProvider64_32** function can only be called by a user logged on as a member of the Administrators group. If **WSCInstallProvider64_32** is called by a user that is not a member of the Administrators group, the function call will fail and <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a> is returned in the <i>lpErrno</i> parameter. 
     *  For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (**RunAs administrator**) for this function to succeed.
     * 
     * 
     * 
     * Any file installation or service provider-specific configuration must be performed by the calling application.
     * 
     * If the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallprovider">WSCInstallProvider</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallproviderandchains">WSCInstallProviderAndChains</a> function is used, the function must be called once to install the provider in the 32-bit catalog and once to install the provider in the 64-bit catalog on a 64-bit platform.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Pointer<PWSTR>} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure defines a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallprovider64_32
     * @since windows5.1.2600
     */
    static WSCInstallProvider64_32(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        DllCall("WS2_32.dll\WSCInstallProvider64_32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "ptr", lpErrno)
    }

    /**
     * Retrieves the DLL path for the specified 32-bit provider.Note  This call is a strictly 32-bit version of WSCGetProviderPath for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs. .
     * @remarks
     * **WSCGetProviderPath32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscgetproviderpath">WSCGetProviderPath</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The 
     * **WSCGetProviderPath32** function retrieves the DLL path for the specified provider. The DLL path can contain embedded environment strings, such as %SystemRoot%, and thus should be expanded prior to being used with the Windows <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function. For more information, see **LoadLibrary**.
     * @param {Pointer<Guid>} lpProviderId Locally unique identifier of the provider. This value is obtained by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a>.
     * @param {Pointer<PWSTR>} lpszProviderDllPath Pointer to a buffer into which the provider DLL's path string is returned. The path is a null-terminated string and any embedded environment strings, such as %SystemRoot%, have not been expanded.
     * @param {Pointer<Int32>} lpProviderDllPathLen Size of the buffer pointed to by the <i>lpszProviderDllPath</i> parameter, in characters.
     * @param {Pointer<Int32>} lpErrno Pointer to the error code.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscgetproviderpath32
     * @since windows6.0.6000
     */
    static WSCGetProviderPath32(lpProviderId, lpszProviderDllPath, lpProviderDllPathLen, lpErrno) {
        DllCall("WS2_32.dll\WSCGetProviderPath32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProviderDllPathLen, "ptr", lpErrno)
    }

    /**
     * Modifies the specified 32-bit transport provider in the system configuration database.Note  This call is a strictly 32-bit version of WSCUpdateProvider for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs. .
     * @remarks
     * **WSCUpdateProvider32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscupdateprovider">WSCUpdateProvider</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * This function modifies Windows Sockets 2 configuration information for the specified 32-bit provider. It is applicable to base protocols, layered protocols, and protocol chains.
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * On success, **WSCUpdateProvider32** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCUpdateProvider32** function can only be called by a user logged on as a member of the Administrators group. If **WSCUpdateProvider32** is called by a user that is not a member of the Administrators group, the function call will fail. 
     *  
     * 
     * For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (**RunAs administrator**) for this function to succeed.
     * 
     * 
     * 
     * Any file installation or service provider-specific configuration must be performed by the caller.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Pointer<PWSTR>} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure specifies or modifies a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscupdateprovider32
     * @since windows6.0.6000
     */
    static WSCUpdateProvider32(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        DllCall("WS2_32.dll\WSCUpdateProvider32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "ptr", lpErrno)
    }

    /**
     * Sets the data value for specified information class for a layered service provider (LSP).
     * @remarks
     * **WSCSetProviderInfo32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscsetproviderinfo">WSCSetProviderInfo</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * **WSCSetProviderInfo32** is used to set the information class data for a 32-bit layered service provider. When the <i>InfoType</i> parameter is set to **ProviderInfoLspCategories**, on success **WSCSetProviderInfo32** sets appropriate LSP category flags implemented by the provider based on the value passed in the <i>Info</i> parameter. 
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions.  These functions will be called during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.dll).  
     * 
     * An LSP that implements an installable file system (IFS) can  selectively choose to provide pointers to functions which are implemented by itself, or pass back the pointers provided by the layer directly below the LSP.  Non-IFS LSPs, because they provide their own handles, must implement all of the Winsock SPI functions.  This is because each SPI will require the LSP to map all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
     * 
     * However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.
     * 
     * It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra processing performed for each of those functions.
     * 
     * By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine if an LSP should be involved in a given process at runtime.
     * 
     * On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP category is an identifiable group of behaviors on a subset of Winsock SPI functions.  For example, an HTTP content filter would be categorized as a data inspector (the **LSP_INSPECTOR** category). The **LSP_INSPECTOR** category will inspect, but not alter, parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP based on the LSP category and the application's set of permitted LSP categories.  
     * 
     * The following table lists categories into which an LSP can be classified.<table>
     * <tr>
     * <th>LSP Category</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>**LSP_CRYPTO_COMPRESS**</td>
     * <td>The LSP is a cryptography or data compression provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_FIREWALL**</td>
     * <td>The LSP is a firewall provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_LOCAL_CACHE**</td>
     * <td>The LSP is a local cache provider.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_INBOUND_MODIFY**</td>
     * <td>The LSP modifies inbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_INSPECTOR**</td>
     * <td>The LSP inspects or filters data.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_OUTBOUND_MODIFY**</td>
     * <td>The LSP modifies outbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_PROXY**</td>
     * <td>The LSP acts as a proxy and redirects packets.</td>
     * </tr>
     * <tr>
     * <td>**LSP_REDIRECTOR**</td>
     * <td>The LSP is a network redirector.</td>
     * </tr>
     * <tr>
     * <td>**LSP_SYSTEM**</td>
     * <td>The LSP is acceptable for use in services and system processes.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * An LSP may belong to more than one category.  For example, firewall/security LSP could belong to both the inspector (**LSP_INSPECTOR**) and firewall (**LSP_FIREWALL**) categories.
     * 
     * If an LSP does not have category set, it is considered to be in the All Other category. This LSP category will not be loaded in services or system processes (for example, lsass, winlogon, and many svchost processes).
     * 
     * The **WSCSetProviderInfo32** function can only be called by a user logged on as a member of the Administrators group. If **WSCSetProviderInfo32** is called by a user that is not a member of the Administrators group, the function call will fail and **WSANO_RECOVERY** is returned in the <i>lpErrno</i> parameter. 
     *  This function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class to be set for this LSP protocol entry.
     * @param {Pointer<Byte>} Info A pointer to a buffer that contains the information class data to set for the LSP protocol entry.
     * @param {Pointer} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info</i> parameter.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCSetProviderInfo32** function call.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscsetproviderinfo32
     * @since windows6.0.6000
     */
    static WSCSetProviderInfo32(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        DllCall("WS2_32.dll\WSCSetProviderInfo32", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr", InfoSize, "uint", Flags, "ptr", lpErrno)
    }

    /**
     * Retrieves the data associated with an information class for a 32-bit layered service provider (LSP).Note  This call is a strictly 32-bit version of WSCGetProviderInfo for use on 64-bit platforms.
     * @remarks
     * **WSCGetProviderInfo32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscgetproviderinfo">WSCGetProviderInfo</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * **WSCGetProviderInfo32** is used to retrieve information class data for a protocol entry on a 32-bit layered service provider. When the <i>InfoType</i> parameter is set to **ProviderInfoLspCategories**, on success **WSCGetProviderInfo32** returns with the <i>Info</i> parameter set with appropriate LSP category flags implemented by 32-bit LSP. 
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions.  These functions will be called during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.DLL).  
     * 
     * An LSP that implements an installable file system (IFS) can  selectively choose to provide pointers to functions which are implemented by itself, or pass back the pointers provided by the layer directly below the LSP.  Non-IFS LSPs, because they provide their own handles, must implement all of the Winsock SPI functions.  This is because each SPI will require the LSP to map all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
     * 
     * However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.  
     * 
     * It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra processing performed for each of those functions.
     * 
     * By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine if an LSP should be involved in a given process at runtime.
     * 
     * On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP category is an identifiable group of behaviors on a subset of Winsock SPI functions.  For example, an HTTP content filter would be categorized as a data inspector (the **LSP_INSPECTOR** category). The **LSP_INSPECTOR** category will inspect, but not alter, parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP based on the LSP category and the application's set of permitted LSP categories.
     * 
     * The following table lists categories into which an LSP can be classified.<table>
     * <tr>
     * <th>LSP Category</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>**LSP_CRYPTO_COMPRESS**</td>
     * <td>The LSP is a cryptography or data compression provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_FIREWALL**</td>
     * <td>The LSP is a firewall provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_LOCAL_CACHE**</td>
     * <td>The LSP is a local cache provider.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_INBOUND_MODIFY**</td>
     * <td>The LSP modifies inbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_INSPECTOR**</td>
     * <td>The LSP inspects or filters data.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_OUTBOUND_MODIFY**</td>
     * <td>The LSP modifies outbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_PROXY**</td>
     * <td>The LSP acts as a proxy and redirects packets.</td>
     * </tr>
     * <tr>
     * <td>**LSP_REDIRECTOR**</td>
     * <td>The LSP is a network redirector.</td>
     * </tr>
     * <tr>
     * <td>**LSP_SYSTEM**</td>
     * <td>The LSP is acceptable for use in services and system processes.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * An LSP may belong to more than one category.  For example, a firewall/security LSP could belong to both the inspector (**LSP_INSPECTOR**) and firewall (**LSP_FIREWALL**) categories.
     * 
     * If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded in services or system processes (for example, lsass, winlogon, and many svchost processes).
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class that is requested for this LSP protocol entry.
     * @param {Pointer<Byte>} Info A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is **NULL**, then **WSCGetProviderInfo32** returns failure and the size required for this buffer is returned in the <i>InfoSize</i> parameter.
     * @param {Pointer<UIntPtr>} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info</i> parameter. If the Info parameter is **NULL**, then  **WSCGetProviderInfo32** returns failure and the <i>InfoSize</i> parameter will receive the size of the required buffer.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCGetProviderInfo32** function call.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscgetproviderinfo32
     * @since windows6.0.6000
     */
    static WSCGetProviderInfo32(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        DllCall("WS2_32.dll\WSCGetProviderInfo32", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr", InfoSize, "uint", Flags, "ptr", lpErrno)
    }

    /**
     * Returns information on available 32-bit namespace providers.Note  This call is a strictly 32-bit version of WSAEnumNameSpaceProviders for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs. .
     * @remarks
     * **WSCEnumNameSpaceProviders32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The 32-bit SPI function is equivalent to the native API function (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a>) because there is no concept of a "hidden" namespace provider.
     * 
     * The **WSCEnumNameSpaceProviders32** function is a Unicode only function and returns <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEXW</a> structures.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to **WSCEnumNameSpaceProviders32** must be sufficient to hold all of the namespace information.
     * @param {Pointer<WSANAMESPACE_INFOW>} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFOW</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * **WSCEnumNameSpaceProviders32**.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscenumnamespaceproviders32
     * @since windows6.0.6000
     */
    static WSCEnumNameSpaceProviders32(lpdwBufferLength, lpnspBuffer) {
        DllCall("WS2_32.dll\WSCEnumNameSpaceProviders32", "ptr", lpdwBufferLength, "ptr", lpnspBuffer)
    }

    /**
     * Retrieves information on available 32-bit namespace providers.
     * @remarks
     * **WSCEnumNameSpaceProvidersEx32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa">WSAEnumNameSpaceProvidersEx</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     *   Currently, the only namespace included with Windows that uses information in the **ProviderSpecific** member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEXW</a> structure are namespace providers for the NS_EMAIL namespace. The format of the **ProviderSpecific** member for an NS_EMAIL namespace provider is a <a href="https://docs.microsoft.com/windows/desktop/api/nsemail/ns-nsemail-napi_provider_installation_blob">NAPI_PROVIDER_INSTALLATION_BLOB</a> structure.
     * 
     * The 32-bit SPI function is equivalent to the native API function (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa">WSAEnumNameSpaceProvidersEx</a>) because there is no concept of a "hidden" namespace provider.
     * 
     * The provider-specific data blob associated with namespace entry
     *                      passed in the <i>lpProviderInfo</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespaceex32">WSCInstallNameSpaceEx32</a> function can be queried using **WSCEnumNameSpaceProvidersEx32** function.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to **WSCEnumNameSpaceProvidersEx32** must be sufficient to hold all of the namespace information.
     * @param {Pointer<WSANAMESPACE_INFOEXW>} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEXW</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * **WSCEnumNameSpaceProvidersEx32**.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscenumnamespaceprovidersex32
     * @since windows6.0.6000
     */
    static WSCEnumNameSpaceProvidersEx32(lpdwBufferLength, lpnspBuffer) {
        DllCall("WS2_32.dll\WSCEnumNameSpaceProvidersEx32", "ptr", lpdwBufferLength, "ptr", lpnspBuffer)
    }

    /**
     * Installs a specified 32-bit namespace provider. (WSCInstallNamespace32)
     * @remarks
     * **WSCInstallNameSpace32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace">WSCInstallNameSpace</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The namespace configuration functions do not affect applications that are already running. Newly installed namespace providers will not be visible to applications nor will the changes in a namespace provider's activation state. Applications launched after the call to 
     * **WSCInstallNameSpace32** will recognize the changes.
     * 
     * The **WSCInstallNameSpace32** function can only be called by a user logged on as a member of the Administrators group. If **WSCInstallNameSpace32** is called by a user that is not a member of the Administrators group, the function call will fail. 
     *  For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (**RunAs administrator**) for this function to succeed.
     * @param {Pointer<PWSTR>} lpszIdentifier A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the <i>lpProviderId</i> parameter.
     * @param {Pointer<PWSTR>} lpszPathName A pointer to a string that contains the path to the provider's DLL image. The string observes the usual rules for path resolution: this path can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded whenever the WS2_32.DLL must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string into the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function to load the provider into memory. For more information, see **LoadLibrary**.
     * @param {Integer} dwNameSpace A descriptor that specifies the namespace supported by this provider.
     * @param {Integer} dwVersion A descriptor that specifies the version number of the provider.
     * @param {Pointer<Guid>} lpProviderId A unique identifier for this provider. This GUID should be generated by Uuidgen.exe.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallnamespace32
     * @since windows6.0.6000
     */
    static WSCInstallNameSpace32(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId) {
        DllCall("WS2_32.dll\WSCInstallNameSpace32", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId)
    }

    /**
     * Installs a specified 32-bit namespace provider. (WSCInstallNameSpaceEx32)
     * @remarks
     * **WSCInstallNameSpaceEx32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespaceex">WSCInstallNameSpaceEx</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The namespace–configuration functions do not affect applications that are already running. Newly installed name-space providers will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched after the call to 
     * **WSCInstallNameSpaceEx32** will see the changes.
     * 
     * The provider-specific data blob associated with namespace entry
     *                      passed in the <i>lpProviderInfo</i> parameter can be queried using <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceprovidersex32">WSCEnumNameSpaceProvidersEx32</a> function.
     * 
     * Currently, the only namespace provider included with Windows that uses the <i>lpProviderInfo</i> parameter is the NS_EMAIL provider. The format of the buffer pointed to by the <i>lpProviderInfo</i> parameter for an NS_EMAIL namespace provider is a <a href="https://docs.microsoft.com/windows/desktop/api/nsemail/ns-nsemail-napi_provider_installation_blob">NAPI_PROVIDER_INSTALLATION_BLOB</a> structure. 
     * 
     * The **WSCInstallNameSpaceEx32**function can only be called by a user logged on as a member of the Administrators group. If **WSCInstallNameSpaceEx32** is called by a user that is not a member of the Administrators group, the function call will fail. 
     *  For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * @param {Pointer<PWSTR>} lpszIdentifier A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the <i>lpProviderId</i> parameter.
     * @param {Pointer<PWSTR>} lpszPathName A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Integer} dwNameSpace The namespace supported by this provider.
     * @param {Integer} dwVersion The version number of the provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID  for the provider. This GUID should be generated by Uuidgen.exe.
     * @param {Pointer<BLOB>} lpProviderSpecific A provider-specific data blob associated with namespace entry.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallnamespaceex32
     * @since windows6.0.6000
     */
    static WSCInstallNameSpaceEx32(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId, lpProviderSpecific) {
        DllCall("WS2_32.dll\WSCInstallNameSpaceEx32", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId, "ptr", lpProviderSpecific)
    }

    /**
     * Uninstalls a specific 32-bit namespace provider.
     * @remarks
     * **WSCUnInstallNameSpace32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscuninstallnamespace">WSCUnInstallNameSpace</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The namespace configuration functions do not affect applications that are already running. Newly installed name-space providers will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched after the call to 
     * **WSCUnInstallNameSpace32** will recognize the changes.
     * 
     * On success, **WSCUnInstallNameSpace32** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCUnInstallNameSpace32** function can only be called by a user logged on as a member of the Administrators group. If **WSCUnInstallNameSpace32** is called by a user that is not a member of the Administrators group, the function call will fail and **WSANO_RECOVERY** is returned in the <i>lpErrno</i> parameter.
     * 
     * For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * 
     * The caller of this function must remove any additional files or service provider–specific configuration information that is required to completely uninstall the service provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the name-space provider to be uninstalled.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscuninstallnamespace32
     * @since windows6.0.6000
     */
    static WSCUnInstallNameSpace32(lpProviderId) {
        DllCall("WS2_32.dll\WSCUnInstallNameSpace32", "ptr", lpProviderId)
    }

    /**
     * Enables or disables a specified 32-bit namespace provider.
     * @remarks
     * The 
     * **WSCEnableNSProvider32** function is intended to be used to change the state of the namespace providers. An independent software vendor (ISV) should not normally de-activate another ISV's namespace provider in order to activate its own. The choice should be left to the user.    
     * 
     * **WSCEnableNSProvider32** is a strictly 32-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenablensprovider">WSCEnableNSProvider</a>. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The namespace configuration functions do not affect applications that are already running. Newly installed namespace providers will not be visible to applications nor will the changes in a namespace provider's activation state. Applications launched after the call to 
     * **WSCEnableNSProvider32** will see the changes.
     * 
     * The **WSCEnableNSProvider32** function can only be called by a user logged on as a member of the Administrators group. If **WSCEnableNSProvider32** is called by a user that is not a member of the Administrators group, the function call will fail.
     * 
     * For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the namespace provider.
     * @param {Integer} fEnable A Boolean value that, if **TRUE**, the namespace provider is set to the active state. If **FALSE**, the namespace provider is disabled and will not be available for query operations or service registration.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscenablensprovider32
     * @since windows6.0.6000
     */
    static WSCEnableNSProvider32(lpProviderId, fEnable) {
        DllCall("WS2_32.dll\WSCEnableNSProvider32", "ptr", lpProviderId, "int", fEnable)
    }

    /**
     * Installs the specified transport provider and its specific protocol chains into both the 32-bit and 64-bit Winsock 2 system configuration databases on a 64-bit computer.
     * @remarks
     * **WSCInstallProviderAndChains64_32** is an enhanced version of the basic <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallprovider64_32">WSCInstallProvider64_32</a> function used to install a single transport service provider. If a layered service provider is being installed, then **WSCInstallProviderAndChains64_32** should be used.  **WSCInstallProviderAndChains64_32** can install a layered protocol and one or more protocol chains with a single function call. To accomplish the same work using **WSCInstallProvider64_32** would require multiple function calls.
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol would be a security layer that adds a  protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * **WSCInstallProviderAndChains64_32** is the 64-bit version of <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallproviderandchains">WSCInstallProviderAndChains</a>. It installs the provider into both the 32-bit and 64-bit catalogs on 64-bit platforms. This means that on 64-bit platforms, two Winsock catalogs are maintained, and that both 32-bit and 64-bit processes are able to load the LSP installed with this function.
     * 
     * On a 64-bit computer, all calls not specifically designed for 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use **WSCInstallProviderAndChains64_32** to operate on both the 32-bit catalog as well as the 64-bit catalog, preserving compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * 
     * <div class="alert">**Note**   On 64-bit platforms, there is no **WSCInstallProviderAndChains** function to install only in the 64-bit catalog. On 64-bit platforms, there must be both a 32-bit and 64-bit version of the LSP installed. For providers that must install only in the 64-bit Winsock catalog, the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallprovider">WSCInstallProvider</a> function can be used.</div>
     * <div> </div>
     * 
     * 
     * If <i>lpProtocolInfoList</i> is set to **NULL**, this function creates protocol chains where the provider is layered over the base protocol for each unique protocol type as defined by the address family, socket type, and protocol. This eliminates the creation of any inaccessible duplicate provider entries.
     * 
     * If <i>lpProtocolInfoList</i> is set to a non-**NULL** value, this function creates protocol chains by obtaining the top-most entry  in the configuration information that matches the <i>{address family, socket type, protocol}</i> tuple from each element in the provided array. Again, only the <i>{address family, socket type, protocol}</i> tuple  is considered; all other members and duplicates are ignored.
     * 
     * Upon successful completion of this call, any subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a>, <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> will return the newly created protocol chain entries. Be aware that in Windows environments, only instances of <i>Ws_32.dll</i> created by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> after the successful completion  of **WSCInstallProviderAndChains64_32** will include the new entries when **WSAEnumProtocols**, **WSCEnumProtocols**, and **WSCEnumProtocols32** returns. <div class="alert">**Note**   The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function does not enumerate a layered protocol entry while <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> do.</div>
     * <div> </div>
     * 
     * 
     * On success, **WSCInstallProviderAndChains64_32** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCInstallProviderAndChains64_32** function can only be called by a user logged on as a member of the Administrators group. If **WSCInstallProviderAndChains64_32** is called by a user that is not a member of the Administrators group, the function call will fail and <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a> is returned in the <i>lpErrno</i> parameter. 
     *  For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (**RunAs administrator**) for this function to succeed.
     * 
     * Any file installation or provider-specific configuration must be performed by the calling application.
     * 
     * <h3><a id="IFS_and_Non-IFS_Providers"></a><a id="ifs_and_non-ifs_providers"></a><a id="IFS_AND_NON-IFS_PROVIDERS"></a>IFS and Non-IFS Providers</h3>
     * An IFS provider is one that returns native operating system handles. Typically these handles are associated with kernel mode protocol drivers. For example, the base TCP/IPv4, UDP/IPv4, TCP/IPv6, and UDP/IPv6 are IFS providers as these entries correspond to a kernel mode component. IFS handles can be used in **ReadFile**, **WriteFile**, and **CancelIo** function calls. A layered service provider that is an IFS provider simply returns the socket handle created from the lower provider (which must also be an IFS provider) directly to the calling application. An IFS LSP cannot intercept completion notifications for Winsock calls.
     * 
     * A non-IFS provider is one that creates an intermediate handle with <a href="https://docs.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wpucreatesockethandle">WPUCreateSocketHandle</a> and returns this handle to the caller. This allows a non-IFS LSP to intercept send and receive completion events before the calling applications to allow for post processing (for example, decrypting a received chunk of data). Non-IFS socket handles can be used in calls to **ReadFile** and **WriteFile**, but cannot be used with **CancelIo**. The only guaranteed method of canceling an operation on a non-IFS handle is by closing the socket with <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>.
     * 
     * <h3><a id="Paths_for_32-bit_and_64-bit_Provider_DLLs"></a><a id="paths_for_32-bit_and_64-bit_provider_dlls"></a><a id="PATHS_FOR_32-BIT_AND_64-BIT_PROVIDER_DLLS"></a>Paths for 32-bit and 64-bit Provider DLLs</h3>
     * <i>lpszProviderDllPath</i> represents the fully qualified path to the 64-bit version of the provider DLL. This parameter can contain embedded environment strings (such as <i>%SystemRoot%</i>). 
     * 
     * <i>lpszProviderDllPath32</i> represents the fully qualified path to the 32-bit version of the provider DLL. This parameter can contain embedded environment strings (such as <i>%SystemRoot%</i>).
     * 
     * If <i>lpszProviderDllPath32</i> is **NULL**, then <i>lpszProviderDllPath</i> is the path for both 32 and 64 bit providers.  When a 32-bit process on a 64-bit computer is running (for example, when a Winsock application loads the 32-bit version of an LSP), it attempts to load the 32-bit provider specified in <i>lpszProviderDllPath</i>.  If <i>lpszProviderDllPath32</i> is **NULL**, then the <i>lpszProviderDllPath</i> parameter must be set to <i>%windir%\system32\&lt;dllname&gt;</i>.  If this is not the case, the call fails with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a>.  If the path in <i>lpszProviderDllPath</i> is <i>%windir%\system32\&lt;dllname&gt;</i> when <i>lpszProviderDllPath32</i> is **NULL**, the call will be redirected (using the file system redirector) to the directory returned by **GetSystemWow64Directory** where the 32-bit LSP must reside. For Windows XP 64-bit edition, Windows Server 2003 and Windows Vista, this directory is <i>%windir%\syswow64</i>.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID) for the provider.
     * @param {Pointer<PWSTR>} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the <i>Ws2_32.dll</i> must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the <i>Ws2_32.dll</i> passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * 
     * <div class="alert">**Note**  If <i>lpszProviderDllPath32</i> is set to **NULL** then <i>lpszProviderDllPath</i> must be set to <i>%windir%\system32\&lt;dllname&gt;</i>.  If not, the call fails and returns the <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a> error code.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpszProviderDllPath32 A pointer to a Unicode string that contains the fully qualified path to the provider 32-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the <i>Ws2_32.dll</i> subsequently loads the provider DLL on behalf of an application. After any embedded environment strings are expanded, the <i>Ws2_32.dll</i> passes the resulting string into the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function to load the provider into memory. For more information, see **LoadLibrary**.
     * 
     * <div class="alert">**Note**  If this parameter is set to **NULL**, the 64-bit provider must exist in the <i>%windir%\system32</i> folder and the 32-bit provider must reside in the <i>%windir%\syswow64</i> folder.</div>
     * <div> </div>
     * @param {Pointer<PWSTR>} lpszLspName A pointer to a Unicode string that contains the name of the layered service provider (LSP).
     * @param {Integer} dwServiceFlags The service flags for the type of layered protocol catalog entry to be created. A layered protocol entry is  a <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure with the **ChainLen** member set to 0. The actual catalog entry for the LSP will reference the ID of this layered protocol entry in its **ProtocolChain** member.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="XP1_IFS_HANDLES"></a><a id="xp1_ifs_handles"></a><dl>
     * <dt><b>XP1_IFS_HANDLES</b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The catalog entry is for an Installable File System (IFS) LSP, which returns IFS-specific socket handles. An IFS LSP cannot intercept the completion of Winsock calls, and does not have to implement all of the Winsock functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure defines a  protocol, address family, and socket type supported by the provider. The members of the **WSAPROTOCOL_INFO** structure that are examined are **iProtocol**, **iAddressFamily**, and  **iSocketType**.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<UInt32>} lpdwCatalogEntryId A pointer to the newly installed layered protocol entry for the transport provider in the Winsock 2 system configuration database. This was the ID used to build the protocol chain entries installed in the catalog for the LSP.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code generated by the call if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallproviderandchains64_32
     * @since windows6.0.6000
     */
    static WSCInstallProviderAndChains64_32(lpProviderId, lpszProviderDllPath, lpszProviderDllPath32, lpszLspName, dwServiceFlags, lpProtocolInfoList, dwNumberOfEntries, lpdwCatalogEntryId, lpErrno) {
        DllCall("WS2_32.dll\WSCInstallProviderAndChains64_32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpszProviderDllPath32, "ptr", lpszLspName, "uint", dwServiceFlags, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "ptr", lpdwCatalogEntryId, "ptr", lpErrno)
    }

    /**
     * Used to reorder the available 32-bit transport providers.
     * @remarks
     * The <b>WSCWriteProviderOrder32</b> function is a strictly 32-bit version of the <a href="https://docs.microsoft.com/windows/desktop/api/sporder/nf-sporder-wscwriteproviderorder">WSCWriteProviderOrder</a> function. On a 64-bit computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
     * 
     * The order in which transport service providers are initially installed governs the order in which they are enumerated through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> at the service provider interface, or through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> at the application interface. More importantly, this order also governs the order in which protocols and service providers are considered when a client requests creation of a socket based on its address family, type, and protocol identifier.
     * 
     * Windows Sockets 2 includes an application called Sporder.exe that allows the catalog of installed protocols to be reordered interactively after protocols have already been installed. Windows Sockets 2 also includes an auxiliary DLL, <i>Sporder.dll</i> that exports this procedural interface for reordering protocols. This interface can be imported by linking with <i>Sporder.lib</i>.
     * 
     * 
     * The following are scenarios in which the 
     * <b>WSCWriteProviderOrder32</b> function could fail:
     * 
     * <ul>
     * <li>The <i>dwNumberOfEntries</i> parameter is not equal to the number of registered service providers.</li>
     * <li>The <i>lpwdCatalogEntryId</i> contains an invalid catalog identifier.</li>
     * <li>The <i>lpwdCatalogEntryId</i> does not contain all valid catalog identifiers exactly one time.</li>
     * <li>The routine is not able to access the registry for some reason (for example, inadequate user permissions).</li>
     * <li>Another process (or thread) is currently calling the function.</li>
     * </ul>
     * 
     * 
     * On success, <b>WSCWriteProviderOrder32</b> will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The <b>WSCWriteProviderOrder32</b> function can only be called by a user logged on as a member of the Administrators group. If <b>WSCWriteProviderOrder32</b> is called by a user that is not a member of the Administrators group, the function call will fail and 
     * 								<a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a> is returned. 
     *  For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to <b>requireAdministrator</b>. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (<b>RunAs administrator</b>) for this function to succeed.
     * @param {Pointer<UInt32>} lpwdCatalogEntryId A pointer to an array of <b>CatalogEntryId</b> elements found in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The order of the <b>CatalogEntryId</b> elements is the new priority ordering for the protocols.
     * @param {Integer} dwNumberOfEntries The number of elements in the <i>lpwdCatalogEntryId</i> array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/sporder/nf-sporder-wscwriteproviderorder32
     * @since windows6.0.6000
     */
    static WSCWriteProviderOrder32(lpwdCatalogEntryId, dwNumberOfEntries) {
        DllCall("WS2_32.dll\WSCWriteProviderOrder32", "ptr", lpwdCatalogEntryId, "uint", dwNumberOfEntries)
    }

    /**
     * Changes the order of available Windows Sockets (Winsock) 2 namespace providers in a 32-bit catalog.
     * @remarks
     * Namespace providers are installed on 64-bit platforms in a 32-bit namespace provider catalog using the  <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace32">WSCInstallNameSpace32</a> function. The order in which namespace providers in a 32-bit catalog are initially installed governs the default order in which they are enumerated through 
     *   <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceproviders32">WSCEnumNameSpaceProviders32</a>.  More importantly, this order also governs the order in which namespace providers are considered when a client requests name resolution. On 64-bit platforms, the <b>WSCWriteNameSpaceOrder32</b> function is provided to allow 64-bit processes to change the order of namespace providers in the 32-bit namespace provider catalog. The order of namespace providers in the native catalog can be changed using the <a href="https://docs.microsoft.com/windows/desktop/api/sporder/nf-sporder-wscwritenamespaceorder">WSCWriteNameSpaceOrder</a> function. 
     * 
     * The current namespace provider catalog is stored in the registry under the following registry key: <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>Current Control Set</b>&#92;<b>Services</b>&#92;<b>Winsock2</b>&#92;<b>Parameters</b>&#92;<b>NameSpace_Catalog5</b>
     * 
     * 
     * 
     * A client request for name resolution uses the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupserviceend">WSALookupServiceEnd</a> routines. The <b>dwNameSpace</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure passed to <b>WSALookupServiceBegin</b> is set to the identifier of a single namespace (<b>NS_DNS</b>, for example) in which to constrain the search, or <b>NS_ALL</b> to include all namespaces. If multiple namespace providers support a specific namespace (for example, <b>NS_DNS</b>), then the results from all namespace providers that match the requested <b>dwNameSpace</b> are returned unless the <b>lpNSProviderId</b> 
     * member is set to a specific namespace provider. The results from all namespace providers is returned if <b>NS_ALL</b> is specified for the <b>dwNameSpace</b> member. The order that the results are returned depends on the namespace provider order in the catalog.
     * 
     * The Windows SDK includes an application called SpOrder.exe that allows the catalog of installed namespace providers to be displayed. Winsock 2 includes the ws2_32.DLL on 64-bit platforms that exports the  <b>WSCWriteNameSpaceOrder32</b> function for reordering namespace providers in the 32-bit namespace provider  catalog. This interface can be imported by linking with WS2_32.lib. For computers running on Windows XP with Service Pack 2 (SP2) and Windows Server 2003 with Service Pack 1 (SP1) and later,  the <b>netsh.exe winsock show catalog</b> command will display both the protocol and namespace providers installed. The native 64-bit catalog is displayed first followed by the 32-bit provider catalogs (denoted with a 32 after their name).
     * 
     * <b>WSCWriteNameSpaceOrder32</b> can only be called by a user logged on as a member of the Administrators group. If <b>WSCWriteNameSpaceOrder32</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>WSANO_RECOVERY</b> is returned in the lpErrno parameter.
     * 
     * For computers running on Windows Vista and Windows Vista, this function can also fail because of user account control (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to <b>requireAdministrator</b>. If the application on Windows Vista and Windows Vista lacks this setting in the manifest file used to build the executable file, a user logged on as a member of the Administrators group other than the Administrator must then be executing the application in an enhanced shell as the  Administrator (<b>RunAs administrator</b>) for this function to succeed.
     * 
     * The following list describes scenarios in which the 
     * <b>WSCWriteNameSpaceOrder32</b> function could fail:
     * 
     * <ul>
     * <li>The <i>dwNumberOfEntries</i> parameter is not equal to the number of registered namespace providers.</li>
     * <li>The <b>NSProviderId</b> array contains an invalid namespace provider identifier.</li>
     * <li>The <b>NSProviderId</b> array does not contain all valid namespace provider identifiers exactly one time.</li>
     * <li>The function is not able to access the registry for some reason (insufficient user permissions, for example).</li>
     * <li>Another process, or thread, is currently calling the function.</li>
     * </ul>
     * @param {Pointer<Guid>} lpProviderId An array of <b>NSProviderId</b> elements as found in the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structure.  The order of the <b>NSProviderId</b> elements is the new
     *       priority ordering for the namespace providers.
     * @param {Integer} dwNumberOfEntries The number of elements in the <b>NSProviderId</b> array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/sporder/nf-sporder-wscwritenamespaceorder32
     * @since windows6.0.6000
     */
    static WSCWriteNameSpaceOrder32(lpProviderId, dwNumberOfEntries) {
        DllCall("WS2_32.dll\WSCWriteNameSpaceOrder32", "ptr", lpProviderId, "uint", dwNumberOfEntries)
    }

    /**
     * The __WSAFDIsSet function (winsock.h) specifies whether a socket is included in a set of socket descriptors.
     * @remarks
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} fd 
     * @param {Pointer<FD_SET>} param1 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-__wsafdisset
     * @since windows8.1
     */
    static __WSAFDIsSet(fd, param1) {
        DllCall("WS2_32.dll\__WSAFDIsSet", "ptr", fd, "ptr", param1)
    }

    /**
     * The accept function permits an incoming connection attempt on a socket.
     * @remarks
     * The 
     * <b>accept</b> function extracts the first connection on the queue of pending connections on socket <i>s</i>. It then creates and returns a handle to the new socket. The newly created socket is the socket that will handle the actual connection; it has the same properties as socket <i>s</i>, including the asynchronous events registered with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> functions.
     * 
     * The 
     * <b>accept</b> function can block the caller until a connection is present if no pending connections are present on the queue, and the socket is marked as blocking. If the socket is marked as nonblocking and no pending connections are present on the queue, 
     * <b>accept</b> returns an error as described in the following. After the successful completion of 
     * <b>accept</b> returns a new socket handle, the accepted socket cannot be used to accept more connections. The original socket remains open and listens for new connection requests.
     * 
     * The parameter <i>addr</i> is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer. The exact format of the <i>addr</i> parameter is determined by the address family in which the communication is occurring. The <i>addrlen</i> is a value-result parameter; it should initially contain the amount of space pointed to by <i>addr</i>; on return it will contain the actual length (in bytes) of the address returned.
     * 
     * The 
     * <b>accept</b> function is used with connection-oriented socket types such as SOCK_STREAM. If <i>addr</i> and/or <i>addrlen</i> are equal to <b>NULL</b>, then no information about the remote address of the accepted socket is returned.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>accept</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>accept</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor that identifies a socket that has been placed in a listening state with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function. The connection is actually made with the socket that is returned by 
     * <b>accept</b>.
     * @param {Pointer<SOCKADDR>} addr An optional pointer to a buffer that receives the address of the connecting entity, as known to the communications layer. The exact format of the <i>addr</i> parameter is determined by the address family that was established when the socket from the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure was created.
     * @param {Pointer<Int32>} addrlen An optional pointer to an integer that contains the length of structure pointed to by the <i>addr</i> parameter.
     * @returns {Pointer} If no error occurs, 
     * <b>accept</b> returns a value of type <b>SOCKET</b> that is a descriptor for the new socket. This returned value is a handle for the socket on which the actual connection is made.
     * 
     * Otherwise, a value of <b>INVALID_SOCKET</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The integer referred to by <i>addrlen</i> initially contains the amount of space pointed to by <i>addr</i>. On return it will contain the actual length in bytes of the address returned.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>addrlen</i> parameter is too small or <i>addr</i> is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call was canceled through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function was not invoked prior to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue is nonempty upon entry to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> and there are no descriptors available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The referenced socket is not a type that supports connection-oriented service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and no connections are present to be accepted.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-accept
     * @since windows8.1
     */
    static accept(s, addr, addrlen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\accept", "ptr", s, "ptr", addr, "ptr", addrlen, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The bind function (winsock.h) associates a local address with a socket.
     * @remarks
     * The <b>bind</b> function is required on an unconnected socket before subsequent calls to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function. It is normally used to bind to either connection-oriented (stream) or connectionless (datagram) sockets. The 
     * <b>bind</b> function may also be used to bind to a raw socket (the socket was created by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function with the <i>type</i> parameter set to SOCK_RAW). The 
     * <b>bind</b> function may also be used on an unconnected socket before subsequent calls to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnectbylist">WSAConnectByList</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnectbynamea">WSAConnectByName</a> functions before send operations. 
     * 
     * When a socket is created with a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function, it exists in a namespace (address family), but it has no name assigned to it. Use the 
     * <b>bind</b> function to establish the local association of the socket by assigning a local name to an unnamed socket.
     * 
     * A name consists of three parts when using the Internet address family:
     * 
     * <ul>
     * <li>The address family.</li>
     * <li>A host address.</li>
     * <li>A port number that identifies the application.</li>
     * </ul>
     * 
     * In Windows Sockets 2, the <i>name</i> parameter is not strictly interpreted as a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure. It is cast this way for Windows Sockets 1.1 compatibility. Service providers are free to regard it as a pointer to a block of memory of size <i>namelen</i>. The first 2 bytes in this block (corresponding to the <b>sa_family</b> member of the <b>sockaddr</b> structure, the <b>sin_family</b> member of the <b>sockaddr_in</b> structure, or the <b>sin6_family</b> member of the <b>sockaddr_in6</b> structure) must contain the address family that was used to create the socket. Otherwise, an error WSAEFAULT occurs.
     * 
     * If an application does not care what local address is assigned, specify the constant value <b>INADDR_ANY</b> for an IPv4 local address or the constant value <b>in6addr_any</b> for an IPv6 local address in the <b>sa_data</b> member of the <i>name</i> parameter. This allows the underlying service provider to use any appropriate network address, potentially simplifying application programming in the presence of <i>multihomed</i> hosts (that is, hosts that have more than one network interface and address).
     * 
     * For TCP/IP, if the port is specified as zero, the service provider assigns a unique port to the application from the dynamic client port range. On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000.  The maximum value for the client dynamic port range can be changed by setting a value under  the following registry key:
     * 
     * <b>HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</b>
     * 
     * The <b>MaxUserPort</b> registry value sets the value to use for the maximum value of the dynamic client port range. You must restart the computer for this setting to take effect.
     * 
     * On Windows Vista and later, the dynamic client port range can be viewed and changed using <b>netsh</b> commands. The dynamic client port range can be set differently for UDP and TCP and also for IPv4 and IPv6. For more information, see <a href="https://support.microsoft.com/kb/929851">KB 929851</a>. 
     * 
     * The application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> after calling 
     * <b>bind</b> to learn the address and the port that has been assigned to the socket. If the Internet address is equal to <b>INADDR_ANY</b> or <b>in6addr_any</b>, 
     * <b>getsockname</b> cannot necessarily supply the address until the socket is connected, since several addresses can be valid if the host is multihomed. Binding to a specific port number other than port 0 is discouraged for client applications, since there is a danger of conflicting with another socket already using that port number on the local computer.<div class="alert"><b>Note</b>  When using <b>bind</b> with the SO_EXCLUSIVEADDRUSE or SO_REUSEADDR socket option, the socket option must be set prior to executing <b>bind</b> to have any affect. For more information, see <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-exclusiveaddruse">SO_EXCLUSIVEADDRUSE</a> and <a href="https://docs.microsoft.com/windows/desktop/WinSock/using-so-reuseaddr-and-so-exclusiveaddruse">Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE</a>.</div>
     * <div> </div>
     * 
     * For multicast operations, the preferred method is to call the <b>bind</b> function to associate a socket with a local IP address  and then join the multicast group. Although this order of operations is not mandatory, it is strongly recommended. So a multicast application would first select an IPv4 or IPv6  address on the local computer, the wildcard IPv4 address (<b>INADDR_ANY</b>), or the wildcard IPv6 address (<b>in6addr_any</b>). The the multicast application would then call the <b>bind</b> function with this address in the in the <b>sa_data</b> member of the <i>name</i> parameter to associate the local IP address with the socket. If a wildcard address was specified, then Windows will select the local IP address to use. After the <b>bind</b> function completes, an application would then join the multicast group of interest. For more information on how to join a multicast group, see the section on <a href="https://docs.microsoft.com/windows/desktop/WinSock/multicast-programming">Multicast Programming</a>. This socket can then be used to receive multicast packets from the multicast group using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-wsarecvex">WSARecvEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, or <a href="https://docs.microsoft.com/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg">LPFN_WSARECVMSG (WSARecvMsg)</a> functions. 
     * 
     * The <b>bind</b> function is not normally required  for send operations to  a multicast group. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>,<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg">WSASendMsg</a>, and  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> functions implicitly bind the socket to the wildcard address if the socket is not already bound.  The <b>bind</b> function is required before the use of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>  or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> functions which do not perform an implicit bind and are allowed only on connected sockets, which means the socket must have already been bound for it to be connected. The <b>bind</b> function might be used before send operations using the <b>sendto</b>,<b>WSASendMsg</b>, or <b>WSASendTo</b> functions if an application wanted to select a specific local  IP address on a local computer with multiple network interfaces and local IP addresses. Otherwise an implicit bind to the wildcard address using the <b>sendto</b>,<b>WSASendMsg</b> , or <b>WSASendTo</b> functions might result in a different local IP address being used for send operations.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>bind</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Notes_for_IrDA_Sockets"></a><a id="notes_for_irda_sockets"></a><a id="NOTES_FOR_IRDA_SOCKETS"></a>Notes for IrDA Sockets</h3>
     * 
     * <ul>
     * <li>The Af_irda.h header file must be explicitly included.</li>
     * <li>Local names are not exposed in IrDA. IrDA client sockets therefore, must never call the 
     * <b>bind</b> function before the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> function. If the IrDA socket was previously bound to a service name using 
     * <b>bind</b>, the 
     * <b>connect</b> function will fail with SOCKET_ERROR.</li>
     * <li>If the service name is of the form "LSAP-SELxxx," where xxx is a decimal integer in the range 1-127, the address indicates a specific LSAP-SEL xxx rather than a service name. Service names such as these allow server applications to accept incoming connections directed to a specific LSAP-SEL, without first performing an ISA service name query to get the associated LSAP-SEL. One example of this service name type is a non-Windows device that does not support IAS.</li>
     * </ul>
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying an unbound socket.
     * @param {Pointer<SOCKADDR>} name 
     * @param {Integer} namelen The length, in bytes, of the value pointed to by *addr*.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-bind
     * @since windows8.1
     */
    static bind(s, name, namelen) {
        A_LastError := 0

        DllCall("WS2_32.dll\bind", "ptr", s, "ptr", name, "int", namelen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The closesocket function (winsock.h) closes an existing socket.
     * @remarks
     * The <b>closesocket</b> function closes a socket. Use it to release the socket descriptor passed in the <i>s</i> parameter. Note that the socket descriptor passed in the <i>s</i>  parameter may immediately be reused by the system as soon as <b>closesocket</b> function is issued. As a result, it is not reliable to expect further references to the socket descriptor passed in the <i>s</i> parameter to fail with the error <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a>. A Winsock client must never issue <b>closesocket</b> on <i>s</i> concurrently with another Winsock function call.
     * 
     * Any pending overlapped send and receive operations (
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>/
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>/
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>/
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a> with an overlapped socket) issued by any thread in this process are also canceled. Any event, completion routine, or completion port action specified for these overlapped operations is performed. The pending overlapped operations fail with the error status 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a>.
     * 
     * An application should not assume that any outstanding I/O operations on a socket will all be guaranteed to completed when <b>closesocket</b> returns. The <b>closesocket</b> function will initiate cancellation on the outstanding I/O operations, but that does not mean that an application will receive I/O completion for these I/O operations by the time the <b>closesocket</b> function returns. Thus, an application should not cleanup any resources (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structures, for example) referenced by the outstanding I/O requests until the I/O requests are indeed completed.
     * 
     *  
     * 
     * 
     * An application should always have a matching call to 
     * <b>closesocket</b> for each successful call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> to return any socket resources to the system.
     * 
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure maintains information about a specific socket that specifies how that socket should behave when data is queued to be sent and the 
     * <b>closesocket</b> function is called on the socket.
     * 
     * The <b>l_onoff</b> member of the <b>linger</b> structure determines whether a socket should remain open for a specified amount of time after a 
     * <b>closesocket</b> function call to enable queued data to be sent. This member can be modified in two ways: <ul>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function with the <i>optname</i> parameter set to <b>SO_DONTLINGER</b>. The <i>optval</i> parameter determines how the <b>l_onoff</b> member is modified. </li>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function with the <i>optname</i> parameter set to <b>SO_LINGER</b>. The <i>optval</i> parameter specifies how both the <b>l_onoff</b> and <b>l_linger</b> members are modified. </li>
     * </ul>
     * 
     * 
     * The <b>l_linger</b> member of the <b>linger</b> structure determines the amount of time, in seconds, a socket should remain open. This member is only applicable if the <b>l_onoff</b> member of the <b>linger</b> structure is nonzero. 
     * 
     * The default parameters for a socket are the <b>l_onoff</b> member of the <b>linger</b> structure is zero, indicating that the socket should not remain open.  The default value for the <b>l_linger</b> member of the <b>linger</b> structure is zero, but this value is ignored when the <b>l_onoff</b> member is set to zero. 
     * 
     * To enable a socket to remain open, an application should set the <b>l_onoff</b> member to a nonzero value and set the <b>l_linger</b> member  to the desired timeout in seconds. To disable a socket from remaining open, an application only needs to set the  <b>l_onoff</b> member of the <b>linger</b> structure to zero.
     * 
     *  If an application calls the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function with the <i>optname</i> parameter set to <b>SO_DONTLINGER</b> to set the <b>l_onoff</b> member to a nonzero value, the value for the <b>l_linger</b> member is not specified. In this case, the timeout used is implementation dependent. If a previous timeout has been established for a socket (by previously calling the <b>setsockopt</b> function with the <i>optname</i> parameter set to <b>SO_LINGER</b>), this timeout value should be reinstated by the service provider.
     * 
     * The semantics of 
     * the <b>closesocket</b> function are affected by the socket options that set members of <b>linger</b> structure.  <table>
     * <tr>
     * <th><b>l_onoff</b></th>
     * <th><b>l_linger</b></th>
     * <th>Type of close</th>
     * <th>Wait for close?</th>
     * </tr>
     * <tr>
     * <td>zero</td>
     * <td>Do not care</td>
     * <td>Graceful close</td>
     * <td>No</td>
     * </tr>
     * <tr>
     * <td>nonzero</td>
     * <td>zero</td>
     * <td>Hard</td>
     * <td>No</td>
     * </tr>
     * <tr>
     * <td>nonzero</td>
     * <td>nonzero</td>
     * <td>
     * Graceful if all data is sent within timeout value specified in the <b>l_linger</b> member. 
     * 
     * Hard if all data could not be sent within timeout value specified in the <b>l_linger</b> member.
     * 
     * </td>
     * <td>Yes</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * If the <b>l_onoff</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">LINGER</a> structure is zero on a stream socket, the 
     * <b>closesocket</b> call will return immediately and does not receive 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> whether the socket is blocking or nonblocking. However, any data queued for transmission will be sent, if possible, before the underlying socket is closed. This is also called a graceful disconnect or close. In this case, the Windows Sockets provider cannot release the socket and other resources for an arbitrary period, thus affecting applications that expect to use all available sockets. This is the default behavior for a socket.
     * 
     * If the 
     * <b>l_onoff</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure is nonzero and <b>l_linger</b> member is zero, 
     * <b>closesocket</b> is not blocked even if queued data has not yet been sent or acknowledged. This is called a hard or abortive close, because the socket's virtual circuit is reset immediately, and any unsent data is lost. On Windows, any 
     * <b>recv</b> call on the remote side of the circuit will fail with 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a>.
     * 
     * If the 
     * <b>l_onoff</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure is set to nonzero and <b>l_linger</b> member is set to a nonzero timeout on a blocking socket, the 
     * <b>closesocket</b> call blocks until the remaining data has been sent or until the timeout expires. This is called a graceful disconnect or close if all of the data is sent within timeout value specified in the <b>l_linger</b> member. If the timeout expires before all data has been sent, the Windows Sockets implementation terminates the connection before 
     * <b>closesocket</b> returns and this is called a hard or abortive close.
     * 
     * Setting the <b>l_onoff</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure to nonzero and the <b>l_linger</b> member with a nonzero timeout interval on a nonblocking socket is not recommended. In this case, the call to 
     * <b>closesocket</b> will fail with an error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> if the close operation cannot be completed immediately. If 
     * <b>closesocket</b> fails with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> the socket handle is still valid, and a disconnect is not initiated. The application must call 
     * <b>closesocket</b> again to close the socket. 
     * 
     * If the <b>l_onoff</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure is nonzero and the <b>l_linger</b> member is a nonzero timeout interval on a blocking socket, the result of the  <b>closesocket</b> function can't be used to determine whether all data has been sent to the peer. If the data is sent before the timeout specified in the <b>l_linger</b> member expires or if the connection was aborted, the <b>closesocket</b> function won't return an error code (the return value from the <b>closesocket</b> function is zero).  
     * 
     * The <b>closesocket</b> call will only block until all data has been delivered to the peer or the timeout expires. If the connection is reset because the timeout expires, then the socket will not go into TIME_WAIT state. If all data is sent within the timeout period, then the socket can go into TIME_WAIT state.
     * 
     * 
     * 
     * If the <b>l_onoff</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure is nonzero and the <b>l_linger</b> member is a zero timeout interval on a blocking socket,  then a call to <b>closesocket</b> will reset the connection. The socket will not go to the TIME_WAIT state. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function can be called with the <i>optname</i> parameter set to <b>SO_LINGER</b> to retrieve the current value of the <b>linger</b> structure associated with a socket.
     * 
     * 
     * <div class="alert"><b>Note</b>  To assure that all data is sent and received on a connection, an application should call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> before calling 
     * <b>closesocket</b> (see 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/graceful-shutdown-linger-options-and-socket-closure-2">Graceful shutdown, linger options, and socket closure</a> for more information). Also note, an FD_CLOSE network event is not posted after 
     * <b>closesocket</b> is called.</div>
     * <div> </div>
     * 
     * 
     * 
     * Here is a summary of 
     * <b>closesocket</b> behavior:
     * 
     * <ul>
     * <li>If the <b>l_onoff</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">LINGER</a> structure is zero (the default for a socket),  <b>closesocket</b> returns immediately and the connection is gracefully closed in the background.</li>
     * <li>If the 
     * <b>l_onoff</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure is set to nonzero and the <b>l_linger</b> member is set to zero (no timeout) <b>closesocket</b> returns immediately and the connection is reset or terminated.</li>
     * <li>If the 
     * <b>l_onoff</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure is set to nonzero and the <b>l_linger</b> member is set to a nonzero timeout:–  For a blocking socket, <b>closesocket</b> blocks until all data is sent or the timeout expires.
     * 
     * – For a nonblocking socket, <b>closesocket</b> returns immediately indicating failure.
     * 
     * </li>
     * </ul>
     * 
     * 
     * For additional information please see 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/graceful-shutdown-linger-options-and-socket-closure-2">Graceful Shutdown, Linger Options, and Socket Closure</a> for more information.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>closesocket</b>,  Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Notes_for_IrDA_Sockets"></a><a id="notes_for_irda_sockets"></a><a id="NOTES_FOR_IRDA_SOCKETS"></a>Notes for IrDA Sockets</h3>
     * 
     * Keep the following in mind:
     * 
     * <ul>
     * <li>The Af_irda.h header file must be explicitly included.</li>
     * <li>The standard linger options are supported.</li>
     * <li>Although IrDA does not provide a graceful close, IrDA will defer closing until receive queues are purged. Thus, an application can send data and immediately call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function, and be confident that the receiver will copy the data before receiving an FD_CLOSE message.</li>
     * </ul>
     * 
     * 
     * <h3><a id="Notes_for_ATM"></a><a id="notes_for_atm"></a><a id="NOTES_FOR_ATM"></a>Notes for ATM</h3>
     * 
     * The following are important issues associated with connection teardown when using Asynchronous Transfer Mode (ATM) and Windows Sockets 2:
     * 
     * <ul>
     * <li>Using the 
     * <b>closesocket</b> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> functions with SD_SEND or SD_BOTH results in a RELEASE signal being sent out on the control channel. Due to ATM's use of separate signal and data channels, it is possible that a RELEASE signal could reach the remote end before the last of the data reaches its destination, resulting in a loss of that data. One possible solutions is programming a sufficient delay between the last data sent and the <b>closesocket</b> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> function calls for an ATM socket.</li>
     * <li>Half close is not supported by ATM.</li>
     * <li>Both abortive and graceful disconnects result in a RELEASE signal being sent out with the same cause field. In either case, received data at the remote end of the socket is still delivered to the application. See 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/graceful-shutdown-linger-options-and-socket-closure-2">Graceful Shutdown, Linger Options, and Socket Closure</a> for more information.</li>
     * </ul>
     * 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying the socket to close.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-closesocket
     * @since windows8.1
     */
    static closesocket(s) {
        A_LastError := 0

        DllCall("WS2_32.dll\closesocket", "ptr", s)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The connect function establishes a connection to a specified socket.
     * @remarks
     * The 
     * <b>connect</b> function is used to create a connection to the specified destination. If socket <i>s</i>, is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.
     * 
     * For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using <i>name</i> (an address in the namespace of the socket; for a detailed description, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a>).<div class="alert"><b>Note</b>  If a socket is opened, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> call is made, and then a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a> call is made, Windows Sockets performs an implicit 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function call.</div>
     * <div> </div>
     * 
     * 
     * When the socket call completes successfully, the socket is ready to send and receive data. If the address member of the structure specified by the <i>name</i> parameter is filled with zeros, 
     * <b>connect</b> will return the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a>. Any attempt to reconnect an active connection will fail with the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a>.
     * 
     * For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such a case, this function returns the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a>. However, the operation proceeds.
     * 
     * 
     * When the success or failure outcome becomes known, it may be reported in one of two ways, depending on how the client registers for notification.
     * 
     * <ul>
     * <li>If the client uses the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a> function, success is reported in the writefds set and failure is reported in the exceptfds set.</li>
     * <li>If the client uses the functions 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>, the notification is announced with FD_CONNECT and the error code associated with the FD_CONNECT indicates either success or a specific reason for failure.</li>
     * </ul>
     * 
     * If the connection is not completed immediately, the client should wait for connection completion before attempting to set socket options using <a href="https://docs.microsoft.com/windows/win32/api/winsock/nf-winsock-setsockopt">setsockopt</a>. Calling setsockopt while a connection is in progress is not supported.
     * 
     * For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by 
     * <b>connect</b> is merely to establish a default destination address that can be used on subsequent 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>/
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>/
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> calls. Any datagrams received from an address other than the destination address specified will be discarded. If the address member of the structure specified by <i>name</i> is filled with zeros, the socket will be disconnected. Then, the default remote address will be indeterminate, so 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>/
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>/
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> calls will return the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a>. However, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>/
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>/
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a> can still be used. The default destination can be changed by simply calling 
     * <b>connect</b> again, even if the socket is already connected. Any datagrams queued for receipt are discarded if <i>name</i> is different from the previous 
     * <b>connect</b>.
     * 
     * For connectionless sockets, <i>name</i> can indicate any valid address, including a broadcast address. However, to connect to a broadcast address, a socket must use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> to enable the SO_BROADCAST option. Otherwise, 
     * <b>connect</b> will fail with the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a>.
     * 
     * When a connection between sockets is broken, the socket that was connected should be discarded and new socket should be created. When a problem develops on a connected socket, the application must discard the socket and create the socket again in order to return to a stable point.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>connect</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>connect</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying an unconnected socket.
     * @param {Pointer<SOCKADDR>} name A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure to which the connection should be established.
     * @param {Integer} namelen The length, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>name</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-connect
     * @since windows6.0.6000
     */
    static connect(s, name, namelen) {
        A_LastError := 0

        DllCall("WS2_32.dll\connect", "ptr", s, "ptr", name, "int", namelen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The ioctlsocket function (winsock.h) controls the I/O mode of a socket.
     * @remarks
     * The 
     * <b>ioctlsocket</b> function can be used on any socket in any state. It is used to set or retrieve some operating parameters associated with the socket, independent of the protocol and communications subsystem. Here are the supported commands to use in the <i>cmd</i> parameter and their semantics:
     * 
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> 
     * 	 function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem.
     * 
     * The <b>WSAIoctl</b> 
     * 	 function is more powerful than the <b>ioctlsocket</b> function and supports a large number of possible values for the operating parameters to set or retrieve.  
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>ioctlsocket</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} cmd A command to perform on the socket <i>s</i>.
     * @param {Pointer<UInt32>} argp A pointer to a parameter for <i>cmd</i>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-ioctlsocket
     * @since windows8.1
     */
    static ioctlsocket(s, cmd, argp) {
        A_LastError := 0

        DllCall("WS2_32.dll\ioctlsocket", "ptr", s, "int", cmd, "ptr", argp)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The getpeername function (winsock.h) retrieves the address of the peer to which a socket is connected.
     * @remarks
     * The 
     * <b>getpeername</b> function retrieves the address of the peer connected to the socket <i>s</i> and stores the address in the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR</a> structure identified by the <i>name</i> parameter. This function works with any address family and it simply returns the address to which the socket is connected. The 
     * <b>getpeername</b> function can be used only on a connected socket. 
     * 
     * For datagram sockets, only the address of a peer specified in a previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> call will be returned. Any address specified by a previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a> call will not be returned by 
     * <b>getpeername</b>.
     * 
     * On call, the <i>namelen</i> parameter contains the size, in bytes, of the <i>name</i> buffer. On return, the <i>namelen</i> parameter contains the actual size, in bytes, of the <i>name</i> parameter returned.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying a connected socket.
     * @param {Pointer<SOCKADDR>} name The 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR</a> structure that receives the address of the peer.
     * @param {Pointer<Int32>} namelen A pointer to the size, in bytes, of the <i>name</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-getpeername
     * @since windows8.1
     */
    static getpeername(s, name, namelen) {
        A_LastError := 0

        DllCall("WS2_32.dll\getpeername", "ptr", s, "ptr", name, "ptr", namelen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The getsockname function (winsock.h) retrieves the local name for a socket.
     * @remarks
     * The 
     * <b>getsockname</b> function retrieves the current name for the specified socket descriptor in <i>name</i>. It is used on the bound or connected socket specified by the <i>s</i> parameter. The local association is returned. This call is especially useful when a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> call has been made without doing a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> first; the 
     * <b>getsockname</b> function provides the only way to determine the local association that has been set by the system.
     * 
     * On call, the <i>namelen</i> parameter contains the size of the <i>name</i> buffer, in bytes. On return, the <i>namelen</i> parameter contains the actual size in bytes of the <i>name</i> parameter.
     * 
     * The 
     * <b>getsockname</b> function does not always return information about the host address when the socket has been bound to an unspecified address, unless the socket has been connected with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> (for example, using ADDR_ANY). A Windows Sockets application must not assume that the address will be specified unless the socket is connected. The address that will be used for the socket is unknown unless the socket is connected when used in a multihomed host. If the socket is using a connectionless protocol, the address may not be available until I/O occurs on the socket.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s Descriptor identifying a socket.
     * @param {Pointer<SOCKADDR>} name Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR</a> structure that receives the address (name) of the socket.
     * @param {Pointer<Int32>} namelen Size of the <i>name</i> buffer, in bytes.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-getsockname
     * @since windows8.1
     */
    static getsockname(s, name, namelen) {
        A_LastError := 0

        DllCall("WS2_32.dll\getsockname", "ptr", s, "ptr", name, "ptr", namelen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The getsockopt function (winsock.h) retrieves a socket option.
     * @remarks
     * The 
     * <b>getsockopt</b> function retrieves the current value for a socket option associated with a socket of any type, in any state, and stores the result in <i>optval</i>. Options can exist at multiple protocol levels, but they are always present at the uppermost socket level. Options affect socket operations, such as the packet routing and OOB data transfer.
     * 
     * The value associated with the selected option is returned in the buffer <i>optval</i>. The integer pointed to by <i>optlen</i> should originally contain the size of this buffer; on return, it will be set to the size of the value returned. For SO_LINGER, this will be the size of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">LINGER</a> structure. For most other options, it will be the size of an integer.
     * 
     * The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specified.
     * 
     * If the option was never set with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a>, then 
     * <b>getsockopt</b> returns the default value for the option.
     * 
     * The following options are supported for 
     * <b>getsockopt</b>. The Type column identifies the type of data addressed by <i>optval</i>.
     * 
     * For more information on socket options, see <a href="https://docs.microsoft.com/windows/desktop/WinSock/socket-options">Socket Options</a>.
     * 
     * The following table of value for the <i>optname</i> parameter are valid when the <i>level</i> parameter is set to <b>SOL_SOCKET</b>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>SO_ACCEPTCONN</td>
     * <td>BOOL</td>
     * <td>The socket is listening.</td>
     * </tr>
     * <tr>
     * <td>SO_BROADCAST</td>
     * <td>BOOL</td>
     * <td>The socket is configured for the transmission and receipt of broadcast messages.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-bsp-state">SO_BSP_STATE</a>
     * </td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a>
     * </td>
     * <td>Returns the local address, local port, remote address, remote port, socket type, and protocol used by a socket.</td>
     * </tr>
     * <tr>
     * <td>SO_CONDITIONAL_ACCEPT</td>
     * <td>BOOL</td>
     * <td>Returns current socket state, either from a previous call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> or the system default.</td>
     * </tr>
     * <tr>
     * <td>SO_CONNECT_TIME</td>
     * <td>DWORD</td>
     * <td>Returns the number of seconds a socket has been connected. This socket option is valid for connection oriented protocols only. </td>
     * </tr>
     * <tr>
     * <td>SO_DEBUG</td>
     * <td>BOOL</td>
     * <td>Debugging is enabled.</td>
     * </tr>
     * <tr>
     * <td>SO_DONTLINGER</td>
     * <td>BOOL</td>
     * <td>If <b>TRUE</b>, the SO_LINGER option is disabled.</td>
     * </tr>
     * <tr>
     * <td>SO_DONTROUTE</td>
     * <td>BOOL</td>
     * <td>Routing is disabled. Setting this succeeds but is ignored on AF_INET sockets; fails on AF_INET6 sockets with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOPROTOOPT</a>. This option is not supported on ATM sockets.</td>
     * </tr>
     * <tr>
     * <td>SO_ERROR</td>
     * <td>int</td>
     * <td>Retrieves error status and clear.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-exclusiveaddruse">SO_EXCLUSIVEADDRUSE</a>
     * </td>
     * <td>BOOL</td>
     * <td>Prevents any other socket from binding to the same address and port. This option must be set before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function.</td>
     * </tr>
     * <tr>
     * <td>SO_GROUP_ID</td>
     * <td>GROUP</td>
     * <td>Reserved.</td>
     * </tr>
     * <tr>
     * <td>SO_GROUP_PRIORITY</td>
     * <td>int</td>
     * <td>Reserved.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-keepalive">SO_KEEPALIVE</a>
     * </td>
     * <td>BOOL</td>
     * <td>Keep-alives are being sent. Not supported on ATM sockets.</td>
     * </tr>
     * <tr>
     * <td>SO_LINGER</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">LINGER</a> structure</td>
     * <td>Returns the current linger options.</td>
     * </tr>
     * <tr>
     * <td>SO_MAX_MSG_SIZE</td>
     * <td>unsigned int</td>
     * <td>The maximum size of a message for message-oriented socket types (for example, SOCK_DGRAM). Has no meaning for stream oriented sockets.</td>
     * </tr>
     * <tr>
     * <td>SO_OOBINLINE</td>
     * <td>BOOL</td>
     * <td>OOB data is being received in the normal data stream. (See section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-1-1-blocking-routines-and-einprogress-2">Windows Sockets 1.1 Blocking Routines and EINPROGRESS</a> for a discussion of this topic.)</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-port-scalability">SO_PORT_SCALABILITY</a>
     * </td>
     * <td>BOOL</td>
     * <td>Enables local port scalability for a socket by allowing port allocation to be maximized by allocating wildcard ports multiple times for different local address port pairs on a local machine.</td>
     * </tr>
     * <tr>
     * <td>SO_PROTOCOL_INFO</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a>
     * </td>
     * <td>A description of the protocol information for the protocol that is bound to this socket.</td>
     * </tr>
     * <tr>
     * <td>SO_RCVBUF</td>
     * <td>int</td>
     * <td>The total per-socket buffer space reserved for receives. This is unrelated to SO_MAX_MSG_SIZE and does not necessarily correspond to the size of the TCP receive window.</td>
     * </tr>
     * <tr>
     * <td>SO_REUSEADDR</td>
     * <td>BOOL</td>
     * <td>The socket can be bound to an address which is already in use. Not applicable for ATM sockets.</td>
     * </tr>
     * <tr>
     * <td>SO_SNDBUF</td>
     * <td>int</td>
     * <td>The total per-socket buffer space reserved for sends. This is unrelated to SO_MAX_MSG_SIZE and does not necessarily correspond to the size of a TCP send window.</td>
     * </tr>
     * <tr>
     * <td>SO_TYPE</td>
     * <td>int</td>
     * <td>The type of the socket (for example, SOCK_STREAM).</td>
     * </tr>
     * <tr>
     * <td>PVD_CONFIG</td>
     * <td>Service Provider Dependent</td>
     * <td>An opaque data structure object from the service provider associated with socket <i>s</i>. This object stores the current configuration information of the service provider. The exact format of this data structure is service provider specific.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <i>level</i> = <b>IPPROTO_TCP</b>
     * 
     * See **TCP_NODELAY** in [IPPROTO_TCP socket options](/windows/desktop/WinSock/ipproto-tcp-socket-options). Also see that topic for more complete and detailed information about socket options for <i>level</i> = <b>IPPROTO_TCP</b>.
     *  
     * 
     * 
     * 
     * The following table of value for the <i>optname</i> parameter are valid when the <i>level</i> parameter is set to <b>NSPROTO_IPX</b>.
     * 
     * <div class="alert"><b>Note</b>  Windows NT supports all IPX options. Windows Me, Windows 98, and Windows 95 support only the following options:<dl>
     * <dd>IPX_PTYPE</dd>
     * <dd>IPX_FILTERPTYPE</dd>
     * <dd>IPX_DSTYPE</dd>
     * <dd>IPX_RECVHDR</dd>
     * <dd>IPX_MAXSIZE</dd>
     * <dd>IPX_ADDRESS</dd>
     * </dl>
     * </div>
     * <div> </div>
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>IPX_PTYPE</td>
     * <td>int</td>
     * <td>Retrieves the IPX packet type.</td>
     * </tr>
     * <tr>
     * <td>IPX_FILTERPTYPE</td>
     * <td>int</td>
     * <td>Retrieves the receive filter packet type</td>
     * </tr>
     * <tr>
     * <td>IPX_DSTYPE</td>
     * <td>int</td>
     * <td>Obtains the value of the data stream field in the SPX header on every packet sent.</td>
     * </tr>
     * <tr>
     * <td>IPX_EXTENDED_ADDRESS</td>
     * <td>BOOL</td>
     * <td>Finds out whether extended addressing is enabled.</td>
     * </tr>
     * <tr>
     * <td>IPX_RECVHDR</td>
     * <td>BOOL</td>
     * <td>Finds out whether the protocol header is sent up on all receive headers.</td>
     * </tr>
     * <tr>
     * <td>IPX_MAXSIZE</td>
     * <td>int</td>
     * <td>Obtains the maximum data size that can be sent.</td>
     * </tr>
     * <tr>
     * <td>IPX_ADDRESS</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsnwlink/ns-wsnwlink-ipx_address_data">IPX_ADDRESS_DATA</a> structure</td>
     * <td>Obtains information about a specific adapter to which IPX is bound. Adapter numbering is base zero. The <b>adapternum</b> member is filled in upon return.</td>
     * </tr>
     * <tr>
     * <td>IPX_GETNETINFO</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsnwlink/ns-wsnwlink-ipx_netnum_data">IPX_NETNUM_DATA</a> structure</td>
     * <td>Obtains information about a specific IPX network number. If not available in the cache, uses RIP to obtain information.</td>
     * </tr>
     * <tr>
     * <td>IPX_GETNETINFO_NORIP</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsnwlink/ns-wsnwlink-ipx_netnum_data">IPX_NETNUM_DATA</a> structure</td>
     * <td>Obtains information about a specific IPX network number. If not available in the cache, will not use RIP to obtain information, and returns error.</td>
     * </tr>
     * <tr>
     * <td>IPX_SPXGETCONNECTIONSTATUS</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsnwlink/ns-wsnwlink-ipx_spxconnstatus_data">IPX_SPXCONNSTATUS_DATA</a> structure</td>
     * <td>Retrieves information about a connected SPX socket.</td>
     * </tr>
     * <tr>
     * <td>IPX_ADDRESS_NOTIFY</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsnwlink/ns-wsnwlink-ipx_address_data">IPX_ADDRESS_DATA</a> structure</td>
     * <td>Retrieves status notification when changes occur on an adapter to which IPX is bound.</td>
     * </tr>
     * <tr>
     * <td>IPX_MAX_ADAPTER_NUM</td>
     * <td>int</td>
     * <td>Retrieves maximum number of adapters present, numbered as base zero.</td>
     * </tr>
     * <tr>
     * <td>IPX_RERIPNETNUMBER</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsnwlink/ns-wsnwlink-ipx_netnum_data">IPX_NETNUM_DATA</a> structure</td>
     * <td>Similar to IPX_GETNETINFO, but forces IPX to use RIP for resolution, even if the network information is in the local cache.</td>
     * </tr>
     * <tr>
     * <td>IPX_IMMEDIATESPXACK</td>
     * <td>BOOL</td>
     * <td>Directs SPX connections not to delay before sending an ACK. Applications without back-and-forth traffic should set this to <b>TRUE</b> to increase performance.</td>
     * </tr>
     * <tr>
     * <td>TCP_MAXSEG</td>
     * <td>int</td>
     * <td>Receives TCP maximum-segment size. Supported in Windows 10 and newer versions.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * The following table lists value for the <i>optname</i> that represent BSD socket options that are not supported by the <b>getsockopt</b> function.
     * 		    <table>
     * <tr>
     * <th>Value</th>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>SO_RCVLOWAT</td>
     * <td>int</td>
     * <td>Receives low watermark.</td>
     * </tr>
     * <tr>
     * <td>SO_RCVTIMEO</td>
     * <td>int</td>
     * <td>Receives time-out.</td>
     * </tr>
     * <tr>
     * <td>SO_SNDLOWAT</td>
     * <td>int</td>
     * <td>Sends low watermark.</td>
     * </tr>
     * <tr>
     * <td>SO_SNDTIMEO</td>
     * <td>int</td>
     * <td>Sends time-out.</td>
     * </tr>
     * <tr>
     * <td>TCP_MAXSEG</td>
     * <td>int</td>
     * <td>Receives TCP maximum-segment size. Not supported in versions before Windows 10.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function, if no data arrives during the period specified in SO_RCVTIMEO, the 
     * <b>recv</b> function completes. In Windows versions prior to Windows 2000, any data received subsequently fails with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>. In Windows 2000 and later, if no data arrives within the period specified in SO_RCVTIMEO, the 
     * <b>recv</b> function returns WSAETIMEDOUT, and if data is received, 
     * <b>recv</b> returns SUCCESS.</div>
     * <div> </div>
     * 
     * 
     * Calling 
     * <b>getsockopt</b> with an unsupported option will result in an error code of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOPROTOOPT</a> being returned from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * More detailed information  on some of the socket options for the <i>optname</i> parameter supported by the <b>getsockopt</b> function are listed below.
     * 
     * 
     * 
     * 
     * <dl>
     * <dt><a id="SO_CONNECT_TIME"></a><a id="so_connect_time"></a>SO_CONNECT_TIME</dt>
     * <dd>
     * This option returns the number of seconds a socket has been connected. This option is valid for connection oriented protocols only.
     * 
     * The SO_CONNECT_TIME option can be used with the <b>getsockopt</b> function to check 
     *     whether a connection has been established. This option can also be used  while a <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a> function call is in progress.
     *     If a connection is established, the SO_CONNECT_TIME option can determine how long the connection has
     *     been established. If the socket is not connected, the <b>getsockopt</b> returns
     *     SOCKET_ERROR. Checking a connection like this is necessary to see if
     *     connections that have been established for a while, without sending any
     *     data. It is recommended that applications terminate these connections. 
     * 
     * </dd>
     * <dt><a id="SO_DEBUG"></a><a id="so_debug"></a>SO_DEBUG</dt>
     * <dd>
     * <div class="alert"><b>Note</b>  Windows Sockets service providers are encouraged (but not required) to supply output debug information if the SO_DEBUG option is set by an application. The mechanism for generating the debug information and the form it takes are beyond the scope of this document.</div>
     * <div> </div>
     * </dd>
     * <dt><a id="SO_ERROR"></a><a id="so_error"></a>SO_ERROR</dt>
     * <dd>
     * The SO_ERROR option returns and resets the per socket–based error code, which is different from the per thread based–error code that is handled using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsasetlasterror">WSASetLastError</a> function calls. A successful call using the socket does not reset the socket based error code returned by the SO_ERROR option.
     * 
     * </dd>
     * <dt><a id="SO_EXCLUSIVEADDRUSE"></a><a id="so_exclusiveaddruse"></a>SO_EXCLUSIVEADDRUSE</dt>
     * <dd>
     * Prevents any other socket from binding to the same address and port. This option must be set before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function. See the <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-exclusiveaddruse">SO_EXCLUSIVEADDRUSE</a> reference for more information.
     * 
     * </dd>
     * <dt><a id="SO_GROUP_ID"></a><a id="so_group_id"></a>SO_GROUP_ID</dt>
     * <dd>
     * <div class="alert"><b>Note</b>  This option is reserved. This option is also exclusive to 
     * <b>getsockopt</b>; the value should be <b>NULL</b>.</div>
     * <div> </div>
     * </dd>
     * <dt><a id="SO_GROUP_PRIORITY"></a><a id="so_group_priority"></a>SO_GROUP_PRIORITY</dt>
     * <dd>
     * This option is reserved. Group priority indicates the priority of the specified socket relative to other sockets within the socket group. Values are nonnegative integers, with zero corresponding to the highest priority. Priority values represent a hint to the underlying service provider about how potentially scarce resources should be allocated. For example, whenever two or more sockets are both ready to transmit data, the highest priority socket (lowest value for SO_GROUP_PRIORITY) should be serviced first, with the remainder serviced in turn according to their relative priorities.
     * 
     * The WSAENOPROTOOPT error code is indicated for nongroup sockets or for service providers that do not support group sockets.
     * 
     * </dd>
     * <dt><a id="SO_KEEPALIVE"></a><a id="so_keepalive"></a><a href="https://docs.microsoft.com/windows/desktop/WinSock/so-keepalive">SO_KEEPALIVE</a>
     * </dt>
     * <dd>
     * An application can request that a TCP/IP service provider enable the use of keep-alive packets on TCP  connections by turning on the SO_KEEPALIVE socket option. This option queries the current value of the keep-alive option on a socket. A Windows Sockets provider need not support the use of keep-alive: if it does, the precise semantics are implementation-specific but should conform to section 4.2.3.6 on the <i>Requirements for Internet Hosts—Communication Layers</i> specified in RFC 1122 available at the <a href="https://www.ietf.org/rfc/rfc1122.txt">IETF website</a>.  If a connection is dropped as the result of keep-alives the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a> is returned to any calls in progress on the socket, and any subsequent calls will fail with 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a>. <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-keepalive">SO_KEEPALIVE</a> is not supported on ATM sockets, and requests to enable the use of keep-alive packets on an ATM socket results in an error being returned by the socket.
     * 
     * </dd>
     * <dt><a id="SO_LINGER"></a><a id="so_linger"></a>SO_LINGER</dt>
     * <dd>
     * SO_LINGER controls the action taken when unsent data is queued on a socket and a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> is performed. See 
     * <b>closesocket</b> for a description of the way in which the SO_LINGER settings affect the semantics of 
     * <b>closesocket</b>. The application gets the current behavior by retrieving a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">LINGER</a> structure (pointed to by the <i>optval</i> parameter).
     * 
     * </dd>
     * <dt><a id="SO_MAX_MSG_SIZE"></a><a id="so_max_msg_size"></a>SO_MAX_MSG_SIZE</dt>
     * <dd>
     * This is a get-only socket option that indicates the maximum outbound (send) size of a message for message-oriented socket types (for example, SOCK_DGRAM) as implemented by a particular service provider. It has no meaning for byte stream oriented sockets. There is no provision to find out the maximum inbound–message size.
     * 
     * </dd>
     * <dt><a id="SO_PROTOCOL_INFO"></a><a id="so_protocol_info"></a>SO_PROTOCOL_INFO</dt>
     * <dd>
     * This is a get-only option that supplies the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure associated with this socket. See 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> for more information about this structure.
     * 
     * </dd>
     * <dt><a id="SO_SNDBUF"></a><a id="so_sndbuf"></a>SO_SNDBUF</dt>
     * <dd>
     * When a Windows Sockets implementation supports the SO_RCVBUF and SO_SNDBUF options, an application can request different buffer sizes (larger or smaller). The call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> can succeed even if the implementation did not provide the whole amount requested. An application must call this function with the same option to check the buffer size actually provided.
     * 
     * </dd>
     * <dt><a id="SO_REUSEADDR"></a><a id="so_reuseaddr"></a>SO_REUSEADDR</dt>
     * <dd>
     * By default, a socket cannot be bound (see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a>) to a local address that is already in use. On occasion, however, it can be necessary to reuse an address in this way. Because every connection is uniquely identified by the combination of local and remote addresses, there is no problem with having two sockets bound to the same local address as long as the remote addresses are different. To inform the Windows Sockets provider that a 
     * <b>bind</b> on a socket should not be disallowed because the desired address is already in use by another socket, the application should set the SO_REUSEADDR socket option for the socket before issuing the 
     * <b>bind</b>. Note that the option is interpreted only at the time of the 
     * <b>bind</b>: it is therefore unnecessary (but harmless) to set the option on a socket that is not to be bound to an existing address, and setting or resetting the option after the 
     * <b>bind</b> has no effect on this or any other socket. SO_REUSEADDR is not applicable for ATM sockets, and although requests to reuse and address do not result in an error, they have no effect on when an ATM socket is in use.
     * 
     * </dd>
     * <dt><a id="PVD_CONFIG"></a><a id="pvd_config"></a>PVD_CONFIG</dt>
     * <dd>
     * This option retrieves an opaque data structure object from the service provider associated with socket <i>s</i>. This object stores the current configuration information of the service provider. The exact format of this data structure is service provider specific.
     * 
     * </dd>
     * <dt><a id="TCP_NODELAY"></a><a id="tcp_nodelay"></a>TCP_NODELAY</dt>
     * <dd>
     * The TCP_NODELAY option is specific to TCP/IP service providers. The Nagle algorithm is disabled if the TCP_NODELAY option is enabled (and vice versa). The Nagle algorithm (described in RFC 896) is very effective in reducing the number of small packets sent by a host. The process involves buffering send data when there is unacknowledged data already in flight or buffering send data until a full-size packet can be sent. It is highly recommended that Windows Sockets implementations enable the Nagle Algorithm by default because, for the vast majority of application protocols, the Nagle Algorithm can deliver significant performance enhancements. However, for some applications this algorithm can impede performance, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> with the same option can be used to turn it off. These are applications where many small messages are sent, and the time delays between the messages are maintained.
     * 
     * </dd>
     * </dl>
     * 
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>getsockopt</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following code sample demonstrates the use of the <b>getsockopt</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} level The level at which the option is defined. Example:  <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET</a>.
     * @param {Integer} optname The socket option for which the value is to be retrieved. Example: <a href="https://docs.microsoft.com/windows/desktop/WinSock/socket-options-and-ioctls-2">SO_ACCEPTCONN</a>. The <i>optname</i> value must be a socket option defined within the specified <i>level</i>, or behavior is undefined.
     * @param {Pointer<PSTR>} optval A pointer to the buffer in which the value for the requested option is to be returned.
     * @param {Pointer<Int32>} optlen A pointer to the size, in bytes, of the <i>optval</i> buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-getsockopt
     * @since windows8.1
     */
    static getsockopt(s, level, optname, optval, optlen) {
        A_LastError := 0

        DllCall("WS2_32.dll\getsockopt", "ptr", s, "int", level, "int", optname, "ptr", optval, "ptr", optlen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The htonl function (winsock.h) converts a u_long from host to TCP/IP network byte order (which is big-endian).
     * @remarks
     * The 
     * <b>htonl</b> function takes a 32-bit number in host byte order and returns a 32-bit number in the network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family).
     * 
     * The 
     * <b>htonl</b> function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the <i>hostlong</i> parameter is a valid IPv4 address.
     * 
     * The <b>htonl</b> function does not require that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} hostlong A 32-bit number in host byte order.
     * @returns {Integer} The 
     * <b>htonl</b> function returns the value in TCP/IP's network byte order.
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-htonl
     * @since windows8.1
     */
    static htonl(hostlong) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\htonl", "uint", hostlong, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The htons function (winsock.h) converts a u_short from host to TCP/IP network byte order (which is big-endian).
     * @remarks
     * The 
     * <b>htons</b> function takes a 16-bit number in host byte order and returns a 16-bit number in network byte order used in TCP/IP networks (the AF_INET or AF_INET6 address family). 
     * 
     * The 
     * <b>htons</b> function can be used to convert an IP port number in host byte order to the IP port number in network byte order. 
     * 
     * The <b>htons</b> function does not require that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} hostshort A 16-bit number in host byte order.
     * @returns {Integer} The 
     * <b>htons</b> function returns the value in TCP/IP network byte order.
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-htons
     * @since windows8.1
     */
    static htons(hostshort) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\htons", "ushort", hostshort, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The inet_addr macro function (wsipv6ok.h) converts a string containing an IPv4 dotted-decimal address into a proper address for the IN_ADDR structure.
     * @remarks
     * The 
     * <b>inet_addr</b> function interprets the character string specified by the <i>cp</i> parameter. This string represents a numeric Internet address expressed in the Internet standard ".'' notation. The value returned is a number suitable for use as an Internet address. All Internet addresses are returned in IP's network order (bytes ordered from left to right). If you pass in " " (a space) to the 
     * <b>inet_addr</b> function, 
     * <b>inet_addr</b> returns zero.
     * 
     * On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4stringtoaddressa">RtlIpv4StringToAddress</a> function can be used to convert a string representation of an IPv4 address to a binary IPv4 address represented as an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure. On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6stringtoaddressa">RtlIpv6StringToAddress</a> function can be used to convert a string representation of an IPv6 address to a binary IPv6 address represented as an <b>IN6_ADDR</b> structure. 
     * 
     * <h3><a id="Internet_Addresses"></a><a id="internet_addresses"></a><a id="INTERNET_ADDRESSES"></a>Internet Addresses</h3>
     * Values specified using the ".'' notation take one of the following forms:
     * 
     * a.b.c.d a.b.c a.b a
     * 
     * When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the 4 bytes of an Internet address. When an Internet address is viewed as a 32-bit integer quantity on the Intel architecture, the bytes referred to above appear as "d.c.b.a''. That is, the bytes on an Intel processor are ordered from right to left.
     * 
     * The parts that make up an address in "." notation can be decimal, octal or hexadecimal as specified in the C language. Numbers that start with "0x" or "0X" imply hexadecimal. Numbers that start with "0" imply octal. All other numbers are interpreted as decimal.
     * 
     * <table>
     * <tr>
     * <th>Internet address value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>"4.3.2.16"</td>
     * <td>Decimal</td>
     * </tr>
     * <tr>
     * <td>"004.003.002.020"</td>
     * <td>Octal</td>
     * </tr>
     * <tr>
     * <td>"0x4.0x3.0x2.0x10"</td>
     * <td>Hexadecimal</td>
     * </tr>
     * <tr>
     * <td>"4.003.002.0x10"</td>
     * <td>Mix</td>
     * </tr>
     * </table>
     *  
     * 
     * The <b>inet_addr</b> function supports the decimal, octal, hexadecimal, and mixed notations for the string passed in the <i>cp</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  The following notations are only used by Berkeley software, and nowhere else on the Internet. For compatibility with Berkeley software, the <b>inet_addr</b> function also supports the additional notations specified below. </div>
     * <div> </div>
     * When a three-part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right-most 2 bytes of the network address. This makes the three-part address format convenient for specifying Class B network addresses as "128.net.host''
     * 
     * When a two-part address is specified, the last part is interpreted as a 24-bit quantity and placed in the right-most 3 bytes of the network address. This makes the two-part address format convenient for specifying Class A network addresses as "net.host''.
     * 
     * When only one part is given, the value is stored directly in the network address without any byte rearrangement.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<PSTR>} cp 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/wsipv6ok/nf-wsipv6ok-inet_addr
     * @deprecated
     * @since windows8.1
     */
    static inet_addr(cp) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\inet_addr", "ptr", cp, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The inet_ntoa macro function (wsipv6ok.h) converts an (Ipv4) Internet network address into an ASCII string in Internet standard dotted-decimal format.
     * @remarks
     * The 
     * <b>inet_ntoa</b> function takes an Internet address structure specified by the <i>in</i> parameter and returns a <b>NULL</b>-terminated ASCII string that represents the address in "." (dot) notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.   The string returned by 
     * <b>inet_ntoa</b> resides in memory that is allocated by Windows Sockets. The application should not make any assumptions about the way in which the memory is allocated. The string returned is guaranteed to be valid only until the next Windows Sockets function call is made within the same thread. Therefore, the data should be copied before another Windows Sockets call is made.
     * 
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaddresstostringa">WSAAddressToString</a> function can be used to convert a <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure containing an IPv4 address to a string representation of an IPv4 address in Internet standard dotted-decimal notation. The advantage of the <b>WSAAddressToString</b>  function is that it supports both IPv4 and IPv6 addresses. Another advantage of the  <b>WSAAddressToString</b>  function is that there are both ASCII and Unicode versions of this function.
     * 
     * On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4addresstostringa">RtlIpv4AddressToString</a> function can be used to convert an IPv4 address represented as an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure to a string representation of an IPv4 address in Internet standard dotted-decimal notation. On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6addresstostringa">RtlIpv6AddressToString</a> function can be used to convert an IPv6 address represented as an <b>IN6_ADDR</b> structure to a string representation of an IPv6 address. 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} in_R 
     * @returns {Pointer<PSTR>} 
     * @see https://learn.microsoft.com/windows/win32/api/wsipv6ok/nf-wsipv6ok-inet_ntoa
     * @deprecated
     * @since windows8.1
     */
    static inet_ntoa(in_R) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\inet_ntoa", "ptr", in_R, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The listen function places a socket in a state in which it is listening for an incoming connection.
     * @remarks
     * To accept connections, a socket is first created with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function and bound to a local address with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function. A backlog for incoming connections is specified with 
     * <b>listen</b>, and then the connections are accepted with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function. Sockets that are connection oriented, those of type <b>SOCK_STREAM</b> for example, are used with 
     * <b>listen</b>. The socket <i>s</i> is put into passive mode where incoming connection requests are acknowledged and queued pending acceptance by the process.
     * 
     * A value for the <i>backlog</i> of <b>SOMAXCONN</b> is a special constant that  instructs the underlying service provider responsible for socket <i>s</i> to set the length of the queue of pending connections to a maximum reasonable value.
     * 
     * On Windows Sockets 2, this maximum value defaults to a large value (typically several hundred or more). 
     *  
     * When calling the <b>listen</b> function in a Bluetooth application, it is strongly recommended that a much lower value be used for the <i>backlog</i> parameter (typically 2 to 4), since only a few client connections are accepted. This reduces the system resources that are allocated for use by the listening socket. This same recommendation applies to other network applications that expect only a few client connections.
     * 
     * 
     * The 
     * <b>listen</b> function is typically used by servers that can have more than one connection request at a time. If a connection request arrives and the queue is full, the client will receive an error with an indication of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a>.
     * 
     * If there are no available socket descriptors, 
     * <b>listen</b> attempts to continue to function. If descriptors become available, a later call to 
     * <b>listen</b> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> will refill the queue to the current or most recent value specified for the  <i>backlog</i> parameter, if possible, and resume listening for incoming connections.
     * 
     * If the <b>listen</b> function is called on an already listening socket, it will return success without changing the value for the <i>backlog</i> parameter.  Setting the <i>backlog</i> parameter to 0 in a subsequent call to <b>listen</b> on a listening socket is not considered a proper reset, especially if there are connections on the socket.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>listen</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>listen</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a bound, unconnected socket.
     * @param {Integer} backlog The maximum length of the queue of pending connections. If set to <b>SOMAXCONN</b>, the underlying service provider responsible for socket <i>s</i> will set the backlog to a maximum reasonable value. If set to <b>SOMAXCONN_HINT(N)</b> (where N is a number), the backlog value will be N, adjusted to be within the range (200, 65535). Note that <b>SOMAXCONN_HINT</b> can be used to set the backlog to a larger value than possible with SOMAXCONN.
     * 
     * <b>SOMAXCONN_HINT</b> is only supported by the Microsoft TCP/IP service provider. There is no standard provision to obtain the actual backlog value.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-listen
     * @since windows8.1
     */
    static listen(s, backlog) {
        A_LastError := 0

        DllCall("WS2_32.dll\listen", "ptr", s, "int", backlog)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The ntohl function (winsock.h) converts a u_long from TCP/IP network order to host byte order, which is little-endian on Intel processors.
     * @remarks
     * The 
     * <b>ntohl</b> function takes a 32-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a 32-bit number in host byte order. 
     * 
     * The 
     * <b>ntohl</b> function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the <i>netlong</i> parameter is a valid IPv4 address.
     * 
     * The <b>ntohl</b> function does not require that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} netlong A 32-bit number in TCP/IP network byte order.
     * @returns {Integer} The 
     * <b>ntohl</b> function returns the value supplied in the <i>netlong</i> parameter with the byte order reversed. If  <i>netlong</i> is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed.
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-ntohl
     * @since windows8.1
     */
    static ntohl(netlong) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\ntohl", "uint", netlong, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ntohs function (winsock.h) converts a u_short from TCP/IP network byte order to host byte order, which is little-endian on Intel processors.
     * @remarks
     * The 
     * <b>ntohs</b> function takes a 16-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and returns a 16-bit number in host byte order.
     * 
     * The 
     * <b>ntohs</b> function can be used to convert an IP port number in network byte order to the IP port number in host byte order. 
     * 
     * The <b>ntohs</b> function does not require that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} netshort A 16-bit number in TCP/IP network byte order.
     * @returns {Integer} The 
     * <b>ntohs</b> function returns the value in host byte order. If the <i>netshort</i> parameter is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed.
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-ntohs
     * @since windows8.1
     */
    static ntohs(netshort) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\ntohs", "ushort", netshort, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The recv function (winsock.h) receives data from a connected socket or a bound connectionless socket.
     * @remarks
     * The 
     * <b>recv</b> function is used to read incoming data on connection-oriented sockets, or connectionless sockets. When using a connection-oriented protocol, the sockets must be connected before calling 
     * <b>recv</b>. When using a connectionless protocol, the sockets must be bound before calling 
     * <b>recv</b>.
     * 
     * The local address of the socket must be known. For server applications, use an explicit 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function or an implicit 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> function. Explicit binding is discouraged for client applications. For client applications, the socket can become bound implicitly to a local address using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a>.
     * 
     * For connected or connectionless sockets, the 
     * <b>recv</b> function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded.
     * 
     * For connection-oriented sockets (type SOCK_STREAM for example), calling 
     * <b>recv</b> will return as much data as is currently available—up to the size of the buffer specified. If the socket has been configured for in-line reception of OOB data (socket option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-ioctlsocket">ioctlsocket</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a><b>SIOCATMARK</b> command to determine whether any more OOB data remains to be read.
     * 
     * For connectionless sockets (type SOCK_DGRAM or other message-oriented sockets), data is extracted from the first enqueued datagram (message) from the destination address specified by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> function.
     * 
     * If the datagram or message is larger than the buffer specified, the buffer is filled with the first part of the datagram, and 
     * <b>recv</b> generates the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a>. For unreliable protocols (for example, UDP) the excess data is lost; for reliable protocols, the data is retained by the service provider until it is successfully read by calling 
     * <b>recv</b> with a large enough buffer.
     * 
     * If no incoming data is available at the socket, the 
     * <b>recv</b> call blocks and waits for data to arrive according to the blocking rules defined for 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value of SOCKET_ERROR is returned with the error code set to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a>. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> functions can be used to determine when more data arrives.
     * 
     * If the socket is connection oriented and the remote side has shut down the connection gracefully, and all data has been received, a 
     * <b>recv</b> will complete immediately with zero bytes received. If the connection has been reset, a 
     * <b>recv</b> will fail with the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a>.
     * 
     * The <i>flags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the <i>flags</i> parameter. The possible value of <i>flags</i> parameter is constructed by using the bitwise OR operator with any of the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>MSG_PEEK</td>
     * <td>Peeks at the incoming data. The data is copied into the buffer, but is not removed from the input queue.</td>
     * </tr>
     * <tr>
     * <td>MSG_OOB</td>
     * <td>Processes Out Of Band (OOB) data.</td>
     * </tr>
     * <tr>
     * <td>MSG_WAITALL</td>
     * <td>The receive request will complete only when one of the following events occurs:<ul>
     * <li>The buffer supplied by the caller is completely full.</li>
     * <li>The connection has been closed.</li>
     * <li>The request has been canceled or an error occurred.</li>
     * </ul>Note that if the underlying transport does not support MSG_WAITALL, or if the socket is in a non-blocking mode, then this call will fail with <b>WSAEOPNOTSUPP</b>. Also, if MSG_WAITALL is specified along with MSG_OOB, MSG_PEEK, or MSG_PARTIAL, then this call will fail with <b>WSAEOPNOTSUPP</b>. This flag is not supported on datagram sockets or message-oriented sockets.</td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>recv</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following code example shows the use of the <b>recv</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s The descriptor that identifies a connected socket.
     * @param {Pointer<PSTR>} buf A pointer to the buffer to receive the incoming data.
     * @param {Integer} len The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags A set of flags that influences the behavior of this function. See remarks below. See the Remarks section for details on the possible value for this parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-recv
     * @since windows8.1
     */
    static recv(s, buf, len, flags) {
        A_LastError := 0

        DllCall("WS2_32.dll\recv", "ptr", s, "ptr", buf, "int", len, "int", flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The recvfrom function receives a datagram and stores the source address.
     * @remarks
     * The 
     * <b>recvfrom</b> function reads incoming data on both connected and unconnected sockets and captures the address from which the data was sent. This function is typically used with connectionless sockets. The local address of the socket must be known. For server applications, this is usually done explicitly through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a>. Explicit binding is discouraged for client applications. For client applications using this function, the socket can become bound implicitly to a local address through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a>.
     * 
     * For stream-oriented sockets such as those of type SOCK_STREAM, a call to 
     * <b>recvfrom</b> returns as much information as is currently available—up to the size of the buffer specified. If the socket has been configured for inline reception of OOB data (socket option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-ioctlsocket">ioctlsocket</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a><b>SIOCATMARK</b> command to determine whether any more OOB data remains to be read. The <i>from</i> and <i>fromlen</i> parameters are ignored for connection-oriented sockets.
     * 
     * For message-oriented sockets, data is extracted from the first enqueued message, up to the size of the buffer specified. If the datagram or message is larger than the buffer specified, the buffer is filled with the first part of the datagram, and 
     * <b>recvfrom</b> generates the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a>. For unreliable protocols (for example, UDP) the excess data is lost. For UDP if the packet received contains no data (empty), the return value from the <b>recvfrom</b> function function is zero.
     * 
     * If the <i>from</i> parameter is nonzero and the socket is not connection oriented, (type SOCK_DGRAM for example), the network address of the peer that sent the data is copied to the corresponding 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure. The value pointed to by <i>fromlen</i> is initialized to the size of this structure and is modified, on return, to indicate the actual size of the address stored in the <b>sockaddr</b> structure.
     * 
     * If no incoming data is available at the socket, the 
     * <b>recvfrom</b> function blocks and waits for data to arrive according to the blocking rules defined for 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value of SOCKET_ERROR is returned with the error code set to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a>. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> can be used to determine when more data arrives.
     * 
     * If the socket is connection oriented and the remote side has shut down the connection gracefully, the call to 
     * <b>recvfrom</b> will complete immediately with zero bytes received. If the connection has been reset 
     * <b>recvfrom</b> will fail with the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a>.
     * 
     * The <i>flags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. The semantics of this function are determined by the socket options and the <i>flags</i> parameter. The latter is constructed by using the bitwise OR operator with any of the following values.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>MSG_PEEK</td>
     * <td>Peeks at the incoming data. The data is copied into the buffer but is not removed from the input queue.</td>
     * </tr>
     * <tr>
     * <td>MSG_OOB</td>
     * <td>Processes Out Of Band (OOB) data.</td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>recvfrom</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>recvfrom</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a bound socket.
     * @param {Pointer<PSTR>} buf A buffer for the incoming data.
     * @param {Integer} len The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags A set of options that modify the behavior of the function call beyond the options specified for the associated socket. See the Remarks below for more details.
     * @param {Pointer<SOCKADDR>} from An optional pointer to a buffer in a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that will hold the source address upon return.
     * @param {Pointer<Int32>} fromlen An optional pointer to the size, in bytes, of the buffer pointed to by the <i>from</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-recvfrom
     * @since windows8.1
     */
    static recvfrom(s, buf, len, flags, from, fromlen) {
        A_LastError := 0

        DllCall("WS2_32.dll\recvfrom", "ptr", s, "ptr", buf, "int", len, "int", flags, "ptr", from, "ptr", fromlen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The select function determines the status of one or more sockets, waiting if necessary, to perform synchronous I/O.
     * @remarks
     * The 
     * <b>select</b> function is used to determine the status of one or more sockets. For each socket, the caller can request information on read, write, or error status. The set of sockets for which a given status is requested is indicated by an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-fd_set">fd_set</a> structure. The sockets contained within the 
     * <b>fd_set</b> structures must be associated with a single service provider. For the purpose of this restriction, sockets are considered to be from the same service provider if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures describing their protocols have the same <i>providerId</i> value. Upon return, the structures are updated to reflect the subset of these sockets that meet the specified condition. The 
     * <b>select</b> function returns the number of sockets meeting the conditions. A set of macros is provided for manipulating an 
     * <b>fd_set</b> structure. These macros are compatible with those used in the Berkeley software, but the underlying representation is completely different.
     * 
     * The parameter <i>readfds</i> identifies the sockets that are to be checked for readability. If the socket is currently in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> state, it will be marked as readable if an incoming connection request has been received such that an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> is guaranteed to complete without blocking. For other sockets, readability means that queued data is available for reading such that a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a> is guaranteed not to block.
     * 
     * For connection-oriented sockets, readability can also indicate that a request to close the socket has been received from the peer. If the virtual circuit was closed gracefully, and all data was received, then a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> will return immediately with zero bytes read. If the virtual circuit was reset, then a 
     * <b>recv</b> will complete immediately with an error code such as 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a>. The presence of OOB data will be checked if the socket option SO_OOBINLINE has been enabled (see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a>).
     * 
     * The parameter <i>writefds</i> identifies the sockets that are to be checked for writability. If a socket is processing a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> call (nonblocking), a socket is writable if the connection establishment successfully completes. If the socket is not processing a 
     * <b>connect</b> call, writability means a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendto</a> are guaranteed to succeed. However, they can block on a blocking socket if the <i>len</i> parameter exceeds the amount of outgoing system buffer space available. It is not specified how long these guarantees can be assumed to be valid, particularly in a multithreaded environment.
     * 
     * The parameter <i>exceptfds</i> identifies the sockets that are to be checked for the presence of OOB data or any exceptional error conditions.
     * 
     * <div class="alert"><b>Note</b>  Out-of-band data will only be reported in this way if the option SO_OOBINLINE is <b>FALSE</b>. If a socket is processing a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> call (nonblocking), failure of the connect attempt is indicated in <i>exceptfds</i> (application must then call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> SO_ERROR to determine the error value to describe why the failure occurred). This document does not define which other errors will be included.</div>
     * <div> </div>
     * Any two of the parameters, <i>readfds</i>, <i>writefds</i>, or <i>exceptfds</i>, can be given as <b>null</b>. At least one must be non-<b>null</b>, and any non-<b>null</b> descriptor set must contain at least one handle to a socket.
     * 
     * In summary, a socket will be identified in a particular set when 
     * <b>select</b> returns if:
     * 
     * <i>readfds</i>:
     * 
     * <ul>
     * <li>If 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> has been called and a connection is pending, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> will succeed.</li>
     * <li>Data is available for reading (includes OOB data if SO_OOBINLINE is enabled).</li>
     * <li>Connection has been closed/reset/terminated.</li>
     * </ul>
     * <i>writefds</i>:
     * 
     * <ul>
     * <li>If processing a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> call (nonblocking), connection has succeeded.</li>
     * <li>Data can be sent.</li>
     * </ul>
     * <i>exceptfds</i>:
     * 
     * <ul>
     * <li>If processing a 
     * <b>connect</b> call (nonblocking), connection attempt failed.</li>
     * <li>OOB data is available for reading (only if SO_OOBINLINE is disabled).</li>
     * </ul>
     * Four macros are defined in the header file Winsock2.h for manipulating and checking the descriptor sets. The variable FD_SETSIZE determines the maximum number of descriptors in a set. (The default value of FD_SETSIZE is 64, which can be modified by defining FD_SETSIZE to another value before including Winsock2.h.) Internally, socket handles in an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-fd_set">fd_set</a> structure are not represented as bit flags as in Berkeley Unix. Their data representation is opaque. Use of these macros will maintain software portability between different socket environments. The macros to manipulate and check 
     * <b>fd_set</b> contents are:
     * <ul>
     * <li><i>FD_ZERO(*set)</i> - Initializes set to the empty set. A set should always be cleared before using.</li>
     * <li><i>FD_CLR(s, *set)</i> - Removes socket s from set.</li>
     * <li><i>FD_ISSET(s, *set)</i> - Checks to see if s is a member of set and returns TRUE if so.</li>
     * <li><i>FD_SET(s, *set)</i> - Adds socket s to set.</li>
     * </ul>
     * 
     * 
     * The parameter <i>time-out</i> controls how long the 
     * <b>select</b> can take to complete. If <i>time-out</i> is a <b>null</b> pointer, 
     * <b>select</b> will block indefinitely until at least one descriptor meets the specified criteria. Otherwise, <i>time-out</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-timeval">TIMEVAL</a> structure that specifies the maximum time that 
     * <b>select</b> should wait before returning. When 
     * <b>select</b> returns, the contents of the <b>TIMEVAL</b> structure are not altered. If <b>TIMEVAL</b> is initialized to {0, 0}, 
     * <b>select</b> will return immediately; this is used to poll the state of the selected sockets. If 
     * <b>select</b> returns immediately, then the 
     * <b>select</b> call is considered nonblocking and the standard assumptions for nonblocking calls apply. For example, the blocking hook will not be called, and Windows Sockets will not yield.
     * 
     * <div class="alert"><b>Note</b>  The 
     * <b>select</b> function has no effect on the persistence of socket events registered with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>select</b> with the <i>timeout</i> parameter set to <b>NULL</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} nfds Ignored. The <i>nfds</i> parameter is included only for compatibility with Berkeley sockets.
     * @param {Pointer<FD_SET>} readfds An optional pointer to a set of sockets to be checked for readability.
     * @param {Pointer<FD_SET>} writefds An optional pointer to a set of sockets to be checked for writability.
     * @param {Pointer<FD_SET>} exceptfds An optional pointer to a set of sockets to be checked for errors.
     * @param {Pointer<TIMEVAL>} timeout The maximum time for 
     * <b>select</b> to wait, provided in the form of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-timeval">TIMEVAL</a> structure. Set the <i>timeout</i> parameter to <b>null</b> for blocking operations.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-select
     * @since windows8.1
     */
    static select(nfds, readfds, writefds, exceptfds, timeout) {
        A_LastError := 0

        DllCall("WS2_32.dll\select", "int", nfds, "ptr", readfds, "ptr", writefds, "ptr", exceptfds, "ptr", timeout)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Sends data on a connected socket. (send)
     * @remarks
     * The 
     * <b>send</b> function is used to write outgoing data on a connected socket. 
     * 
     * For message-oriented sockets (address family of <b>AF_INET</b> or <b>AF_INET6</b>, type of <b>SOCK_DGRAM</b>, and protocol of <b>IPPROTO_UDP</b>, for example), care must be taken not to exceed the maximum packet size of the underlying provider. The maximum message packet size for a provider can be obtained by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> with the <i>optname</i> parameter set to <b>SO_MAX_MSG_SIZE</b> to retrieve the value of socket option. If the data is too long to pass atomically through the underlying protocol, the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a> is returned, and no data is transmitted.
     * 
     * The successful completion of a 
     * <b>send</b> function does not indicate that the data was successfully delivered and received to the recipient. This function only indicates the data was successfully sent. 
     * 
     * If no buffer space is available within the transport system to hold the data to be transmitted, 
     * <b>send</b> will block unless the socket has been placed in nonblocking mode. On nonblocking stream oriented sockets, the number of bytes written can be between 1 and the requested length, depending on buffer availability on both the client and server computers. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> functions can be used to determine when it is possible to send more data.
     * 
     * Calling 
     * <b>send</b> with a <i>len</i> parameter of zero is permissible and will be treated by implementations as successful. In such cases, 
     * <b>send</b> will return zero as a valid value. For message-oriented sockets, a zero-length transport datagram is sent.
     * 
     * The <i>flags</i> parameter can be used to influence the behavior of the function beyond the options specified for the associated socket. The semantics of the <b>send</b> function are determined by any options previously set on the socket specified in the <i>s</i> parameter and the <i>flags</i> parameter passed to the <b>send</b> function. 
     * 
     * The order of calls made to <b>send</b> is also the order in which the buffers are transmitted to the transport layer. <b>send</b> should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from multiple concurrent send requests on the same stream-oriented socket.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>send</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>send</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a connected socket.
     * @param {Pointer<PSTR>} buf A pointer to a buffer containing the data to be transmitted.
     * @param {Integer} len The length, in bytes, of the data in buffer pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags 
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-send
     * @since windows8.1
     */
    static send(s, buf, len, flags) {
        A_LastError := 0

        DllCall("WS2_32.dll\send", "ptr", s, "ptr", buf, "int", len, "int", flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The sendto function (winsock.h) sends data to a specific destination.
     * @remarks
     * The 
     * <b>sendto</b> function is used to write outgoing data on a socket. For message-oriented sockets, care must be taken not to exceed the maximum packet size of the underlying subnets, which can be obtained by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> to retrieve the value of socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol, the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a> is returned and no data is transmitted.
     * 
     * The <i>to</i> parameter can be any valid address in the socket's address family, including a broadcast or any multicast address. To send to a broadcast address, an application must have used 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> with SO_BROADCAST enabled. Otherwise, 
     * <b>sendto</b> will fail with the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a>. For TCP/IP, an application can send to any multicast address (without becoming a group member).
     * 
     * <div class="alert"><b>Note</b>  If a socket is opened, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> call is made, and then a 
     * <b>sendto</b> call is made, Windows Sockets performs an implicit 
     * <b>bind</b> function call.</div>
     * <div> </div>
     * If the socket is unbound, unique values are assigned to the local association by the system, and the socket is then marked as bound. If the socket is connected, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function can be used to determine the local IP address and port associated with the socket. 
     * 
     * If the socket is not connected, the  
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a>   function can be used to determine the local port number associated with the socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY  or "0.0.0.0" for IPv4 and IN6ADDR_ANY_INIT or "::" for IPv6).
     * 
     * The successful completion of a 
     * <b>sendto</b> does not indicate that the data was successfully delivered.
     * 
     * The 
     * <b>sendto</b> function is normally used on a connectionless socket to send a datagram to a specific peer socket identified by the <i>to</i> parameter. Even if the connectionless socket has been previously connected to a specific address, the <i>to</i> parameter overrides the destination address for that particular datagram only. On a connection-oriented socket, the <i>to</i> and <i>tolen</i> parameters are ignored, making 
     * <b>sendto</b> equivalent to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>sendto</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>sendto</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a (possibly connected) socket.
     * @param {Pointer<PSTR>} buf A pointer to a buffer containing the data to be transmitted.
     * @param {Integer} len The length, in bytes, of the data pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags A set of flags that specify the way in which the call is made.
     * @param {Pointer<SOCKADDR>} to An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that contains the address of the target socket.
     * @param {Integer} tolen The size, in bytes, of the address pointed to by the <i>to</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-sendto
     * @since windows8.1
     */
    static sendto(s, buf, len, flags, to, tolen) {
        A_LastError := 0

        DllCall("WS2_32.dll\sendto", "ptr", s, "ptr", buf, "int", len, "int", flags, "ptr", to, "int", tolen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The setsockopt function (winsock.h) sets a socket option.
     * @remarks
     * The 
     * <b>setsockopt</b> function sets the current value for a socket option associated with a socket of any type, in any state. Although options can exist at multiple protocol levels, they are always present at the uppermost socket level. Options affect socket operations, such as whether expedited data (OOB data for example) is received in the normal data stream, and whether broadcast messages can be sent on the socket.
     * 
     * <div class="alert"><b>Note</b>  If the 
     * <b>setsockopt</b> function is called before the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function, TCP/IP options will not be checked by using TCP/IP until the 
     * <b>bind</b> occurs. In this case, the 
     * <b>setsockopt</b> function call will always succeed, but the 
     * <b>bind</b> function call can fail because of an early 
     * <b>setsockopt</b> call failing.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  If a socket is opened, a 
     * <b>setsockopt</b> call is made, and then a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a> call is made, Windows Sockets performs an implicit 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function call.</div>
     * <div> </div>
     * There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options that require an integer value or structure. To enable a Boolean option, the <i>optval</i> parameter points to a nonzero integer. To disable the option <i>optval</i> points to an integer equal to zero. The <i>optlen</i> parameter should be equal to <c>sizeof(int)</c> for Boolean options. For other options, <i>optval</i> points to an integer or structure that contains the desired value for the option, and <i>optlen</i> is the length of the integer or structure.
     * 
     * The following tables list some of the common options supported by the <b>setsockopt</b> function. The Type column identifies the type of data addressed by <i>optval</i> parameter. The  Description column provides some basic information about the socket option. For more complete lists of socket options and more detailed information (default values, for example), see the detailed topics under <a href="https://docs.microsoft.com/windows/desktop/WinSock/socket-options">Socket Options</a>. 
     * 
     * <i>level</i> = <b>SOL_SOCKET</b>
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Type</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>SO_BROADCAST</td>
     * <td>BOOL</td>
     * <td>Configures a socket for sending broadcast data.</td>
     * </tr>
     * <tr>
     * <td>SO_CONDITIONAL_ACCEPT</td>
     * <td>BOOL</td>
     * <td>Enables incoming connections are to be accepted or rejected by the application, not by the protocol stack.</td>
     * </tr>
     * <tr>
     * <td>SO_DEBUG</td>
     * <td>BOOL</td>
     * <td>Enables debug output. Microsoft providers currently do not output any debug information.</td>
     * </tr>
     * <tr>
     * <td>SO_DONTLINGER</td>
     * <td>BOOL</td>
     * <td>Does not block close waiting for unsent data to be sent. Setting this option is equivalent to setting SO_LINGER with <b>l_onoff</b> set to zero.</td>
     * </tr>
     * <tr>
     * <td>SO_DONTROUTE</td>
     * <td>BOOL</td>
     * <td>Sets whether outgoing data should be sent on interface the socket is bound to and not a routed on some other interface. This option is not supported on ATM sockets (results in an error).</td>
     * </tr>
     * <tr>
     * <td>SO_GROUP_PRIORITY</td>
     * <td>int</td>
     * <td>Reserved.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-keepalive">SO_KEEPALIVE</a>
     * </td>
     * <td>BOOL</td>
     * <td>Enables sending keep-alive packets for a socket connection. Not supported on ATM sockets (results in an error).</td>
     * </tr>
     * <tr>
     * <td>SO_LINGER</td>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-linger">LINGER</a>
     * </td>
     * <td>Lingers on close if unsent data is present.</td>
     * </tr>
     * <tr>
     * <td>SO_OOBINLINE</td>
     * <td>BOOL</td>
     * <td>Indicates that out-of-bound data should be returned in-line with regular data. This option is only valid for connection-oriented protocols that support out-of-band data. For a discussion of this topic, see 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/protocol-independent-out-of-band-data-2">Protocol Independent Out-Of-band Data</a>.</td>
     * </tr>
     * <tr>
     * <td>SO_RCVBUF</td>
     * <td>int</td>
     * <td>Specifies the total per-socket buffer space reserved for receives. </td>
     * </tr>
     * <tr>
     * <td>SO_REUSEADDR</td>
     * <td>BOOL</td>
     * <td>Allows the socket to be bound to an address that is already in use. For more information, see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a>. Not applicable on ATM sockets.</td>
     * </tr>
     * <tr>
     * <td>
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-exclusiveaddruse">SO_EXCLUSIVEADDRUSE</a>
     * </td>
     * <td>BOOL</td>
     * <td>Enables a socket to be bound for exclusive access. Does not require administrative privilege. </td>
     * </tr>
     * <tr>
     * <td>SO_RCVTIMEO</td>
     * <td>DWORD</td>
     * <td>Sets the timeout, in milliseconds, for blocking receive calls. </td>
     * </tr>
     * <tr>
     * <td>SO_SNDBUF</td>
     * <td>int</td>
     * <td>Specifies the total per-socket buffer space reserved for sends.</td>
     * </tr>
     * <tr>
     * <td>SO_SNDTIMEO</td>
     * <td>DWORD</td>
     * <td>The timeout, in milliseconds, for blocking send calls. </td>
     * </tr>
     * <tr>
     * <td>SO_UPDATE_ACCEPT_CONTEXT</td>
     * <td>int</td>
     * <td>Updates the accepting socket with the context of the listening socket.</td>
     * </tr>
     * <tr>
     * <td>PVD_CONFIG</td>
     * <td>Service Provider Dependent</td>
     * <td>This object stores the configuration information for the service provider associated with socket <i>s</i>. The exact format of this data structure is service provider specific.</td>
     * </tr>
     * </table>
     *  
     * For more complete and detailed information about socket options for <i>level</i> = <b>SOL_SOCKET</b>, see <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET Socket Options</a>.
     * 
     * <i>level</i> = <b>IPPROTO_TCP</b>
     * 
     * See **TCP_NODELAY** in [IPPROTO_TCP socket options](/windows/desktop/WinSock/ipproto-tcp-socket-options). Also see that topic for more complete and detailed information about socket options for <i>level</i> = <b>IPPROTO_TCP</b>.
     * 
     * <i>level</i> = <b>NSPROTO_IPX</b>
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Type</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>IPX_PTYPE</td>
     * <td>int</td>
     * <td>Sets the IPX packet type.</td>
     * </tr>
     * <tr>
     * <td>IPX_FILTERPTYPE</td>
     * <td>int</td>
     * <td>Sets the receive filter packet type</td>
     * </tr>
     * <tr>
     * <td>IPX_STOPFILTERPTYPE</td>
     * <td>int</td>
     * <td>Stops filtering the filter type set with IPX_FILTERTYPE</td>
     * </tr>
     * <tr>
     * <td>IPX_DSTYPE</td>
     * <td>int</td>
     * <td>Sets the value of the data stream field in the SPX header on every packet sent.</td>
     * </tr>
     * <tr>
     * <td>IPX_EXTENDED_ADDRESS</td>
     * <td>BOOL</td>
     * <td>Sets whether extended addressing is enabled.</td>
     * </tr>
     * <tr>
     * <td>IPX_RECVHDR</td>
     * <td>BOOL</td>
     * <td>Sets whether the protocol header is sent up on all receive headers.</td>
     * </tr>
     * <tr>
     * <td>IPX_RECEIVE_BROADCAST</td>
     * <td>BOOL</td>
     * <td>Indicates broadcast packets are likely on the socket. Set to <b>TRUE</b> by default. Applications that do not use broadcasts should set this to <b>FALSE</b> for better system performance.</td>
     * </tr>
     * <tr>
     * <td>IPX_IMMEDIATESPXACK</td>
     * <td>BOOL</td>
     * <td>Directs SPX connections not to delay before sending an ACK. Applications without back-and-forth traffic should set this to <b>TRUE</b> to increase performance.</td>
     * </tr>
     * </table>
     *  
     * 
     * For more complete and detailed information about socket options for <i>level</i> = <b>NSPROTO_IPX</b>, see <a href="https://docs.microsoft.com/windows/desktop/WinSock/nsproto-ipx-socket-options">NSPROTO_IPX Socket Options</a>.
     * 
     * BSD options not supported for 
     * <b>setsockopt</b> are shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Type</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>SO_ACCEPTCONN</td>
     * <td>BOOL</td>
     * <td>Returns whether a socket is in listening mode. This option is only Valid for connection-oriented protocols. This socket option is not supported for the setting.</td>
     * </tr>
     * <tr>
     * <td>SO_RCVLOWAT</td>
     * <td>int</td>
     * <td>A socket option from BSD UNIX included for backward compatibility. This option sets the minimum number of bytes to process for socket input operations. 
     * </td>
     * </tr>
     * <tr>
     * <td>SO_SNDLOWAT</td>
     * <td>int</td>
     * <td>A socket option from BSD UNIX included for backward compatibility. This option sets the minimum number of bytes to process for socket output operations. </td>
     * </tr>
     * <tr>
     * <td>SO_TYPE</td>
     * <td>int</td>
     * <td>Returns the socket type for the given socket (SOCK_STREAM or SOCK_DGRAM, for example This socket option is not supported for the setting the socket type.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>setsockopt</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the <b>setsockopt</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor that identifies a socket.
     * @param {Integer} level The level at which the option is defined (for example, SOL_SOCKET).
     * @param {Integer} optname The socket option for which the value is to be set (for example, SO_BROADCAST). The <i>optname</i> parameter must be a socket option defined within the specified <i>level</i>, or behavior is undefined.
     * @param {Pointer<PSTR>} optval A pointer to the buffer in which the value for the requested option is specified.
     * @param {Integer} optlen The size, in bytes, of the buffer pointed to by the <i>optval</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-setsockopt
     * @since windows8.1
     */
    static setsockopt(s, level, optname, optval, optlen) {
        A_LastError := 0

        DllCall("WS2_32.dll\setsockopt", "ptr", s, "int", level, "int", optname, "ptr", optval, "int", optlen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The shutdown function (winsock.h) disables sends or receives on a socket.
     * @remarks
     * The 
     * <b>shutdown</b> function is used on all types of sockets to disable reception, transmission, or both.
     * 
     * If the <i>how</i> parameter is SD_RECEIVE, subsequent calls to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function on the socket will be disallowed. This has no effect on the lower protocol layers. For TCP sockets, if there is still data queued on the socket waiting to be received, or data arrives subsequently, the connection is reset, since the data cannot be delivered to the user. For UDP sockets, incoming datagrams are accepted and queued. In no case will an ICMP error packet be generated.
     * 
     * If the <i>how</i> parameter is SD_SEND, subsequent calls to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> function are disallowed. For TCP sockets, a FIN will be sent after all data is sent and acknowledged by the receiver.
     * 
     * Setting <i>how</i> to SD_BOTH disables both sends and receives as described above.
     * 
     * The 
     * <b>shutdown</b> function does not close the socket. Any resources attached to the socket will not be freed until 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> is invoked.
     * 
     * To assure that all data is sent and received on a connected socket before it is closed, an application should use 
     * <b>shutdown</b> to close connection before calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>. One method to wait for notification that the remote end has sent all its data and initiated a graceful disconnect uses the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> function as follows :
     * 
     * <ol>
     * <li>Call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> to register for FD_CLOSE notification.</li>
     * <li>Call 
     * <b>shutdown</b> with <i>how</i>=SD_SEND.</li>
     * <li>When FD_CLOSE received, call 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>  or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> until the function completes with success and indicates that zero bytes were received. If SOCKET_ERROR is returned, then the graceful disconnect is not possible.</li>
     * <li>Call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>.</li>
     * </ol>
     * Another method to wait for notification that the remote end has sent all its data and initiated a graceful disconnect uses overlapped receive calls follows :
     * 
     * <ol>
     * <li>Call 
     * <b>shutdown</b> with <i>how</i>=SD_SEND.</li>
     * <li>Call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> until the function completes with success and indicates zero bytes were received. If SOCKET_ERROR is returned, then the graceful disconnect is not possible.</li>
     * <li>Call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>.</li>
     * </ol>
     * 
     * <div class="alert"><b>Note</b>  The 
     * <b>shutdown</b> function does not block regardless of the SO_LINGER setting on the socket.</div>
     * <div> </div>
     * 
     * 
     * For more information, see the section on <a href="https://docs.microsoft.com/windows/desktop/WinSock/graceful-shutdown-linger-options-and-socket-closure-2">Graceful Shutdown, Linger Options, and Socket Closure</a>.
     * 
     * Once the <b>shutdown</b> function is called to disable send, receive, or both, there is no method to re-enable send or receive for the existing socket connection. 
     * 
     * 
     * An application should not rely on being able to reuse a socket after it has been shut down. In particular, a Windows Sockets provider is not required to support the use of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> on a socket that has been shut down.
     * 
     * If an application wants to reuse a socket, then the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms737757(v=vs.85)">DisconnectEx</a> function should be called with the <i>dwFlags</i> parameter set to <b>TF_REUSE_SOCKET</b> to close a connection on a socket and prepare the socket handle to be reused.  When the 
     * <b>DisconnectEx</b> request completes, the socket handle can be passed to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a> function.   
     * 
     * If an application wants to reuse a socket, the <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> or <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_transmitpackets">TransmitPackets</a> functions can be called with the <i>dwFlags</i> parameter set with <b>TF_DISCONNECT</b> and <b>TF_REUSE_SOCKET</b> to disconnect after all the data has been queued for transmission and prepare the socket handle to be reused. When the <b>TransmitFile</b> request completes, the socket handle can be passed to the 
     * function call previously used to establish the connection, such as <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>  or <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>. When the 
     * <b>TransmitPackets</b> function completes, the socket handle can be passed to the 
     * <b>AcceptEx</b> function. 
     * 
     * 
     * <div class="alert"><b>Note</b>  The socket level disconnect is subject to the behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing  the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms737757(v=vs.85)">DisconnectEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_transmitpackets">TransmitPackets</a> call to be delayed.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>shutdown</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * 
     * 
     * <h3><a id="Notes_for_ATM"></a><a id="notes_for_atm"></a><a id="NOTES_FOR_ATM"></a>Notes for ATM</h3>
     * There are important issues associated with connection teardown when using Asynchronous Transfer Mode (ATM) and Windows Sockets 2. For more information about these important considerations, see the section titled Notes for ATM in the Remarks section of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> function reference.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} how A flag that describes what types of operation will no longer be allowed. Possible values for this flag are listed in the <i>Winsock2.h</i> header file.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SD_RECEIVE"></a><a id="sd_receive"></a><dl>
     * <dt><b>SD_RECEIVE</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Shutdown receive operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SD_SEND"></a><a id="sd_send"></a><dl>
     * <dt><b>SD_SEND</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Shutdown send operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SD_BOTH"></a><a id="sd_both"></a><dl>
     * <dt><b>SD_BOTH</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Shutdown both send and receive operations.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-shutdown
     * @since windows8.1
     */
    static shutdown(s, how) {
        A_LastError := 0

        DllCall("WS2_32.dll\shutdown", "ptr", s, "int", how)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The socket function creates a socket that is bound to a specific transport service provider.
     * @remarks
     * The 
     * <b>socket</b> function causes a socket descriptor and any related resources to be allocated and bound to a specific transport-service provider. Winsock will utilize the first available service provider that supports the requested combination of address family, socket type and protocol parameters. The socket that is created will have the overlapped attribute as a default. For Windows, the Microsoft-specific socket option, SO_OPENTYPE, defined in Mswsock.h can affect this default. See Microsoft-specific documentation for a detailed description of SO_OPENTYPE.
     * 
     * Sockets without the overlapped attribute can be created by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a>. All functions that allow overlapped operation (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>,
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operation are <b>NULL</b>.
     * 
     * When selecting a protocol and its supporting service provider this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on <i>type</i> or <i>af</i> either. That is, they do not lead to an error code of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a> if no suitable protocol is found.
     * 
     * <div class="alert"><b>Note</b>    The manifest constant <b>AF_UNSPEC</b> continues to be defined in the header file but its use is strongly discouraged, as this can cause ambiguity in interpreting the value of the <i>protocol</i> parameter.</div>
     * <div> </div>
     * Applications are encouraged to use <b>AF_INET6</b> for the <i>af</i> parameter and create a dual-mode socket that can be used with both IPv4 and IPv6.
     * 
     * Connection-oriented sockets such as <b>SOCK_STREAM</b> provide full-duplex connections, and must be in a connected state before any data can be sent or received on it. A connection to another socket is created with a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> call. Once connected, data can be transferred using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> calls. When a session has been completed, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> must be performed.
     * 
     * The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>.
     * 
     * Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>. If such a socket is connected to a specific peer, datagrams can be sent to that peer using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> and can be received only from this peer using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>.
     * 
     * IPv6 and IPv4 operate differently when receiving a socket with a <i>type</i> of <b>SOCK_RAW</b>. The IPv4 receive packet includes the packet payload, the next upper-level header (for example, the IP header for a TCP or UDP packet), and the IPv4 packet header. The IPv6 receive packet includes the packet payload and the next upper-level header. The IPv6 receive packet never includes the IPv6 packet header.
     * 
     * <div class="alert"><b>Note</b>  On Windows NT, raw socket support requires administrative privileges.</div>
     * <div> </div>
     * A socket with a <i>type</i> parameter of <b>SOCK_SEQPACKET</b> is based on datagrams, but functions as a pseudo-stream protocol. For both send and receive packets, separate datagrams are used. However, Windows Sockets can coalesce multiple receive packets into a single packet. So an application  can issue a receive call (for example, <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> or <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-wsarecvex">WSARecvEx</a>) and retrieve the data from several coalesced multiple packets in single call. The AF_NETBIOS address family supports a <i>type</i> parameter of <b>SOCK_SEQPACKET</b>.
     * 
     * When the <i>af</i> parameter is <b>AF_NETBIOS</b> for NetBIOS over TCP/IP, the <i>type</i> parameter can be  <b>SOCK_DGRAM</b> or <b>SOCK_SEQPACKET</b>. For the <b>AF_NETBIOS</b> address family, the <i>protocol</i> parameter is the LAN adapter number represented as a negative number.
     * 
     * On Windows XP and later, the following command can be used to list the Windows Sockets catalog to determine the service providers installed and the address family, socket type, and protocols that are supported.
     * 
     * <b>netsh winsock show catalog </b>
     * 
     * Support for sockets with type <b>SOCK_RAW</b> is not required, but service providers are encouraged to support raw sockets as practicable.
     * 
     * <h3><a id="Notes_for_IrDA_Sockets"></a><a id="notes_for_irda_sockets"></a><a id="NOTES_FOR_IRDA_SOCKETS"></a>Notes for IrDA Sockets</h3>
     * Keep the following in mind:
     * 
     * <ul>
     * <li>The Af_irda.h header file must be explicitly included.</li>
     * <li>Only <b>SOCK_STREAM</b> is supported; the <b>SOCK_DGRAM</b> type is not supported by IrDA.</li>
     * <li>The <i>protocol</i> parameter is always set to 0 for IrDA.</li>
     * </ul>
     * A socket for use with the AF_IRDA address family can only be created if the local computer has an infrared port and driver installed. Otherwise, a call to the <b>socket</b> function with <i>af</i> parameter set to AF_IRDA will fail and <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> returns <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a>. 
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>socket</b> function to create a socket that is bound to a specific transport service provider..
     * 
     * 
     * ```cpp
     * @param {Integer} af The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i> header file. 
     * 
     * On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * The values currently supported are AF_INET or AF_INET6, which are the Internet
     *                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The table below lists common values for address family although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>Af</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl>
     * <dt><b>AF_UNSPEC</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family is unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl>
     * <dt><b>AF_IPX</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. 
     * 
     * This address family is not supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
     * <dt><b>AF_APPLETALK</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. 
     * 
     * This address family is not supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
     * <dt><b>AF_NETBIOS</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. 
     * 
     * The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows. 
     * 
     * The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows 7,  Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP.  
     * 
     * The Windows Sockets provider for NetBIOS  only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>.
     * 
     * The Windows Sockets provider for NetBIOS  is not directly related to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/netbios/portal">NetBIOS</a> programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008, and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
     * <dt><b>AF_IRDA</b></dt>
     * <dt>26</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Infrared Data Association (IrDA) address family. 
     * 
     * This address family is only supported if the computer has an infrared port and driver installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
     * <dt><b>AF_BTH</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth address family. 
     * 
     * This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} type The type specification for the new socket. 
     * 
     * 
     * Possible values for the socket type are defined in the <i>Winsock2.h</i> header file.
     * 
     * The following table lists the possible values for the <i>type</i> parameter supported for Windows Sockets 2:
     * 
     * <table>
     * <tr>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
     * <dt><b>SOCK_STREAM</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl>
     * <dt><b>SOCK_DGRAM</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
     * <dt><b>SOCK_RAW</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ip-socket-options">IP_HDRINCL</a> socket option must be set on the socket.  To manipulate the IPv6 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPV6_HDRINCL</a> socket option must be set on the socket.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
     * <dt><b>SOCK_RDM</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as <a href="https://docs.microsoft.com/windows/desktop/WinSock/reliable-multicast-programming--pgm-">reliable multicast programming</a>. 
     * 
     * This <i>type</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
     * <dt><b>SOCK_SEQPACKET</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a pseudo-stream packet based on datagrams. 
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address families, and protocols are defined.
     * 
     * In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b> and <b>SOCK_STREAM</b>.
     * @param {Integer} protocol The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address family and socket type specified. Possible values for the <i>protocol</i> are defined in the  <i>Winsock2.h</i> and <i>Wsrm.h</i> header files.
     * 
     * On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * If a value of  0 is specified, the caller does not
     *               wish to specify a protocol and the service provider will choose the <i>protocol</i> to use.
     * 
     * 
     * When the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. 
     * 
     * The table below lists common values for the <i>protocol</i> although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>protocol</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
     * <dt><b>IPPROTO_ICMP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl>
     * <dt><b>IPPROTO_IGMP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
     * <dt><b>BTHPROTO_RFCOMM</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. 
     * 
     * This <i>protocol</i> value is supported on Windows XP with SP2 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl>
     * <dt><b>IPPROTO_ICMPV6</b></dt>
     * <dt>58</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b>  and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl>
     * <dt><b>IPPROTO_RM</b></dt>
     * <dt>113</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PGM protocol for reliable multicast. This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later,  this protocol is also called <b>IPPROTO_PGM</b>. 
     * 
     * This <i>protocol</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Pointer} If no error occurs, 
     * <b>socket</b> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem or the associated service provider has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported. For example, an application tried to create a socket for the <b>AF_IRDA</b> address family but an infrared adapter and device driver is not installed on the local computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.  This error is returned if the <i>af</i> parameter is set to <b>AF_UNSPEC</b> and the <i>type</i> and <i>protocol</i> parameter are unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned a version other than 2.2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROCTABLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned an invalid or incomplete procedure table to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wspstartup">WSPStartup</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTOTYPE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is the wrong type for this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROVIDERFAILEDINIT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the provider fails to operate correctly. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified socket type is not supported in this address family.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-socket
     * @since windows8.1
     */
    static socket(af, type, protocol) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\socket", "int", af, "int", type, "int", protocol, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The gethostbyaddr macro function (wsipv6ok.h) retrieves the host information corresponding to a network address.
     * @remarks
     * The 
     * <b>gethostbyaddr</b> function returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure that contains the name and address corresponding to the given network address.
     * 
     * The memory for the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure  returned by the <b>gethostbyaddr</b> function is allocated internally by the Winsock DLL from thread local storage. Only a single <b>hostent</b> structure is allocated and used, no matter how many times the <b>gethostbyaddr</b> or <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a> functions are called on the thread. The returned  <b>hostent</b> structure  must be copied to an application buffer if additional calls are to be made to the <b>gethostbyaddr</b> or <b>gethostbyname</b> functions on the same thread. Otherwise, the return value will be overwritten by subsequent <b>gethostbyaddr</b> or <b>gethostbyname</b> calls on the same thread. The internal memory allocated for the returned  <b>hostent</b> structure is released by the Winsock DLL when the thread exits. 
     * 
     * An application should not try to release the memory used by the returned <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other function calls to <b>gethostbyaddr</b> or <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a>.
     * 
     * Although 
     * <b>gethostbyaddr</b> no longer recommended for use as of Windows Sockets 2 and the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getnameinfo">getnameinfo</a> function should be used, 
     * <b>gethostbyaddr</b> is capable of returning a NetBIOS name; 
     * <b>getnameinfo</b> is not. Developers requiring NetBIOS name resolution may need to use <b>gethostbyaddr</b> until their applications are completely independent of NetBIOS names.
     * 
     * 
     * <div class="alert"><b>Note</b>   The capability to perform reverse lookups using the <b>gethostbyaddr</b> function is convenient, but such lookups are considered inherently unreliable, and should be used only as a hint.</div>
     * <div> </div>
     * 
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>gethostbyaddr</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer<PSTR>} addr 
     * @param {Integer} len 
     * @param {Integer} type 
     * @returns {Pointer<HOSTENT>} 
     * @see https://learn.microsoft.com/windows/win32/api/wsipv6ok/nf-wsipv6ok-gethostbyaddr
     * @deprecated
     * @since windows8.1
     */
    static gethostbyaddr(addr, len, type) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\gethostbyaddr", "ptr", addr, "int", len, "int", type, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The gethostbyname macro function (wsipv6ok.h) retrieves host information corresponding to a host name from a host database.
     * @remarks
     * The 
     * <b>gethostbyname</b> function returns a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure—a structure allocated by Windows Sockets. The 
     * <b>hostent</b> structure contains the results of a successful search for the host specified in the <i>name</i> parameter. 
     * 
     * If the host specified in the <i>name</i> parameter has both IPv4 and IPv6 addresses, only the IPv4 addresses will be returned. The  <b>gethostbyname</b> function can only return IPv4 addresses for the <i>name</i> parameter. The  <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a> function and associated <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure should be used if IPv6 addresses for the host are required or if both IPv4 and IPv6 addresses for the host are required.
     * 
     * If the <i>name</i> parameter points to an empty string or <i>name</i> is <b>NULL</b>, the returned string is the same as the string returned by a successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-gethostname">gethostname</a> function call (the standard host name for the local computer).
     * 
     * If the <i>name</i> parameter contains a string representation of a legal IPv4 address, then the binary IPv4 address that represents the string is returned in the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure. The <b>h_name</b> member of the <b>hostent</b> structure contains the string representation of the IPv4 address and the <b>h_addr_list</b>  contains the binary IPv4 address. If the <i>name</i> parameter contains a string representation of an IPv6 address or an illegal IPv4 address, then the  <b>gethostbyname</b> function will fail and return <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a>.  
     * 
     * The memory for the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure  returned by the <b>gethostbyname</b> function is allocated internally by the Winsock DLL from thread local storage. Only a single <b>hostent</b> structure is allocated and used, no matter how many times the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyaddr">gethostbyaddr</a> 
     * 		 or <b>gethostbyname</b> functions are called on the thread. The returned  <b>hostent</b> structure  must be copied to an application buffer if additional calls are to be made to the <b>gethostbyname</b> or <b>gethostbyaddr</b> functions on the same thread. Otherwise, the return value will be overwritten by subsequent <b>gethostbyname</b> or <b>gethostbyaddr</b> 
     * 		 calls on the same thread. The internal memory allocated for the returned  <b>hostent</b> structure is released by the Winsock DLL when the thread exits. 
     * 
     * An application should not try to release the memory used by the returned <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other function calls to <b>gethostbyname</b> or <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyaddr">gethostbyaddr</a> 
     * 		.
     * 
     * The 
     * <b>gethostbyname</b> function cannot take an IP address string as a parameter passed to it in the <i>name</i> and resolve it to a host name. Such a request is treated exactly as a string representation of an IPv4 address or an unknown host name were passed. An application can use the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-inet_addr">inet_addr</a> to convert an IPv4 address string to a binary IPv4 address, then use another function, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyaddr">gethostbyaddr</a>, to resolve the IPv4 address to a host name.  
     * 
     * 
     * <div class="alert"><b>Note</b>  The <b>gethostbyname</b> function does not check the size of the <i>name</i> parameter before passing the buffer. With an improperly sized <i>name</i> parameter, heap corruption can occur.</div>
     * <div> </div>
     * 
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following examples demonstrates the use of the <b>gethostbyname</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer<PSTR>} name 
     * @returns {Pointer<HOSTENT>} 
     * @see https://learn.microsoft.com/windows/win32/api/wsipv6ok/nf-wsipv6ok-gethostbyname
     * @deprecated
     * @since windows8.1
     */
    static gethostbyname(name) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\gethostbyname", "ptr", name, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The gethostname function (winsock.h) retrieves the standard host name for the local computer.
     * @remarks
     * The 
     * <b>gethostname</b> function returns the name of the local host into the buffer specified by the <i>name</i> parameter. The host name is returned as a <b>null</b>-terminated string. The form of the host name is dependent on the Windows Sockets provider—it can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed that the name returned will be successfully parsed by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-wsaasyncgethostbyname">WSAAsyncGetHostByName</a>.
     * 
     * The maximum length of the name returned in the buffer pointed to by the <i>name</i> parameter is dependent on the namespace provider.
     * 
     * If the 
     * <b>gethostname</b> function is used on a cluster resource on Windows Server 2008, Windows Server 2003, or 
     *   Windows 2000 Server and the _CLUSTER_NETWORK_NAME_ environment variable is defined, then the value in this environment variable overrides the actual hostname and is returned. On a cluster resource, the _CLUSTER_NETWORK_NAME_ environment variable contains the name of the cluster.
     * 
     * The 
     * <b>gethostname</b> function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID defined in the <i>Svgguid.h</i> header file. If no namespace provider responds, then the 
     * <b>gethostname</b> function returns the NetBIOS name of the local computer.
     * 
     * The maximum length, in bytes, of the string returned in the buffer pointed to by the <i>name</i> parameter is dependent on the namespace provider, but this string must be 256 bytes or less. So if a buffer of 256 bytes is passed in the <i>name</i> parameter and the <i>namelen</i> parameter is set to 256, the buffer size will always be adequate.
     * 
     * 
     * <div class="alert"><b>Note</b>  If no local host name has been configured, 
     * <b>gethostname</b> must succeed and return a token host name that 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-wsaasyncgethostbyname">WSAAsyncGetHostByName</a> can resolve.</div>
     * <div> </div>
     * 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<PSTR>} name A pointer to a buffer that receives the local host name.
     * @param {Integer} namelen The length, in bytes, of the buffer pointed to by the <i>name</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-gethostname
     * @since windows8.1
     */
    static gethostname(name, namelen) {
        A_LastError := 0

        DllCall("WS2_32.dll\gethostname", "ptr", name, "int", namelen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetHostNameW function retrieves the standard host name for the local computer as a Unicode string.
     * @remarks
     * The 
     * <b>GetHostNameW</b> function returns the name of the local host into the buffer specified by the <i>name</i> parameter in Unicode (UTF-16). The host name is returned as a <b>null</b>-terminated Unicode string. The form of the host name is dependent on the Windows Sockets provider—it can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed that the name returned will be successfully parsed by 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a>.
     * 
     * With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as special ASCII character strings (Punycode) are known as Internationalized Domain Names (IDNs). A  mechanism called
     *    Internationalizing Domain Names in Applications (IDNA) is used to handle
     *    IDNs in a standard fashion. The <b>GetHostNameW</b> function does not convert the local hostname between Punycode and Unicode. The <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a> function provides support for Internationalized Domain Name (IDN) parsing and performs Punycode/IDN encoding and conversion.  
     * 
     * If the 
     * <b>GetHostNameW</b> function is used on a cluster resource on Windows Server 2012 and the _CLUSTER_NETWORK_NAME_ environment variable is defined, then the value in this environment variable overrides the actual hostname and is returned. On a cluster resource, the _CLUSTER_NETWORK_NAME_ environment variable contains the name of the cluster.
     * 
     * The 
     * <b>GetHostNameW</b> function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID defined in the <i>Svgguid.h</i> header file. If no namespace provider responds, then the 
     * <b>GetHostNameW</b> function returns the NetBIOS name of the local computer in Unicode.
     * 
     * The maximum length, in wide characters, of the string returned in the buffer pointed to by the <i>name</i> parameter is dependent on the namespace provider, but this string must be 256 wide characters or less. So if a buffer of 256 wide characters is passed in the <i>name</i> parameter and the <i>namelen</i> parameter is set to 256, the buffer size will always be adequate.
     * 
     * 
     * <div class="alert"><b>Note</b>  If no local host name has been configured, 
     * <b>GetHostNameW</b> must succeed and return a token host name that 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a> can resolve.</div>
     * <div> </div>
     * 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<PWSTR>} name A pointer to a buffer that receives the local host name as a <b>null</b>-terminated Unicode string.
     * @param {Integer} namelen The length, in wide characters, of the buffer pointed to by the <i>name</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-gethostnamew
     * @since windows8.1
     */
    static GetHostNameW(name, namelen) {
        A_LastError := 0

        DllCall("WS2_32.dll\GetHostNameW", "ptr", name, "int", namelen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The getservbyport function (winsock.h) retrieves service information corresponding to a port and protocol.
     * @remarks
     * The 
     * <b>getservbyport</b> function returns a pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure as it does in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getservbyname">getservbyname</a> function.
     * 
     * The 
     * <b>servent</b> structure is allocated by Windows Sockets. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other Windows Sockets function calls.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} port Port for a service, in network byte order.
     * @param {Pointer<PSTR>} proto Optional pointer to a protocol name. If this is null, 
     * <b>getservbyport</b> returns the first service entry for which the <i>port</i> matches the <b>s_port</b> of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. Otherwise, 
     * <b>getservbyport</b> matches both the <i>port</i> and the <i>proto</i> parameters.
     * @returns {Pointer<SERVENT>} If no error occurs, 
     * <b>getservbyport</b> returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative Answer Service not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative Service not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>proto</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-getservbyport
     * @since windows8.1
     */
    static getservbyport(port, proto) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\getservbyport", "int", port, "ptr", proto, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getservbyname function (winsock.h) retrieves service information corresponding to a service name and protocol.
     * @remarks
     * The 
     * <b>getservbyname</b> function returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure containing the name(s) and service number that match the string in the <i>name</i> parameter. All strings are <b>null</b>-terminated.
     * 
     * The pointer that is returned points to the 
     * <b>servent</b> structure allocated by the Windows Sockets library. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information it needs before issuing any other Windows Sockets function calls.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<PSTR>} name A pointer to a <b>null</b>-terminated service name.
     * @param {Pointer<PSTR>} proto A pointer to a <b>null</b>-terminated protocol name. If this pointer is <b>NULL</b>, 
     * the <b>getservbyname</b> function returns the first service entry where <i>name</i> matches the <b>s_name</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure or the <b>s_aliases</b> member of the 
     * <b>servent</b> structure. Otherwise, 
     * <b>getservbyname</b> matches both the <i>name</i> and the <i>proto</i>.
     * @returns {Pointer<SERVENT>} If no error occurs, 
     * <b>getservbyname</b> returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. Otherwise, it returns a <b>null</b> pointer and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative Answer Service not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative Service not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-getservbyname
     * @since windows8.1
     */
    static getservbyname(name, proto) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\getservbyname", "ptr", name, "ptr", proto, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getprotobynumber function (winsock.h) retrieves protocol information corresponding to a protocol number.
     * @remarks
     * This 
     * <b>getprotobynumber</b> function returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure as previously described in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getprotobyname">getprotobyname</a>. The contents of the structure correspond to the given protocol number.
     * 
     * The pointer that is returned points to the structure allocated by Windows Sockets. The application must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy any information that it needs before issuing any other Windows Sockets function calls.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} number 
     * @returns {Pointer<PROTOENT>} If no error occurs, 
     * <b>getprotobynumber</b> returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative Protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-getprotobynumber
     * @since windows8.1
     */
    static getprotobynumber(number) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\getprotobynumber", "int", number, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getprotobyname function (winsock.h) retrieves the protocol information corresponding to a protocol name.
     * @remarks
     * The 
     * <b>getprotobyname</b> function returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure containing the name(s) and protocol number that correspond to the protocol specified in the <i>name</i> parameter. All strings are null-terminated. The 
     * <b>protoent</b> structure is allocated by the Windows Sockets library. An application must never attempt to modify this structure or to free any of its components. Furthermore, like 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a>, only one copy of this structure is allocated per thread, so the application should copy any information that it needs before issuing any other Windows Sockets function calls.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<PSTR>} name Pointer to a null-terminated protocol name.
     * @returns {Pointer<PROTOENT>} If no error occurs, 
     * <b>getprotobyname</b> returns a pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a>. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-getprotobyname
     * @since windows8.1
     */
    static getprotobyname(name) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\getprotobyname", "ptr", name, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAStartup function (winsock.h) initiates use of the Winsock DLL by a process.
     * @remarks
     * The 
     * <b>WSAStartup</b> function must be the first Windows Sockets function called by an application or DLL. It allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation. The application or DLL can only issue further Windows Sockets functions after successfully calling 
     * <b>WSAStartup</b>.
     * 
     * In order to support various Windows Sockets implementations and applications that can have functional differences from the latest version of Windows Sockets specification, a negotiation takes place in 
     * <b>WSAStartup</b>. The caller of 
     * <b>WSAStartup</b> passes in the <i>wVersionRequested</i> parameter the highest version of the Windows Sockets specification that the application supports. The Winsock DLL indicates the highest version of the Windows Sockets specification that it can support in its response. The Winsock DLL also replies with version of the Windows Sockets specification that it expects the caller to use.
     * 
     * When an application or DLL calls the 
     * <b>WSAStartup</b> function, the Winsock DLL examines the version of the Windows Sockets specification requested by the application passed in the  <i>wVersionRequested</i> parameter. If the version requested by the application is equal to or higher than the lowest version supported by the Winsock DLL, the call succeeds and the Winsock DLL returns detailed information in the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-wsadata">WSADATA</a> structure pointed to by the <i>lpWSAData</i> parameter. The <b>wHighVersion</b> member of the <b>WSADATA</b> structure indicates the highest version of the Windows Sockets specification that the Winsock DLL supports.  The <b>wVersion</b> member of the <b>WSADATA</b> structure indicates the version of the Windows Sockets specification that the Winsock DLL expects the caller to use.
     * 
     * If the <b>wVersion</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-wsadata">WSADATA</a> structure is unacceptable to the caller, the application or DLL should call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsacleanup">WSACleanup</a> to release the Winsock DLL  resources and fail to initialize the Winsock application. In order to support this application or DLL,  it will be necessary to search for an updated version of the Winsock DLL to install on the platform. 
     * 
     * The current version of the Windows Sockets specification is version 2.2. The current Winsock DLL, <i>Ws2_32.dll</i>, supports applications that request  any of the following  versions of Windows Sockets specification: <ul>
     * <li>1.0</li>
     * <li>1.1</li>
     * <li>2.0</li>
     * <li>2.1</li>
     * <li>2.2</li>
     * </ul>
     * 
     * 
     * To get full access to the new syntax of a higher version of the Windows Sockets specification, the application must negotiate for this higher version. In this case, the <i>wVersionRequested</i> parameter should be set to request version 2.2.  The application must also fully conform to that higher version of the Windows Socket specification, such as compiling against the appropriate header file, linking with a new library, or other special cases. The <i>Winsock2.h header</i> file for Winsock 2 support is included with the Microsoft Windows Software Development Kit (SDK).
     * 
     * Windows Sockets version 2.2 is supported on Windows Server 2008, 
     *   Windows Vista, Windows Server 2003,
     *   Windows XP,
     *   Windows 2000, Windows NT 4.0 with Service Pack 4 (SP4) and later,
     *   Windows Me,
     *   Windows 98, and Windows 95 OSR2. 
     *   Windows Sockets version 2.2 is also supported on   
     *   Windows 95 with the Windows Socket 2 Update. Applications on these platforms should normally request Winsock 2.2 by setting the <i>wVersionRequested</i> parameter accordingly.
     * 
     * On Windows 95 and versions of Windows NT 3.51 and earlier, Windows Sockets version 1.1 is the highest version of the Windows Sockets specification supported. 
     * 
     * It is legal and possible for an application or DLL written to use a lower version of the Windows Sockets specification that is supported by the Winsock DLL to successfully negotiate this lower version using the  <b>WSAStartup</b> function. For example, an application can request version 1.1 in the <i>wVersionRequested</i> parameter passed to the <b>WSAStartup</b> function on a platform with the Winsock 2.2 DLL. In this case, the application should only rely on features that fit within the version requested. New Ioctl codes, new behavior of existing functions, and new functions should not be used. The version negotiation provided by the <b>WSAStartup</b> was primarily used to allow older Winsock 1.1 applications developed for Windows 95 and   Windows NT 3.51 and earlier to run with the same behavior on later versions of Windows. The <i>Winsock.h header</i> file for Winsock 1.1 support is included with the Windows SDK.
     * 
     * This negotiation in the <b>WSAStartup</b> function allows both the application or DLL that uses Windows Sockets  and the Winsock DLL to support a range of Windows Sockets versions. An application or DLL can use the Winsock DLL if there is any overlap in the version ranges. Detailed information on the Windows Sockets implementation is provided in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-wsadata">WSADATA</a> structure returned by the <b>WSAStartup</b> function.
     * 
     * The following table shows how 
     * <b>WSAStartup</b> works with different applications and Winsock DLL versions.<table>
     * <tr>
     * <th>Caller version support</th>
     * <th>Winsock DLL version support</th>
     * <th><b>wVersion </b> requested</th>
     * <th><b>wVersion </b> returned</th>
     * <th><b>wHighVersion </b>  returned</th>
     * <th>End result</th>
     * </tr>
     * <tr>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>use 1.1</td>
     * </tr>
     * <tr>
     * <td>1.0 1.1</td>
     * <td>1.0</td>
     * <td>1.1</td>
     * <td>1.0</td>
     * <td>1.0</td>
     * <td>use 1.0</td>
     * </tr>
     * <tr>
     * <td>1.0</td>
     * <td>1.0 1.1</td>
     * <td>1.0</td>
     * <td>1.0</td>
     * <td>1.1</td>
     * <td>use 1.0</td>
     * </tr>
     * <tr>
     * <td>1.1</td>
     * <td>1.0 1.1</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>use 1.1</td>
     * </tr>
     * <tr>
     * <td>1.1</td>
     * <td>1.0</td>
     * <td>1.1</td>
     * <td>1.0</td>
     * <td>1.0</td>
     * <td>Application fails</td>
     * </tr>
     * <tr>
     * <td>1.0</td>
     * <td>1.1</td>
     * <td>1.0</td>
     * <td>—</td>
     * <td>—</td>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAVERNOTSUPPORTED</a></td>
     * </tr>
     * <tr>
     * <td>1.0 1.1</td>
     * <td>1.0 1.1</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>use 1.1</td>
     * </tr>
     * <tr>
     * <td>1.1 2.0</td>
     * <td>1.0 1.1</td>
     * <td>2.0</td>
     * <td>1.1</td>
     * <td>1.1</td>
     * <td>use 1.1</td>
     * </tr>
     * <tr>
     * <td>2.0</td>
     * <td>1.0 1.1 2.0</td>
     * <td>2.0</td>
     * <td>2.0</td>
     * <td>2.0</td>
     * <td>use 2.0</td>
     * </tr>
     * <tr>
     * <td>2.0 2.2</td>
     * <td>1.0 1.1 2.0</td>
     * <td>2.2</td>
     * <td>2.0</td>
     * <td>2.0</td>
     * <td>use 2.0</td>
     * </tr>
     * <tr>
     * <td>2.2</td>
     * <td>1.0 1.1 2.0 2.1 2.2</td>
     * <td>2.2</td>
     * <td>2.2</td>
     * <td>2.2</td>
     * <td>use 2.2</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * Once an application or DLL has made a successful 
     * <b>WSAStartup</b> call, it can proceed to make other Windows Sockets calls as needed. When it has finished using the services of the Winsock DLL, the application must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsacleanup">WSACleanup</a> to allow the Winsock DLL to free internal Winsock resources used by the application.
     * 
     * 
     * An application can call 
     * <b>WSAStartup</b> more than once if it needs to obtain the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-wsadata">WSADATA</a> structure information more than once. On each such call, the application can specify any version number supported by the Winsock DLL.
     * 
     * The 
     * <b>WSAStartup</b> function typically leads to protocol-specific helper DLLs being loaded. As a result, the 
     * <b>WSAStartup</b> function should not be called from the DllMain function in a application DLL. This can potentially cause deadlocks. For more information, please see the <a href="https://docs.microsoft.com/windows/win32/dlls/dllmain">DLL Main Function</a>.
     * 
     * An application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsacleanup">WSACleanup</a> function for every successful 
     * time the <b>WSAStartup</b> function is called.  This means, for example, that if an application calls 
     * <b>WSAStartup</b> three times, it must call 
     * <b>WSACleanup</b> three times. The first two calls to 
     * <b>WSACleanup</b> do nothing except decrement an internal counter; the final 
     * <b>WSACleanup</b> call for the task does all necessary resource deallocation for the task.
     * 
     * 
     * <div class="alert"><b>Note</b>  An application can call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function to determine the extended error code for other Windows sockets functions as is normally done in Windows Sockets even if 
     * the <b>WSAStartup</b> function fails or the <b>WSAStartup</b> function was not called to properly initialize Windows Sockets before calling a Windows Sockets function. The <b>WSAGetLastError</b> function is one of the only functions in the Winsock 2.2 DLL that can be called in the case of a <b>WSAStartup</b> failure. </div>
     * <div> </div>
     * 
     * 
     * <b>Windows Phone 8:</b> This  function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} wVersionRequested 
     * @param {Pointer<WSADATA>} lpWSAData A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-wsadata">WSADATA</a> data structure that is to receive details of the Windows Sockets implementation.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsastartup
     * @since windows8.1
     */
    static WSAStartup(wVersionRequested, lpWSAData) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAStartup", "ushort", wVersionRequested, "ptr", lpWSAData)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSACleanup function (winsock.h) terminates use of the WS2_32.dll.
     * @remarks
     * An application or DLL is required to perform a successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call before it can use Windows Sockets services. When it has completed the use of Windows Sockets, the application or DLL must call 
     * <b>WSACleanup</b> to deregister itself from a Windows Sockets implementation and allow the implementation to free any resources allocated on behalf of the application or DLL. 
     * 
     * When <b>WSACleanup</b> is called, any pending blocking or asynchronous Windows Sockets calls issued by any thread in this process are canceled without posting any notification messages or without signaling any event objects. Any pending overlapped send or receive operations (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a> with an overlapped socket, for example) issued by any thread in this process are also canceled without setting the event object or invoking the completion routine, if one was specified. In this case, the pending overlapped operations fail with the error status <b>WSA_OPERATION_ABORTED</b>.
     * 
     * Sockets that were open when 
     * <b>WSACleanup</b> was called are reset and automatically deallocated as if 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> were called. Sockets that have been closed with 
     * <b>closesocket</b> but that still have pending data to be sent can be affected when 
     * <b>WSACleanup</b> is called. In this case, the pending data can be lost if the WS2_32.DLL is unloaded from memory as the application exits. To ensure that all pending data is sent, an application should use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> to close the connection, then wait until the close completes before calling 
     * <b>closesocket</b> and 
     * <b>WSACleanup</b>. All resources and internal state, such as queued unposted or posted messages, must be deallocated so as to be available to the next user.
     * 
     * There must be a call to 
     * <b>WSACleanup</b> for each successful call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a>. Only the final 
     * <b>WSACleanup</b> function call performs the actual cleanup. The preceding calls simply decrement an internal reference count in the WS2_32.DLL.
     * 
     * <div class="alert"><b>Note</b>  <b>WSACleanup</b> does not unregister names (peer names, for example) that may have been registered with a Windows Sockets namespace provider such as Peer Name Resolution Protocol (PNRP) namespace provider.</div>
     * <div> </div>
     * In  Windows Sockets 1.1, attempting to call 
     * <b>WSACleanup</b> from within a blocking hook and then failing to check the return code was a common programming error. If a Winsock 1.1 application needs to quit while a blocking call is outstanding, the application has to first cancel the blocking call with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a> then issue the 
     * <b>WSACleanup</b> call once control has been returned to the application. In Windows Sockets 2, this issue does not exist and the <b>WSACancelBlockingCall</b> function has been removed.
     * 
     * The 
     * <b>WSACleanup</b> function typically leads to protocol-specific helper DLLs being unloaded. As a result, the 
     * <b>WSACleanup</b> function should not be called from the DllMain function in a application DLL. This can potentially cause deadlocks. For more information, please see the <a href="https://docs.microsoft.com/windows/win32/dlls/dllmain">DLL Main Function</a>.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsacleanup
     * @since windows8.1
     */
    static WSACleanup() {
        A_LastError := 0

        DllCall("WS2_32.dll\WSACleanup")
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSASetLastError function (winsock.h) sets the error code that can be retrieved through the WSAGetLastError function.
     * @remarks
     * The 
     * <b>WSASetLastError</b> function allows an application to set the error code to be returned by a subsequent 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> call for the current thread. Note that any subsequent Windows Sockets routine called by the application will override the error code as set by this routine.
     * 
     * The error code set by 
     * <b>WSASetLastError</b> is different from the error code reset by calling the function 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> with SO_ERROR. 
     * 
     * The Windows Sockets error codes used by this function are listed under <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} iError Integer that specifies the error code to be returned by a subsequent 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> call.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsasetlasterror
     * @since windows8.1
     */
    static WSASetLastError(iError) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASetLastError", "int", iError)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAGetLastError function (winsock.h) returns the error status for the last Windows Sockets operation that failed.
     * @remarks
     * The 
     * <b>WSAGetLastError</b> function returns the last error that occurred for the calling thread. When a particular Windows Sockets function indicates an error has occurred, this function should be called immediately to retrieve the extended error code for the failing function call. This extended error code can be different from the error code obtained from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> when called with an <i>optname</i> parameter of <b>SO_ERROR</b>, which is socket-specific since 
     * <b>WSAGetLastError</b> is for all thread-specific sockets.
     * 
     * If a function call's return value indicates that error or other relevant data was returned in the error code, <b>WSAGetLastError</b> should be called immediately. This is necessary because some functions may  reset the last extended error code to 0 if they succeed, overwriting the extended error code returned by a previously failed function. To specifically reset the extended error code, use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsasetlasterror">WSASetLastError</a> function call with the <i>iError</i> parameter set to zero. A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function when called with an <i>optname</i> parameter of <b>SO_ERROR</b> also resets the extended error code to zero.
     * 
     * The 
     * <b>WSAGetLastError</b> function should not be used to check for an extended error value on receipt of an asynchronous message. In this case, the extended error value is passed in the <i>lParam</i> parameter of the message, and this can differ from the value returned by 
     * <b>WSAGetLastError</b>.
     * 
     * 
     * <div class="alert"><b>Note</b>  An application can call the <b>WSAGetLastError</b> function to determine the extended error code for other Windows sockets functions as is normally done in Windows Sockets even if 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function fails or the <b>WSAStartup</b> function was not called to properly initialize Windows Sockets before calling a Windows Sockets function. The <b>WSAGetLastError</b> function is one of the only functions in the Winsock 2.2 DLL that can be called in the case of a <b>WSAStartup</b> failure. </div>
     * <div> </div>
     * 
     * 
     * The Windows Sockets extended error codes returned by this function and the text description of the error are listed under <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>. These error codes and a short text description associated with an error code are defined in the <i>Winerror.h</i> header file. The <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> function can be used to obtain the message string for the returned error.
     * 
     * For information on how to handle error codes when porting socket applications to Winsock, see <a href="https://docs.microsoft.com/windows/desktop/WinSock/error-codes-errno-h-errno-and-wsagetlasterror-2">Error Codes - errno, h_errno and WSAGetLastError</a>. 
     * 		
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @returns {Integer} The return value indicates the error code for this thread's last Windows Sockets operation that failed.
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsagetlasterror
     * @since windows8.1
     */
    static WSAGetLastError() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetLastError", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0. (WSAIsBlocking)
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaisblocking
     * @deprecated
     */
    static WSAIsBlocking() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAIsBlocking", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0. (WSAUnhookBlockingHook)
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaunhookblockinghook
     * @deprecated
     */
    static WSAUnhookBlockingHook() {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAUnhookBlockingHook")
        if(A_LastError)
            throw OSError()

    }

    /**
     * This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0. (WSASetBlockingHook)
     * @param {Pointer<FARPROC>} lpBlockFunc 
     * @returns {Pointer<FARPROC>} 
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasetblockinghook
     * @deprecated
     */
    static WSASetBlockingHook(lpBlockFunc) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASetBlockingHook", "ptr", lpBlockFunc, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSACancelBlockingCall function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsacancelblockingcall
     * @deprecated
     */
    static WSACancelBlockingCall() {
        A_LastError := 0

        DllCall("WS2_32.dll\WSACancelBlockingCall")
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAAsyncGetServByName function (winsock.h) asynchronously retrieves service information that corresponds to a service name and port.
     * @remarks
     * The 
     * <b>WSAAsyncGetServByName</b> function is an asynchronous version of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getservbyname">getservbyname</a> and is used to retrieve service information corresponding to a service name. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
     * 
     * When the asynchronous operation has completed, the application window indicated by the <i>hWnd</i> parameter receives message in the <i>wMsg</i> parameter. The <i>wParam</i> parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of <i>lParam</i> contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.
     * 
     * On successful completion, the buffer specified to the original function call contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. To access the members of this structure, the original buffer address should be cast to a 
     * <b>servent</b> structure pointer and accessed as appropriate.
     * 
     * If the error code is <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a>, the size of the buffer specified by <i>buflen</i> in the original call was too small to contain all the resulting information. In this case, the low 16 bits of <i>lParam</i> contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the 
     * <b>WSAAsyncGetServByName</b> function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of <i>lParam</i>).
     * 
     * The buffer specified to this function is used by Windows Sockets to construct a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure together with the contents of data areas referenced by members of the same 
     * <b>servent</b> structure. To avoid the <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a> error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
     * 
     * The error code and buffer length should be extracted from the <i>lParam</i> using the macros <b>WSAGETASYNCERROR</b> and <b>WSAGETASYNCBUFLEN</b>, defined in Winsock2.h as:
     * 
     * 
     * ```cpp
     * @param {Pointer<HWND>} hWnd Handle of the window that should receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {Pointer<PSTR>} name Pointer to a <b>null</b>-terminated service name.
     * @param {Pointer<PSTR>} proto Pointer to a protocol name. This can be <b>NULL</b>, in which case 
     * <b>WSAAsyncGetServByName</b> will search for the first service entry for which <i>s_name</i> or one of the <i>s_aliases</i> matches the given <i>name</i>. Otherwise, 
     * <b>WSAAsyncGetServByName</b> matches both <i>name</i> and <i>proto</i>.
     * @param {Pointer<PSTR>} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> data. The data area must be larger than the size of a 
     * <b>servent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>servent</b> structure and all of the data that is referenced by members of the 
     * <b>servent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {Pointer<HANDLE>} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetServByName</b> returns a nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, <b>WSAAsyncServByName</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer host not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative service not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsaasyncgetservbyname
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetServByName(hWnd, wMsg, name, proto, buf, buflen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetServByName", "ptr", hWnd, "uint", wMsg, "ptr", name, "ptr", proto, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAAsyncGetServByPort function (winsock.h) asynchronously retrieves service information that corresponds to a port and protocol.
     * @remarks
     * The 
     * <b>WSAAsyncGetServByPort</b> function is an asynchronous version of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getservbyport">getservbyport</a>, and is used to retrieve service information corresponding to a port number. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
     * 
     * When the asynchronous operation has completed, the application window indicated by the <i>hWnd</i> parameter receives message in the <i>wMsg</i> parameter. The <i>wParam</i> parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of <i>lParam</i> contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.
     * 
     * On successful completion, the buffer specified to the original function call contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. To access the members of this structure, the original buffer address should be cast to a 
     * <b>servent</b> structure pointer and accessed as appropriate.
     * 
     * If the error code is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a>, the size of the buffer specified by <i>buflen</i> in the original call was too small to contain all the resulting information. In this case, the low 16 bits of <i>lParam</i> contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the 
     * <b>WSAAsyncGetServByPort</b> function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of <i>lParam</i>).
     * 
     * The buffer specified to this function is used by Windows Sockets to construct a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure together with the contents of data areas referenced by members of the same 
     * <b>servent</b> structure. To avoid the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a> error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
     * 
     * The error code and buffer length should be extracted from the <i>lParam</i> using the macros <b>WSAGETASYNCERROR</b> and <b>WSAGETASYNCBUFLEN</b>, defined in Winsock2.h as:
     * 
     * 
     * ```cpp
     * @param {Pointer<HWND>} hWnd Handle of the window that should receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {Integer} port Port for the service, in network byte order.
     * @param {Pointer<PSTR>} proto Pointer to a protocol name. This can be <b>NULL</b>, in which case 
     * <b>WSAAsyncGetServByPort</b> will search for the first service entry for which <i>s_port</i> match the given <i>port</i>. Otherwise, 
     * <b>WSAAsyncGetServByPort</b> matches both <i>port</i> and <i>proto</i>.
     * @param {Pointer<PSTR>} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> data. The data area must be larger than the size of a 
     * <b>servent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>servent</b> structure and all of the data that is referenced by members of the 
     * <b>servent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {Pointer<HANDLE>} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetServByPort</b> returns a nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetServByPort</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>proto</i> or <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer port not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative port not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsaasyncgetservbyport
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetServByPort(hWnd, wMsg, port, proto, buf, buflen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetServByPort", "ptr", hWnd, "uint", wMsg, "int", port, "ptr", proto, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAAsyncGetProtoByName function (winsock.h) asynchronously retrieves protocol information that corresponds to a protocol name.
     * @remarks
     * The 
     * <b>WSAAsyncGetProtoByName</b> function is an asynchronous version of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getprotobyname">getprotobyname</a>. It is used to retrieve the protocol name and number from the Windows Sockets database corresponding to a given protocol name. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
     * 
     * When the asynchronous operation has completed, the application window indicated by the <i>hWnd</i> parameter receives message in the <i>wMsg</i> parameter. The <i>wParam</i> parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of <i>lParam</i> contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.
     * 
     * On successful completion, the buffer specified to the original function call contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure. To access the members of this structure, the original buffer address should be cast to a 
     * <b>protoent</b> structure pointer and accessed as appropriate.
     * 
     * If the error code is <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a>, the size of the buffer specified by <i>buflen</i> in the original call was too small to contain all the resulting information. In this case, the low 16 bits of <i>lParam</i> contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the 
     * <b>WSAAsyncGetProtoByName</b> function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of <i>lParam</i>).
     * 
     * The buffer specified to this function is used by Windows Sockets to construct a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure together with the contents of data areas referenced by members of the same 
     * <b>protoent</b> structure. To avoid the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a> error noted above, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
     * 
     * The error code and buffer length should be extracted from the <i>lParam</i> using the macros <b>WSAGETASYNCERROR</b> and <b>WSAGETASYNCBUFLEN</b>, defined in Winsock2.h as:
     * 
     * 
     * ```cpp
     * @param {Pointer<HWND>} hWnd Handle of the window that will receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {Pointer<PSTR>} name Pointer to the null-terminated protocol name to be resolved.
     * @param {Pointer<PSTR>} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> data. The data area must be larger than the size of a 
     * <b>protoent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>protoent</b> structure and all of the data that is referenced by members of the 
     * <b>protoent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {Pointer<HANDLE>} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetProtoByName</b> returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetProtoByName</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsaasyncgetprotobyname
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetProtoByName(hWnd, wMsg, name, buf, buflen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetProtoByName", "ptr", hWnd, "uint", wMsg, "ptr", name, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAAsyncGetProtoByNumber function (winsock.h) asynchronously retrieves protocol information that corresponds to a protocol number.
     * @remarks
     * The 
     * <b>WSAAsyncGetProtoByNumber</b> function is an asynchronous version of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getprotobynumber">getprotobynumber</a>, and is used to retrieve the protocol name and number corresponding to a protocol number. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
     * 
     * When the asynchronous operation has completed, the application window indicated by the <i>hWnd</i> parameter receives message in the <i>wMsg</i> parameter. The <i>wParam</i> parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of <i>lParam</i> contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.
     * 
     * On successful completion, the buffer specified to the original function call contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure. To access the members of this structure, the original buffer address is cast to a 
     * <b>protoent</b> structure pointer and accessed as appropriate.
     * 
     * If the error code is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a>, the size of the buffer specified by <i>buflen</i> in the original call was too small to contain all the resulting information. In this case, the low 16 bits of <i>lParam</i> contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the 
     * <b>WSAAsyncGetProtoByNumber</b> function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of <i>lParam</i>).
     * 
     * The buffer specified to this function is used by Windows Sockets to construct a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure together with the contents of data areas referenced by members of the same 
     * <b>protoent</b> structure. To avoid the WSAENOBUFS error noted above, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
     * 
     * The error code and buffer length should be extracted from the <i>lParam</i> using the macros <b>WSAGETASYNCERROR</b> and <b>WSAGETASYNCBUFLEN</b>, defined in Winsock2.h as:
     * 
     * 
     * ```cpp
     * @param {Pointer<HWND>} hWnd Handle of the window that will receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {Integer} number Protocol number to be resolved, in host byte order.
     * @param {Pointer<PSTR>} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> data. The data area must be larger than the size of a 
     * <b>protoent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>protoent</b> structure and all of the data that is referenced by members of the 
     * <b>protoent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {Pointer<HANDLE>} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetProtoByNumber</b> returns a nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetProtoByNumber</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsaasyncgetprotobynumber
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetProtoByNumber(hWnd, wMsg, number, buf, buflen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetProtoByNumber", "ptr", hWnd, "uint", wMsg, "int", number, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAAsyncGetHostByName macro function (wsipv6ok.h) asynchronously retrieves host information that corresponds to a host name.
     * @remarks
     * The 
     * <b>WSAAsyncGetHostByName</b> function is an asynchronous version of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a>, and is used to retrieve host name and address information corresponding to a host name. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque asynchronous task handle that which the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
     * 
     * When the asynchronous operation has completed, the application window indicated by the <i>hWnd</i> parameter receives message in the <i>wMsg</i> parameter. The <i>wParam</i> parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of <i>lParam</i> contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.
     * 
     * On successful completion, the buffer specified to the original function call contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure. To access the elements of this structure, the original buffer address should be cast to a 
     * <b>hostent</b> structure pointer and accessed as appropriate.
     * 
     * If the error code is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a>, the size of the buffer specified by <i>buflen</i> in the original call was too small to contain all the resulting information. In this case, the low 16 bits of <i>lParam</i> contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the 
     * <b>WSAAsyncGetHostByName</b> function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of <i>lParam</i>).
     * 
     * The buffer specified to this function is used by Windows Sockets to construct a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure together with the contents of data areas referenced by members of the same 
     * <b>hostent</b> structure. To avoid the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a> error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
     * 
     * The error code and buffer length should be extracted from the <i>lParam</i> using the macros <b>WSAGETASYNCERROR</b> and <b>WSAGETASYNCBUFLEN</b>, defined in Winsock2.h as:
     * 
     * 
     * ```cpp
     * @param {Pointer<HWND>} hWnd 
     * @param {Integer} wMsg 
     * @param {Pointer<PSTR>} name 
     * @param {Pointer<PSTR>} buf 
     * @param {Integer} buflen 
     * @returns {Pointer<HANDLE>} 
     * @see https://learn.microsoft.com/windows/win32/api/wsipv6ok/nf-wsipv6ok-wsaasyncgethostbyname
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetHostByName(hWnd, wMsg, name, buf, buflen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetHostByName", "ptr", hWnd, "uint", wMsg, "ptr", name, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAAsyncGetHostByAddr macro function (wsipv6ok.h) asynchronously retrieves host information that corresponds to an address.
     * @remarks
     * The 
     * <b>WSAAsyncGetHostByAddr</b> function is an asynchronous version of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyaddr">gethostbyaddr</a>. It is used to retrieve the host name and address information that corresponds to a network address. Windows Sockets initiates the operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
     * 
     * When the asynchronous operation has completed, the application window indicated by the <i>hWnd</i> parameter receives message in the <i>wMsg</i> parameter. The <i>wParam</i> parameter contains the asynchronous task handle as returned by the original function call. The high 16 bits of <i>lParam</i> contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero indicates successful completion of the asynchronous operation.
     * 
     * On successful completion, the buffer specified to the original function call contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure. To access the members of this structure, the original buffer address is cast to a 
     * <b>hostent</b> structure pointer and accessed as appropriate.
     * 
     * If the error code is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a>, the size of the buffer specified by <i>buflen</i> in the original call was too small to contain all the resulting information. In this case, the low 16 bits of <i>lParam</i> contain the size of buffer required to supply all the requisite information. If the application decides that the partial data is inadequate, it can reissue the 
     * <b>WSAAsyncGetHostByAddr</b> function call with a buffer large enough to receive all the desired information (that is, no smaller than the low 16 bits of <i>lParam</i>).
     * 
     * The buffer specified to this function is used by Windows Sockets to construct a structure together with the contents of data areas referenced by members of the same 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure. To avoid the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a> error, the application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
     * 
     * The error code and buffer length should be extracted from the <i>lParam</i> using the macros <b>WSAGETASYNCERROR</b> and <b>WSAGETASYNCBUFLEN</b>, defined in Winsock2.h as:
     * 
     * 
     * ```cpp
     * @param {Pointer<HWND>} hWnd 
     * @param {Integer} wMsg 
     * @param {Pointer<PSTR>} addr 
     * @param {Integer} len 
     * @param {Integer} type 
     * @param {Pointer<PSTR>} buf 
     * @param {Integer} buflen 
     * @returns {Pointer<HANDLE>} 
     * @see https://learn.microsoft.com/windows/win32/api/wsipv6ok/nf-wsipv6ok-wsaasyncgethostbyaddr
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetHostByAddr(hWnd, wMsg, addr, len, type, buf, buflen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetHostByAddr", "ptr", hWnd, "uint", wMsg, "ptr", addr, "int", len, "int", type, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSACancelAsyncRequest function (winsock.h) cancels an incomplete asynchronous operation.
     * @remarks
     * The 
     * <b>WSACancelAsyncRequest</b> function is used to cancel an asynchronous operation that was initiated by one of the <b>WSAAsyncGetXByY</b> functions such as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-wsaasyncgethostbyname">WSAAsyncGetHostByName</a>. The operation to be canceled is identified by the <i>hAsyncTaskHandle</i> parameter, which should be set to the asynchronous task handle as returned by the initiating <b>WSAAsyncGetXByY</b> function.
     * 
     * An attempt to cancel an existing asynchronous <b>WSAAsyncGetXByY</b> operation can fail with an error code of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a> for two reasons. First, the original operation has already completed and the application has dealt with the resultant message. Second, the original operation has already completed but the resultant message is still waiting in the application window queue.
     * @param {Pointer<HANDLE>} hAsyncTaskHandle Handle that specifies the asynchronous operation to be canceled.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsacancelasyncrequest
     * @deprecated
     * @since windows5.0
     */
    static WSACancelAsyncRequest(hAsyncTaskHandle) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSACancelAsyncRequest", "ptr", hAsyncTaskHandle)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAAsyncSelect function (winsock.h) requests Windows message-based notification of network events for a socket.
     * @remarks
     * The 
     * <b>WSAAsyncSelect</b> function is used to request that WS2_32.DLL should send a message to the window <i>hWnd</i> when it detects any network event specified by the <i>lEvent</i> parameter. The message that should be sent is specified by the <i>wMsg</i> parameter. The socket for which notification is required is identified by the <i>s</i> parameter.
     * 
     * The <b>WSAAsyncSelect</b> function automatically sets socket <i>s</i> to nonblocking mode, regardless of the value of <i>lEvent</i>. To set socket <i>s</i> back to blocking mode, it is first necessary to clear the event record associated with socket <i>s</i> via a call to <b>WSAAsyncSelect</b> with <i>lEvent</i> set to zero. You can then call <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-ioctlsocket">ioctlsocket</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> to set the socket back to blocking mode.  For more information about how to set the nonblocking socket back to blocking mode, see the <b>ioctlsocket</b> and <b>WSAIoctl</b> functions.
     * 
     * The <i>lEvent</i> parameter is constructed by using the bitwise OR operator with any value listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>FD_READ</b></td>
     * <td>Set to receive notification of readiness for reading.</td>
     * </tr>
     * <tr>
     * <td><b>FD_WRITE</b></td>
     * <td>Wants to receive notification of readiness for writing.</td>
     * </tr>
     * <tr>
     * <td><b>FD_OOB</b></td>
     * <td>Wants to receive notification of the arrival of OOB data.</td>
     * </tr>
     * <tr>
     * <td><b>FD_ACCEPT</b></td>
     * <td>Wants to receive notification of incoming connections.</td>
     * </tr>
     * <tr>
     * <td><b>FD_CONNECT</b></td>
     * <td>Wants to receive notification of completed connection or multipoint join operation.</td>
     * </tr>
     * <tr>
     * <td><b>FD_CLOSE</b></td>
     * <td>Wants to receive notification of socket closure.</td>
     * </tr>
     * <tr>
     * <td><b>FD_QOS</b></td>
     * <td>Wants to receive notification of socket Quality of Service (QoS) changes.</td>
     * </tr>
     * <tr>
     * <td><b>FD_GROUP_QOS</b></td>
     * <td>Wants to receive notification of socket group Quality of Service (QoS) changes (reserved for future use with socket groups). Reserved.</td>
     * </tr>
     * <tr>
     * <td><b>FD_ROUTING_INTERFACE_CHANGE</b></td>
     * <td>Wants to receive notification of routing interface changes for the specified destination(s).</td>
     * </tr>
     * <tr>
     * <td><b>FD_ADDRESS_LIST_CHANGE</b></td>
     * <td>Wants to receive notification of local address list changes for the socket protocol family.</td>
     * </tr>
     * </table>
     *  
     * 
     * Issuing a 
     * <b>WSAAsyncSelect</b> for a socket cancels any previous 
     * <b>WSAAsyncSelect</b> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> for the same socket. For example, to receive notification for both reading and writing, the application must call 
     * <b>WSAAsyncSelect</b> with both <b>FD_READ</b> and <b>FD_WRITE</b>, as follows:
     * 
     * 
     * ```cpp
     * rc = WSAAsyncSelect(s, hWnd, wMsg, FD_READ|FD_WRITE);
     * 
     * ```
     * 
     * 
     * It is not possible to specify different messages for different events. The following code will not work; the second call will cancel the effects of the first, and only <b>FD_WRITE</b> events will be reported with message wMsg2:
     * 
     * 
     * ```cpp
     * rc = WSAAsyncSelect(s, hWnd, wMsg1, FD_READ);
     * rc = WSAAsyncSelect(s, hWnd, wMsg2, FD_WRITE);
     * 
     * ```
     * 
     * 
     * To cancel all notification indicating that Windows Sockets should send no further messages related to network events on the socket, <i>lEvent</i> is set to zero.
     * 
     * 
     * ```cpp
     * rc = WSAAsyncSelect(s, hWnd, 0, 0);
     * 
     * ```
     * 
     * 
     * Although 
     * <b>WSAAsyncSelect</b> immediately disables event message posting for the socket in this instance, it is possible that messages could be waiting in the application message queue. Therefore, the application must be prepared to receive network event messages even after cancellation. Closing a socket with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> also cancels 
     * <b>WSAAsyncSelect</b> message sending, but the same caveat about messages in the queue still applies.
     * 
     * The socket created by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function has the same properties as the listening socket used to accept it. Consequently, 
     * <b>WSAAsyncSelect</b> events set for the listening socket also apply to the accepted socket. For example, if a listening socket has 
     * <b>WSAAsyncSelect</b> events <b>FD_ACCEPT</b>, <b>FD_READ</b>, and <b>FD_WRITE</b>, then any socket accepted on that listening socket will also have <b>FD_ACCEPT</b>, <b>FD_READ</b>, and <b>FD_WRITE</b> events with the same <i>wMsg</i> value used for messages. If a different <i>wMsg</i> or events are desired, the application should call 
     * <b>WSAAsyncSelect</b>, passing the accepted socket and the desired new data.
     * 
     * When one of the nominated network events occurs on the specified socket <i>s</i>, the application window <i>hWnd</i> receives message <i>wMsg</i>. The <i>wParam</i> parameter identifies the socket on which a network event has occurred. The low word of <i>lParam</i> specifies the network event that has occurred. The high word of <i>lParam</i> contains any error code. The error code be any error as defined in Winsock2.h.
     * 
     * <div class="alert"><b>Note</b>  Upon receipt of an event notification message, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function cannot be used to check the error value because the error value returned can differ from the value in the high word of <i>lParam</i>.</div>
     * <div> </div>
     * The error and event codes can be extracted from the <i>lParam</i> using the macros <b>WSAGETSELECTERROR</b> and <b>WSAGETSELECTEVENT</b>, defined in Winsock2.h as:
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor that identifies the socket for which event notification is required.
     * @param {Pointer<HWND>} hWnd A handle that identifies the window that will receive a message when a network event occurs.
     * @param {Integer} wMsg A message to be received when a network event occurs.
     * @param {Integer} lEvent A bitmask that specifies a combination of network events in which the application is interested.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock/nf-winsock-wsaasyncselect
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncSelect(s, hWnd, wMsg, lEvent) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAAsyncSelect", "ptr", s, "ptr", hWnd, "uint", wMsg, "int", lEvent)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAAccept function conditionally accepts a connection based on the return value of a condition function, provides quality of service flow specifications, and allows the transfer of connection data.
     * @remarks
     * The <b>WSAAccept</b> function extracts the first connection on the queue of pending connections on socket <i>s</i>, and checks it against the condition function, provided the condition function is specified (that is, not <b>NULL</b>). If the condition function returns CF_ACCEPT, 
     * <b>WSAAccept</b> creates a new socket. The newly created socket has the same properties as socket <i>s</i> including asynchronous events registered with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>. If the condition function returns CF_REJECT, 
     * <b>WSAAccept</b> rejects the connection request. The condition function runs in the same thread as this function does, and should return as soon as possible. If the decision cannot be made immediately, the condition function should return CF_DEFER to indicate that no decision has been made, and no action about this connection request should be taken by the service provider. When the application is ready to take action on the connection request, it will invoke 
     * <b>WSAAccept</b> again and return either CF_ACCEPT or CF_REJECT as a return value from the condition function.
     * 
     * A socket in default mode (blocking) will block until a connection is present when an application calls 
     * <b>WSAAccept</b> and no connections are pending on the queue.
     * 
     * A socket in nonblocking mode (blocking) fails with the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> when an application calls 
     * <b>WSAAccept</b> and no connections are pending on the queue. After 
     * <b>WSAAccept</b> succeeds and returns a new socket handle, the accepted socket cannot be used to accept any more connections. The original socket remains open and listens for new connection requests.
     * 
     * The <i>addr</i> parameter is a result parameter that is filled in with the address of the connecting entity, as known to the communications layer. The exact format of the <i>addr</i> parameter is determined by the address family in which the communication is occurring. The <i>addrlen</i> is a value-result parameter; it should initially contain the amount of space pointed to by <i>addr</i>. On return, it will contain the actual length (in bytes) of the address returned. This call is used with connection-oriented socket types such as SOCK_STREAM. If <i>addr</i> and/or <i>addrlen</i> are equal to <b>NULL</b>, then no information about the remote address of the accepted socket is returned. Otherwise, these two parameters will be filled in if the connection is successfully accepted.
     * 
     * A prototype of the condition function is defined in the `Winsock2.h` header file as the <b>LPCONDITIONPROC</b>, as follows.
     * 
     * ```cpp
     * int CALLBACK 
     * ConditionFunc( 
     *   IN     LPWSABUF    lpCallerId, 
     *   IN     LPWSABUF    lpCallerData, 
     *   IN OUT LPQOS       lpSQOS, 
     *   IN OUT LPQOS       lpGQOS,
     *   IN     LPWSABUF    lpCalleeId, 
     *   IN     LPWSABUF    lpCalleeData, 
     *   OUT    GROUP FAR * g, 	
     *   IN     DWORD_PTR   dwCallbackData
     * );
     * ```
     * 
     * The <b>ConditionFunc</b> is a placeholder for the application-specified callback function. The actual condition function must reside in a DLL or application module. It is exported in the module definition file.
     * 
     * The <i>lpCallerId</i> parameter points to a WSABUF structure that contains the address of the connecting entity, where its <i>len</i> parameter is the length of the buffer in bytes, and its <i>buf</i> parameter is a pointer to the buffer. The <i>lpCallerData</i> is a value parameter that contains any user data. The information in these parameters is sent along with the connection request. If no caller identification or caller data is available, the corresponding parameters will be <b>NULL</b>. Many network protocols do not support connect-time caller data. Most conventional network protocols can be expected to support caller identifier information at connection-request time. The buf portion of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> pointed to by <i>lpCallerId</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a>. The <b>sockaddr</b> structure is interpreted according to its address family (typically by casting the <b>sockaddr</b> to some type specific to the address family).
     * 
     * The <i>lpSQOS</i> parameter references the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for socket <i>s</i> specified by the caller, one for each direction, followed by any additional provider-specific parameters. The sending or receiving flow specification values will be ignored as appropriate for any unidirectional sockets. A <b>NULL</b> value indicates that there is no caller-supplied quality of service and that no negotiation is possible. A non-<b>NULL</b> <i>lpSQOS</i> pointer indicates that a quality of service negotiation is to occur or that the provider is prepared to accept the quality of service request without negotiation.
     * 
     * The <i>lpGQOS</i> parameter is reserved, and should be <b>NULL</b>. (reserved for future use with socket groups) references the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structure for the socket group the caller is to create, one for each direction, followed by any additional provider-specific parameters. A <b>NULL</b> value for <i>lpGQOS</i> indicates no caller-specified group quality of service. Quality of service information can be returned if negotiation is to occur.
     * 
     * The <i>lpCalleeId</i> is a parameter that contains the local address of the connected entity. The <i>buf</i> portion of the WSABUF pointed to by <i>lpCalleeId</i> points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure. The <b>sockaddr</b> structure is interpreted according to its address family (typically by casting the <b>sockaddr</b> to some type specific to the address family such as struct <b>sockaddr_in</b>).
     * 
     * The <i>lpCalleeData</i> is a result parameter used by the condition function to supply user data back to the connecting entity. The <i>lpCalleeData-&gt;len</i> initially contains the length of the buffer allocated by the service provider and pointed to by <i>lpCalleeData-&gt;buf</i>. A value of zero means passing user data back to the caller is not supported. The condition function should copy up to <i>lpCalleeData-&gt;len</i> bytes of data into <i>lpCalleeData-&gt;buf</i>, and then update <i>lpCalleeData-&gt;len</i> to indicate the actual number of bytes transferred. If no user data is to be passed back to the caller, the condition function should set <i>lpCalleeData-&gt;len</i> to zero. The format of all address and user data is specific to the address family to which the socket belongs.
     * 
     * The <i>g</i> parameter is assigned within the condition function to indicate any of the following actions:
     * 
     * <ul>
     * <li>If <i>g</i> is an existing socket group identifier, add <i>s</i> to this group, provided all the requirements set by this group are met.</li>
     * <li>If  <i>g</i> = SG_UNCONSTRAINED_GROUP, create an unconstrained socket group and have <i>s</i> as the first member.</li>
     * <li>If <i>g</i> = SG_CONSTRAINED_GROUP, create a constrained socket group and have <i>s</i> as the first member.</li>
     * <li>If <i>g</i> = zero, no group operation is performed.</li>
     * </ul>
     * For unconstrained groups, any set of sockets can be grouped together as long as they are supported by a single service provider. A constrained socket group can consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host. For newly created socket groups, the new group identifier can be retrieved by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function with <i>level</i> parameter set to <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET</a> and the <i>optname</i> parameter set to <b>SO_GROUP_ID</b>.  A socket group and its associated socket group ID remain valid until the last socket belonging to this socket group is closed. Socket group IDs are unique across all processes for a given service provider. A socket group and its associated identifier remain valid until the last socket belonging to this socket group is closed. Socket group identifiers are unique across all processes for a given service provider. For more information on socket groups, see the Remarks for the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> functions.
     * 
     * The <i>dwCallbackData</i> parameter value passed to the condition function is the value passed as the <i>dwCallbackData</i> parameter in the original 
     * <b>WSAAccept</b> call. This value is interpreted only by the Windows Socket version 2 client. This allows a client to pass some context information from the 
     * <b>WSAAccept</b> call site through to the condition function. This also provides the condition function with any additional information required to determine whether to accept the connection or not. A typical usage is to pass a (suitably cast) pointer to a data structure containing references to application-defined objects with which this socket is associated.
     * 
     * <div class="alert"><b>Note</b>  To protect use of the <b>WSAAccept</b> function from SYN attacks, applications must perform full TCP handshakes (SYN-SYNACK-ACK) before reporting the connection request. Protecting against SYN attacks in this manner results in the SO_CONDITIONAL_ACCEPT socket option becoming inoperative; the conditional function is still called, and the <b>WSAAccept</b> function operates properly, but   server applications that rely on clients being unable to perform the handshake will not operate properly.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSAAccept</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSAAccept</b> function.
     * 
     * ```cpp
     * @param {Pointer} s A descriptor that identifies a socket that is listening for connections after a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function.
     * @param {Pointer<SOCKADDR>} addr An optional pointer to an <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that receives the address of the connecting entity, as known to the communications layer. The exact format of the <i>addr</i> parameter is determined by the address family established when the socket was created.
     * @param {Pointer<Int32>} addrlen An optional pointer to an integer that contains the length of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>addr</i> parameter, in bytes.
     * @param {Pointer<LPCONDITIONPROC>} lpfnCondition The  address of an optional, application-specified condition function that will make an accept/reject decision based on the caller information passed in as parameters, and optionally create or join a socket group by assigning an appropriate value to the result parameter <i>g</i> of this function. If this parameter is <b>NULL</b>, then no condition function is called.
     * @param {Pointer} dwCallbackData Callback data passed back to the application-specified condition function as the value of the <i>dwCallbackData</i> parameter passed to the condition function. This parameter is only applicable if the <i>lpfnCondition</i> parameter is not <b>NULL</b>. This parameter is not interpreted by Windows Sockets.
     * @returns {Pointer} If no error occurs, 
     * <b>WSAAccept</b> returns a value of type SOCKET that is a descriptor for the accepted socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The integer referred to by <i>addrlen</i> initially contains the amount of space pointed to by <i>addr</i>. On return it will contain the actual length in bytes of the address returned.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to access a socket in a way forbidden by its access permissions. This error is returned if the connection request that was offered has timed out or been withdrawn.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No connection could be made because the target machine actively refused it. This error is returned if the connection request was forcefully rejected as indicated in the return value of the condition function (CF_REJECT).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An existing connection was forcibly closed by the remote host. This error is returned of an incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned of the <i>addrlen</i> parameter is too small or the <i>addr</i> or <i>lpfnCondition</i> is not part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking operation was interrupted by a call to <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>. This error is returned if a blocking Windows Sockets 1.1 call was canceled through 
     * <b>WSACancelBlockingCall</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking operation is currently executing. This error is returned if a blocking Windows Sockets 1.1 call is in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.
     * 								This error is returned if <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> was not invoked prior to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a>, the return value of the condition function is not a valid one, or any case where the specified socket is in an invalid state.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Too many open sockets. This error is returned if the queue is nonempty upon entry to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> and there are no socket descriptors available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation encountered a dead network. This error is returned if the network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. This error is returned if no buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation was attempted on something that is not a socket. This error is returned if the socket descriptor passed in the <i>s</i> parameter is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol family has not been configured into the system or no implementation for it exists. This error is returned if the referenced socket is not a type that supports connection-oriented service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A non-blocking socket operation could not be completed immediately. This error is returned if the socket is marked as nonblocking and no connections are present to be accepted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the application has not called <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a>, or <b>WSAStartup</b> failed. This error is returned of a successful 
     * call to the <b>WSAStartup</b> function dit not occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server. This error is returned if the acceptance of the connection request was deferred as indicated in the return value of the condition function (CF_DEFER).
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaaccept
     * @since windows8.1
     */
    static WSAAccept(s, addr, addrlen, lpfnCondition, dwCallbackData) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAccept", "ptr", s, "ptr", addr, "ptr", addrlen, "ptr", lpfnCondition, "ptr", dwCallbackData, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSACloseEvent function closes an open event object handle.
     * @remarks
     * The 
     * <b>WSACloseEvent</b> function closes the handle to an event object and frees resources associated with the event object. This function is used to close a handle created by the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacreateevent">WSACreateEvent</a> function. Once the handle to the  event object is closed, further references to this handle will fail with the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a>.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} hEvent Object handle identifying the open event.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> is not a valid event object handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsacloseevent
     * @since windows8.1
     */
    static WSACloseEvent(hEvent) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSACloseEvent", "ptr", hEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAConnect function establishes a connection to another socket application, exchanges connect data, and specifies required quality of service based on the specified FLOWSPEC structure.
     * @remarks
     * The 
     * <b>WSAConnect</b> function is used to create a connection to the specified destination, and to perform a number of other ancillary operations that occur at connect time. If the socket, <i>s</i>, is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.
     * 
     * For applications targeted to Windows Vista and later, consider using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnectbylist">WSAConnectByList</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnectbynamea">WSAConnectByName</a> function which greatly simplify client application design.
     * 
     * For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using <i>name</i> (an address in the namespace of the socket; for a detailed description, please see 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a>). When this call completes successfully, the socket is ready to send/receive data. If the address parameter of the <i>name</i> structure is all zeroes, 
     * <b>WSAConnect</b> will return the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a>. Any attempt to reconnect an active connection will fail with the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a>.
     * 
     * <div class="alert"><b>Note</b>  If a socket is opened, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> call is made, and then a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a> call is made, Windows Sockets performs an implicit 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function call.</div>
     * <div> </div>
     * For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such cases, this function returns the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a>. However, the operation proceeds. When the success or failure outcome becomes known, it may be reported in one of several ways depending on how the client registers for notification. If the client uses 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a>, success is reported in the <i>writefds</i> set and failure is reported in the <i>exceptfds</i> set. If the client uses 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>, the notification is announced with FD_CONNECT and the error code associated with the FD_CONNECT indicates either success or a specific reason for failure.
     * 
     * For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by 
     * <b>WSAConnect</b> is merely to establish a default destination address so that the socket can be used on subsequent connection-oriented send and receive operations (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>). Any datagrams received from an address other than the destination address specified will be discarded. If the entire name structure is all zeros (not just the address parameter of the name structure), then the socket will be disconnected. Then, the default remote address will be indeterminate, so <b>send</b>, <b>WSASend</b>, <b>recv</b>, and <b>WSARecv</b> calls will return the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a>. However, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>,
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>, and 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a> can still be used. The default destination can be changed by simply calling 
     * <b>WSAConnect</b> again, even if the socket is already connected. Any datagrams queued for receipt are discarded if <i>name</i> is different from the previous 
     * <b>WSAConnect</b>.
     * 
     * For connectionless sockets, <i>name</i> can indicate any valid address, including a broadcast address. However, to connect to a broadcast address, a socket must have 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> SO_BROADCAST enabled. Otherwise, 
     * <b>WSAConnect</b> will fail with the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a>.
     * 
     * On connectionless sockets, exchange of user-to-user data is not possible and the corresponding parameters will be silently ignored.
     * 
     * The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies.
     * 
     * The <i>lpCallerData</i> parameter contains a pointer to any user data that is to be sent along with the connection request (called connect data). This is additional data, not in the normal network data stream, that is sent with network requests to establish a connection. This option is used by legacy protocols such as DECNet, OSI TP4, and others. <div class="alert"><b>Note</b>  Connect data is not supported by the TCP/IP protocol in Windows. Connect data is supported only on ATM (RAWWAN) over a raw socket. </div>
     * <div> </div>
     * 
     * 
     * If <i>lpCallerData</i> is <b>NULL</b>, no user data will be passed to the peer. The <i>lpCalleeData</i> is a result parameter that will contain any user data passed back from the other socket as part of the connection establishment in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure. The <b>len</b> member of the <b>WSABUF</b> structure pointed to by the <i>lpCalleeData</i> parameter initially contains the length of the buffer allocated by the application for the <b>buf</b> member of the <b>WSABUF</b> structure. The <b>len</b> member of the <b>WSABUF</b> structure pointed to by the <i>lpCalleeData</i> parameter will be set to zero if no user data has been passed back. The <i>lpCalleeData</i> information will be valid when the connection operation is complete. For blocking sockets, the connection operation completes when the 
     * <b>WSAConnect</b> function returns. For nonblocking sockets, completion will be after the FD_CONNECT notification has occurred. If <i>lpCalleeData</i> is <b>NULL</b>, no user data will be passed back. The exact format of the user data is specific to the address family to which the socket belongs.
     * 
     * At connect time, an application can use the <i>lpSQOS</i> and <i>lpGQOS</i> parameter to override any previous quality of service specification made for the socket through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> with either the SIO_SET_QOS or SIO_SET_GROUP_QOS opcode.
     * 
     * The <i>lpSQOS</i> parameter specifies the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for socket <i>s</i>, one for each direction, followed by any additional provider-specific parameters. If either the associated transport provider in general or the specific type of socket in particular cannot honor the quality of service request, an error will be returned as indicated in the following. The sending or receiving flow specification values will be ignored, respectively, for any unidirectional sockets. If no provider-specific parameters are specified, the <b>buf</b> and <b>len</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure pointed to by the <i>lpCalleeData</i> parameter  should be set to <b>NULL</b> and zero, respectively. A <b>NULL</b> value for <i>lpSQOS</i> parameter indicates no application-supplied quality of service.
     * 
     * Reserved for future use with socket groups <i>lpGQOS</i> specifies the <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for the socket group (if applicable), one for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are specified, the <b>buf</b> and <b>len</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure pointed to by the <i>lpCalleeData</i> parameter   should be set to <b>NULL</b> and zero, respectively. A <b>NULL</b> value for <i>lpGQOS</i> indicates no application-supplied group quality of service. This parameter will be ignored if <i>s</i> is not the creator of the socket group.
     * 
     * When connected sockets become closed for whatever reason, they should be discarded and recreated. It is safest to assume that when things go awry for any reason on a connected socket, the application must discard and recreate the needed sockets in order to return to a stable point.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSAConnect</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying an unconnected socket.
     * @param {Pointer<SOCKADDR>} name A pointer to a <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure  that specifies the address to which to connect. For  IPv4, the <b>sockaddr</b> contains <b>AF_INET</b> for the address family, the destination IPv4 address, and the destination port. For  IPv6, the <b>sockaddr</b> structure contains <b>AF_INET6</b> for the address family, the destination IPv6 address, the destination port, and may contain additional flow and scope-id information.
     * @param {Integer} namelen The length, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>name</i> parameter.
     * @param {Pointer<WSABUF>} lpCallerData A pointer to the user data that is to be transferred to the other socket during connection establishment. See Remarks.
     * @param {Pointer<WSABUF>} lpCalleeData A pointer to the user data that is to be transferred back from the other socket during connection establishment. See Remarks.
     * @param {Pointer<QOS>} lpSQOS A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for socket <i>s</i>, one for each direction.
     * @param {Pointer<QOS>} lpGQOS Reserved for future use with socket groups. A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for the socket group (if applicable). This parameter should be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaconnect
     * @since windows8.1
     */
    static WSAConnect(s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAConnect", "ptr", s, "ptr", name, "int", namelen, "ptr", lpCallerData, "ptr", lpCalleeData, "ptr", lpSQOS, "ptr", lpGQOS)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Establishes a connection to a specified host and port. (Unicode)
     * @remarks
     * <b>WSAConnectByName</b> is provided to enable quick and transparent connections to remote hosts on specific ports. It is compatible with both IPv6 and IPv4 versions.
     * 
     * To enable both IPv6 and IPv4 communications, use the following method:<ul>
     * <li>The <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function must be called on a socket created for the AF_INET6 address family to disable the <b>IPV6_V6ONLY</b> socket option before calling <b>WSAConnectByName</b>. This is accomplished by calling the <b>setsockopt</b> function on the socket with the <i>level</i> parameter set to <b>IPPROTO_IPV6</b> (see <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPPROTO_IPV6 Socket Options</a>), the <i>optname</i> parameter set to <b>IPV6_V6ONLY</b>, and the  <i>optvalue</i> parameter value set to  zero .</li>
     * </ul>
     * 
     * 
     * <b>WSAConnectByName</b> has limitations:
     * It works only for connection-oriented sockets, such as those of type SOCK_STREAM.
     * The function does not support overlapped I/O or non-blocking behavior. <b>WSAConnectByName</b> will block even if the socket is in non-blocking mode.
     * 	
     * 
     * <b>WSAConnectByName</b> does not support user-provided data during the establishment of a connection. This call does not support FLOWSPEC structures, either. In cases where these features are required, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> must be used instead.
     * 
     * In versions before Windows 10, if an application needs to bind to a specific local address or port, then <b>WSAConnectByName</b> cannot be used since the socket parameter to <b>WSAConnectByName</b> must be an unbound socket.
     * 
     *  
     * This restriction was removed Windows 10.
     * 
     * The <i>RemoteAddress</i> and the <i>LocalAddress</i> parameters point to a <b>SOCKADDR</b>  structure, which is a generic data type. When <b>WSAConnectByName</b> is called, it is expected that a socket address type specific to the network protocol or address family being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a <b>sockaddr_in</b> structure would be cast to a pointer to <b>SOCKADDR</b> as the <i>RemoteAddress</i> and <i>LocalAddress</i> parameters. For IPv6 addresses, a pointer to a <b>sockaddr_in6</b> structure would be cast to a pointer to <b>SOCKADDR</b> as the <i>RemoteAddress</i> and <i>LocalAddress</i> parameters. 
     * 
     * When the 
     * <b>WSAConnectByName</b> function returns <b>TRUE</b>, the socket <i>s</i> is in the default state for a connected socket. The socket <i>s</i> does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function to set the SO_UPDATE_CONNECT_CONTEXT option. 
     * 
     * For example:
     * 
     * 
     * ```cpp
     * //Need to #include <mswsock.h> for SO_UPDATE_CONNECT_CONTEXT
     * 
     * int iResult = 0;
     * 
     * iResult = setsockopt( s, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0 );
     * 
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSAConnectByName</b> with the <i>timeout</i> parameter set to <b>NULL</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <b>Windows Phone 8:</b> The <b>WSAConnectByNameW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSAConnectByNameW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor that identifies an unconnected socket.
     * 
     * <div class="alert"><b>Note</b>  On Windows 7,  Windows Server 2008 R2, and earlier, the <b>WSAConnectByName</b> function requires an unbound and unconnected socket. This differs from other Winsock calls to establish a connection (for example, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>). </div>
     * <div> </div>
     * @param {Pointer<PWSTR>} nodename A <b>NULL</b>-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6.
     * @param {Pointer<PWSTR>} servicename A <b>NULL</b>-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6. 
     * 
     * A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>servicename</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<UInt32>} LocalAddressLength On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the local address stored in the <i>LocalAddress</i> buffer filled in by the system upon successful completion of the call.
     * @param {Pointer<SOCKADDR>} LocalAddress A pointer to the <b>SOCKADDR</b> structure that receives the local address of the connection. The size of the parameter is exactly the size returned in <i>LocalAddressLength</i>. This is the same information that would be returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function. This parameter can be <b>NULL</b>, in which case, the <i>LocalAddressLength</i> parameter is ignored.
     * @param {Pointer<UInt32>} RemoteAddressLength On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the remote address stored in <i>RemoteAddress</i> buffer filled-in by the system upon successful completion of the call.
     * @param {Pointer<SOCKADDR>} RemoteAddress A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the connection. This is the same information that would be returned by the <b>getpeername</b> function. This parameter can be <b>NULL</b>, in which case, the <i>RemoteAddressLength</i> is ignored.
     * @param {Pointer<TIMEVAL>} timeout The time, in milliseconds, to wait for a response from the remote application before aborting the call.
     * @returns {Integer} If a connection is established, <b>WSAConnectByName</b> returns <b>TRUE</b> and <i>LocalAddress</i> and <i>RemoteAddress</i> parameters are filled in if these buffers were supplied by the caller.
     * 
     * If the call fails, <b>FALSE</b> is returned. <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can then be called to get extended error information.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEHOSTUNREACH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The host passed as the <i>nodename</i> parameter was unreachable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEINVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function.  The <i>nodename</i>  or the <i>servicename</i> parameter must not be <b>NULL</b>. The  <i>Reserved</i>  parameter must be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOBUFS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory could not be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOTSOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid socket was passed to the function. The <i>s</i>  parameter must not be <b>INVALID_SOCKET</b> or <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAETIMEDOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A response from the  remote application was not received before the <i>timeout</i> parameter was exceeded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaconnectbynamew
     * @since windows8.1
     */
    static WSAConnectByNameW(s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAConnectByNameW", "ptr", s, "ptr", nodename, "ptr", servicename, "ptr", LocalAddressLength, "ptr", LocalAddress, "ptr", RemoteAddressLength, "ptr", RemoteAddress, "ptr", timeout, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a connection to a specified host and port. (ANSI)
     * @remarks
     * <b>WSAConnectByName</b> is provided to enable quick and transparent connections to remote hosts on specific ports. It is compatible with both IPv6 and IPv4 versions.
     * 
     * To enable both IPv6 and IPv4 communications, use the following method:<ul>
     * <li>The <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function must be called on a socket created for the AF_INET6 address family to disable the <b>IPV6_V6ONLY</b> socket option before calling <b>WSAConnectByName</b>. This is accomplished by calling the <b>setsockopt</b> function on the socket with the <i>level</i> parameter set to <b>IPPROTO_IPV6</b> (see <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPPROTO_IPV6 Socket Options</a>), the <i>optname</i> parameter set to <b>IPV6_V6ONLY</b>, and the  <i>optvalue</i> parameter value set to  zero .</li>
     * </ul>
     * 
     * 
     * <b>WSAConnectByName</b> has limitations:
     * It works only for connection-oriented sockets, such as those of type SOCK_STREAM.
     * The function does not support overlapped I/O or non-blocking behavior. <b>WSAConnectByName</b> will block even if the socket is in non-blocking mode.
     * 	
     * 
     * <b>WSAConnectByName</b> does not support user-provided data during the establishment of a connection. This call does not support FLOWSPEC structures, either. In cases where these features are required, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> must be used instead.
     * 
     * In versions before Windows 10, if an application needs to bind to a specific local address or port, then <b>WSAConnectByName</b> cannot be used since the socket parameter to <b>WSAConnectByName</b> must be an unbound socket.
     * 
     *  
     * This restriction was removed Windows 10.
     * 
     * The <i>RemoteAddress</i> and the <i>LocalAddress</i> parameters point to a <b>SOCKADDR</b>  structure, which is a generic data type. When <b>WSAConnectByName</b> is called, it is expected that a socket address type specific to the network protocol or address family being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a <b>sockaddr_in</b> structure would be cast to a pointer to <b>SOCKADDR</b> as the <i>RemoteAddress</i> and <i>LocalAddress</i> parameters. For IPv6 addresses, a pointer to a <b>sockaddr_in6</b> structure would be cast to a pointer to <b>SOCKADDR</b> as the <i>RemoteAddress</i> and <i>LocalAddress</i> parameters. 
     * 
     * When the 
     * <b>WSAConnectByName</b> function returns <b>TRUE</b>, the socket <i>s</i> is in the default state for a connected socket. The socket <i>s</i> does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function to set the SO_UPDATE_CONNECT_CONTEXT option. 
     * 
     * For example:
     * 
     * 
     * ```cpp
     * //Need to #include <mswsock.h> for SO_UPDATE_CONNECT_CONTEXT
     * 
     * int iResult = 0;
     * 
     * iResult = setsockopt( s, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0 );
     * 
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSAConnectByName</b> with the <i>timeout</i> parameter set to <b>NULL</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <b>Windows Phone 8:</b> The <b>WSAConnectByNameW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSAConnectByNameW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor that identifies an unconnected socket.
     * 
     * <div class="alert"><b>Note</b>  On Windows 7,  Windows Server 2008 R2, and earlier, the <b>WSAConnectByName</b> function requires an unbound and unconnected socket. This differs from other Winsock calls to establish a connection (for example, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>). </div>
     * <div> </div>
     * @param {Pointer<PSTR>} nodename A <b>NULL</b>-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6.
     * @param {Pointer<PSTR>} servicename A <b>NULL</b>-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6. 
     * 
     * A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>servicename</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<UInt32>} LocalAddressLength On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the local address stored in the <i>LocalAddress</i> buffer filled in by the system upon successful completion of the call.
     * @param {Pointer<SOCKADDR>} LocalAddress A pointer to the <b>SOCKADDR</b> structure that receives the local address of the connection. The size of the parameter is exactly the size returned in <i>LocalAddressLength</i>. This is the same information that would be returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function. This parameter can be <b>NULL</b>, in which case, the <i>LocalAddressLength</i> parameter is ignored.
     * @param {Pointer<UInt32>} RemoteAddressLength On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the remote address stored in <i>RemoteAddress</i> buffer filled-in by the system upon successful completion of the call.
     * @param {Pointer<SOCKADDR>} RemoteAddress A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the connection. This is the same information that would be returned by the <b>getpeername</b> function. This parameter can be <b>NULL</b>, in which case, the <i>RemoteAddressLength</i> is ignored.
     * @param {Pointer<TIMEVAL>} timeout The time, in milliseconds, to wait for a response from the remote application before aborting the call.
     * @returns {Integer} If a connection is established, <b>WSAConnectByName</b> returns <b>TRUE</b> and <i>LocalAddress</i> and <i>RemoteAddress</i> parameters are filled in if these buffers were supplied by the caller.
     * 
     * If the call fails, <b>FALSE</b> is returned. <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can then be called to get extended error information.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEHOSTUNREACH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The host passed as the <i>nodename</i> parameter was unreachable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEINVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function.  The <i>nodename</i>  or the <i>servicename</i> parameter must not be <b>NULL</b>. The  <i>Reserved</i>  parameter must be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOBUFS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory could not be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOTSOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid socket was passed to the function. The <i>s</i>  parameter must not be <b>INVALID_SOCKET</b> or <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAETIMEDOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A response from the  remote application was not received before the <i>timeout</i> parameter was exceeded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaconnectbynamea
     * @deprecated
     * @since windows8.1
     */
    static WSAConnectByNameA(s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAConnectByNameA", "ptr", s, "ptr", nodename, "ptr", servicename, "ptr", LocalAddressLength, "ptr", LocalAddress, "ptr", RemoteAddressLength, "ptr", RemoteAddress, "ptr", timeout, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a connection to one out of a collection of possible endpoints represented by a set of destination addresses (host names and ports).
     * @remarks
     * <b>WSAConnectByList</b> is similar to the 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnectbynamea">WSAConnectByName</a> function.  Instead of taking a 
     *      single host name and service name (port), 
     *      <b>WSAConnectByList</b> takes a list of addresses (host 
     *      addresses and ports) and connects to one of the addresses. The 
     *      <b>WSAConnectByList</b> function is designed to support 
     *      peer-to-peer collaboration scenarios where an application needs to connect to any available node out of a list of 
     *      potential nodes. <b>WSAConnectByList</b> is compatible 
     *      with both IPv6 and IPv4 versions.
     * 
     * The set of possible destinations, represented by a list of addresses, is 
     *      provided by the caller. <b>WSAConnectByList</b> does 
     *      more than simply attempt to connect to one of possibly many destination addresses.  Specifically, the function 
     *      takes all remote addresses passed in by the caller, all local addresses, and then attempts a connection first 
     *      using address pairs with the highest chance of success. As such, 
     *      <b>WSAConnectByList</b> not only ensures that connection 
     *      will be established if a connection is at all possible, but also minimizes the time to establish the 
     *      connection.
     * 
     * The caller can specify the <i>LocalAddress</i> and <i>RemoteAddress</i> 
     *      buffers and lengths to determine the local and remote addresses for which the connection was successfully 
     *      established.
     * 
     * The <i>timeout</i> parameter allows the caller to limit the time spent by the function in 
     *      establishing a connection. Internally, 
     *      <b>WSAConnectByList</b> performs multiple operations 
     *      (connection attempts).  In between each operation, the <i>timeout</i> parameter is checked to 
     *      see if the <i>timeout</i> has been exceeded and, if so, the call is aborted. Note that an 
     *      individual operation (connect) will not be interrupted once the <i>timeout</i> is exceeded, 
     *      so the <b>WSAConnectByList</b> call can take longer to 
     *      time out than the value specified in the <i>timeout</i> parameter.
     * 
     * <b>WSAConnectByList</b> has limitations: It works only 
     *      for connection-oriented sockets, such as those of type SOCK_STREAM. The function does not support overlapped I/O 
     *      or non-blocking behavior. <b>WSAConnectByList</b> will 
     *      block even if the socket is in non-blocking mode. 
     *      <b>WSAConnectByList</b> will try connecting (one-by-one) 
     *      to the various addresses provided by the caller. Potentially, each of these connection attempts may fail with a 
     *      different error code. Since only a single error code can be returned, the value returned is the error code from 
     *      the last connection attempt.
     * 
     * To enable both IPv6 and IPv4 addresses to be passed in the single address list accepted by the function, the 
     *      following steps must be performed prior to calling the function:
     *      <ul>
     * <li>The <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function must be called on a 
     *        socket created for the AF_INET6 address family to disable the <b>IPV6_V6ONLY</b> socket 
     *        option before calling <b>WSAConnectByList</b>. This is 
     *        accomplished by calling the <b>setsockopt</b> function on 
     *        the socket with the <i>level</i> parameter set to <b>IPPROTO_IPV6</b> 
     *        (see <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPPROTO_IPV6 Socket Options</a>), the 
     *        <i>optname</i> parameter set to <b>IPV6_V6ONLY</b>, and the  
     *        <i>optvalue</i> parameter value set to  zero .</li>
     * <li>Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to communicate with an IPv4 node.  The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as an IPv6
     *    address.  The IPv4 address is encoded into the low-order 32 bits of
     *    the IPv6 address, and the high-order 96 bits hold the fixed prefix
     *    0:0:0:0:0:FFFF. The IPv4-mapped IPv6 address format is specified in RFC 4291. For more information, see <a href="https://www.rfc-editor.org/rfc/rfc4291.html">www.ietf.org/rfc/rfc4291.txt</a>. The IN6ADDR_SETV4MAPPED macro in <i>Mstcpip.h</i> can be used to convert an IPv4 address to the required IPv4-mapped IPv6 address format.</li>
     * </ul>
     * 
     * 
     * The arrays of pointers passed in the <i>SocketAddressList</i> parameter point to an array of 
     *      <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-socket_address">SOCKET_ADDRESS</a>  structures, which are a generic 
     *      data type. The <i>RemoteAddress</i> and the <i>LocalAddress</i> 
     *      parameters also point to <b>SOCKADDR</b>  structures. When 
     *      <b>WSAConnectByList</b> is called, it is expected that 
     *      a socket address type specific to the network protocol or address family being used will actually be passed in 
     *      these parameters. So for IPv4 addresses, a pointer to a <b>sockaddr_in</b> structure 
     *      would be cast to a pointer to <b>SOCKADDR</b> when passed as a parameter. For IPv6 
     *      addresses, a pointer to a <b>sockaddr_in6</b> structure would be cast to a pointer to 
     *      <b>SOCKADDR</b> when passed as a parameter. The 
     *      <i>SocketAddressList</i> parameter can contain pointers to a mixture of IPv4 and IPv6 
     *      addresses. So some <b>SOCKET_ADDRESS</b> pointers can be 
     *      to <b>sockaddr_in</b> structures and others can be to 
     *      <b>sockaddr_in6</b> structures. If it is expected that IPv6 addresses can be used, then 
     *      the <i>RemoteAddress</i> and <i>LocalAddress</i> parameters should point 
     *      to <b>sockaddr_in6</b> structures and be cast to <b>SOCKADDR</b> 
     *      structures. The <i>RemoteAddressLength</i> and the 
     *      <i>LocalAddressLength</i> parameters must represent the length of these larger 
     *      structures.
     * 
     * When the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">WSAConnectByList</a> function returns <b>TRUE</b>, the socket <i>s</i> is in the default state for a connected socket. The socket <i>s</i> does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function to set the SO_UPDATE_CONNECT_CONTEXT option. 
     * 
     * For example:
     * 
     * 
     * ```cpp
     * //Need to #include <mswsock.h> for SO_UPDATE_CONNECT_CONTEXT
     * 
     * int iResult = 0;
     * 
     * iResult = setsockopt( s, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0 );
     * 
     * ```
     * 
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">WSAConnectByList</a> with the <i>timeout</i> parameter set to <b>NULL</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor that identifies an unbound and unconnected socket. Note that unlike other Winsock calls to 
     *       establish a connection (for example, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>), 
     *       the <b>WSAConnectByList</b> function requires an 
     *       unbound socket.
     * @param {Pointer<SOCKET_ADDRESS_LIST>} SocketAddress A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa385467(v=vs.85)">SOCKET_ADDRESS_LIST</a> 
     *       structure that represents the possible destination address and port pairs to connect to a peer. It is the 
     *       application's responsibility to fill in the port number in the each 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-socket_address">SOCKET_ADDRESS</a> structure in the 
     *       <b>SOCKET_ADDRESS_LIST</b>.
     * @param {Pointer<UInt32>} LocalAddressLength On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by 
     *       the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the 
     *       local address stored in the <i>LocalAddress</i> buffer filled in by the system upon 
     *       successful completion of the call.
     * @param {Pointer<SOCKADDR>} LocalAddress A pointer to the <b>SOCKADDR</b> structure that receives the local address of the 
     *       connection. The size of the parameter is exactly the size returned in 
     *       <i>LocalAddressLength</i>. This is the same information that would be returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function. This parameter can be 
     *       <b>NULL</b>, in which case, the <i>LocalAddressLength</i> parameter is 
     *       ignored.
     * @param {Pointer<UInt32>} RemoteAddressLength On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided 
     *       by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the 
     *       remote address stored in <i>RemoteAddress</i> buffer filled-in by the system upon successful 
     *       completion of the call.
     * @param {Pointer<SOCKADDR>} RemoteAddress A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the 
     *       connection. This is the same information that would be returned by the 
     *       <b>getpeername</b> function. This parameter can be <b>NULL</b>, in 
     *       which case, the <i>RemoteAddressLength</i> is ignored.
     * @param {Pointer<TIMEVAL>} timeout The time, in milliseconds, to wait for a response from the remote application before aborting the call. 
     *       This parameter can be <b>NULL</b> in which case 
     *       <b>WSAConnectByList</b> will complete after either the 
     *       connection is successfully established or after a connection was attempted and failed on all possible 
     *       local-remote address pairs.
     * @returns {Integer} If a connection is established, 
     *        <b>WSAConnectByList</b> returns <b>TRUE</b> and 
     *        <i>LocalAddress</i> and <i>RemoteAddress</i> parameters are filled in if 
     *        these buffers were supplied by the caller.
     * 
     * If the call fails, <b>FALSE</b> is returned. 
     *        <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can then be called to get 
     *        extended error information.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEHOSTUNREACH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The host passed as the <i>nodename</i> parameter was unreachable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEINVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. The <i>Reserved</i> parameter must be 
     *         <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOBUFS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory could not be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOTSOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid socket was passed to the function. The <i>s</i> parameter must not be 
     *         <b>INVALID_SOCKET</b> or <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAETIMEDOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A response from the  remote application was not received before the <i>timeout</i> 
     *         parameter was exceeded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaconnectbylist
     * @since windows8.1
     */
    static WSAConnectByList(s, SocketAddress, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAConnectByList", "ptr", s, "ptr", SocketAddress, "ptr", LocalAddressLength, "ptr", LocalAddress, "ptr", RemoteAddressLength, "ptr", RemoteAddress, "ptr", timeout, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSACreateEvent function creates a new event object.
     * @remarks
     * The 
     * <b>WSACreateEvent</b> function creates a manual-reset event object with an initial state of nonsignaled. The handle of the event object returned cannot be inherited by child processes. 
     * The event object is unnamed.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasetevent">WSASetEvent</a> function can be called to set the state of the event object to signaled. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaresetevent">WSAResetEvent</a> function can be called to set the state of the event object to nonsignaled. When an event object is no longer needed, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacloseevent">WSACloseEvent</a> function should be called to free the resources associated with the event object.
     * 
     * Windows Sockets 2 event objects are system objects in Windows environments. Therefore, if a Windows application wants to use an auto-reset event rather than a manual-reset event, the application can call the <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-createeventa">CreateEvent</a> function directly. The scope of an event object is limited to the process in which it is created.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @returns {Pointer} If no error occurs, 
     * <b>WSACreateEvent</b> returns the handle of the event object. Otherwise, the return value is WSA_INVALID_EVENT. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not enough free memory available to create the event object.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsacreateevent
     * @since windows8.1
     */
    static WSACreateEvent() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSACreateEvent", "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSADuplicateSocket function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor for a shared socket. The WSADuplicateSocket function cannot be used on a QOS-enabled socket. (ANSI)
     * @remarks
     * The 
     * <b>WSADuplicateSocket</b> function is used to enable socket sharing between processes. A source process calls 
     * <b>WSADuplicateSocket</b> to obtain a special 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. It uses some interprocess communications (IPC) mechanism to pass the contents of this structure to a target process, which in turn uses it in a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> to obtain a descriptor for the duplicated socket. The special 
     * <b>WSAPROTOCOL_INFO</b> structure can only be used once by the target process.
     * 
     * Sockets can be shared among threads in a given process without using the 
     * <b>WSADuplicateSocket</b> function because a socket descriptor is valid in all threads of a process.
     * 
     * One possible scenario for establishing and handing off a shared socket is illustrated in the following table.
     * 
     * <table>
     * <tr>
     * <th>Source process</th>
     * <th>IPC</th>
     * <th>Destination process</th>
     * </tr>
     * <tr>
     * <td>1) 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>
     * </td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>2) Request target process identifier</td>
     * <td>==&gt;</td>
     * <td></td>
     * </tr>
     * <tr>
     * <td></td>
     * <td></td>
     * <td>3) Receive process identifier request and respond</td>
     * </tr>
     * <tr>
     * <td>4) Receive process identifier</td>
     * <td>&lt;==</td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>5) Call 
     * <b>WSADuplicateSocket</b> to get a special 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>6) Send 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure to target</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>==&gt;</td>
     * <td>7) Receive 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td></td>
     * <td>8) Call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> to create shared socket descriptor.</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td></td>
     * <td>9) Use shared socket for data exchange</td>
     * </tr>
     * <tr>
     * <td>10) 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>
     * </td>
     * <td>&lt;==</td>
     * <td></td>
     * </tr>
     * </table>
     *  
     * 
     * The descriptors that reference a shared socket can be used independently for I/O. However, the Windows Sockets interface does not implement any type of access control, so it is up to the processes involved to coordinate their operations on a shared socket. Shared sockets are typically used to having one process that is responsible for creating sockets and establishing connections, and other processes that are responsible for information exchange.
     * 
     * All of the state information associated with a socket is held in common across all the descriptors because the socket descriptors are duplicated and not the actual socket. For example, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> operation performed using one descriptor is subsequently visible using a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> from any or all descriptors. Both the source process and the destination process should pass the same flags to their respective <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function calls. If the source process uses the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function to create the socket, the destination process must pass the <b>WSA_FLAG_OVERLAPPED</b> flag to its <b>WSASocket</b> function call. A process can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> on a duplicated socket and the descriptor will become deallocated. The underlying socket, however, will remain open until 
     * <b>closesocket</b> is called by the last remaining descriptor.
     * 
     * Notification on shared sockets is subject to the usual constraints of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>. Issuing either of these calls using any of the shared descriptors cancels any previous event registration for the socket, regardless of which descriptor was used to make that registration. Thus, a shared socket cannot deliver FD_READ events to process A and FD_WRITE events to process B. For situations when such tight coordination is required, developers would be advised to use threads instead of separate processes.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>WSADuplicateSocketW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSADuplicateSocket as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} s Descriptor identifying the local socket.
     * @param {Integer} dwProcessId Process identifier of the target process in which the duplicated socket will be used.
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo Pointer to a buffer, allocated by the client, that is large enough to contain a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The service provider copies the protocol information structure contents to this buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaduplicatesocketa
     * @deprecated
     * @since windows8.1
     */
    static WSADuplicateSocketA(s, dwProcessId, lpProtocolInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSADuplicateSocketA", "ptr", s, "uint", dwProcessId, "ptr", lpProtocolInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSADuplicateSocket function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor for a shared socket. The WSADuplicateSocket function cannot be used on a QOS-enabled socket. (Unicode)
     * @remarks
     * The 
     * <b>WSADuplicateSocket</b> function is used to enable socket sharing between processes. A source process calls 
     * <b>WSADuplicateSocket</b> to obtain a special 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. It uses some interprocess communications (IPC) mechanism to pass the contents of this structure to a target process, which in turn uses it in a call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> to obtain a descriptor for the duplicated socket. The special 
     * <b>WSAPROTOCOL_INFO</b> structure can only be used once by the target process.
     * 
     * Sockets can be shared among threads in a given process without using the 
     * <b>WSADuplicateSocket</b> function because a socket descriptor is valid in all threads of a process.
     * 
     * One possible scenario for establishing and handing off a shared socket is illustrated in the following table.
     * 
     * <table>
     * <tr>
     * <th>Source process</th>
     * <th>IPC</th>
     * <th>Destination process</th>
     * </tr>
     * <tr>
     * <td>1) 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>
     * </td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>2) Request target process identifier</td>
     * <td>==&gt;</td>
     * <td></td>
     * </tr>
     * <tr>
     * <td></td>
     * <td></td>
     * <td>3) Receive process identifier request and respond</td>
     * </tr>
     * <tr>
     * <td>4) Receive process identifier</td>
     * <td>&lt;==</td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>5) Call 
     * <b>WSADuplicateSocket</b> to get a special 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td>6) Send 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure to target</td>
     * <td></td>
     * <td></td>
     * </tr>
     * <tr>
     * <td></td>
     * <td>==&gt;</td>
     * <td>7) Receive 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td></td>
     * <td>8) Call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> to create shared socket descriptor.</td>
     * </tr>
     * <tr>
     * <td></td>
     * <td></td>
     * <td>9) Use shared socket for data exchange</td>
     * </tr>
     * <tr>
     * <td>10) 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>
     * </td>
     * <td>&lt;==</td>
     * <td></td>
     * </tr>
     * </table>
     *  
     * 
     * The descriptors that reference a shared socket can be used independently for I/O. However, the Windows Sockets interface does not implement any type of access control, so it is up to the processes involved to coordinate their operations on a shared socket. Shared sockets are typically used to having one process that is responsible for creating sockets and establishing connections, and other processes that are responsible for information exchange.
     * 
     * All of the state information associated with a socket is held in common across all the descriptors because the socket descriptors are duplicated and not the actual socket. For example, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> operation performed using one descriptor is subsequently visible using a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> from any or all descriptors. Both the source process and the destination process should pass the same flags to their respective <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function calls. If the source process uses the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function to create the socket, the destination process must pass the <b>WSA_FLAG_OVERLAPPED</b> flag to its <b>WSASocket</b> function call. A process can call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> on a duplicated socket and the descriptor will become deallocated. The underlying socket, however, will remain open until 
     * <b>closesocket</b> is called by the last remaining descriptor.
     * 
     * Notification on shared sockets is subject to the usual constraints of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>. Issuing either of these calls using any of the shared descriptors cancels any previous event registration for the socket, regardless of which descriptor was used to make that registration. Thus, a shared socket cannot deliver FD_READ events to process A and FD_WRITE events to process B. For situations when such tight coordination is required, developers would be advised to use threads instead of separate processes.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>WSADuplicateSocketW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSADuplicateSocket as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer} s Descriptor identifying the local socket.
     * @param {Integer} dwProcessId Process identifier of the target process in which the duplicated socket will be used.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo Pointer to a buffer, allocated by the client, that is large enough to contain a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The service provider copies the protocol information structure contents to this buffer.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaduplicatesocketw
     * @since windows8.1
     */
    static WSADuplicateSocketW(s, dwProcessId, lpProtocolInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSADuplicateSocketW", "ptr", s, "uint", dwProcessId, "ptr", lpProtocolInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAEnumNetworkEvents function discovers occurrences of network events for the indicated socket, clear internal network event records, and reset event objects (optional).
     * @remarks
     * The 
     * <b>WSAEnumNetworkEvents</b> function is used to discover which network events have occurred for the indicated socket since the last invocation of this function. It is intended for use in conjunction with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>, which associates an event object with one or more network events. The recording of network events commences when 
     * <b>WSAEventSelect</b> is called with a nonzero <i>lNetworkEvents</i> parameter and remains in effect until another call is made to 
     * <b>WSAEventSelect</b> with the <i>lNetworkEvents</i> parameter set to zero, or until a call is made to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a>.
     * 
     * <b>WSAEnumNetworkEvents</b> only reports network activity and errors nominated through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>. See the descriptions of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> to find out how those functions report network activity and errors.
     * 
     * The socket's internal record of network events is copied to the structure referenced by <i>lpNetworkEvents</i>, after which the internal network events record is cleared. If the <i>hEventObject</i> parameter is not <b>NULL</b>, the indicated event object is also reset. The Windows Sockets provider guarantees that the operations of copying the network event record, clearing it and resetting any associated event object are atomic, such that the next occurrence of a nominated network event will cause the event object to become set. In the case of this function returning SOCKET_ERROR, the associated event object is not reset and the record of network events is not cleared.
     * 
     * The <b>lNetworkEvents</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanetworkevents">WSANETWORKEVENTS</a> structure indicates which of the FD_XXX network events have occurred. The <b>iErrorCode</b> array is used to contain any associated error codes with the array index corresponding to the position of event bits in <b>lNetworkEvents</b>. Identifiers such as FD_READ_BIT and FD_WRITE_BIT can be used to index the <b>iErrorCode</b> array. Note that only those elements of the <b>iErrorCode</b> array are set that correspond to the bits set in <i>lNetworkEvents</i> parameter. Other parameters are not modified (this is important for backward compatibility with the applications that are not aware of new FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events).
     * 
     * The following error codes can be returned along with the corresponding network event.
     * 
     * <b>Event: FD_CONNECT</b>
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>Addresses in the specified family cannot be used with this socket.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></td>
     * <td>The attempt to connect was forcefully rejected.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></td>
     * <td>The network cannot be reached from this host at this time.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></td>
     * <td>No buffer space is available. The socket cannot be connected.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></td>
     * <td>An attempt to connect timed out without establishing a connection</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <b>Event: FD_CLOSE</b>
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></td>
     * <td>The connection was reset by the remote side.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></td>
     * <td>The connection was terminated due to a time-out or other failure.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <b>Event: FD_ACCEPT</b>
     * 
     * <b>Event: FD_ADDRESS_LIST_CHANGE</b>
     * 
     * <b>Event: FD_GROUP_QOS</b>
     * 
     * <b>Event: FD_QOS</b>
     * 
     * <b>Event: FD_OOB</b>
     * 
     * <b>Event: FD_READ</b>
     * 
     * <b>Event: FD_WRITE</b>
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <b>Event: FD_ROUTING_INTERFACE_CHANGE</b>
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></td>
     * <td>The specified destination is no longer reachable.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the WSAEnumNetworkEvents function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying the socket.
     * @param {Pointer} hEventObject An optional handle identifying an associated event object to be reset.
     * @param {Pointer<WSANETWORKEVENTS>} lpNetworkEvents A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanetworkevents">WSANETWORKEVENTS</a> structure that is filled with a record of network events that occurred and any associated error codes.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaenumnetworkevents
     * @since windows8.1
     */
    static WSAEnumNetworkEvents(s, hEventObject, lpNetworkEvents) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEnumNetworkEvents", "ptr", s, "ptr", hEventObject, "ptr", lpNetworkEvents)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAEnumProtocols function retrieves information about available transport protocols. (ANSI)
     * @remarks
     * The 
     * <b>WSAEnumProtocols</b> function is used to discover information about the collection of transport protocols installed on the local computer. Layered protocols are only usable by applications when installed in protocol chains. Information on layered protocols is not returned except for any dummy layered service providers (LSPs) installed with a chain length of zero in the  <i>lpProtocolBuffer</i>. 
     * 
     * <div class="alert"><b>Note</b>  Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server 2012, use <a href="https://docs.microsoft.com/windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a>.</div>
     * <div> </div>
     * The <i>lpiProtocols</i> parameter can be used as a filter to constrain the amount of information provided. Often, <i>lpiProtocols</i> will be specified as a <b>NULL</b> pointer that will cause the function to return information on all available transport protocols and protocol chains.
     * 
     * The 
     * <b>WSAEnumProtocols</b> function differs from the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> functions in that 
     * the <b>WSAEnumProtocols</b> function doesn't return <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures for all installed protocols. The <b>WSAEnumProtocols</b> function excludes protocols that the service provider has set with the <b>PFL_HIDDEN</b> flag in the <b>dwProviderFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by <b>WSAEnumProtocols</b> function.  In addition, the <b>WSAEnumProtocols</b> function does not return data for <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures that have a chain length of one or greater (an LSP provider).   The <b>WSAEnumProtocols</b> only returns information on base protocols and protocol chains that lack the <b>PFL_HIDDEN</b> flag  and don't have a protocol chain length of zero. 
     * 
     * A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure is provided in the buffer pointed to by <i>lpProtocolBuffer</i> for each requested protocol. If the specified buffer is not large enough (as indicated by the input value of <i>lpdwBufferLength</i> ), the value pointed to by <i>lpdwBufferLength</i> will be updated to indicate the required buffer size. The application should then obtain a large enough buffer and call 
     * <b>WSAEnumProtocols</b> again.
     * 
     * The order in which the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider using the WS2_32.DLL, or with any subsequent reordering that occurred through the Windows Sockets application or DLL supplied for establishing default TCP/IP providers.
     * 
     * <b>Windows Phone 8:</b> The <b>WSAEnumProtocolsW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSAEnumProtocolsW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<Int32>} lpiProtocols A <b>NULL</b>-terminated array of iProtocol values. This parameter is optional; if <i>lpiProtocols</i> is <b>NULL</b>, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolBuffer A pointer to a buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, number of bytes in the <i>lpProtocolBuffer</i> buffer passed to 
     * <b>WSAEnumProtocols</b>. On output, the minimum buffer size that can be passed to 
     * <b>WSAEnumProtocols</b> to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a computer is typically small.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaenumprotocolsa
     * @deprecated
     * @since windows8.1
     */
    static WSAEnumProtocolsA(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEnumProtocolsA", "ptr", lpiProtocols, "ptr", lpProtocolBuffer, "ptr", lpdwBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAEnumProtocols function retrieves information about available transport protocols. (Unicode)
     * @remarks
     * The 
     * <b>WSAEnumProtocols</b> function is used to discover information about the collection of transport protocols installed on the local computer. Layered protocols are only usable by applications when installed in protocol chains. Information on layered protocols is not returned except for any dummy layered service providers (LSPs) installed with a chain length of zero in the  <i>lpProtocolBuffer</i>. 
     * 
     * <div class="alert"><b>Note</b>  Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server 2012, use <a href="https://docs.microsoft.com/windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a>.</div>
     * <div> </div>
     * The <i>lpiProtocols</i> parameter can be used as a filter to constrain the amount of information provided. Often, <i>lpiProtocols</i> will be specified as a <b>NULL</b> pointer that will cause the function to return information on all available transport protocols and protocol chains.
     * 
     * The 
     * <b>WSAEnumProtocols</b> function differs from the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> functions in that 
     * the <b>WSAEnumProtocols</b> function doesn't return <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures for all installed protocols. The <b>WSAEnumProtocols</b> function excludes protocols that the service provider has set with the <b>PFL_HIDDEN</b> flag in the <b>dwProviderFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by <b>WSAEnumProtocols</b> function.  In addition, the <b>WSAEnumProtocols</b> function does not return data for <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures that have a chain length of one or greater (an LSP provider).   The <b>WSAEnumProtocols</b> only returns information on base protocols and protocol chains that lack the <b>PFL_HIDDEN</b> flag  and don't have a protocol chain length of zero. 
     * 
     * A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure is provided in the buffer pointed to by <i>lpProtocolBuffer</i> for each requested protocol. If the specified buffer is not large enough (as indicated by the input value of <i>lpdwBufferLength</i> ), the value pointed to by <i>lpdwBufferLength</i> will be updated to indicate the required buffer size. The application should then obtain a large enough buffer and call 
     * <b>WSAEnumProtocols</b> again.
     * 
     * The order in which the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider using the WS2_32.DLL, or with any subsequent reordering that occurred through the Windows Sockets application or DLL supplied for establishing default TCP/IP providers.
     * 
     * <b>Windows Phone 8:</b> The <b>WSAEnumProtocolsW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSAEnumProtocolsW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<Int32>} lpiProtocols A <b>NULL</b>-terminated array of iProtocol values. This parameter is optional; if <i>lpiProtocols</i> is <b>NULL</b>, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolBuffer A pointer to a buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, number of bytes in the <i>lpProtocolBuffer</i> buffer passed to 
     * <b>WSAEnumProtocols</b>. On output, the minimum buffer size that can be passed to 
     * <b>WSAEnumProtocols</b> to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a computer is typically small.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaenumprotocolsw
     * @since windows8.1
     */
    static WSAEnumProtocolsW(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEnumProtocolsW", "ptr", lpiProtocols, "ptr", lpProtocolBuffer, "ptr", lpdwBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAEventSelect function specifies an event object to be associated with the specified set of FD_XXX network events.
     * @remarks
     * The 
     * <b>WSAEventSelect</b> function is used to specify an event object, <i>hEventObject</i>, to be associated with the selected FD_XXX network events, <i>lNetworkEvents</i>. The socket for which an event object is specified is identified by the <i>s</i> parameter. The event object is set when any of the nominated network events occur.
     * 
     * The 
     * <b>WSAEventSelect</b> function operates very similarly to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a>, the difference being the actions taken when a nominated network event occurs. The 
     * <b>WSAAsyncSelect</b> function causes an application-specified Windows message to be posted. The 
     * <b>WSAEventSelect</b> sets the associated event object and records the occurrence of this event in an internal network event record. An application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> to wait or poll on the event object, and use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnetworkevents">WSAEnumNetworkEvents</a> to retrieve the contents of the internal network event record and thus determine which of the nominated network events have occurred.
     * 
     * The proper way to reset the state of an event object used with the <b>WSAEventSelect</b> function is to pass the handle of the event object to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnetworkevents">WSAEnumNetworkEvents</a> function in the <i>hEventObject</i> parameter. This will reset the event object and adjust the status of active FD events on the socket in an atomic fashion.
     * 
     * <b>WSAEventSelect</b> is the only function that causes network activity and errors to be recorded and retrievable through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnetworkevents">WSAEnumNetworkEvents</a>. See the descriptions of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> to find out how those functions report network activity and errors.
     * 
     * The <b>WSAEventSelect</b> function automatically sets socket <i>s</i> to nonblocking mode, regardless of the value of <i>lNetworkEvents</i>. To set socket <i>s</i> back to blocking mode, it is first necessary to clear the event record associated with socket <i>s</i> via a call to <b>WSAEventSelect</b> with <i>lNetworkEvents</i> set to zero and the <i>hEventObject</i> parameter set to <b>NULL</b>. You can then call <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-ioctlsocket">ioctlsocket</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> to set the socket back to blocking mode.
     * 
     * The <i>lNetworkEvents</i> parameter is constructed by using the bitwise OR operator with any of the values specified in the following list.
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>FD_READ</td>
     * <td>Wants to receive notification of readiness for reading.</td>
     * </tr>
     * <tr>
     * <td>FD_WRITE</td>
     * <td>Wants to receive notification of readiness for writing.</td>
     * </tr>
     * <tr>
     * <td>FD_OOB</td>
     * <td>Wants to receive notification of the arrival of OOB data.</td>
     * </tr>
     * <tr>
     * <td>FD_ACCEPT</td>
     * <td>Wants to receive notification of incoming connections.</td>
     * </tr>
     * <tr>
     * <td>FD_CONNECT</td>
     * <td>Wants to receive notification of completed connection or multipoint join operation.</td>
     * </tr>
     * <tr>
     * <td>FD_CLOSE</td>
     * <td>Wants to receive notification of socket closure.</td>
     * </tr>
     * <tr>
     * <td>FD_QOS</td>
     * <td>Wants to receive notification of socket (QoS changes.</td>
     * </tr>
     * <tr>
     * <td>FD_GROUP_QOS</td>
     * <td>Reserved for future use with socket groups. Want to receive notification of socket group QoS changes.</td>
     * </tr>
     * <tr>
     * <td>FD_ROUTING_
     * INTERFACE_CHANGE</td>
     * <td>Wants to receive notification of routing interface changes for the specified destination.</td>
     * </tr>
     * <tr>
     * <td>FD_ADDRESS_
     * LIST_CHANGE</td>
     * <td>Wants to receive notification of local address list changes for the address family of the socket.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * Issuing a 
     * <b>WSAEventSelect</b> for a socket cancels any previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <b>WSAEventSelect</b> for the same socket and clears the internal network event record. For example, to associate an event object with both reading and writing network events, the application must call 
     * <b>WSAEventSelect</b> with both FD_READ and FD_WRITE, as follows:
     * 
     * 
     * ```cpp
     * rc = WSAEventSelect(s, hEventObject, FD_READ|FD_WRITE);
     * 
     * ```
     * 
     * 
     * It is not possible to specify different event objects for different network events. The following code will not work; the second call will cancel the effects of the first, and only the FD_WRITE network event will be associated with <i>hEventObject2</i>:
     * 
     * 
     * ```cpp
     * rc = WSAEventSelect(s, hEventObject1, FD_READ);
     * rc = WSAEventSelect(s, hEventObject2, FD_WRITE); //bad
     * 
     * ```
     * 
     * 
     * To cancel the association and selection of network events on a socket, <i>lNetworkEvents</i> should be set to zero, in which case the <i>hEventObject</i> parameter will be ignored.
     * 
     * 
     * ```cpp
     * rc = WSAEventSelect(s, hEventObject, 0);
     * 
     * ```
     * 
     * 
     * Closing a socket with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> also cancels the association and selection of network events specified in 
     * <b>WSAEventSelect</b> for the socket. The application, however, still must call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacloseevent">WSACloseEvent</a> to explicitly close the event object and free any resources.
     * 
     * The socket created when the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function is called has the same properties as the listening socket used to accept it. Any 
     * <b>WSAEventSelect</b> association and network events selection set for the listening socket apply to the accepted socket. For example, if a listening socket has 
     * <b>WSAEventSelect</b> association of <i>hEventObject</i> with FD_ACCEPT, FD_READ, and FD_WRITE, then any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE network events associated with the same <i>hEventObject</i>. If a different <i>hEventObject</i> or network events are desired, the application should call 
     * <b>WSAEventSelect</b>, passing the accepted socket and the desired new information.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSAEventSelect</b> function.
     * 
     * 
     * ```cpp
     * //-------------------------
     * // Declare and initialize variables
     * SOCKET ListenSocket;
     * WSAEVENT NewEvent;
     * sockaddr_in InetAddr;
     * 
     * //-------------------------
     * // Initialize listening socket
     * ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
     * 
     * //-------------------------
     * // Bind listening socket
     * InetAddr.sin_family = AF_INET;
     * InetAddr.sin_addr.s_addr = htonl(INADDR_ANY);
     * InetAddr.sin_port = htons(27015);
     * 
     * bind (ListenSocket, (SOCKADDR *) &InetAddr, sizeof(InetAddr));
     * 
     * //-------------------------
     * // Create new event
     * NewEvent = WSACreateEvent();
     * 
     * //-------------------------
     * // Associate event types FD_ACCEPT and FD_CLOSE
     * // with the listening socket and NewEvent
     * WSAEventSelect( ListenSocket, NewEvent, FD_ACCEPT | FD_CLOSE);
     * 
     * //----------------------
     * // Listen for incoming connection requests 
     * // on the created socket
     * if (listen( ListenSocket, SOMAXCONN ) == SOCKET_ERROR)
     *     printf("Error listening on socket.\n");
     * 
     * printf("Listening on socket...\n");
     * 
     * // Need an event handler added to handle connection requests
     * 
     * 
     * 
     * ```
     * 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying the socket.
     * @param {Pointer} hEventObject A handle identifying the event object to be associated with the specified set of FD_XXX network events.
     * @param {Integer} lNetworkEvents A bitmask that specifies the combination of FD_XXX network events in which the application has interest.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaeventselect
     * @since windows8.1
     */
    static WSAEventSelect(s, hEventObject, lNetworkEvents) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEventSelect", "ptr", s, "ptr", hEventObject, "int", lNetworkEvents)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAGetOverlappedResult function retrieves the results of an overlapped operation on the specified socket.
     * @remarks
     * The 
     * <b>WSAGetOverlappedResult</b> function reports the results of the overlapped operation specified in the <i>lpOverlapped</i> parameter for the socket specified in the <i>s</i> parameter. The 
     * <b>WSAGetOverlappedResult</b> function is passed the socket descriptor and the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure that was specified when the overlapped function was called. A pending operation is indicated when the function that started the operation returns <b>FALSE</b> and the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function returns <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a>. When an I/O operation such as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> is pending, the function that started the operation resets the <i>hEvent</i> member of the 
     * <b>WSAOVERLAPPED</b> structure to the nonsignaled state. Then, when the pending operation has completed, the system sets the event object to the signaled state.
     * 
     * If the <i>fWait</i> parameter is <b>TRUE</b>, 
     * <b>WSAGetOverlappedResult</b> determines whether the pending operation has been completed by waiting for the event object to be in the signaled state. A client may set the <i>fWait</i> parameter to <b>TRUE</b>, but only if it selected event-based completion notification when the I/O operation was requested. If another form of notification was selected, the usage of the <i>hEvent</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure is different, and setting <i>fWait</i> to <b>TRUE</b> causes unpredictable results.
     * 
     * If the <b>WSAGetOverlappedResult</b> function is called with the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or <i>lpdwFlags</i> parameter  set to a <b>NULL</b> pointer on Windows Vista, this will result in an access violation. If the <b>WSAGetOverlappedResult</b> function is called with the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or <i>lpdwFlags</i> parameter  set to a <b>NULL</b> pointer on Windows Server 2003 and earlier, this will result in the <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> error code being returned.  
     * 
     * <div class="alert"><b>Note</b>   All I/O is canceled when a thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. See <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> for more information.</div>
     * <div> </div>
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying the socket. 
     * 
     * This is the same socket that was specified when the overlapped operation was started by a call to 
     * any of the Winsock functions that supports overlapped operations. These functions include <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms737757(v=vs.85)">DisconnectEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_transmitpackets">TransmitPackets</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg">LPFN_WSARECVMSG (WSARecvMsg)</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg">WSASendMsg</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure that was specified when the overlapped operation was started. This parameter must not be a <b>NULL</b> pointer.
     * @param {Pointer<UInt32>} lpcbTransfer A pointer to a 32-bit variable that receives the number of bytes that were actually transferred by a send or receive operation, or by 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function. This parameter must not be a <b>NULL</b> pointer.
     * @param {Integer} fWait A flag that specifies whether the function should wait for the pending overlapped operation to complete. If <b>TRUE</b>, the function does not return until the operation has been completed. If <b>FALSE</b> and the operation is still pending, the function returns <b>FALSE</b> and the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function returns WSA_IO_INCOMPLETE. The <i>fWait</i> parameter may be set to <b>TRUE</b> only if the overlapped operation selected the event-based completion notification.
     * @param {Pointer<UInt32>} lpdwFlags A pointer to a 32-bit variable that will receive one or more flags that supplement the completion status. If the overlapped operation was initiated through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, this parameter will contain the results value for <i>lpFlags</i> parameter. This parameter must not be a <b>NULL</b> pointer.
     * @returns {Integer} If 
     * <b>WSAGetOverlappedResult</b> succeeds, the return value is <b>TRUE</b>. This means that the overlapped operation has completed successfully and that the value pointed to by <i>lpcbTransfer</i> has been updated. 
     * 
     * If 
     * <b>WSAGetOverlappedResult</b> returns <b>FALSE</b>, this means that either the overlapped operation has not completed, the overlapped operation completed but with errors, or the overlapped operation's completion status could not be determined due to errors in one or more parameters to 
     * <b>WSAGetOverlappedResult</b>. On failure, the value pointed to by <i>lpcbTransfer</i> will not be updated. Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> to determine the cause of the failure (either by the <b>WSAGetOverlappedResult</b> function or by the associated overlapped operation).
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure does not contain a valid event object handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters is unacceptable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_INCOMPLETE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>fWait</i> parameter is <b>FALSE</b> and the I/O operation has not yet completed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or <i>lpdwFlags</i> parameters are not in a valid part of the user address space. This error is returned if the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or <i>lpdwFlags</i> parameter  was a <b>NULL</b> pointer on Windows Server 2003 and earlier.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsagetoverlappedresult
     * @since windows8.1
     */
    static WSAGetOverlappedResult(s, lpOverlapped, lpcbTransfer, fWait, lpdwFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetOverlappedResult", "ptr", s, "ptr", lpOverlapped, "ptr", lpcbTransfer, "int", fWait, "ptr", lpdwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAGetQOSByName function initializes a QOS structure based on a named template, or it supplies a buffer to retrieve an enumeration of the available template names.
     * @remarks
     * The 
     * <b>WSAGetQOSByName</b> function is used by applications to initialize a 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-qos">QOS</a> structure to a set of known values appropriate for a particular service class or media type. These values are stored in a template that is referenced by a well-known name. The client may retrieve these values by setting the <i>buf</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure indicated by <i>lpQOSName</i>, which points to a string of nonzero length specifying a template name. In this case, the usage of <i>lpQOSName</i> is IN only, and results are returned through <i>lpQOS</i>.
     * 
     * Alternatively, the client may use this function to retrieve an enumeration of available template names. The client may do this by setting the <i>buf</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> indicated by <i>lpQOSName</i> to a zero-length null-terminated string. In this case the buffer indicated by <i>buf</i> is overwritten with a sequence of as many available, null-terminated template names up to the number of bytes available in <i>buf</i> as indicated by the <i>len</i> parameter of the 
     * <b>WSABUF</b> indicated by <i>lpQOSName</i>. The list of names itself is terminated by a zero-length name. When the 
     * <b>WSAGetQOSByName</b> function is used to retrieve template names, the <i>lpQOS</i> parameter is ignored.
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpQOSName A pointer to a specific quality of service template.
     * @param {Pointer<QOS>} lpQOS A pointer to the 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-qos">QOS</a> structure to be filled.
     * @returns {Integer} If 
     * <b>WSAGetQOSByName</b> succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpQOSName</i> or <i>lpQOS</i> parameter are not a valid part of the user address space, or the buffer length for <i>lpQOS</i> is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsagetqosbyname
     * @deprecated
     * @since windows5.0
     */
    static WSAGetQOSByName(s, lpQOSName, lpQOS) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetQOSByName", "ptr", s, "ptr", lpQOSName, "ptr", lpQOS, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAHtonl function converts a u_long from host byte order to network byte order.
     * @remarks
     * The 
     * <b>WSAHtonl</b> function takes a 32-bit number in host byte order and returns a 32-bit number in network byte order in the 32-bit number pointed to by the <i>lpnetlong</i> parameter. The socket passed in the <i>s</i> parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders. 
     * 
     * If the socket is for the AF_INET or AF_INET6 address family, the 
     * <b>WSAHtonl</b> function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the <i>hostlong</i> parameter is a valid IPv4 address.
     * 
     * The 
     * <b>WSAHtonl</b> function requires that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function. For use with the AF_INET or AF_INET6 family, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-htonl">htonl</a> function does not require that the Winsock DLL be loaded. 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} hostlong A 32-bit number in host byte order.
     * @param {Pointer<UInt32>} lpnetlong A pointer to a 32-bit number to receive the number in network byte order.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsahtonl
     * @since windows8.1
     */
    static WSAHtonl(s, hostlong, lpnetlong) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAHtonl", "ptr", s, "uint", hostlong, "ptr", lpnetlong)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAHtons function converts a u_short from host byte order to network byte order.
     * @remarks
     * The 
     * <b>WSAHtons</b> function takes a 16-bit number in host byte order and returns a 16-bit number  in network byte order in the 16-bit number pointed to by the <i>lpnetshort</i> parameter. The socket passed in the <i>s</i> parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders.  
     * 
     * If the socket is for the AF_INET or AF_INET6 address family, the 
     * <b>WSAHtons</b> function can be used to convert an IP port number  in host byte order to the IP port number in network byte order. 
     * 
     * The 
     * <b>WSAHtons</b> function requires that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function. For use with the AF_INET OR AF_INET6 address family, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-htons">htons</a> function does not require that the Winsock DLL be loaded. 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} hostshort A 16-bit number in host byte order.
     * @param {Pointer<UInt16>} lpnetshort A pointer to a 16-bit buffer to receive the number in network byte order.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsahtons
     * @since windows8.1
     */
    static WSAHtons(s, hostshort, lpnetshort) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAHtons", "ptr", s, "ushort", hostshort, "ptr", lpnetshort)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAIoctl function controls the mode of a socket.
     * @remarks
     * The 
     * <b>WSAIoctl</b> function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the communications subsystem.
     * 
     * If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b>, the socket in this function will be treated as a non-overlapped socket. For a non-overlapped socket, <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> parameters are ignored, which causes the function to behave like the standard 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-ioctlsocket">ioctlsocket</a> function except that  the function can block if socket <i>s</i> is in blocking mode. If socket <i>s</i> is in non-blocking mode, this function can return WSAEWOULDBLOCK when the specified operation cannot be finished immediately. In this case, the application may change the socket to blocking mode and reissue the request or wait for the corresponding network event (such as FD_ROUTING_INTERFACE_CHANGE or FD_ADDRESS_LIST_CHANGE in the case of <b>SIO_ROUTING_INTERFACE_CHANGE</b> or <b>SIO_ADDRESS_LIST_CHANGE</b>) using a Windows message (using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a>)-based or event (using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>)-based notification mechanism.
     * 
     * For overlapped sockets, operations that cannot be completed immediately will be initiated, and completion will be indicated at a later time. The <b>DWORD</b> value pointed to by the <i>lpcbBytesReturned</i> parameter that is returned may be ignored. The final completion status and bytes returned can be retrieved when the appropriate completion method is signaled when the operation 
     *        has completed.  
     *        
     * 
     * Any IOCTL may block indefinitely, depending on the service provider's implementation. If the application cannot tolerate blocking in a 
     * <b>WSAIoctl</b> call, overlapped I/O would be advised for IOCTLs that are especially likely to block including:
     * 
     * <b>SIO_ADDRESS_LIST_CHANGE</b>
     * 
     * <b>SIO_FINDROUTE</b>
     * 
     * <b>SIO_FLUSH</b>
     * 
     * <b>SIO_GET_QOS</b>
     * 
     * <b>SIO_GET_GROUP_QOS</b>
     * 
     * <b>SIO_ROUTING_INTERFACE_CHANGE</b>
     * 
     * <b>SIO_SET_QOS</b>
     * 
     * <b>SIO_SET_GROUP_QOS</b>
     * 
     * Some protocol-specific IOCTLs may also be especially likely to block. Check the relevant protocol-specific annex for any available information.
     * 
     * The prototype for the completion routine pointed to by the <i>lpCompletionRoutine</i> parameter is as follows:
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} dwIoControlCode The control code of operation to perform.
     * @param {Pointer<Void>} lpvInBuffer A pointer to the input buffer.
     * @param {Integer} cbInBuffer The size, in bytes, of the input buffer.
     * @param {Pointer<Void>} lpvOutBuffer A pointer to the output buffer.
     * @param {Integer} cbOutBuffer The size, in bytes, of the output buffer.
     * @param {Pointer<UInt32>} lpcbBytesReturned A pointer to actual number of bytes of output.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for non-overlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * <div class="alert"><b>Note</b>  A pointer to the completion routine called when the operation has been completed (ignored for non-overlapped sockets). See Remarks.</div>
     * <div> </div>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaioctl
     * @since windows8.1
     */
    static WSAIoctl(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAIoctl", "ptr", s, "uint", dwIoControlCode, "ptr", lpvInBuffer, "uint", cbInBuffer, "ptr", lpvOutBuffer, "uint", cbOutBuffer, "ptr", lpcbBytesReturned, "ptr", lpOverlapped, "ptr", lpCompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAJoinLeaf function joins a leaf node into a multipoint session, exchanges connect data, and specifies needed quality of service based on the specified FLOWSPEC structures.
     * @remarks
     * The 
     * <b>WSAJoinLeaf</b> function is used to join a leaf node to a multipoint session, and to perform a number of other ancillary operations that occur at session join time as well. If the socket <i>s</i> is unbound, unique values are assigned to the local association by the system, and the socket is marked as bound.
     * 
     * The 
     * <b>WSAJoinLeaf</b> function has the same parameters and semantics as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> except that it returns a socket descriptor (as in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a>), and it has an additional <i>dwFlags</i> parameter. Only multipoint sockets created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> with appropriate multipoint flags set can be used for input parameter <i>s</i> in this function. The returned socket descriptor will not be usable until after the join operation completes. For example, if the socket is in nonblocking mode after a corresponding FD_CONNECT indication has been received from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> on the original socket <i>s</i>, except that 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> may be invoked on this new socket descriptor to cancel a pending join operation. A root application in a multipoint session may call 
     * <b>WSAJoinLeaf</b> one or more times in order to add a number of leaf nodes, however at most one multipoint connection request may be outstanding at a time. Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information.
     * 
     * For nonblocking sockets it is often not possible to complete the connection immediately. In such a case, this function returns an as-yet unusable socket descriptor and the operation proceeds. There is no error code such as 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> in this case, since the function has effectively returned a successful start indication. When the final outcome success or failure becomes known, it may be reported through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> depending on how the client registers for notification on the original socket <i>s</i>. In either case, the notification is announced with FD_CONNECT and the error code associated with the FD_CONNECT indicates either success or a specific reason for failure. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a> function cannot be used to detect completion notification for 
     * <b>WSAJoinLeaf</b>.
     * 
     * The socket descriptor returned by 
     * <b>WSAJoinLeaf</b> is different depending on whether the input socket descriptor, <i>s</i>, is a c_root or a c_leaf. When used with a c_root socket, the <i>name</i> parameter designates a particular leaf node to be added and the returned socket descriptor is a c_leaf socket corresponding to the newly added leaf node. The newly created socket has the same properties as <i>s</i>, including asynchronous events registered with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a>. It is not intended to be used for exchange of multipoint data, but rather is used to receive network event indications (for example, FD_CLOSE) for the connection that exists to the particular c_leaf. Some multipoint implementations can also allow this socket to be used for side chats between the root and an individual leaf node. An FD_CLOSE indication will be received for this socket if the corresponding leaf node calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> to drop out of the multipoint session. Symmetrically, invoking 
     * <b>closesocket</b> on the c_leaf socket returned from 
     * <b>WSAJoinLeaf</b> will cause the socket in the corresponding leaf node to get an FD_CLOSE notification.
     * 
     * When 
     * <b>WSAJoinLeaf</b> is invoked with a c_leaf socket, the <i>name</i> parameter contains the address of the root application (for a rooted control scheme) or an existing multipoint session (nonrooted control scheme), and the returned socket descriptor is the same as the input socket descriptor. In other words, a new socket descriptor is not allocated. In a rooted control scheme, the root application would put its c_root socket in listening mode by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a>. The standard FD_ACCEPT notification will be delivered when the leaf node requests to join itself to the multipoint session. The root application uses the usual 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> or 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> functions to admit the new leaf node. The value returned from either 
     * <b>accept</b> or 
     * <b>WSAAccept</b> is also a c_leaf socket descriptor just like those returned from 
     * <b>WSAJoinLeaf</b>. To accommodate multipoint schemes that allow both root-initiated and leaf-initiated joins, it is acceptable for a c_root socket that is already in listening mode to be used as an input to 
     * <b>WSAJoinLeaf</b>.
     * 
     * The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies.
     * 
     * The <i>lpCallerData</i> is a value parameter that contains any user data that is to be sent along with the multipoint session join request. If <i>lpCallerData</i> is <b>NULL</b>, no user data will be passed to the peer. The <i>lpCalleeData</i> is a result parameter that will contain any user data passed back from the peer as part of the multipoint session establishment. The <b>len</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure pointed to by the <i>lpCalleeData</i> parameter initially contains the length of the buffer allocated by the application and pointed to by the <b>buf</b> member of the <b>WSABUF</b> structure. The <b>len</b> member of the <b>WSABUF</b> structure pointed to by the <i>lpCalleeData</i> parameter will be set to zero if no user data has been passed back. The <i>lpCalleeData</i> information will be valid when the multipoint join operation is complete.
     * 
     * For blocking sockets, this will be when the 
     * <b>WSAJoinLeaf</b> function returns. For nonblocking sockets, this will be after the join operation has completed. For example, this could occur after FD_CONNECT notification on the original socket <i>s</i>). If <i>lpCalleeData</i> is <b>NULL</b>, no user data will be passed back. The exact format of the user data is specific to the address family to which the socket belongs.
     * 
     * At multipoint session establishment time, an application can use the <i>lpSQOS</i> and/or <i>lpGQOS</i> parameters to override any previous quality of service specification made for the socket through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> with the SIO_SET_QOS or  SIO_SET_GROUP_QOS opcodes.
     * 
     * The <i>lpSQOS</i> parameter specifies the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for socket <i>s</i>, one for each direction, followed by any additional provider-specific parameters. If either the associated transport provider in general or the specific type of socket in particular cannot honor the quality of service request, an error will be returned as indicated in the following. The respective sending or receiving flow specification values will be ignored for any unidirectional sockets. If no provider-specific parameters are specified, the <b>buf</b> and <b>len</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure pointed to by the <i>lpCalleeData</i> parameter should be set to <b>NULL</b> and zero, respectively. A <b>NULL</b> value for <i>lpSQOS</i> indicates no application-supplied quality of service.
     * 
     * Reserved for future socket groups. The <i>lpGQOS</i> parameter specifies the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for the socket group (if applicable), one for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are specified, the the <b>buf</b> and <b>len</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure pointed to by the <i>lpCalleeData</i> parameter should be set to should be set to <b>NULL</b> and zero, respectively. A <b>NULL</b> value for <i>lpGQOS</i> indicates no application-supplied group quality of service. This parameter will be ignored if <i>s</i> is not the creator of the socket group.
     * 
     * When connected sockets break (that is, become closed for whatever reason), they should be discarded and recreated. It is safest to assume that when things go awry for any reason on a connected socket, the application must discard and recreate the needed sockets in order to return to a stable point.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSAJoinLeaf</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s Descriptor identifying a multipoint socket.
     * @param {Pointer<SOCKADDR>} name Name of the peer to which the socket is to be joined.
     * @param {Integer} namelen Length of <i>name</i>, in bytes.
     * @param {Pointer<WSABUF>} lpCallerData Pointer to the user data that is to be transferred to the peer during multipoint session establishment.
     * @param {Pointer<WSABUF>} lpCalleeData Pointer to the user data that is to be transferred back from the peer during multipoint session establishment.
     * @param {Pointer<QOS>} lpSQOS Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for socket <i>s</i>, one for each direction.
     * @param {Pointer<QOS>} lpGQOS Reserved for future use with socket groups. A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for the socket group (if applicable).
     * @param {Integer} dwFlags Flags to indicate that the socket is acting as a sender (JL_SENDER_ONLY), receiver (JL_RECEIVER_ONLY), or both (JL_BOTH).
     * @returns {Pointer} If no error occurs, 
     * <b>WSAJoinLeaf</b> returns a value of type SOCKET that is a descriptor for the newly created multipoint socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * On a blocking socket, the return value indicates success or failure of the join operation.
     * 
     * With a nonblocking socket, successful initiation of a join operation is indicated by a return of a valid socket descriptor. Subsequently, an FD_CONNECT indication will be given on the original socket <i>s</i> when the join operation completes, either successfully or otherwise. The application must use either 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> with interest registered for the FD_CONNECT event in order to determine when the join operation has completed and checks the associated error code to determine the success or failure of the operation. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-select">select</a> function cannot be used to determine when the join operation completes.
     * 
     * Also, until the multipoint session join attempt completes all subsequent calls to 
     * <b>WSAJoinLeaf</b> on the same socket will fail with the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a>. After the 
     * <b>WSAJoinLeaf</b> operation completes successfully, a subsequent attempt will usually fail with the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a>. An exception to the WSAEISCONN rule occurs for a c_root socket that allows root-initiated joins. In such a case, another join may be initiated after a prior 
     * <b>WSAJoinLeaf</b> operation completes.
     * 
     * If the return error code indicates the multipoint session join attempt failed (that is, 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>) the application can call 
     * <b>WSAJoinLeaf</b> again for the same socket.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRINUSE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs at the time of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, but could be delayed until this function if the 
     * <b>bind</b> was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote address is not a valid address (such as ADDR_ANY).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Addresses in the specified family cannot be used with this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonblocking 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a> call is in progress on the specified socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The attempt to join was forcefully rejected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or the <i>namelen</i> parameter is not a valid part of the user address space, the <i>namelen</i> parameter is too small, the buffer length for <i>lpCalleeData</i>, <i>lpSQOS</i>, and <i>lpGQOS</i> are too small, or the buffer length for <i>lpCallerData</i> is too large.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a> function call was performed on a UDP socket that was opened without setting its WSA_FLAG_MULTIPOINT_C_LEAF or WSA_FLAG_MULTIPOINT_D_LEAF multipoint flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is already a member of the multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be joined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures specified in <i>lpSQOS</i> and <i>lpGQOS</i> cannot be satisfied.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpCallerData</i> augment is not supported by the service provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The attempt to join timed out without establishing a multipoint session.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsajoinleaf
     * @since windows8.1
     */
    static WSAJoinLeaf(s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS, dwFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAJoinLeaf", "ptr", s, "ptr", name, "int", namelen, "ptr", lpCallerData, "ptr", lpCalleeData, "ptr", lpSQOS, "ptr", lpGQOS, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSANtohl function converts a u_long from network byte order to host byte order.
     * @remarks
     * The 
     * <b>WSANtohl</b> function takes a 32-bit number in network byte order and returns a 32-bit number in host byte order in the 32-bit number pointed to by the <i>lphostlong</i> parameter. The socket passed in the <i>s</i> parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders. 
     * 
     * If the socket is for the AF_INET or AF_INET6 address family, the 
     * <b>WSANtohl</b> function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the <i>netlong</i> parameter is a valid IPv4 address.
     * 
     * The 
     * <b>WSANtohl</b> function requires that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function. For use with the AF_INET or AF_INET6 family, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-ntohl">ntohl</a> function does not require that the Winsock DLL be loaded. 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} netlong A 32-bit number in network byte order.
     * @param {Pointer<UInt32>} lphostlong A pointer to a 32-bit number to receive the number in host byte order.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsantohl
     * @since windows8.1
     */
    static WSANtohl(s, netlong, lphostlong) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSANtohl", "ptr", s, "uint", netlong, "ptr", lphostlong)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSANtohs function converts a u_short from network byte order to host byte order.
     * @remarks
     * The 
     * <b>WSANtohs</b> function takes a 16-bit number in network byte order and returns a 16-bit number in host byte order in the 16-bit number pointed to by the <i>lphostshort</i> parameter. The socket passed in the <i>s</i> parameter is used to determine the network byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers that use different network byte orders. 
     * 
     * If the socket is for the AF_INET or AF_INET6 address family, the 
     * <b>WSANtohs</b> function can be used to convert an IP port number  in network byte order to the IP port number in host byte order. 
     * 
     * The 
     * <b>WSANtohs</b> function requires that the Winsock DLL has previously been loaded with a successful 
     * call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function. For use with the AF_INET OR AF_INET6 address family, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-ntohs">ntohs</a> function does not require that the Winsock DLL be loaded. 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Integer} netshort A 16-bit number in network byte order.
     * @param {Pointer<UInt16>} lphostshort A pointer to a 16-bit number to receive the number in host byte order.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsantohs
     * @since windows8.1
     */
    static WSANtohs(s, netshort, lphostshort) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSANtohs", "ptr", s, "ushort", netshort, "ptr", lphostshort)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Receives data from a connected socket or a bound connectionless socket. (WSARecv)
     * @remarks
     * The 
     * <b>WSARecv</b> function provides some additional features compared with the standard 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function in three important areas:
     * 
     * <ul>
     * <li>It can be used in conjunction with overlapped sockets to perform overlapped 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> operations.</li>
     * <li>It allows multiple receive buffers to be specified making it applicable to the scatter/gather type of I/O.</li>
     * <li>The <i>lpFlags</i> parameter is used both on input and returned on output, allowing applications to sense the output state of the <b>MSG_PARTIAL</b> flag bit. However, the <b>MSG_PARTIAL</b> flag bit is not supported by all protocols.</li>
     * </ul>
     * The 
     * <b>WSARecv</b> function is used on connected sockets or bound connectionless sockets specified by the <i>s</i> parameter and is used to read incoming data. The socket's local address must be known. For server applications, this is usually done explicitly through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> or implicitly through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a>. Explicit binding is discouraged for client applications. For client applications the socket can become bound implicitly to a local address through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a>.
     * 
     * For connected, connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded.
     * 
     * For overlapped sockets, 
     * <b>WSARecv</b> is used to post one or more buffers into which incoming data will be placed as it becomes available, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>.
     * 
     * <div class="alert"><b>Note</b>  All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. See <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> for more information.</div>
     * <div> </div>
     * If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b>, the socket in this function will be treated as a nonoverlapped socket.
     * 
     * For nonoverlapped sockets, the blocking semantics are identical to that of the standard 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function and the <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the specified user buffers. In the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received. Windows Sockets 2 does not define any standard blocking time-out mechanism for this function. For protocols acting as byte-stream protocols the stack tries to return as much data as possible subject to the available buffer space and amount of received data available. However, receipt of a single byte is sufficient to unblock the caller. There is no guarantee that more than a single byte will be returned. For protocols acting as message-oriented, a full message is required to unblock the caller.
     * 
     * <div class="alert"><b>Note</b>  The socket options <b>SO_RCVTIMEO</b> and <b>SO_SNDTIMEO</b> apply only to blocking sockets.</div>
     * <div> </div>
     * Whether or not a protocol is acting as byte stream is determined by the setting of XP1_MESSAGE_ORIENTED and XP1_PSEUDO_STREAM in its 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure and the setting of the MSG_PARTIAL flag passed in to this function (for protocols that support it). The following table lists relevant combinations, (an asterisk (*) indicates that the setting of this bit does not matter in this case).
     * 
     * 
     * <table>
     * <tr>
     * <th>XP1_MESSAGE_ORIENTED</th>
     * <th>XP1_PSEUDO_STREAM</th>
     * <th>MSG_PARTIAL</th>
     * <th>Acts as</th>
     * </tr>
     * <tr>
     * <td>not set</td>
     * <td>*</td>
     * <td>*</td>
     * <td>Byte stream</td>
     * </tr>
     * <tr>
     * <td>*</td>
     * <td>Set</td>
     * <td>*</td>
     * <td>Byte stream</td>
     * </tr>
     * <tr>
     * <td>set</td>
     * <td>Not set</td>
     * <td>set</td>
     * <td>Byte stream</td>
     * </tr>
     * <tr>
     * <td>set</td>
     * <td>Not set</td>
     * <td>not set</td>
     * <td>Message oriented</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * The buffers are filled in the order in which they appear in the array pointed to by <i>lpBuffers</i>, and the buffers are packed so that no holes are created.
     * 
     * If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures before returning from this call. This enables applications to build stack-based 
     * <b>WSABUF</b> arrays pointed to by the <i>lpBuffers</i> parameter.
     * 
     * For byte stream-style sockets (for example, type <b>SOCK_STREAM</b>), incoming data is placed into the buffers until the buffers are filled, the connection is closed, or the internally buffered data is exhausted. Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets.
     * 
     * For message-oriented sockets (for example, type <b>SOCK_DGRAM</b>), an incoming message is placed into the buffers up to the total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the first part of the message. If the <b>MSG_PARTIAL</b> feature is supported by the underlying service provider, the <b>MSG_PARTIAL</b> flag is set in <i>lpFlags</i> and subsequent receive operations will retrieve the rest of the message. If <b>MSG_PARTIAL</b> is not supported but the protocol is reliable, 
     * <b>WSARecv</b> generates the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a> and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol is unreliable and does not support <b>MSG_PARTIAL</b>), the excess data is lost, and 
     * <b>WSARecv</b> generates the error WSAEMSGSIZE.
     * 
     * For connection-oriented sockets, 
     * <b>WSARecv</b> can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read (as indicated by a zero return value to indicate success, and <i>lpNumberOfBytesRecvd</i> value of zero) indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a failure with an error code of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEDISCON</a> is used to indicate graceful closure. In any case a return error code of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a> indicates an abortive close has occurred.
     * 
     * The <i>lpFlags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the <i>lpFlags</i> parameter. The latter is constructed by using the bitwise OR operator with any of the values listed in the following table.
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>MSG_PEEK</td>
     * <td>
     * Peeks at the incoming data. The data is copied into the buffer, but is not removed from the input queue.
     * 
     * This flag is valid only for nonoverlapped sockets.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>MSG_OOB</td>
     * <td>Processes OOB data.</td>
     * </tr>
     * <tr>
     * <td>MSG_PARTIAL</td>
     * <td>
     * This flag is for message-oriented sockets only. On output, this flag indicates that the data specified is a portion of the message transmitted by the sender. Remaining portions of the message will be specified in subsequent receive operations. A subsequent receive operation with the <b>MSG_PARTIAL</b> flag cleared indicates end of sender's message.
     * 
     * As an input parameter, this flag indicates that the receive operation should complete even if only part of a message has been received by the transport  provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>MSG_PUSH_IMMEDIATE</td>
     * <td>
     * This flag is for stream-oriented sockets only. This flag allows an application that uses stream sockets to tell the  transport provider not to delay completion of partially filled pending receive requests. This is a hint to the transport provider that the application is willing to receive any incoming data as soon as possible without necessarily waiting for the remainder of the data that might still be in transit. What constitutes a partially filled pending receive request is a transport-specific matter. 
     * 
     * In the case of TCP, this refers to the case of incoming TCP segments being placed into the receive request data buffer where none of the TCP segments indicated a PUSH bit value of 1. In this case, TCP may hold the partially filled receive request a little longer to allow the remainder of the data to arrive with a TCP segment that has the PUSH bit set to 1. This flag tells TCP not to hold the receive request but to complete it immediately.
     * 
     *  Using this flag for large block transfers is not recommended since processing partial blocks is often not optimal. This flag is useful only for cases where receiving and processing the partial data immediately helps decrease processing latency.
     * 
     * This flag is a hint rather than an actual guarantee.
     * 
     * This flag is supported on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td>MSG_WAITALL</td>
     * <td>
     * The receive request will complete only when one of the following events occurs:<ul>
     * <li>The buffer supplied by the caller is completely full.</li>
     * <li>The connection has been closed.</li>
     * <li>The request has been canceled or an error occurred.</li>
     * </ul>
     * 
     * 
     * Be aware that if the underlying transport provider does not support <b>MSG_WAITALL</b>, or if the socket is in a non-blocking mode, then this call will fail with <b>WSAEOPNOTSUPP</b>. Also, if <b>MSG_WAITALL</b> is specified along with <b>MSG_OOB</b>, <b>MSG_PEEK</b>, or <b>MSG_PARTIAL</b>, then this call will fail with <b>WSAEOPNOTSUPP</b>.
     * 
     * This flag is not supported on datagram sockets or message-oriented sockets.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * For message-oriented sockets, the <b>MSG_PARTIAL</b> bit is set in the <i>lpFlags</i> parameter if a partial message is received. If a complete message is received, <b>MSG_PARTIAL</b> is cleared in <i>lpFlags</i>. In the case of delayed completion, the value pointed to by <i>lpFlags</i> is not updated. When completion has been indicated, the application should call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> and examine the flags indicated by the <i>lpdwFlags</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSARecv</b> with the <i>lpOverlapped</i> parameter set to NULL, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Overlapped_Socket_I_O"></a><a id="overlapped_socket_i_o"></a><a id="OVERLAPPED_SOCKET_I_O"></a>Overlapped Socket I/O</h3>
     * If an overlapped operation completes immediately, 
     * <b>WSARecv</b> returns a value of zero and the <i>lpNumberOfBytesRecvd</i> parameter is updated with the number of bytes received and the flag bits indicated by the <i>lpFlags</i> parameter are also updated. If the overlapped operation is successfully initiated and will complete later, 
     * <b>WSARecv</b> returns <b>SOCKET_ERROR</b> and indicates error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a>. In this case, <i>lpNumberOfBytesRecvd</i> and <i>lpFlags</i> are not updated. When the overlapped operation completes, the amount of data transferred is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>. Flag values are obtained by examining the <i>lpdwFlags</i> parameter of 
     * <b>WSAGetOverlappedResult</b>.
     * 
     * The 
     * <b>WSARecv</b> function using overlapped I/O can be called from within the completion routine of a previous 
     * <b>WSARecv</b>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.
     * 
     * If the <i>lpCompletionRoutine</i> parameter is <b>NULL</b>, the <i>hEvent</i> parameter of <i>lpOverlapped</i> is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> to wait or poll on the event object.
     * 
     * If <i>lpCompletionRoutine</i> is not <b>NULL</b>, the <i>hEvent</i> parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-<b>NULL</b> <i>lpCompletionRoutine</i> and later calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> for the same overlapped I/O request may not set the <i>fWait</i> parameter for that invocation of 
     * <b>WSAGetOverlappedResult</b> to <b>TRUE</b>. In this case the usage of the <i>hEvent</i> parameter is undefined, and attempting to wait on the <i>hEvent</i> parameter would produce unpredictable results.
     * 
     * The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> with the <i>fAlertable</i> parameter set to <b>TRUE</b> is invoked.
     * 
     * The prototype of the completion routine is as follows:
     * 
     * 
     * ```cpp
     * 
     * void CALLBACK CompletionROUTINE(
     *   IN DWORD dwError, 
     *   IN DWORD cbTransferred, 
     *   IN LPWSAOVERLAPPED lpOverlapped, 
     *   IN DWORD dwFlags
     * );
     * 
     * ```
     * 
     * 
     * CompletionRoutine is a placeholder for an application-defined or library-defined function name. The <i>dwError</i> specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. The <i>cbTransferred</i> parameter specifies the number of bytes received. The <i>dwFlags</i> parameter contains information that would have appeared in <i>lpFlags</i> if the receive operation had completed immediately. This function does not return a value.
     * 
     * Returning from this function allows invocation of another pending completion routine for this socket. When using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a>, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of <b>WSA_IO_COMPLETION</b>. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order in which they are specified.
     * 
     * If you are using I/O completion ports, be aware that the order of calls made to <b>WSARecv</b> is also the order in which the buffers are populated. <b>WSARecv</b> should not be called on the same socket simultaneously from different threads, because it can result in an unpredictable buffer order.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example shows how to use  the <b>WSARecv</b> function in overlapped I/O mode.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A  descriptor identifying a connected socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length, in bytes, of the buffer.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<UInt32>} lpNumberOfBytesRecvd A pointer to the number, in bytes, of data received by this call if the receive operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Pointer<UInt32>} lpFlags A pointer to flags used to modify the behavior of the 
     * <b>WSARecv</b> function call. For more information, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for nonoverlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the receive operation has been completed (ignored for nonoverlapped sockets).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsarecv
     * @since windows8.1
     */
    static WSARecv(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSARecv", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "ptr", lpNumberOfBytesRecvd, "ptr", lpFlags, "ptr", lpOverlapped, "ptr", lpCompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSARecvDisconnect function terminates reception on a socket, and retrieves the disconnect data if the socket is connection oriented.
     * @remarks
     * The 
     * <b>WSARecvDisconnect</b> function is used on connection-oriented sockets to disable reception and retrieve any incoming disconnect data from the remote party. This is equivalent to a shutdown (SD_RECEIVE), except that 
     * <b>WSARecvDisconnect</b> also allows receipt of disconnect data (in protocols that support it).
     * 
     * After this function has been successfully issued, subsequent receives on the socket will be disallowed. Calling 
     * <b>WSARecvDisconnect</b> has no effect on the lower protocol layers. For TCP sockets, if there is still data queued on the socket waiting to be received, or data arrives subsequently, the connection is reset, since the data cannot be delivered to the user. For UDP, incoming datagrams are accepted and queued. In no case will an ICMP error packet be generated.
     * 
     * <div class="alert"><b>Note</b>  The native implementation of TCP/IP on Windows does not support disconnect data. Disconnect data is only supported with Windows Sockets providers that have the XP1_DISCONNECT_DATA flag in their 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function to obtain 
     * <b>WSAPROTOCOL_INFO</b> structures for all installed providers.</div>
     * <div> </div>
     * To successfully receive incoming disconnect data, an application must use other mechanisms to determine that the circuit has been closed. For example, an application needs to receive an FD_CLOSE notification, to receive a zero return value, or to receive a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEDISCON</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a> error code from 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>.
     * 
     * The 
     * <b>WSARecvDisconnect</b> function does not close the socket, and resources attached to the socket will not be freed until 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> is invoked.
     * 
     * The 
     * <b>WSARecvDisconnect</b> function does not block regardless of the SO_LINGER setting on the socket.
     * 
     * An application should not rely on being able to reuse a socket after it has been disconnected using 
     * <b>WSARecvDisconnect</b>. In particular, a Windows Sockets provider is not required to support the use of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> or 
     * 				<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> on such a socket.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSARecvDisconnect</b>,  Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpInboundDisconnectData A pointer to the incoming disconnect data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsarecvdisconnect
     * @deprecated
     * @since windows5.0
     */
    static WSARecvDisconnect(s, lpInboundDisconnectData) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSARecvDisconnect", "ptr", s, "ptr", lpInboundDisconnectData)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Receives a datagram and stores the source address.
     * @remarks
     * The 
     * <b>WSARecvFrom</b> function provides functionality over and above the standard 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a> function in three important areas:
     * 
     * <ul>
     * <li>It can be used in conjunction with overlapped sockets to perform overlapped receive operations.</li>
     * <li>It allows multiple receive buffers to be specified making it applicable to the scatter/gather type of I/O.</li>
     * <li>The <i>lpFlags</i> parameter is both an input and an output parameter, allowing applications to sense the output state of the <b>MSG_PARTIAL</b> flag bit. Be aware that the <b>MSG_PARTIAL</b> flag bit is not supported by all protocols.</li>
     * </ul>
     * The 
     * <b>WSARecvFrom</b> function is used primarily on a connectionless socket specified by <i>s</i>. The socket's local address must be known. For server applications, this is usually done explicitly through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a>. Explicit binding is discouraged for client applications. For client applications using this function the socket can become bound implicitly to a local address through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a>.
     * 
     * For overlapped sockets, this function is used to post one or more buffers into which incoming data will be placed as it becomes available on a (possibly connected) socket, after which the application-specified completion indication (invocation of the completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>. Also, the values indicated by <i>lpFrom</i> and <i>lpFromlen</i> are not updated until completion is itself indicated. Applications must not use or disturb these values until they have been updated; therefore the application must not use automatic (that is, stack-based) variables for these parameters.
     * 
     * <div class="alert"><b>Note</b> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the operations complete. See <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> for more information.</div>
     * <div> </div>
     * If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b>, the socket in this function will be treated as a nonoverlapped socket.
     * 
     * For nonoverlapped sockets, the blocking semantics are identical to that of the standard 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> function and the <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> parameters are ignored. Any data that has already been received and buffered by the transport will be copied into the user buffers. For the case of a blocking socket with no data currently having been received and buffered by the transport, the call will block until data is received.
     * 
     * The buffers are filled in the order in which they appear in the array indicated by <i>lpBuffers</i>, and the buffers are packed so that no holes are created.
     * 
     * If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures before returning from this call. This enables applications to build stack-based 
     * <b>WSABUF</b> arrays pointed to by the <i>lpBuffers</i> parameter.
     * 
     * For connectionless socket types, the address from which the data originated is copied to the buffer indicated by <i>lpFrom</i>. The value pointed to by <i>lpFromlen</i> is initialized to the size of this buffer, and is modified on completion to indicate the actual size of the address stored there. As stated previously for overlapped sockets, the <i>lpFrom</i> and <i>lpFromlen</i> parameters are not updated until after the overlapped I/O has completed. The memory pointed to by these parameters must, therefore, remain available to the service provider and cannot be allocated on the application stack frame. The <i>lpFrom</i> and <i>lpFromlen</i> parameters are ignored for connection-oriented sockets.
     * 
     * For byte stream–style sockets (for example, type SOCK_STREAM), incoming data is placed into the buffers until:
     * 
     * <ul>
     * <li>The buffers are filled.</li>
     * <li>The connection is closed.</li>
     * <li>The internally buffered data is exhausted.</li>
     * </ul>
     * Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets. For message-oriented sockets, an incoming message is placed into the buffers up to the total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the first part of the message. If the <b>MSG_PARTIAL</b> feature is supported by the underlying service provider, the <b>MSG_PARTIAL</b> flag is set in <i>lpFlags</i> and subsequent receive operation(s) will retrieve the rest of the message. If <b>MSG_PARTIAL</b> is not supported, but the protocol is reliable, 
     * <b>WSARecvFrom</b> generates the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a> and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol is unreliable and does not support <b>MSG_PARTIAL</b>), the excess data is lost, and 
     * <b>WSARecvFrom</b> generates the error WSAEMSGSIZE.
     * 
     * The <i>lpFlags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the <i>lpFlags</i> parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>MSG_PEEK</b></td>
     * <td>Previews the incoming data. The data is copied into the buffer, but is not removed from the input queue. This flag is valid only for nonoverlapped sockets.</td>
     * </tr>
     * <tr>
     * <td><b>MSG_OOB</b></td>
     * <td>Processes OOB data.</td>
     * </tr>
     * <tr>
     * <td><b>MSG_PARTIAL</b></td>
     * <td>This flag is for message-oriented sockets only. On output, this flag indicates that the data is a portion of the message transmitted by the sender. Remaining portions of the message will be transmitted in subsequent receive operations. A subsequent receive operation with <b>MSG_PARTIAL</b> flag cleared indicates the end of the sender's message. 
     * 
     * 
     * As an input parameter, this flag indicates that the receive operation should complete even if only part of a message has been received by the service provider.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * For message-oriented sockets, the <b>MSG_PARTIAL</b> bit is set in the <i>lpFlags</i> parameter if a partial message is received. If a complete message is received, <b>MSG_PARTIAL</b> is cleared in <i>lpFlags</i>. In the case of delayed completion, the value pointed to by <i>lpFlags</i> is not updated. When completion has been indicated the application should call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> and examine the flags pointed to by the <i>lpdwFlags</i> parameter.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSARecvFrom</b> with the <i>lpOverlapped</i> parameter set to NULL, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Overlapped_Socket_I_O"></a><a id="overlapped_socket_i_o"></a><a id="OVERLAPPED_SOCKET_I_O"></a>Overlapped Socket I/O</h3>
     * If an overlapped operation completes immediately, 
     * <b>WSARecvFrom</b> returns a value of zero and the <i>lpNumberOfBytesRecvd</i> parameter is updated with the number of bytes received and the flag bits pointed by the <i>lpFlags</i> parameter are also updated. If the overlapped operation is successfully initiated and will complete later, 
     * <b>WSARecvFrom</b> returns <b>SOCKET_ERROR</b> and indicates error code <b>WSA_IO_PENDING</b>. In this case, <i>lpNumberOfBytesRecvd</i> and <i>lpFlags</i> is not updated. When the overlapped operation completes the amount of data transferred is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>. Flag values are obtained either through the <i>dwFlags</i> parameter of the completion routine, or by examining the <i>lpdwFlags</i> parameter of 
     * <b>WSAGetOverlappedResult</b>.
     * 
     * The 
     * <b>WSARecvFrom</b> function can be called from within the completion routine of a previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <b>WSARecvFrom</b>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.
     * 
     * If the <i>lpCompletionRoutine</i> parameter is <b>NULL</b>, the <i>hEvent</i> parameter of <i>lpOverlapped</i> is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> to wait or poll on the event object.
     * 
     * If <i>lpCompletionRoutine</i> is not <b>NULL</b>, the <i>hEvent</i> parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-<b>NULL</b> <i>lpCompletionRoutine</i> and later calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> for the same overlapped I/O request may not set the <i>fWait</i> parameter for that invocation of 
     * <b>WSAGetOverlappedResult</b> to <b>TRUE</b>. In this case the usage of the <i>hEvent</i> parameter is undefined, and attempting to wait on the <i>hEvent</i> parameter would produce unpredictable results.
     * 
     * The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> with the <i>fAlertable</i> parameter set to <b>TRUE</b> is invoked.
     * 
     * If an IO completion port is used and the <i>lpCompletionRoutine</i> parameter and the <i>hEvent</i> parameter are <b>NULL</b>, the result of the operation is schedule on the IO completion port. This happens for all successful operations, whether the operations complete immediately or not.
     * 
     * The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The prototype of the completion routine is as follows.
     * 
     * 
     * ```cpp
     * 
     * void CALLBACK CompletionROUTINE(
     *   IN DWORD dwError, 
     *   IN DWORD cbTransferred, 
     *   IN LPWSAOVERLAPPED lpOverlapped, 
     *   IN DWORD dwFlags
     * );
     * 
     * ```
     * 
     * 
     * The <b>CompletionRoutine</b> is a placeholder for an application-defined or library-defined function name. The <i>dwError</i> specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. The <i>cbTransferred</i> specifies the number of bytes received. The <i>dwFlags</i> parameter contains information that would have appeared in <i>lpFlags</i> if the receive operation had completed immediately. This function does not return a value.
     * 
     * Returning from this function allows invocation of another pending completion routine for this socket. When using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a>, all waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order they are specified.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSARecvFrom</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length of the buffer.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<UInt32>} lpNumberOfBytesRecvd A pointer to the number of bytes received by this call if the 
     * <b>WSARecvFrom</b> operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Pointer<UInt32>} lpFlags A pointer to flags used to modify the behavior of the 
     * <b>WSARecvFrom</b> function call. See remarks below.
     * @param {Pointer<SOCKADDR>} lpFrom An optional pointer to a buffer that will hold the source address upon the completion of the overlapped operation.
     * @param {Pointer<Int32>} lpFromlen A pointer to the size, in bytes, of the "from" buffer required only if <i>lpFrom</i> is specified.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for nonoverlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the 
     * <b>WSARecvFrom</b> operation has been completed (ignored for nonoverlapped sockets).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsarecvfrom
     * @since windows8.1
     */
    static WSARecvFrom(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpFrom, lpFromlen, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSARecvFrom", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "ptr", lpNumberOfBytesRecvd, "ptr", lpFlags, "ptr", lpFrom, "ptr", lpFromlen, "ptr", lpOverlapped, "ptr", lpCompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAResetEvent function resets the state of the specified event object to nonsignaled.
     * @remarks
     * The 
     * <b>WSAResetEvent</b> function is used to set the state of the event object to nonsignaled.
     * 
     * The proper way to reset the state of an event object used with the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> function is to pass the handle of the event object to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnetworkevents">WSAEnumNetworkEvents</a> function in the <i>hEventObject</i> parameter. This will reset the event object and adjust the status of active FD events on the socket in an atomic fashion.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} hEvent A handle that identifies an open event object handle.
     * @returns {Integer} If the 
     * <b>WSAResetEvent</b> function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter is not a valid event object handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaresetevent
     * @since windows8.1
     */
    static WSAResetEvent(hEvent) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAResetEvent", "ptr", hEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends data on a connected socket. (WSASend)
     * @remarks
     * The 
     * <b>WSASend</b> function provides functionality over and above the standard 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> function in two important areas:
     * 
     * <ul>
     * <li>It can be used in conjunction with overlapped sockets to perform overlapped 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> operations.</li>
     * <li>It allows multiple 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> buffers to be specified making it applicable to the scatter/gather type of I/O.</li>
     * </ul>
     * The 
     * <b>WSASend</b> function is used to write outgoing data from one or more buffers on a connection-oriented socket specified by <i>s</i>. It can also be used, however, on connectionless sockets that have a stipulated default peer address established through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> function.
     * 
     * A socket created by the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function will have the overlapped attribute as the default. A socket created by the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function with the <i>dwFlags</i> parameter passed to <b>WSASocket</b> with the <b>WSA_FLAG_OVERLAPPED</b> bit set will have the overlapped attribute. For sockets with the overlapped attribute,  <b>WSASend</b> uses overlapped I/O unless both the  <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> parameters are <b>NULL</b>. In that case, the socket is treated as a non-overlapped socket. A completion indication will occur, invoking the completion of a routine or setting of an event object, when the buffer(s) have been consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>.
     * 
     * If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b>, the socket in this function will be treated as a non-overlapped socket.
     * 
     * For non-overlapped sockets, the last two parameters (<i>lpOverlapped</i>, <i>lpCompletionRoutine</i>) are ignored and 
     * <b>WSASend</b> adopts the same blocking semantics as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>. Data is copied from the buffer(s) into the transport's buffer. If the socket is non-blocking and stream-oriented, and there is not sufficient space in the transport's buffer, 
     * <b>WSASend</b> will return with only part of the application's buffers having been consumed. Given the same buffer situation and a blocking socket, 
     * <b>WSASend</b> will block until all of the application buffer contents have been consumed.
     * 
     * <div class="alert"><b>Note</b>  The socket options <b>SO_RCVTIMEO</b> and <b>SO_SNDTIMEO</b> apply only to blocking sockets.</div>
     * <div> </div>
     * If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures before returning from this call. This enables applications to build stack-based 
     * <b>WSABUF</b> arrays pointed to by the <i>lpBuffers</i> parameter.
     * 
     * For message-oriented sockets, do not exceed the maximum message size of the underlying provider, which can be obtained by getting the value of socket option <b>SO_MAX_MSG_SIZE</b>. If the data is too long to pass atomically through the underlying protocol the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a> is returned, and no data is transmitted.
     * 
     * <b>Windows Me/98/95:  </b>The <b>WSASend</b> function does not support more than 16 buffers.
     * 
     * <div class="alert"><b>Note</b>  The successful completion of a 
     * <b>WSASend</b> does not indicate that the data was successfully delivered.</div>
     * <div> </div>
     * <h3><a id="Using_dwFlags"></a><a id="using_dwflags"></a><a id="USING_DWFLAGS"></a>Using dwFlags</h3>
     * The <i>dwFlags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the <i>dwFlags</i> parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>MSG_DONTROUTE</b></td>
     * <td>Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.</td>
     * </tr>
     * <tr>
     * <td><b>MSG_OOB</b></td>
     * <td>Send OOB data on a stream-style socket such as <b>SOCK_STREAM</b> only.</td>
     * </tr>
     * <tr>
     * <td><b>MSG_PARTIAL</b></td>
     * <td>Specifies that <i>lpBuffers</i> only contains a partial message. Be aware that the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a> will be returned by transports that do not support partial message transmissions.</td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSASend</b> with the <i>lpOverlapped</i> parameter set to NULL, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Overlapped_Socket_I_O"></a><a id="overlapped_socket_i_o"></a><a id="OVERLAPPED_SOCKET_I_O"></a>Overlapped Socket I/O</h3>
     * If an overlapped operation completes immediately, 
     * <b>WSASend</b> returns a value of zero and the <i>lpNumberOfBytesSent</i> parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later, 
     * <b>WSASend</b> returns SOCKET_ERROR and indicates error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a>. In this case, <i>lpNumberOfBytesSent</i> is not updated. When the overlapped operation completes the amount of data transferred is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>.
     * 
     * <div class="alert"><b>Note</b>  All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a>.</div>
     * <div> </div>
     * The 
     * <b>WSASend</b> function using overlapped I/O can be called from within the completion routine of a previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, <b>WSASend</b>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> function. This enables time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.
     * 
     * If the <i>lpCompletionRoutine</i> parameter is <b>NULL</b>, the <i>hEvent</i> parameter of <i>lpOverlapped</i> is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> to wait or poll on the event object.
     * 
     * If <i>lpCompletionRoutine</i> is not <b>NULL</b>, the <i>hEvent</i> parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-<b>NULL</b> <i>lpCompletionRoutine</i> and later calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> for the same overlapped I/O request may not set the <i>fWait</i> parameter for that invocation of 
     * <b>WSAGetOverlappedResult</b> to <b>TRUE</b>. In this case the usage of the <i>hEvent</i> parameter is undefined, and attempting to wait on the <i>hEvent</i> parameter would produce unpredictable results.
     * 
     * The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> with the <i>fAlertable</i> parameter set to <b>TRUE</b> is invoked.
     * 
     * The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The following C++ code example is a prototype of the completion routine.
     * 
     * 
     * ``` syntax
     * 
     * void CALLBACK CompletionROUTINE(
     *   IN DWORD dwError,
     *   IN DWORD cbTransferred,
     *   IN LPWSAOVERLAPPED lpOverlapped,
     *   IN DWORD dwFlags
     * );
     * ```
     * 
     * The CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The <i>dwError</i> parameter specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. <i>cbTransferred</i> specifies the number of bytes sent. Currently there are no flag values defined and <i>dwFlags</i> will be zero. This function does not return a value.
     * 
     * Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of <b>WSA_IO_COMPLETION</b>. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified.
     * 
     * The order of calls made to <b>WSASend</b> is also the order in which the buffers are transmitted to the transport layer. <b>WSASend</b> should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from multiple concurrent send requests on the same stream-oriented socket.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following code example shows how to use the <b>WSASend</b> function in overlapped I/O mode.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor that identifies a connected socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length, in bytes, of the buffer. For a Winsock application, once the 
     * <b>WSASend</b> function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<UInt32>} lpNumberOfBytesSent A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Integer} dwFlags The flags used to modify the behavior of the 
     * <b>WSASend</b> function call. For more information, see Using <i>dwFlags</i> in the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure. This parameter is ignored for nonoverlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the send operation has been completed. This parameter is ignored for nonoverlapped sockets.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasend
     * @since windows8.1
     */
    static WSASend(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASend", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "ptr", lpNumberOfBytesSent, "uint", dwFlags, "ptr", lpOverlapped, "ptr", lpCompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Sends data and optional control information from connected and unconnected sockets. Note  This function is a Microsoft-specific extension to the Windows Sockets specification. .
     * @remarks
     * The <b>WSASendMsg</b> function can be used in place of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> functions. The <b>WSASendMsg</b> function can only be used with datagrams  and raw sockets. The socket descriptor in the <i>s</i> parameter must be opened with the socket type set to <b>SOCK_DGRAM</b> or <b>SOCK_RAW</b>.
     * 
     * The <i>dwFlags</i> parameter can only contain a combination of the  following control flags: <b>MSG_DONTROUTE</b>, <b>MSG_PARTIAL</b>, and <b>MSG_OOB</b>. The <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure pointed to by the <i>lpMsg</i> parameter is ignored on input and not used on output.
     * 
     * 
     * <div class="alert"><b>Note</b>  The function pointer for the 
     * <b>WSASendMsg</b> function must be obtained at run time by making a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with the <b>SIO_GET_EXTENSION_FUNCTION_POINTER</b> opcode specified. The input buffer passed to the <b>WSAIoctl</b> function must contain <b>WSAID_WSASENDMSG</b>, a globally unique identifier (GUID) whose value identifies the <b>WSASendMsg</b> extension function. On success, the output returned by the <b>WSAIoctl</b> function contains a pointer to the <b>WSASendMsg</b> function. The <b>WSAID_WSASENDMSG</b> GUID is defined in the <i>Mswsock.h</i> header file.</div>
     * <div> </div>
     * 
     * 
     * Overlapped sockets are  created with a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function call that has the <b>WSA_FLAG_OVERLAPPED</b> flag set. For overlapped sockets, sending information uses overlapped I/O unless both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b>; when <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b>, the socket is treated as a nonoverlapped socket. A completion indication occurs with overlapped sockets; once the buffer or buffers have been consumed by the transport, a completion routine is triggered or an event object is set. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or by calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> function.
     * 
     * For nonoverlapped sockets, the <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> parameters  are ignored and <b>WSASendMsg</b> adopts the same blocking semantics as the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> function: data is copied from the buffer or buffers into the transport's buffer. If the socket is nonblocking and stream oriented, and there is insufficient space in the transport's buffer, <b>WSASendMsg</b> returns with only part of the application's buffers having been consumed. In contrast, this buffer situation on a blocking socket results in <b>WSASendMsg</b> blocking until all of the application's buffer contents have been consumed.
     * 
     * 
     * If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture this <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structure before returning from this call. This enables applications to build stack-based 
     * <b>WSABUF</b> arrays pointed to by the <b>lpBuffers</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure pointed to by the <i>lpMsg</i> parameter.
     * 
     * For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying provider, which can be obtained by getting the value of socket option <b>SO_MAX_MSG_SIZE</b>. If the data is too long to pass atomically through the underlying protocol, the error <b>WSAEMSGSIZE</b> is returned and no data is transmitted.
     * 
     * 
     * On an IPv4 socket of type  <b>SOCK_DGRAM</b> or <b>SOCK_RAW</b>, an application can specific  the local IP source address to use for sending with the <b>WSASendMsg</b> function. One of the control data objects passed in the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure to the <b>WSASendMsg</b> function may contain an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2ipdef/ns-ws2ipdef-in_pktinfo">in_pktinfo</a> structure used to specify the local IPv4 source address to use for sending.
     * 
     * On an IPv6 socket of type  <b>SOCK_DGRAM</b> or <b>SOCK_RAW</b>, an application can specific  the local IP source address to use for sending with the <b>WSASendMsg</b> function. One of the control data objects passed in the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure to the <b>WSASendMsg</b> function may contain an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2ipdef/ns-ws2ipdef-in6_pktinfo">in6_pktinfo</a> structure used to specify the local IPv6 source address to use for sending.
     * 
     * For a dual-stack socket when sending datagrams  with the <b>WSASendMsg</b> function and an application wants to specify a specific local IP source address to be used, the method to handle this depends on the destination IP address. When sending to an IPv4 destination address or an IPv4-mapped IPv6 destination address, one of the control data objects passed in the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure pointed to by the <i>lpMsg</i> parameter should contain an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2ipdef/ns-ws2ipdef-in_pktinfo">in_pktinfo</a> structure containing the local IPv4 source address to use for sending. When sending to an IPv6 destination address that is not a an IPv4-mapped IPv6 address, one of the control data objects passed in the <b>WSAMSG</b> structure pointed to by the <i>lpMsg</i> parameter should contain an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2ipdef/ns-ws2ipdef-in6_pktinfo">in6_pktinfo</a> structure containing the local IPv6 source address to use for sending. 
     * 
     * <div class="alert"><b>Note</b>  The <b>SO_SNDTIMEO</b> socket option applies only to blocking sockets.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  The successful completion of a 
     * <b>WSASendMsg</b> does not indicate that the data was successfully delivered.</div>
     * <div> </div>
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSASendMsg</b> with the <i>lpOverlapped</i> parameter set to NULL, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="dwFlags"></a><a id="dwflags"></a><a id="DWFLAGS"></a>dwFlags</h3>
     * The <i>dwFlags</i> input parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the <i>dwFlags</i> parameter. The latter is constructed by using the bitwise OR operator with any of the following values.<table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>MSG_DONTROUTE</b></td>
     * <td>Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.</td>
     * </tr>
     * <tr>
     * <td><b>MSG_PARTIAL</b></td>
     * <td>Specifies that <i>lpMsg-&gt;lpBuffers</i> contains only a partial message. Note that the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a> will be returned by transports that do not support partial message transmissions.</td>
     * </tr>
     * </table>
     *  </p>The possible values for <i>dwFlags</i> parameter are defined in the <i>Winsock2.h</i> header file.
     * 
     * On output, the <b>dwFlags</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure pointed to by the <i>lpMsg</i> parameter is not used. 
     * 
     * <h3><a id="Overlapped_Socket_I_O"></a><a id="overlapped_socket_i_o"></a><a id="OVERLAPPED_SOCKET_I_O"></a>Overlapped Socket I/O</h3>
     * If an overlapped operation completes immediately, 
     * <b>WSASendMsg</b> returns a value of zero and the <i>lpNumberOfBytesSent</i> parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later, 
     * <b>WSASendMsg</b> returns SOCKET_ERROR and indicates error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a>. In this case, <i>lpNumberOfBytesSent</i> is not updated. When the overlapped operation completes, the amount of data transferred is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified) or through the <i>lpcbTransfer</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>.
     * 
     * 
     * <div class="alert"><b>Note</b>   All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. See <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> for more information.</div>
     * <div> </div>
     * 
     * 
     * The 
     * <b>WSASendMsg</b> function using overlapped I/O can be called from within the completion routine of a previous 
     * , <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, <a href="https://docs.microsoft.com/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg">LPFN_WSARECVMSG (WSARecvMsg)</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, <b>WSASendMsg</b>, or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> function. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.
     * 
     * If the <i>lpCompletionRoutine</i> parameter is <b>NULL</b>, the <i>hEvent</i> parameter of <i>lpOverlapped</i> is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> to wait or poll on the event object.
     * 
     * If <i>lpCompletionRoutine</i> is not <b>NULL</b>, the <i>hEvent</i> parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-<b>NULL</b> <i>lpCompletionRoutine</i> and later calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> for the same overlapped I/O request may not set the <i>fWait</i> parameter for that invocation of 
     * <b>WSAGetOverlappedResult</b> to <b>TRUE</b>. In this case, the usage of the <i>hEvent</i> parameter is undefined, and attempting to wait on the <i>hEvent</i> parameter would produce unpredictable results.
     * 
     * The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state, for example, with <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> called with the <i>fAlertable</i> parameter set to <b>TRUE</b>.
     * 
     * The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The prototype of the completion routine is as follows.
     * 
     * 
     * ```cpp
     * 
     * void CALLBACK CompletionRoutine(
     *   IN DWORD dwError,
     *   IN DWORD cbTransferred,
     *   IN LPWSAOVERLAPPED lpOverlapped,
     *   IN DWORD dwFlags
     * );
     * 
     * ```
     * 
     * 
     * The <b>CompletionRoutine</b> function is a placeholder for an application-defined or library-defined function name. The <i>dwError</i> parameter specifies the completion status for the overlapped operation as indicated by the <i>lpOverlapped</i> parameter. The <i>cbTransferred</i> parameter indicates the number of bytes sent. Currently there are no flag values defined and the <i>dwFlags</i> parameter will be zero. The <b>CompletionRoutine</b> function does not return a value.
     * 
     * Returning from this function allows invocation of another pending completion routine for the socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} Handle A descriptor identifying the  socket.
     * @param {Pointer<WSAMSG>} lpMsg A <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure storing the Posix.1g <b>msghdr</b> structure.
     * @param {Integer} dwFlags The flags used to modify the behavior of the <b>WSASendMsg</b> function call. For more information, see Using <i>dwFlags</i> in the Remarks section.
     * @param {Pointer<UInt32>} lpNumberOfBytesSent A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure. Ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the send operation completes. Ignored for non-overlapped sockets.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasendmsg
     * @since windows8.1
     */
    static WSASendMsg(Handle, lpMsg, dwFlags, lpNumberOfBytesSent, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASendMsg", "ptr", Handle, "ptr", lpMsg, "uint", dwFlags, "ptr", lpNumberOfBytesSent, "ptr", lpOverlapped, "ptr", lpCompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSASendDisconnect function initiates termination of the connection for the socket and sends disconnect data.
     * @remarks
     * The 
     * <b>WSASendDisconnect</b> function is used on connection-oriented sockets to disable transmission and to initiate termination of the connection along with the transmission of disconnect data, if any. This is equivalent to a shutdown (SD_SEND), except that 
     * <b>WSASendDisconnect</b> also allows sending disconnect data (in protocols that support it).
     * 
     * After this function has been successfully issued, subsequent sends are disallowed.
     * 
     * The <i>lpOutboundDisconnectData</i> parameter, if not <b>NULL</b>, points to a buffer containing the outgoing disconnect data to be sent to the remote party for retrieval by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvdisconnect">WSARecvDisconnect</a>.
     * 
     * <div class="alert"><b>Note</b>  The native implementation of TCP/IP on Windows does not support disconnect data. Disconnect data is only supported with Windows Sockets providers that have the XP1_DISCONNECT_DATA flag in their 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function to obtain 
     * <b>WSAPROTOCOL_INFO</b> structures for all installed providers.</div>
     * <div> </div>
     * The 
     * <b>WSASendDisconnect</b> function does not close the socket, and resources attached to the socket will not be freed until 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> is invoked.
     * 
     * The 
     * <b>WSASendDisconnect</b> function does not block regardless of the SO_LINGER setting on the socket.
     * 
     * An application should not rely on being able to reuse a socket after calling 
     * <b>WSASendDisconnect</b>. In particular, a Windows Sockets provider is not required to support the use of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> on such a socket.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSASendDisconnect</b>,  Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * @param {Pointer} s Descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpOutboundDisconnectData A pointer to the outgoing disconnect data.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasenddisconnect
     * @deprecated
     * @since windows5.0
     */
    static WSASendDisconnect(s, lpOutboundDisconnectData) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASendDisconnect", "ptr", s, "ptr", lpOutboundDisconnectData)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Sends data to a specific destination, using overlapped I/O where applicable.
     * @remarks
     * The 
     * <b>WSASendTo</b> function provides enhanced features over the standard 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a> function in two important areas:
     * 
     * <ul>
     * <li>It can be used in conjunction with overlapped sockets to perform overlapped send operations.</li>
     * <li>It allows multiple send buffers to be specified making it applicable to the scatter/gather type of I/O.</li>
     * </ul>
     * The 
     * <b>WSASendTo</b> function is normally used on a connectionless socket specified by <i>s</i> to send a datagram contained in one or more buffers to a specific peer socket identified by the <i>lpTo</i> parameter. Even if the connectionless socket has been previously connected using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> function to a specific address, <i>lpTo</i> overrides the destination address for that particular datagram only. On a connection-oriented socket, the <i>lpTo</i> and <i>iToLen</i> parameters are ignored; in this case, the 
     * <b>WSASendTo</b> is equivalent to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>.
     * 
     * For overlapped sockets (created using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> with flag <b>WSA_FLAG_OVERLAPPED</b>) sending data uses overlapped I/O, unless both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b> in which case the socket is treated as a nonoverlapped socket. A completion indication will occur (invoking the completion routine or setting of an event object) when the buffer(s) have been consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the completion routine or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>.
     * 
     * <div class="alert"><b>Note</b>  If a socket is opened, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> call is made, and then a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a> call is made, Windows Sockets performs an implicit 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function call.</div>
     * <div> </div>
     * If both <i>lpOverlapped</i> and <i>lpCompletionRoutine</i> are <b>NULL</b>, the socket in this function will be treated as a nonoverlapped socket.
     * 
     * For nonoverlapped sockets, the last two parameters (<i>lpOverlapped</i>, <i>lpCompletionRoutine</i>) are ignored and 
     * <b>WSASendTo</b> adopts the same blocking semantics as 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>. Data is copied from the buffer(s) into the transport buffer. If the socket is nonblocking and stream oriented, and there is not sufficient space in the transport's buffer, 
     * <b>WSASendTo</b> returns with only part of the application's buffers having been consumed. Given the same buffer situation and a blocking socket, 
     * <b>WSASendTo</b> will block until all of the application's buffer contents have been consumed.
     * 
     * If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures before returning from this call. This enables applications to build stack-based 
     * <b>WSABUF</b> arrays pointed to by the <i>lpBuffers</i> parameter.
     * 
     * For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport, which can be obtained by getting the value of socket option <b>SO_MAX_MSG_SIZE</b>. If the data is too long to pass atomically through the underlying protocol the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a> is returned, and no data is transmitted.
     * 
     * If the socket is unbound, unique values are assigned to the local association by the system, and the socket is then marked as bound. 
     * 
     * If the socket is connected, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function can be used to determine the local IP address and port associated with the socket. 
     * 
     * If the socket is not connected, the  
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a>   function can be used to determine the local port number associated with the socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY  or "0.0.0.0" for IPv4 and IN6ADDR_ANY_INIT or "::" for IPv6).
     * 
     * The successful completion of a 
     * <b>WSASendTo</b> does not indicate that the data was successfully delivered.
     * 
     * The <i>dwFlags</i> parameter can be used to influence the behavior of the function invocation beyond the options specified for the associated socket. That is, the semantics of this function are determined by the socket options and the <i>dwFlags</i> parameter. The latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><b>MSG_DONTROUTE</b></td>
     * <td>Specifies that the data should not be subject to routing. A Windows Socket service provider may choose to ignore this flag.</td>
     * </tr>
     * <tr>
     * <td><b>MSG_OOB</b></td>
     * <td>Send OOB data (stream-style socket such as <b>SOCK_STREAM</b> only).</td>
     * </tr>
     * <tr>
     * <td><b>MSG_PARTIAL</b></td>
     * <td>Specifies that <i>lpBuffers</i> only contains a partial message. Be aware that the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a> will be returned by transports that do not support partial message transmissions.</td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSASendTo</b> with the <i>lpOverlapped</i> parameter set to <b>NULL</b>, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * <h3><a id="Overlapped_Socket_I_O"></a><a id="overlapped_socket_i_o"></a><a id="OVERLAPPED_SOCKET_I_O"></a>Overlapped Socket I/O</h3>
     * If an overlapped operation completes immediately, 
     * <b>WSASendTo</b> returns a value of zero and the <i>lpNumberOfBytesSent</i> parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later, 
     * <b>WSASendTo</b> returns <b>SOCKET_ERROR</b> and indicates error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a>. In this case, <i>lpNumberOfBytesSent</i> is not updated. When the overlapped operation completes the amount of data transferred is indicated either through the <i>cbTransferred</i> parameter in the completion routine (if specified), or through the <i>lpcbTransfer</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a>.
     * 
     * <div class="alert"><b>Note</b>   All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. See <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> for more information.</div>
     * <div> </div>
     * The 
     * <b>WSASendTo</b> function using overlapped I/O can be called from within the completion routine of a previous 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, or 
     * <b>WSASendTo</b> function. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The <i>lpOverlapped</i> parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are simultaneously outstanding, each must reference a separate 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.
     * 
     * If the <i>lpCompletionRoutine</i> parameter is <b>NULL</b>, the <i>hEvent</i> parameter of <i>lpOverlapped</i> is signaled when the overlapped operation completes if it contains a valid event object handle. An application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> to wait or poll on the event object.
     * 
     * If <i>lpCompletionRoutine</i> is not <b>NULL</b>, the <i>hEvent</i> parameter is ignored and can be used by the application to pass context information to the completion routine. A caller that passes a non-<b>NULL</b><i>lpCompletionRoutine</i> and later calls 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsagetoverlappedresult">WSAGetOverlappedResult</a> for the same overlapped I/O request may not set the <i>fWait</i> parameter for that invocation of 
     * <b>WSAGetOverlappedResult</b> to <b>TRUE</b>. In this case the usage of the <i>hEvent</i> parameter is undefined, and attempting to wait on the <i>hEvent</i> parameter would produce unpredictable results.
     * 
     * The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine will not be invoked until the thread is in an alertable wait state such as can occur when the function 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> with the <i>fAlertable</i> parameter set to <b>TRUE</b> is invoked.
     * 
     * Transport providers allow an application to invoke send and receive operations from within the context of the socket I/O completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits time-sensitive data transmissions to occur entirely within a preemptive context.
     * 
     * The prototype of the completion routine is as follows.
     * 
     * 
     * ```cpp
     * 
     * void CALLBACK CompletionROUTINE(
     *   IN DWORD dwError,
     *   IN DWORD cbTransferred,
     *   IN LPWSAOVERLAPPED lpOverlapped,
     *   IN DWORD dwFlags
     * );
     * 
     * ```
     * 
     * 
     * The  CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The <i>dwError</i> parameter specifies the completion status for the overlapped operation as indicated by <i>lpOverlapped</i>. The <i>cbTransferred</i> parameter specifies the number of bytes sent. Currently there are no flag values defined and <i>dwFlags</i> will be zero. This function does not return a value.
     * 
     * Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order in which the overlapped operations are completed. However, the posted buffers are guaranteed to be sent in the same order they are specified.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSASendTo</b> function using an event object.
     * 
     * 
     * ```cpp
     * @param {Pointer} s A descriptor identifying a (possibly connected) socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length of the buffer, in bytes. For a Winsock application, once the 
     * <b>WSASendTo</b> function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<UInt32>} lpNumberOfBytesSent A pointer to the number of bytes sent by this call if the I/O operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Integer} dwFlags The flags  used to modify the behavior of the 
     * <b>WSASendTo</b> function call.
     * @param {Pointer<SOCKADDR>} lpTo An optional pointer to the address of the target socket in the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR</a> structure.
     * @param {Integer} iTolen The size, in bytes, of the address in the <i>lpTo</i> parameter.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for nonoverlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the send operation has been completed (ignored for nonoverlapped sockets).
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasendto
     * @since windows8.1
     */
    static WSASendTo(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpTo, iTolen, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASendTo", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "ptr", lpNumberOfBytesSent, "uint", dwFlags, "ptr", lpTo, "int", iTolen, "ptr", lpOverlapped, "ptr", lpCompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSASetEvent function sets the state of the specified event object to signaled.
     * @remarks
     * The 
     * <b>WSASetEvent</b> function sets the state of the event object to be signaled.
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer} hEvent Handle that identifies an open event object.
     * @returns {Integer} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter is not a valid event object handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasetevent
     * @since windows8.1
     */
    static WSASetEvent(hEvent) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASetEvent", "ptr", hEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASocket function creates a socket that is bound to a specific transport-service provider. (ANSI)
     * @remarks
     * The 
     * <b>WSASocket</b> function causes a socket descriptor and any related resources to be allocated and associated with a transport-service provider. Most sockets should be created with the <b>WSA_FLAG_OVERLAPPED</b> attribute set in the <i>dwFlags</i> parameter. A socket created with this attribute supports the use of overlapped I/O operations which provide higher performance. By default, a socket created with the <b>WSASocket</b> function will not have this overlapped attribute set. In contrast, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function creates a socket that supports overlapped I/O operations as the default behavior.
     * 
     * If the <i>lpProtocolInfo</i> parameter is <b>NULL</b>, Winsock will utilize the first available transport-service provider that supports the requested combination of address family, socket type and protocol specified in the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters.
     * 
     * If the <i>lpProtocolInfo</i> parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. In this instance, the application can supply the manifest constant <b>FROM_PROTOCOL_INFO</b> as the value for any of <i>af</i>, <i>type</i>, or <i>protocol</i> parameters. This indicates that the corresponding values from the indicated 
     * <b>WSAPROTOCOL_INFO</b> structure (<b>iAddressFamily</b>, <b>iSocketType</b>, <b>iProtocol</b>) are to be assumed. In any case, the values specified for <i>af</i>, <i>type</i>, and <i>protocol</i> are passed unmodified to the transport-service provider.
     * 
     * When selecting a protocol and its supporting service provider based on <i>af</i>, <i>type</i>, and <i>protocol</i>, this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on <i>type</i> or <i>af</i>, either. That is, they do not lead to an error code of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a>, if no suitable protocol is found.
     * 
     * <div class="alert"><b>Note</b>  The manifest constant <b>AF_UNSPEC</b> continues to be defined in the header file but its use is strongly discouraged, as this can cause ambiguity in interpreting the value of the <i>protocol</i> parameter.</div>
     * <div> </div>
     * Applications are encouraged to use <b>AF_INET6</b> for the <i>af</i> parameter and create a dual-mode socket that can be used with both IPv4 and IPv6.
     * 
     * If a socket is created using the <b>WSASocket</b> function, then the <i>dwFlags</i> parameter must have the <b>WSA_FLAG_OVERLAPPED</b> attribute set for the <b>SO_RCVTIMEO</b> or <b>SO_SNDTIMEO</b> socket options to function properly. Otherwise the timeout never takes effect on the socket.
     * 
     * Connection-oriented sockets such as <b>SOCK_STREAM</b> provide full-duplex connections, and must be in a connected state before any data can be sent or received on them. A connection to  a specified socket is established with a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> function call. Once connected, data can be transferred using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> calls. When a session has been completed, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> function should be called to release the resources associated with the socket. For connection-oriented sockets, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> function should be called to stop data transfer on the socket before calling the <b>closesocket</b> function.
     * 
     * The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>.
     * 
     * Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>. If such a socket is connected to a specific peer, datagrams can be sent to that peer using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> and can be received from (only) this peer using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>.
     * 
     * Support for sockets with type <b>SOCK_RAW</b> is not required, but service providers are encouraged to support raw sockets whenever possible.
     * 
     * The <b>WSASocket</b> function can be used to create a socket to be used by a service so that if another socket tries to bind to the same port used by the service, and audit record is generated. To enable this option, an application would need to do the following:
     * 
     * 
     * <ul>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a> function to enable the <b>SE_SECURITY_NAME</b> privilege in the access token for the process. This privilege is required to set the  <b>ACCESS_SYSTEM_SECURITY</b> access rights on the security descriptor for an object. </li>
     * <li>Call the <b>WSASocket</b> function to create a socket with <i>dwFlag</i> with the <b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b> option set. The <b>WSASocket</b> function will fail if the <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a> function is not called first to enable the <b>SE_SECURITY_NAME</b> privilege needed for this operation.</li>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/aclapi/nf-aclapi-setsecurityinfo">SetSecurityInfo</a> function to set a security descriptor with a System Access Control List (SACL) on the socket. The socket handle returned by the <b>WSASocket</b> function is passed in the <i>handle</i> parameter. If the function succeeds, this will set the the  <b>ACCESS_SYSTEM_SECURITY</b> access right on the security descriptor for the socket.</li>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function to bind the socket to a specific port. If the <b>bind</b> function succeeds, then an audit entry is generated if another socket tries to bind to the same port. </li>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a> function to remove the <b>SE_SECURITY_NAME</b> privilege in the access token for the process, since this is no longer needed. </li>
     * </ul>
     * 
     * 
     * For more information on <b>ACCESS_SYSTEM_SECURITY</b>, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a> and <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/audit-generation">Audit Generation</a> in the Authorization documentation.
     * 
     * 
     * <h3><a id="Socket_Groups"></a><a id="socket_groups"></a><a id="SOCKET_GROUPS"></a>Socket Groups</h3>
     * WinSock 2 introduced the notion of a socket group as a means for an application, or cooperating set of applications, to indicate to an underlying service provider that a particular set of sockets are related and that the group thus formed has certain attributes.  Group attributes include relative priorities of the individual sockets within the group and a group quality of service specification. 
     * 
     * Applications that need to exchange multimedia streams over the network are an example where being able to establish a specific relationship among a set of sockets could be beneficial.  It is up to the transport on how to treat socket groups. 
     * 
     * The <b>WSASocket</b> and <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> functions can be used to explicitly create and join a socket group when creating a new socket.  The socket group ID for a socket can be retrieved by using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function with <i>level</i> parameter set to <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET</a> and the <i>optname</i> parameter set to <b>SO_GROUP_ID</b>.  A socket group
     *     and its associated socket group ID remain valid until the last socket belonging to this
     *     socket group is closed. Socket group IDs are unique across all processes
     *     for a given service provider. A socket group of zero indicates that the socket is not member of a socket group.
     * 
     * The relative group priority of  a socket group can be accessed by using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function with the <i>level</i> parameter set to <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET</a> and the <i>optname</i> parameter set to <b>SO_GROUP_PRIORITY</b>. The relative group priority of  a socket group can be set by using <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> with the <i>level</i> parameter set to SOL_SOCKET and the <i>optname</i> parameter set to <b>SO_GROUP_PRIORITY</b>. 
     * 
     * The Winsock provider included with Windows allows the creation of socket groups and it enforces the SG_CONSTRAINED_GROUP. All sockets in a constrained socket group must be created with the same value for the <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.  This is the only restriction applied to a socket group by the Winsock provider included with Windows. The socket group priority is not currently used by the Winsock provider or the TCP/IP stack included with Windows. 
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSASocket</b> function.
     * 
     * 
     * ```cpp
     * @param {Integer} af The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i> header file. 
     * 
     * On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * The values currently supported are AF_INET or AF_INET6, which are the Internet
     *                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The table below lists common values for address family although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>Af</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl>
     * <dt><b>AF_UNSPEC</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family is unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl>
     * <dt><b>AF_IPX</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. 
     * 
     * This address family is not supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
     * <dt><b>AF_APPLETALK</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. 
     * 
     * This address family is not supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
     * <dt><b>AF_NETBIOS</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. 
     * 
     * The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows. 
     * 
     * The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows 7,  Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP.  
     * 
     * The Windows Sockets provider for NetBIOS  only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>.
     * 
     * The Windows Sockets provider for NetBIOS  is not directly related to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/netbios/portal">NetBIOS</a> programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008, and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
     * <dt><b>AF_IRDA</b></dt>
     * <dt>26</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Infrared Data Association (IrDA) address family. 
     * 
     * This address family is only supported if the computer has an infrared port and driver installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
     * <dt><b>AF_BTH</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth address family. 
     * 
     * This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} type The type specification for the new socket. 
     * 
     * 
     * Possible values for the socket type are defined in the <i>Winsock2.h</i> header file.
     * 
     * The following table lists the possible values for the <i>type</i> parameter supported for Windows Sockets 2:
     * 
     * <table>
     * <tr>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
     * <dt><b>SOCK_STREAM</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl>
     * <dt><b>SOCK_DGRAM</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
     * <dt><b>SOCK_RAW</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ip-socket-options">IP_HDRINCL</a> socket option must be set on the socket.  To manipulate the IPv6 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPV6_HDRINCL</a> socket option must be set on the socket.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
     * <dt><b>SOCK_RDM</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as <a href="https://docs.microsoft.com/windows/desktop/WinSock/reliable-multicast-programming--pgm-">reliable multicast programming</a>. 
     * 
     * This <i>type</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
     * <dt><b>SOCK_SEQPACKET</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a pseudo-stream packet based on datagrams. 
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address families, and protocols are defined.
     * 
     * In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b> and <b>SOCK_STREAM</b>.
     * @param {Integer} protocol The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address family and socket type specified. Possible values for the <i>protocol</i> are defined are defined in the  <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. 
     * 
     * On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * If a value of  0 is specified, the caller does not
     *               wish to specify a protocol and the service provider will choose the <i>protocol</i> to use.
     * 
     * 
     * When the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. 
     * 
     * The table below lists common values for the <i>protocol</i> although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>protocol</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
     * <dt><b>IPPROTO_ICMP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl>
     * <dt><b>IPPROTO_IGMP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
     * <dt><b>BTHPROTO_RFCOMM</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. 
     * 
     * This <i>protocol</i> value is supported on Windows XP with SP2 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl>
     * <dt><b>IPPROTO_ICMPV6</b></dt>
     * <dt>58</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b>  and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl>
     * <dt><b>IPPROTO_RM</b></dt>
     * <dt>113</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PGM protocol for reliable multicast. This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later,  this protocol is also called <b>IPPROTO_PGM</b>. 
     * 
     * This <i>protocol</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that defines the characteristics of the socket to be created. If this parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated 
     * <b>WSAPROTOCOL_INFO</b> structure.
     * @param {Integer} g An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group. 
     * 
     * If <i>g</i> is an existing socket group ID, join the new socket to this
     *             socket group, provided all the requirements set by this group are met. 
     * 
     * If <i>g</i> is not an existing socket group ID, then the following values are possible.
     * 
     * <table>
     * <tr>
     * <th>g</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id=""></a><dl>
     * <dt><b></b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No group operation is performed. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_UNCONSTRAINED_GROUP"></a><a id="sg_unconstrained_group"></a><dl>
     * <dt><b>SG_UNCONSTRAINED_GROUP</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create an unconstrained socket group and have the new socket  be the first member. For an unconstrained group, Winsock does not constrain all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_CONSTRAINED_GROUP"></a><a id="sg_constrained_group"></a><dl>
     * <dt><b>SG_CONSTRAINED_GROUP</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a constrained socket group and have the new socket  be the first member. For a constrained socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.  
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are not currently defined in a public header file.</div>
     * <div> </div>
     * @param {Integer} dwFlags A set of flags used to specify additional socket attributes. 
     * 
     * A combination of these flags may be set, although some combinations are not allowed. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_OVERLAPPED"></a><a id="wsa_flag_overlapped"></a><dl>
     * <dt><b>WSA_FLAG_OVERLAPPED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that supports overlapped I/O operations.
     * 
     * Most sockets should be created with this flag set. Overlapped sockets can utilize 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> for overlapped I/O operations, which allow multiple operations to be initiated and in progress simultaneously. 
     * 
     * All functions that allow overlapped operation (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operations are <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_ROOT"></a><a id="wsa_flag_multipoint_c_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_ROOT</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_LEAF"></a><a id="wsa_flag_multipoint_c_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_LEAF</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_ROOT"></a><a id="wsa_flag_multipoint_d_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_ROOT</b></dt>
     * <dt>0x08</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_DATA_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_LEAF"></a><a id="wsa_flag_multipoint_d_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_LEAF</b></dt>
     * <dt>0x10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_DATA_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_ACCESS_SYSTEM_SECURITY"></a><a id="wsa_flag_access_system_security"></a><dl>
     * <dt><b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b></dt>
     * <dt>0x40</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access control list (SACL) as opposed to just a discretionary access control list (DACL).
     * 
     * SACLs are used for generating audits and alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the socket should be allowed to bind to a specific address specified to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function.
     * 
     * The <b>ACCESS_SYSTEM_SECURITY</b> access right controls the ability to get or set the SACL in an object's security descriptor. The system grants this access right only if the <b>SE_SECURITY_NAME</b> privilege is enabled in the access token of the requesting thread.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_NO_HANDLE_INHERIT"></a><a id="wsa_flag_no_handle_inherit"></a><dl>
     * <dt><b>WSA_FLAG_NO_HANDLE_INHERIT</b></dt>
     * <dt>0x80</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that is non-inheritable. 
     * 
     * A socket handle created by the <b>WSASocket</b> or the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function is inheritable by default. When this flag is set, the socket handle is non-inheritable. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-gethandleinformation">GetHandleInformation</a> function can be used to determine if a socket handle was created with the <b>WSA_FLAG_NO_HANDLE_INHERIT</b> flag set. The <b>GetHandleInformation</b> function will return that the <b>HANDLE_FLAG_INHERIT</b> value is set.
     * 
     * This flag is supported on Windows 7 with SP1,  Windows Server 2008 R2 with SP1, and later 
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Important</b>  For multipoint sockets, only one of <b>WSA_FLAG_MULTIPOINT_C_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_C_LEAF</b> flags can be specified, and only  one of <b>WSA_FLAG_MULTIPOINT_D_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_D_LEAF</b> flags can be specified. Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information.</div>
     * <div> </div>
     * @returns {Pointer} If no error occurs, 
     * <b>WSASocket</b> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  This error code description is Microsoft-specific.</div>
     * <div> </div>
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProtocolInfo</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is true for any of the following conditions. 
     * 
     * 
     * 
     * 
     * <ul>
     * <li>The parameter <i>g</i> specified is not valid.</li>
     * <li>The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that <i>lpProtocolInfo</i> points to is incomplete, the contents are invalid or the 
     * <b>WSAPROTOCOL_INFO</b> structure has already been used in an earlier duplicate socket operation.</li>
     * <li>The values specified for members of the socket triple &lt;<i>af</i>, <i>type</i>, and <i>protocol</i>&gt; are individually supported, but the given combination is not.</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned a version other than 2.2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROCTABLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned an invalid or incomplete procedure table to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wspstartup">WSPStartup</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTOTYPE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is the wrong type for this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROVIDERFAILEDINIT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the provider fails to operate correctly. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified socket type is not supported in this address family.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasocketa
     * @deprecated
     * @since windows8.1
     */
    static WSASocketA(af, type, protocol, lpProtocolInfo, g, dwFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASocketA", "int", af, "int", type, "int", protocol, "ptr", lpProtocolInfo, "uint", g, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASocket function creates a socket that is bound to a specific transport-service provider. (Unicode)
     * @remarks
     * The 
     * <b>WSASocket</b> function causes a socket descriptor and any related resources to be allocated and associated with a transport-service provider. Most sockets should be created with the <b>WSA_FLAG_OVERLAPPED</b> attribute set in the <i>dwFlags</i> parameter. A socket created with this attribute supports the use of overlapped I/O operations which provide higher performance. By default, a socket created with the <b>WSASocket</b> function will not have this overlapped attribute set. In contrast, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function creates a socket that supports overlapped I/O operations as the default behavior.
     * 
     * If the <i>lpProtocolInfo</i> parameter is <b>NULL</b>, Winsock will utilize the first available transport-service provider that supports the requested combination of address family, socket type and protocol specified in the <i>af</i>, <i>type</i>, and <i>protocol</i> parameters.
     * 
     * If the <i>lpProtocolInfo</i> parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. In this instance, the application can supply the manifest constant <b>FROM_PROTOCOL_INFO</b> as the value for any of <i>af</i>, <i>type</i>, or <i>protocol</i> parameters. This indicates that the corresponding values from the indicated 
     * <b>WSAPROTOCOL_INFO</b> structure (<b>iAddressFamily</b>, <b>iSocketType</b>, <b>iProtocol</b>) are to be assumed. In any case, the values specified for <i>af</i>, <i>type</i>, and <i>protocol</i> are passed unmodified to the transport-service provider.
     * 
     * When selecting a protocol and its supporting service provider based on <i>af</i>, <i>type</i>, and <i>protocol</i>, this procedure will only choose a base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on <i>type</i> or <i>af</i>, either. That is, they do not lead to an error code of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a>, if no suitable protocol is found.
     * 
     * <div class="alert"><b>Note</b>  The manifest constant <b>AF_UNSPEC</b> continues to be defined in the header file but its use is strongly discouraged, as this can cause ambiguity in interpreting the value of the <i>protocol</i> parameter.</div>
     * <div> </div>
     * Applications are encouraged to use <b>AF_INET6</b> for the <i>af</i> parameter and create a dual-mode socket that can be used with both IPv4 and IPv6.
     * 
     * If a socket is created using the <b>WSASocket</b> function, then the <i>dwFlags</i> parameter must have the <b>WSA_FLAG_OVERLAPPED</b> attribute set for the <b>SO_RCVTIMEO</b> or <b>SO_SNDTIMEO</b> socket options to function properly. Otherwise the timeout never takes effect on the socket.
     * 
     * Connection-oriented sockets such as <b>SOCK_STREAM</b> provide full-duplex connections, and must be in a connected state before any data can be sent or received on them. A connection to  a specified socket is established with a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> function call. Once connected, data can be transferred using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> calls. When a session has been completed, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> function should be called to release the resources associated with the socket. For connection-oriented sockets, the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> function should be called to stop data transfer on the socket before calling the <b>closesocket</b> function.
     * 
     * The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, the connection is considered broken and subsequent calls will fail with the error code set to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>.
     * 
     * Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>. If such a socket is connected to a specific peer, datagrams can be sent to that peer using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> and can be received from (only) this peer using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>/<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>.
     * 
     * Support for sockets with type <b>SOCK_RAW</b> is not required, but service providers are encouraged to support raw sockets whenever possible.
     * 
     * The <b>WSASocket</b> function can be used to create a socket to be used by a service so that if another socket tries to bind to the same port used by the service, and audit record is generated. To enable this option, an application would need to do the following:
     * 
     * 
     * <ul>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a> function to enable the <b>SE_SECURITY_NAME</b> privilege in the access token for the process. This privilege is required to set the  <b>ACCESS_SYSTEM_SECURITY</b> access rights on the security descriptor for an object. </li>
     * <li>Call the <b>WSASocket</b> function to create a socket with <i>dwFlag</i> with the <b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b> option set. The <b>WSASocket</b> function will fail if the <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a> function is not called first to enable the <b>SE_SECURITY_NAME</b> privilege needed for this operation.</li>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/aclapi/nf-aclapi-setsecurityinfo">SetSecurityInfo</a> function to set a security descriptor with a System Access Control List (SACL) on the socket. The socket handle returned by the <b>WSASocket</b> function is passed in the <i>handle</i> parameter. If the function succeeds, this will set the the  <b>ACCESS_SYSTEM_SECURITY</b> access right on the security descriptor for the socket.</li>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function to bind the socket to a specific port. If the <b>bind</b> function succeeds, then an audit entry is generated if another socket tries to bind to the same port. </li>
     * <li>Call the <a href="https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-adjusttokenprivileges">AdjustTokenPrivileges</a> function to remove the <b>SE_SECURITY_NAME</b> privilege in the access token for the process, since this is no longer needed. </li>
     * </ul>
     * 
     * 
     * For more information on <b>ACCESS_SYSTEM_SECURITY</b>, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/sacl-access-right">SACL Access Right</a> and <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/audit-generation">Audit Generation</a> in the Authorization documentation.
     * 
     * 
     * <h3><a id="Socket_Groups"></a><a id="socket_groups"></a><a id="SOCKET_GROUPS"></a>Socket Groups</h3>
     * WinSock 2 introduced the notion of a socket group as a means for an application, or cooperating set of applications, to indicate to an underlying service provider that a particular set of sockets are related and that the group thus formed has certain attributes.  Group attributes include relative priorities of the individual sockets within the group and a group quality of service specification. 
     * 
     * Applications that need to exchange multimedia streams over the network are an example where being able to establish a specific relationship among a set of sockets could be beneficial.  It is up to the transport on how to treat socket groups. 
     * 
     * The <b>WSASocket</b> and <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> functions can be used to explicitly create and join a socket group when creating a new socket.  The socket group ID for a socket can be retrieved by using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function with <i>level</i> parameter set to <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET</a> and the <i>optname</i> parameter set to <b>SO_GROUP_ID</b>.  A socket group
     *     and its associated socket group ID remain valid until the last socket belonging to this
     *     socket group is closed. Socket group IDs are unique across all processes
     *     for a given service provider. A socket group of zero indicates that the socket is not member of a socket group.
     * 
     * The relative group priority of  a socket group can be accessed by using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function with the <i>level</i> parameter set to <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET</a> and the <i>optname</i> parameter set to <b>SO_GROUP_PRIORITY</b>. The relative group priority of  a socket group can be set by using <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> with the <i>level</i> parameter set to SOL_SOCKET and the <i>optname</i> parameter set to <b>SO_GROUP_PRIORITY</b>. 
     * 
     * The Winsock provider included with Windows allows the creation of socket groups and it enforces the SG_CONSTRAINED_GROUP. All sockets in a constrained socket group must be created with the same value for the <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.  This is the only restriction applied to a socket group by the Winsock provider included with Windows. The socket group priority is not currently used by the Winsock provider or the TCP/IP stack included with Windows. 
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSASocket</b> function.
     * 
     * 
     * ```cpp
     * @param {Integer} af The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i> header file. 
     * 
     * On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * The values currently supported are AF_INET or AF_INET6, which are the Internet
     *                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The table below lists common values for address family although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>Af</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl>
     * <dt><b>AF_UNSPEC</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family is unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl>
     * <dt><b>AF_IPX</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. 
     * 
     * This address family is not supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
     * <dt><b>AF_APPLETALK</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. 
     * 
     * This address family is not supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
     * <dt><b>AF_NETBIOS</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. 
     * 
     * The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows. 
     * 
     * The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows 7,  Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP.  
     * 
     * The Windows Sockets provider for NetBIOS  only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>.
     * 
     * The Windows Sockets provider for NetBIOS  is not directly related to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/netbios/portal">NetBIOS</a> programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008, and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
     * <dt><b>AF_IRDA</b></dt>
     * <dt>26</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Infrared Data Association (IrDA) address family. 
     * 
     * This address family is only supported if the computer has an infrared port and driver installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
     * <dt><b>AF_BTH</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth address family. 
     * 
     * This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth adapter and driver installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} type The type specification for the new socket. 
     * 
     * 
     * Possible values for the socket type are defined in the <i>Winsock2.h</i> header file.
     * 
     * The following table lists the possible values for the <i>type</i> parameter supported for Windows Sockets 2:
     * 
     * <table>
     * <tr>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
     * <dt><b>SOCK_STREAM</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl>
     * <dt><b>SOCK_DGRAM</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
     * <dt><b>SOCK_RAW</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ip-socket-options">IP_HDRINCL</a> socket option must be set on the socket.  To manipulate the IPv6 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPV6_HDRINCL</a> socket option must be set on the socket.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
     * <dt><b>SOCK_RDM</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as <a href="https://docs.microsoft.com/windows/desktop/WinSock/reliable-multicast-programming--pgm-">reliable multicast programming</a>. 
     * 
     * This <i>type</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
     * <dt><b>SOCK_SEQPACKET</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a pseudo-stream packet based on datagrams. 
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address families, and protocols are defined.
     * 
     * In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b> and <b>SOCK_STREAM</b>.
     * @param {Integer} protocol The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address family and socket type specified. Possible values for the <i>protocol</i> are defined are defined in the  <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. 
     * 
     * On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * If a value of  0 is specified, the caller does not
     *               wish to specify a protocol and the service provider will choose the <i>protocol</i> to use.
     * 
     * 
     * When the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. 
     * 
     * The table below lists common values for the <i>protocol</i> although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>protocol</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
     * <dt><b>IPPROTO_ICMP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl>
     * <dt><b>IPPROTO_IGMP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
     * <dt><b>BTHPROTO_RFCOMM</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. 
     * 
     * This <i>protocol</i> value is supported on Windows XP with SP2 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl>
     * <dt><b>IPPROTO_ICMPV6</b></dt>
     * <dt>58</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b>  and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl>
     * <dt><b>IPPROTO_RM</b></dt>
     * <dt>113</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PGM protocol for reliable multicast. This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK released for Windows Vista and later,  this protocol is also called <b>IPPROTO_PGM</b>. 
     * 
     * This <i>protocol</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that defines the characteristics of the socket to be created. If this parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated 
     * <b>WSAPROTOCOL_INFO</b> structure.
     * @param {Integer} g An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group. 
     * 
     * If <i>g</i> is an existing socket group ID, join the new socket to this
     *             socket group, provided all the requirements set by this group are met. 
     * 
     * If <i>g</i> is not an existing socket group ID, then the following values are possible.
     * 
     * <table>
     * <tr>
     * <th>g</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id=""></a><dl>
     * <dt><b></b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No group operation is performed. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_UNCONSTRAINED_GROUP"></a><a id="sg_unconstrained_group"></a><dl>
     * <dt><b>SG_UNCONSTRAINED_GROUP</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create an unconstrained socket group and have the new socket  be the first member. For an unconstrained group, Winsock does not constrain all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_CONSTRAINED_GROUP"></a><a id="sg_constrained_group"></a><dl>
     * <dt><b>SG_CONSTRAINED_GROUP</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a constrained socket group and have the new socket  be the first member. For a constrained socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.  
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Note</b>  The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are not currently defined in a public header file.</div>
     * <div> </div>
     * @param {Integer} dwFlags A set of flags used to specify additional socket attributes. 
     * 
     * A combination of these flags may be set, although some combinations are not allowed. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_OVERLAPPED"></a><a id="wsa_flag_overlapped"></a><dl>
     * <dt><b>WSA_FLAG_OVERLAPPED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that supports overlapped I/O operations.
     * 
     * Most sockets should be created with this flag set. Overlapped sockets can utilize 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> for overlapped I/O operations, which allow multiple operations to be initiated and in progress simultaneously. 
     * 
     * All functions that allow overlapped operation (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operations are <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_ROOT"></a><a id="wsa_flag_multipoint_c_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_ROOT</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_LEAF"></a><a id="wsa_flag_multipoint_c_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_LEAF</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_ROOT"></a><a id="wsa_flag_multipoint_d_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_ROOT</b></dt>
     * <dt>0x08</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_DATA_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_LEAF"></a><a id="wsa_flag_multipoint_d_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_LEAF</b></dt>
     * <dt>0x10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_DATA_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_ACCESS_SYSTEM_SECURITY"></a><a id="wsa_flag_access_system_security"></a><dl>
     * <dt><b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b></dt>
     * <dt>0x40</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access control list (SACL) as opposed to just a discretionary access control list (DACL).
     * 
     * SACLs are used for generating audits and alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the socket should be allowed to bind to a specific address specified to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function.
     * 
     * The <b>ACCESS_SYSTEM_SECURITY</b> access right controls the ability to get or set the SACL in an object's security descriptor. The system grants this access right only if the <b>SE_SECURITY_NAME</b> privilege is enabled in the access token of the requesting thread.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_NO_HANDLE_INHERIT"></a><a id="wsa_flag_no_handle_inherit"></a><dl>
     * <dt><b>WSA_FLAG_NO_HANDLE_INHERIT</b></dt>
     * <dt>0x80</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that is non-inheritable. 
     * 
     * A socket handle created by the <b>WSASocket</b> or the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function is inheritable by default. When this flag is set, the socket handle is non-inheritable. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-gethandleinformation">GetHandleInformation</a> function can be used to determine if a socket handle was created with the <b>WSA_FLAG_NO_HANDLE_INHERIT</b> flag set. The <b>GetHandleInformation</b> function will return that the <b>HANDLE_FLAG_INHERIT</b> value is set.
     * 
     * This flag is supported on Windows 7 with SP1,  Windows Server 2008 R2 with SP1, and later 
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Important</b>  For multipoint sockets, only one of <b>WSA_FLAG_MULTIPOINT_C_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_C_LEAF</b> flags can be specified, and only  one of <b>WSA_FLAG_MULTIPOINT_D_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_D_LEAF</b> flags can be specified. Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information.</div>
     * <div> </div>
     * @returns {Pointer} If no error occurs, 
     * <b>WSASocket</b> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>  This error code description is Microsoft-specific.</div>
     * <div> </div>
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProtocolInfo</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is true for any of the following conditions. 
     * 
     * 
     * 
     * 
     * <ul>
     * <li>The parameter <i>g</i> specified is not valid.</li>
     * <li>The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that <i>lpProtocolInfo</i> points to is incomplete, the contents are invalid or the 
     * <b>WSAPROTOCOL_INFO</b> structure has already been used in an earlier duplicate socket operation.</li>
     * <li>The values specified for members of the socket triple &lt;<i>af</i>, <i>type</i>, and <i>protocol</i>&gt; are individually supported, but the given combination is not.</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned a version other than 2.2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROCTABLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned an invalid or incomplete procedure table to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wspstartup">WSPStartup</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTOTYPE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is the wrong type for this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROVIDERFAILEDINIT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the provider fails to operate correctly. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified socket type is not supported in this address family.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasocketw
     * @since windows8.1
     */
    static WSASocketW(af, type, protocol, lpProtocolInfo, g, dwFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASocketW", "int", af, "int", type, "int", protocol, "ptr", lpProtocolInfo, "uint", g, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Returns when one or all of the specified event objects are in the signaled state, when the time-out interval expires, or when an I/O completion routine has executed.
     * @remarks
     * The <b>WSAWaitForMultipleEvents</b> function determines whether the wait criteria have been met. If the criteria have not been met, the calling thread enters the wait state. It uses no processor time while waiting for the criteria to be met.
     * 
     * The 
     * <b>WSAWaitForMultipleEvents</b> function returns when any one or all of the specified objects are in the signaled state, or when the time-out interval elapses.
     * 
     * When the <i>bWaitAll</i> parameter is <b>TRUE</b>, the wait operation is completed only when the states of all objects have been set to signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled. 
     * 
     * When <i>bWaitAll</i> parameter is <b>FALSE</b>, <b>WSAWaitForMultipleEvents</b> checks the handles in the <i>lphEvents</i> array in order starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the <i>lphEvents</i> array whose object was signaled.
     * 
     * This function is also used to perform an alertable wait by setting the <i>fAlertable</i> parameter to <b>TRUE</b>. This enables the function to return when the system executes an I/O completion routine by the calling thread.
     * 
     * A thread must be in an alertable wait state in order for the system to execute I/O completion routines (asynchronous procedure calls or APCs). So if an application calls <b>WSAWaitForMultipleEvents</b> when there are pending asynchronous operations that have I/O completion routines and the <i>fAlertable</i> parameter is <b>FALSE</b>, then those I/O completion routines will not be executed even if those I/O operations are completed.
     * 
     * If the <i>fAlertable</i> parameter is <b>TRUE</b> and one of the pending operations completes, the APC is executed and <b>WSAWaitForMultipleEvents</b> will return <b>WSA_IO_COMPLETION</b>.
     * The pending event is not signaled yet. The application must call the <b>WSAWaitForMultipleEvents</b> function again.
     * 
     * Applications that require an alertable wait state without waiting for any event objects to be signaled should use the Windows 
     * <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-sleepex">SleepEx</a> function.
     * 
     * The current implementation of <b>WSAWaitForMultipleEvents</b> calls the <a href="https://docs.microsoft.com/windows/desktop/api/synchapi/nf-synchapi-waitformultipleobjectsex">WaitForMultipleObjectsEx</a> function.
     * 
     * <div class="alert"><b>Note</b>  Use caution when calling the <b>WSAWaitForMultipleEvents</b> with code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses <b>WSAWaitForMultipleEvents</b> with no time-out limit (the <i>dwTimeout</i> parameter set to <b>WSA_INFINITE</b>) may cause the system to become deadlocked.</div>
     * <div> </div>
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following code example shows how to use the <b>WSAWaitForMultipleEvents</b> function.
     * 
     * 
     * ```cpp
     * @param {Integer} cEvents The number of event object handles in the array pointed to by <i>lphEvents</i>. The maximum number of event object handles is <b>WSA_MAXIMUM_WAIT_EVENTS</b>. One or more events must be specified.
     * @param {Pointer<HANDLE>} lphEvents A pointer to an array of event object handles. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle if the <i>fWaitAll</i> parameter is set to <b>TRUE</b>. 
     * If one of these handles is closed while the wait is still pending, the behavior of <b>WSAWaitForMultipleEvents</b> is undefined.
     * 
     * The handles must have the <b>SYNCHRONIZE</b> access right.  For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.
     * @param {Integer} fWaitAll A value that specifies the wait type. If <b>TRUE</b>, the function returns when the state of all objects in the <i>lphEvents</i> array is signaled. If <b>FALSE</b>, the function returns when any  of the event objects is signaled. In the latter case, the return value minus <b>WSA_WAIT_EVENT_0</b> indicates the index of the event object whose state caused the function to return. If more than one event object became signaled during the call, this is the array index to the signaled event object with the smallest index value of all the signaled event objects.
     * @param {Integer} dwTimeout The time-out interval, in milliseconds. <b>WSAWaitForMultipleEvents</b> returns if the time-out interval expires, even if conditions specified by the <i>fWaitAll</i> parameter are not satisfied. If the <i>dwTimeout</i> parameter is zero, <b>WSAWaitForMultipleEvents</b> tests the state of the specified event objects and returns immediately. If <i>dwTimeout</i> is <b>WSA_INFINITE</b>, <b>WSAWaitForMultipleEvents</b> waits forever; that is, the time-out interval never expires.
     * @param {Integer} fAlertable A value that specifies whether the thread is placed in an alertable wait state so the system can execute I/O completion routines. If <b>TRUE</b>, the thread is placed in an alertable wait state and <b>WSAWaitForMultipleEvents</b> can return when the system executes an I/O completion routine. In this case, <b>WSA_WAIT_IO_COMPLETION</b> is returned and the event that was being waited on is not signaled yet. The application must call the <b>WSAWaitForMultipleEvents</b> function again. If <b>FALSE</b>, the thread is not placed in an alertable wait state and I/O completion routines are not executed.
     * @returns {Integer} If the 
     * <b>WSAWaitForMultipleEvents</b> function succeeds,  the return value upon success is one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSA_WAIT_EVENT_0 to (WSA_WAIT_EVENT_0 + cEvents - 1)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>fWaitAll</i> parameter is <b>TRUE</b>, the return value indicates that all specified event objects is signaled. 
     * 
     * If the <i>fWaitAll</i> parameter is <b>FALSE</b>, the return value minus <b>WSA_WAIT_EVENT_0</b> indicates the <i>lphEvents</i> array index of the signaled event object that satisfied the wait. If more than one event object became signaled during the call, the return value indicates the <i>lphEvents</i> array index of the signaled event object with the smallest index value of all the signaled event objects. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSA_WAIT_IO_COMPLETION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The wait was ended by one or more I/O completion routines that were executed. The event that was being waited on is not signaled yet. The application must call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> function again. This return value can only be returned if the <i>fAlertable</i> parameter is <b>TRUE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSA_WAIT_TIMEOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The time-out interval elapsed and the conditions specified by the <i>fWaitAll</i> parameter were not satisfied. No I/O completion routines were executed.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * If the <b>WSAWaitForMultipleEvents</b> function fails, the return value is <b>WSA_WAIT_FAILED</b>. The following table lists values that can be used with <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> to get extended error information. 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>Not enough free memory was available to complete the operation.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></td>
     * <td>One or more of the values in the <i>lphEvents</i> array is not a valid event object handle.</td>
     * </tr>
     * <tr>
     * <td><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></td>
     * <td>The <i>cEvents</i> parameter does not contain a valid handle count.</td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsawaitformultipleevents
     * @since windows8.1
     */
    static WSAWaitForMultipleEvents(cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAWaitForMultipleEvents", "uint", cEvents, "ptr", lphEvents, "int", fWaitAll, "uint", dwTimeout, "int", fAlertable, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts all components of a sockaddr structure into a human-readable string representation of the address. (ANSI)
     * @remarks
     * The 
     * <b>WSAAddressToString</b> function provides a protocol-independent address-to-string translation. The 
     * <b>WSAAddressToString</b> function takes a socket address structure pointed to by the <i>lpsaAddress</i> parameter and returns a pointer to <b>NULL</b>-terminated string that represents the socket address in the <i>lpszAddressString</i> parameter. While the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-inet_ntoa">inet_ntoa</a> function works only with IPv4 addresses, the <b>WSAAddressToString</b> function works with any socket address supported by a Winsock provider on the local computer including IPv6 addresses.
     * 
     * If the <i>lpsaAddress</i> parameter points to an IPv4 socket address (the address family is  <b>AF_INET</b>), then the address string returned in the buffer pointed to by the <i>lpszAddressString</i> parameter is  in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.   
     * 
     * If the <i>lpsaAddress</i> parameter points to an IPv6 socket address (the address family is  <b>AF_INET6</b>), then the address string returned in the buffer pointed to by the <i>lpszAddressString</i> parameter is  in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. 
     * 
     * If the length of the buffer pointed to by the <i>lpszAddressString</i> parameter is not large enough to receive the string representation of the socket address, <b>WSAAddressToString</b> returns 
     * 								<a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>. 
     * 
     * Support for IPv6 addresses using the <b>WSAAddressToString</b> function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the <b>WSAAddressToString</b> function to support IPv6 addresses. 
     * 
     * <b>Windows Phone 8:</b> The <b>WSAAddressToStringW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSAAddressToStringW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAAddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SOCKADDR>} lpsaAddress A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure to translate into a string.
     * @param {Integer} dwAddressLength The length, in bytes, of the address in the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>lpsaAddress</i> parameter. The <i>dwAddressLength</i> parameter may vary in size with different protocols.
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for a particular provider. If this is parameter is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the address family indicated in the <i>lpsaAddress</i> parameter.
     * @param {Pointer<PSTR>} lpszAddressString A pointer to the buffer that receives the human-readable address string.
     * @param {Pointer<UInt32>} lpdwAddressStringLength On input, this parameter specifies the length of the buffer pointed to by the <i>lpszAddressString</i> parameter. The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the string including the <b>NULL</b> terminator actually copied into the buffer pointed to by the <i>lpszAddressString</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaaddresstostringa
     * @deprecated
     * @since windows8.1
     */
    static WSAAddressToStringA(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAAddressToStringA", "ptr", lpsaAddress, "uint", dwAddressLength, "ptr", lpProtocolInfo, "ptr", lpszAddressString, "ptr", lpdwAddressStringLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Converts all components of a sockaddr structure into a human-readable string representation of the address. (Unicode)
     * @remarks
     * The 
     * <b>WSAAddressToString</b> function provides a protocol-independent address-to-string translation. The 
     * <b>WSAAddressToString</b> function takes a socket address structure pointed to by the <i>lpsaAddress</i> parameter and returns a pointer to <b>NULL</b>-terminated string that represents the socket address in the <i>lpszAddressString</i> parameter. While the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-inet_ntoa">inet_ntoa</a> function works only with IPv4 addresses, the <b>WSAAddressToString</b> function works with any socket address supported by a Winsock provider on the local computer including IPv6 addresses.
     * 
     * If the <i>lpsaAddress</i> parameter points to an IPv4 socket address (the address family is  <b>AF_INET</b>), then the address string returned in the buffer pointed to by the <i>lpszAddressString</i> parameter is  in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.   
     * 
     * If the <i>lpsaAddress</i> parameter points to an IPv6 socket address (the address family is  <b>AF_INET6</b>), then the address string returned in the buffer pointed to by the <i>lpszAddressString</i> parameter is  in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. 
     * 
     * If the length of the buffer pointed to by the <i>lpszAddressString</i> parameter is not large enough to receive the string representation of the socket address, <b>WSAAddressToString</b> returns 
     * 								<a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>. 
     * 
     * Support for IPv6 addresses using the <b>WSAAddressToString</b> function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the <b>WSAAddressToString</b> function to support IPv6 addresses. 
     * 
     * <b>Windows Phone 8:</b> The <b>WSAAddressToStringW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSAAddressToStringW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAAddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<SOCKADDR>} lpsaAddress A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure to translate into a string.
     * @param {Integer} dwAddressLength The length, in bytes, of the address in the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>lpsaAddress</i> parameter. The <i>dwAddressLength</i> parameter may vary in size with different protocols.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for a particular provider. If this is parameter is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the address family indicated in the <i>lpsaAddress</i> parameter.
     * @param {Pointer<PWSTR>} lpszAddressString A pointer to the buffer that receives the human-readable address string.
     * @param {Pointer<UInt32>} lpdwAddressStringLength On input, this parameter specifies the length of the buffer pointed to by the <i>lpszAddressString</i> parameter. The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the string including the <b>NULL</b> terminator actually copied into the buffer pointed to by the <i>lpszAddressString</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaaddresstostringw
     * @since windows8.1
     */
    static WSAAddressToStringW(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAAddressToStringW", "ptr", lpsaAddress, "uint", dwAddressLength, "ptr", lpProtocolInfo, "ptr", lpszAddressString, "ptr", lpdwAddressStringLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAStringToAddress function converts a network address in its standard text presentation form into its numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure. (ANSI)
     * @remarks
     * The 
     * <b>WSAStringToAddress</b> function converts a network address in standard text   form into its numeric binary form in a <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure.
     * 
     * Any missing components of the address will be defaulted to a reasonable value, if possible. For example, a missing port number will default to zero. If the caller wants the translation to be done by a particular provider, it should supply the corresponding 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure in the <i>lpProtocolInfo</i> parameter.
     * 
     * The 
     * <b>WSAStringToAddress</b> function fails (and returns WSAEINVAL) if the <b>sin_family</b> member of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR_IN</a> structure, which is passed in the <i>lpAddress</i> parameter in the form of a 
     * <b>sockaddr</b> structure, is not set to AF_INET or AF_INET6. 
     * 
     * Support for IPv6 addresses using the <b>WSAStringToAddress</b> function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the <b>WSAStringToAddress</b> function to support IPv6 addresses. 
     * 
     * <b>Windows Phone 8:</b> This  function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAStringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} AddressString A pointer to the zero-terminated string that contains the network address in standard text form to convert.
     * @param {Integer} AddressFamily The address family of the network address pointed to by the <i>AddressString</i> parameter.
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure associated with the provider to be used. If this is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the indicated <i>AddressFamily</i>.
     * @param {Pointer<SOCKADDR>} lpAddress A pointer to a buffer that is filled with a  <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the address string if the function succeeds.
     * @param {Pointer<Int32>} lpAddressLength A pointer to the length, in bytes, of the buffer pointed to by the <i>lpAddress</i> parameter. If the function call is successful, this parameter returns a pointer to the size of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure returned in the <i>lpAddress</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size in bytes.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsastringtoaddressa
     * @deprecated
     * @since windows8.1
     */
    static WSAStringToAddressA(AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAStringToAddressA", "ptr", AddressString, "int", AddressFamily, "ptr", lpProtocolInfo, "ptr", lpAddress, "ptr", lpAddressLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAStringToAddress function converts a network address in its standard text presentation form into its numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure. (Unicode)
     * @remarks
     * The 
     * <b>WSAStringToAddress</b> function converts a network address in standard text   form into its numeric binary form in a <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure.
     * 
     * Any missing components of the address will be defaulted to a reasonable value, if possible. For example, a missing port number will default to zero. If the caller wants the translation to be done by a particular provider, it should supply the corresponding 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure in the <i>lpProtocolInfo</i> parameter.
     * 
     * The 
     * <b>WSAStringToAddress</b> function fails (and returns WSAEINVAL) if the <b>sin_family</b> member of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR_IN</a> structure, which is passed in the <i>lpAddress</i> parameter in the form of a 
     * <b>sockaddr</b> structure, is not set to AF_INET or AF_INET6. 
     * 
     * Support for IPv6 addresses using the <b>WSAStringToAddress</b> function was added on Windows XP with Service Pack 1 (SP1)and later. IPv6 must also be installed on the local computer for the <b>WSAStringToAddress</b> function to support IPv6 addresses. 
     * 
     * <b>Windows Phone 8:</b> This  function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAStringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} AddressString A pointer to the zero-terminated string that contains the network address in standard text form to convert.
     * @param {Integer} AddressFamily The address family of the network address pointed to by the <i>AddressString</i> parameter.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure associated with the provider to be used. If this is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the indicated <i>AddressFamily</i>.
     * @param {Pointer<SOCKADDR>} lpAddress A pointer to a buffer that is filled with a  <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the address string if the function succeeds.
     * @param {Pointer<Int32>} lpAddressLength A pointer to the length, in bytes, of the buffer pointed to by the <i>lpAddress</i> parameter. If the function call is successful, this parameter returns a pointer to the size of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure returned in the <i>lpAddress</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size in bytes.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsastringtoaddressw
     * @since windows8.1
     */
    static WSAStringToAddressW(AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAStringToAddressW", "ptr", AddressString, "int", AddressFamily, "ptr", lpProtocolInfo, "ptr", lpAddress, "ptr", lpAddressLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSALookupServiceBegin function initiates a client query that is constrained by the information contained within a WSAQUERYSET structure. (ANSI)
     * @remarks
     * The <i>lpqsRestrictions</i> parameter points to a buffer containing a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure. At a minimum, the <b>dwSize</b> member of the <b>WSAQUERYSET</b> must be set to the length of the buffer before calling the 
     * <b>WSALookupServiceBegin</b> function. Applications can restrict the query by specifying other members in the <b>WSAQUERYSET</b>. 
     * 
     * In most instances, applications interested in only a particular transport protocol should constrain their query by address family and protocol using the <b>dwNumberOfProtocols</b> and <b>lpafpProtocols</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> rather than by specifiying the namespace in the <b>dwNameSpace</b> member. 
     * 
     * Information on supported network transport protocols can be retreived using the <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/nf-nspapi-enumprotocolsa">EnumProtocols</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a>, <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>, or  <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> function.
     * 
     * It is also possible to constrain the query to a single namespace. For example, a query that only wants results from DNS (not results from the local hosts file and other naming services) would set the <b>dwNameSpace</b> member to NS_DNS. For example, a bluetooth device discovery would set the the <b>dwNameSpace</b> member to NS_BTH. 
     * 
     * Applications can also restrict the query to a specific namespace provider by specifying a pointer to the GUID for the provider in the <b>lpNSProviderId</b> member. 
     * 
     * Information on namespace providers on the local computer can be retrieved using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa">WSAEnumNameSpaceProvidersEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceproviders32">WSCEnumNameSpaceProviders32</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceprovidersex32">WSCEnumNameSpaceProvidersEx32</a> function. 
     * 
     * If LUP_CONTAINERS is specified in a call, other restriction values should be avoided. If any are specified, it is up to the name service provider to decide if it can support this restriction over the containers. If it cannot, it should return an error.
     * 
     * Some name service providers can have other means of finding containers. For example, containers might all be of some well-known type, or of a set of well-known types, and therefore a query restriction can be created for finding them. No matter what other means the name service provider has for locating containers, LUP_CONTAINERS and LUP_NOCONTAINERS take precedence. Hence, if a query restriction is given that includes containers, specifying LUP_NOCONTAINERS will prevent the container items from being returned. Similarly, no matter the query restriction, if LUP_CONTAINERS is given, only containers should be returned. If a namespace does not support containers, and LUP_CONTAINERS is specified, it should simply return <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a>.
     * 
     * The preferred method of obtaining the containers within another container, is the call:
     * 
     * 
     * ```cpp
     * dwStatus = WSALookupServiceBegin(
     *       lpqsRestrictions,
     *       LUP_CONTAINERS,
     *       lphLookup);
     * 
     * ```
     * 
     * 
     * This call is followed by the requisite number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> calls. This will return all containers contained immediately within the starting context; that is, it is not a deep query. With this, one can map the address space structure by walking the hierarchy, perhaps enumerating the content of selected containers. Subsequent uses of 
     * <b>WSALookupServiceBegin</b> use the containers returned from a previous call.
     * 
     * As mentioned above, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure is used as an input parameter to <b>WSALookupBegin</b> in order to qualify the query. The following table indicates how the 
     * <b>WSAQUERYSET</b> is used to construct a query. When a parameter is marked as (Optional) a <b>NULL</b> pointer can be specified, indicating that the parameter will not be used as a search criteria. See section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/name-resolution-data-structures-2">Query-Related Data Structures</a> for additional information.
     * 
     * <table>
     * <tr>
     * <th>WSAQUERYSET member</th>
     * <th>Query interpretation</th>
     * </tr>
     * <tr>
     * <td><b>dwSize</b></td>
     * <td>Must be set to sizeof(<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a>). This is a versioning mechanism.</td>
     * </tr>
     * <tr>
     * <td><b>dwOutputFlags</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td><b>lpszServiceInstanceName</b></td>
     * <td>(Optional) Referenced string contains service name. The semantics for wildcarding within the string are not defined, but can be supported by certain namespace providers.</td>
     * </tr>
     * <tr>
     * <td><b>lpServiceClassId</b></td>
     * <td>(Required) The GUID corresponding to the service class.</td>
     * </tr>
     * <tr>
     * <td><b>lpVersion</b></td>
     * <td>(Optional) References desired version number and provides version comparison semantics (that is, version must match exactly, or version must be not less than the value specified).</td>
     * </tr>
     * <tr>
     * <td><b>lpszComment</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>dwNameSpace</b>
     * 
     * See the Important note that follows.
     * 
     * </td>
     * <td>Identifier of a single namespace in which to constrain the search, or NS_ALL to include all namespaces.</td>
     * </tr>
     * <tr>
     * <td><b>lpNSProviderId</b></td>
     * <td>(Optional) References the GUID of a specific namespace provider, and limits the query to this provider only.</td>
     * </tr>
     * <tr>
     * <td><b>lpszContext</b></td>
     * <td>(Optional) Specifies the starting point of the query in a hierarchical namespace.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfProtocols</b></td>
     * <td>Size of the protocol constraint array, can be zero.</td>
     * </tr>
     * <tr>
     * <td><b>lpafpProtocols</b></td>
     * <td>(Optional) References an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-afprotocols">AFPROTOCOLS</a> structure. Only services that utilize these protocols will be returned.</td>
     * </tr>
     * <tr>
     * <td><b>lpszQueryString</b></td>
     * <td>(Optional) Some namespaces (such as whois++) support enriched SQL-like queries that are contained in a simple text string. This parameter is used to specify that string.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfCsAddrs</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td><b>lpcsaBuffer</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td><b>lpBlob</b></td>
     * <td>(Optional) This is a pointer to a provider-specific entity.</td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Important</b>  In most instances, applications interested in only a particular transport protocol should constrain their query by address family and protocol rather than by namespace. This would allow an application that needs to locate a TCP/IP service, for example, to have its query processed by all available namespaces such as the local hosts file, DNS, and NIS.</div>
     * <div> </div>
     * <b>Windows Phone 8:</b> The <b>WSALookupServiceBeginW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSALookupServiceBeginW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSALookupServiceBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<WSAQUERYSETA>} lpqsRestrictions A pointer to the search criteria. See the Remarks for details.
     * @param {Integer} dwControlFlags A set of flags that controls the depth of the search.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HANDLE>} lphLookup A  handle to be used when calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> in order to start retrieving the results set.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsalookupservicebegina
     * @deprecated
     * @since windows8.1
     */
    static WSALookupServiceBeginA(lpqsRestrictions, dwControlFlags, lphLookup) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSALookupServiceBeginA", "ptr", lpqsRestrictions, "uint", dwControlFlags, "ptr", lphLookup)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSALookupServiceBegin function initiates a client query that is constrained by the information contained within a WSAQUERYSET structure. (Unicode)
     * @remarks
     * The <i>lpqsRestrictions</i> parameter points to a buffer containing a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure. At a minimum, the <b>dwSize</b> member of the <b>WSAQUERYSET</b> must be set to the length of the buffer before calling the 
     * <b>WSALookupServiceBegin</b> function. Applications can restrict the query by specifying other members in the <b>WSAQUERYSET</b>. 
     * 
     * In most instances, applications interested in only a particular transport protocol should constrain their query by address family and protocol using the <b>dwNumberOfProtocols</b> and <b>lpafpProtocols</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> rather than by specifiying the namespace in the <b>dwNameSpace</b> member. 
     * 
     * Information on supported network transport protocols can be retreived using the <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/nf-nspapi-enumprotocolsa">EnumProtocols</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a>, <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>, or  <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a> function.
     * 
     * It is also possible to constrain the query to a single namespace. For example, a query that only wants results from DNS (not results from the local hosts file and other naming services) would set the <b>dwNameSpace</b> member to NS_DNS. For example, a bluetooth device discovery would set the the <b>dwNameSpace</b> member to NS_BTH. 
     * 
     * Applications can also restrict the query to a specific namespace provider by specifying a pointer to the GUID for the provider in the <b>lpNSProviderId</b> member. 
     * 
     * Information on namespace providers on the local computer can be retrieved using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa">WSAEnumNameSpaceProvidersEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceproviders32">WSCEnumNameSpaceProviders32</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceprovidersex32">WSCEnumNameSpaceProvidersEx32</a> function. 
     * 
     * If LUP_CONTAINERS is specified in a call, other restriction values should be avoided. If any are specified, it is up to the name service provider to decide if it can support this restriction over the containers. If it cannot, it should return an error.
     * 
     * Some name service providers can have other means of finding containers. For example, containers might all be of some well-known type, or of a set of well-known types, and therefore a query restriction can be created for finding them. No matter what other means the name service provider has for locating containers, LUP_CONTAINERS and LUP_NOCONTAINERS take precedence. Hence, if a query restriction is given that includes containers, specifying LUP_NOCONTAINERS will prevent the container items from being returned. Similarly, no matter the query restriction, if LUP_CONTAINERS is given, only containers should be returned. If a namespace does not support containers, and LUP_CONTAINERS is specified, it should simply return <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a>.
     * 
     * The preferred method of obtaining the containers within another container, is the call:
     * 
     * 
     * ```cpp
     * dwStatus = WSALookupServiceBegin(
     *       lpqsRestrictions,
     *       LUP_CONTAINERS,
     *       lphLookup);
     * 
     * ```
     * 
     * 
     * This call is followed by the requisite number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> calls. This will return all containers contained immediately within the starting context; that is, it is not a deep query. With this, one can map the address space structure by walking the hierarchy, perhaps enumerating the content of selected containers. Subsequent uses of 
     * <b>WSALookupServiceBegin</b> use the containers returned from a previous call.
     * 
     * As mentioned above, a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure is used as an input parameter to <b>WSALookupBegin</b> in order to qualify the query. The following table indicates how the 
     * <b>WSAQUERYSET</b> is used to construct a query. When a parameter is marked as (Optional) a <b>NULL</b> pointer can be specified, indicating that the parameter will not be used as a search criteria. See section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/name-resolution-data-structures-2">Query-Related Data Structures</a> for additional information.
     * 
     * <table>
     * <tr>
     * <th>WSAQUERYSET member</th>
     * <th>Query interpretation</th>
     * </tr>
     * <tr>
     * <td><b>dwSize</b></td>
     * <td>Must be set to sizeof(<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a>). This is a versioning mechanism.</td>
     * </tr>
     * <tr>
     * <td><b>dwOutputFlags</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td><b>lpszServiceInstanceName</b></td>
     * <td>(Optional) Referenced string contains service name. The semantics for wildcarding within the string are not defined, but can be supported by certain namespace providers.</td>
     * </tr>
     * <tr>
     * <td><b>lpServiceClassId</b></td>
     * <td>(Required) The GUID corresponding to the service class.</td>
     * </tr>
     * <tr>
     * <td><b>lpVersion</b></td>
     * <td>(Optional) References desired version number and provides version comparison semantics (that is, version must match exactly, or version must be not less than the value specified).</td>
     * </tr>
     * <tr>
     * <td><b>lpszComment</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td>
     * <b>dwNameSpace</b>
     * 
     * See the Important note that follows.
     * 
     * </td>
     * <td>Identifier of a single namespace in which to constrain the search, or NS_ALL to include all namespaces.</td>
     * </tr>
     * <tr>
     * <td><b>lpNSProviderId</b></td>
     * <td>(Optional) References the GUID of a specific namespace provider, and limits the query to this provider only.</td>
     * </tr>
     * <tr>
     * <td><b>lpszContext</b></td>
     * <td>(Optional) Specifies the starting point of the query in a hierarchical namespace.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfProtocols</b></td>
     * <td>Size of the protocol constraint array, can be zero.</td>
     * </tr>
     * <tr>
     * <td><b>lpafpProtocols</b></td>
     * <td>(Optional) References an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-afprotocols">AFPROTOCOLS</a> structure. Only services that utilize these protocols will be returned.</td>
     * </tr>
     * <tr>
     * <td><b>lpszQueryString</b></td>
     * <td>(Optional) Some namespaces (such as whois++) support enriched SQL-like queries that are contained in a simple text string. This parameter is used to specify that string.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfCsAddrs</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td><b>lpcsaBuffer</b></td>
     * <td>Ignored for queries.</td>
     * </tr>
     * <tr>
     * <td><b>lpBlob</b></td>
     * <td>(Optional) This is a pointer to a provider-specific entity.</td>
     * </tr>
     * </table>
     *  
     * 
     * <div class="alert"><b>Important</b>  In most instances, applications interested in only a particular transport protocol should constrain their query by address family and protocol rather than by namespace. This would allow an application that needs to locate a TCP/IP service, for example, to have its query processed by all available namespaces such as the local hosts file, DNS, and NIS.</div>
     * <div> </div>
     * <b>Windows Phone 8:</b> The <b>WSALookupServiceBeginW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSALookupServiceBeginW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSALookupServiceBegin as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<WSAQUERYSETW>} lpqsRestrictions A pointer to the search criteria. See the Remarks for details.
     * @param {Integer} dwControlFlags A set of flags that controls the depth of the search.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HANDLE>} lphLookup A  handle to be used when calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> in order to start retrieving the results set.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsalookupservicebeginw
     * @since windows8.1
     */
    static WSALookupServiceBeginW(lpqsRestrictions, dwControlFlags, lphLookup) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSALookupServiceBeginW", "ptr", lpqsRestrictions, "uint", dwControlFlags, "ptr", lphLookup)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSALookupServiceNext function is called after obtaining a handle from a previous call to WSALookupServiceBegin in order to retrieve the requested service information. (ANSI)
     * @remarks
     * The <i>dwControlFlags</i> parameter specified in this function and the ones specified at the time of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> are treated as restrictions for the purpose of combination. The restrictions are combined between the ones at 
     * <b>WSALookupServiceBegin</b> time and the ones at 
     * <b>WSALookupServiceNext</b> time. Therefore the flags at 
     * <b>WSALookupServiceNext</b> can never increase the amount of data returned beyond what was requested at 
     * <b>WSALookupServiceBegin</b>, although it is not an error to specify more or fewer flags. The flags specified at a given 
     * <b>WSALookupServiceNext</b> apply only to that call.
     * 
     * The <i>dwControlFlags</i> LUP_FLUSHPREVIOUS and LUP_RES_SERVICE are exceptions to the combined restrictions rule (because they are behavior flags instead of restriction flags). If either of these flags are used in 
     * <b>WSALookupServiceNext</b> they have their defined effect regardless of the setting of the same flags at 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * 
     * For example, if LUP_RETURN_VERSION is specified at 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> the service provider retrieves records including the version. If LUP_RETURN_VERSION is NOT specified at 
     * <b>WSALookupServiceNext</b>, the returned information does not include the version, even though it was available. No error is generated.
     * 
     * Also for example, if LUP_RETURN_BLOB is NOT specified at 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> but is specified at 
     * <b>WSALookupServiceNext</b>, the returned information does not include the private data. No error is generated.
     * 
     * If the <b>WSALookupServiceNext</b> function fails with an error of 
     * 								<a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, this indicates that the buffer pointed to by the <i>lpqsResults</i> parameter was too small to contain the query results. A new buffer for a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> should be provided with a size specified by the value pointed to by  the <i>lpdwBufferLength</i> parameter. This new buffer for the <b>WSAQUERYSET</b> needs to have some of the members of the <b>WSAQUERYSET</b> specified before calling the <b>WSALookupServiceNext</b> function again. At a minimum, the <b>dwSize</b> member of the <b>WSAQUERYSET</b> must be set to the new size of the buffer.
     * 
     * <h3><a id="Query_Results"></a><a id="query_results"></a><a id="QUERY_RESULTS"></a>Query Results</h3>
     * The following table describes how the query results are represented in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure.
     * 
     * <table>
     * <tr>
     * <th>WSAQUERYSET member</th>
     * <th>Result interpretation</th>
     * </tr>
     * <tr>
     * <td><b>dwSize</b></td>
     * <td>Will be set to sizeof(
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a>). This is used as a versioning mechanism.</td>
     * </tr>
     * <tr>
     * <td><b>dwOutputFlags</b></td>
     * <td>RESULT_IS_ALIAS flag indicates this is an alias result.</td>
     * </tr>
     * <tr>
     * <td><b>lpszServiceInstanceName</b></td>
     * <td>Referenced string contains service name.</td>
     * </tr>
     * <tr>
     * <td><b>lpServiceClassId</b></td>
     * <td>The GUID corresponding to the service class.</td>
     * </tr>
     * <tr>
     * <td><b>lpVersion</b></td>
     * <td>References version number of the particular service instance.</td>
     * </tr>
     * <tr>
     * <td><b>lpszComment</b></td>
     * <td>Optional comment string specified by service instance.</td>
     * </tr>
     * <tr>
     * <td><b>dwNameSpace</b></td>
     * <td>Namespace in which the service instance was found.</td>
     * </tr>
     * <tr>
     * <td><b>lpNSProviderId</b></td>
     * <td>Identifies the specific namespace provider that supplied this query result.</td>
     * </tr>
     * <tr>
     * <td><b>lpszContext</b></td>
     * <td>Specifies the context point in a hierarchical namespace at which the service is located.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfProtocols</b></td>
     * <td>Undefined for results.</td>
     * </tr>
     * <tr>
     * <td><b>lpafpProtocols</b></td>
     * <td>Undefined for results, all needed protocol information is in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures.</td>
     * </tr>
     * <tr>
     * <td><b>lpszQueryString</b></td>
     * <td>When <i>dwControlFlags</i> includes LUP_RETURN_QUERY_STRING, this parameter returns the unparsed remainder of the <i>lpszServiceInstanceName</i> specified in the original query. For example, in a namespace that identifies services by hierarchical names that specify a host name and a file path within that host, the address returned might be the host address and the unparsed remainder might be the file path. If the <i>lpszServiceInstanceName</i> is fully parsed and LUP_RETURN_QUERY_STRING is used, this parameter is <b>NULL</b> or points to a zero-length string.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfCsAddrs</b></td>
     * <td>Indicates the number of elements in the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures.</td>
     * </tr>
     * <tr>
     * <td><b>lpcsaBuffer</b></td>
     * <td>A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures, with one complete transport address contained within each element.</td>
     * </tr>
     * <tr>
     * <td><b>lpBlob</b></td>
     * <td>(Optional) This is a pointer to a provider-specific entity.</td>
     * </tr>
     * </table>
     *  
     * 
     * <b>Windows Phone 8:</b> The <b>WSALookupServiceNextW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSALookupServiceNextW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSALookupServiceNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HANDLE>} hLookup A handle returned from the previous call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * @param {Integer} dwControlFlags A set of flags that controls the operation. The values passed in the <i>dwControlFlags</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function determine the possible criteria. Any values passed in the <i>dwControlFlags</i> parameter to the <b>WSALookupServiceNext</b> function further restrict the criteria for the service lookup. 
     * 
     * Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result set—which was too large—and move on to the next set for this call.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <b>WSALookupServiceNext</b>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <b>WSALookupServiceNext</b>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, then it contains the minimum number of bytes to pass for the <i>lpqsResults</i> to retrieve the record.
     * @param {Pointer<WSAQUERYSETA>} lpqsResults A pointer to a block of memory, which will contain one result set in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure on return.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsalookupservicenexta
     * @deprecated
     * @since windows8.1
     */
    static WSALookupServiceNextA(hLookup, dwControlFlags, lpdwBufferLength, lpqsResults) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSALookupServiceNextA", "ptr", hLookup, "uint", dwControlFlags, "ptr", lpdwBufferLength, "ptr", lpqsResults)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSALookupServiceNext function is called after obtaining a handle from a previous call to WSALookupServiceBegin in order to retrieve the requested service information. (Unicode)
     * @remarks
     * The <i>dwControlFlags</i> parameter specified in this function and the ones specified at the time of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> are treated as restrictions for the purpose of combination. The restrictions are combined between the ones at 
     * <b>WSALookupServiceBegin</b> time and the ones at 
     * <b>WSALookupServiceNext</b> time. Therefore the flags at 
     * <b>WSALookupServiceNext</b> can never increase the amount of data returned beyond what was requested at 
     * <b>WSALookupServiceBegin</b>, although it is not an error to specify more or fewer flags. The flags specified at a given 
     * <b>WSALookupServiceNext</b> apply only to that call.
     * 
     * The <i>dwControlFlags</i> LUP_FLUSHPREVIOUS and LUP_RES_SERVICE are exceptions to the combined restrictions rule (because they are behavior flags instead of restriction flags). If either of these flags are used in 
     * <b>WSALookupServiceNext</b> they have their defined effect regardless of the setting of the same flags at 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * 
     * For example, if LUP_RETURN_VERSION is specified at 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> the service provider retrieves records including the version. If LUP_RETURN_VERSION is NOT specified at 
     * <b>WSALookupServiceNext</b>, the returned information does not include the version, even though it was available. No error is generated.
     * 
     * Also for example, if LUP_RETURN_BLOB is NOT specified at 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> but is specified at 
     * <b>WSALookupServiceNext</b>, the returned information does not include the private data. No error is generated.
     * 
     * If the <b>WSALookupServiceNext</b> function fails with an error of 
     * 								<a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, this indicates that the buffer pointed to by the <i>lpqsResults</i> parameter was too small to contain the query results. A new buffer for a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> should be provided with a size specified by the value pointed to by  the <i>lpdwBufferLength</i> parameter. This new buffer for the <b>WSAQUERYSET</b> needs to have some of the members of the <b>WSAQUERYSET</b> specified before calling the <b>WSALookupServiceNext</b> function again. At a minimum, the <b>dwSize</b> member of the <b>WSAQUERYSET</b> must be set to the new size of the buffer.
     * 
     * <h3><a id="Query_Results"></a><a id="query_results"></a><a id="QUERY_RESULTS"></a>Query Results</h3>
     * The following table describes how the query results are represented in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure.
     * 
     * <table>
     * <tr>
     * <th>WSAQUERYSET member</th>
     * <th>Result interpretation</th>
     * </tr>
     * <tr>
     * <td><b>dwSize</b></td>
     * <td>Will be set to sizeof(
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a>). This is used as a versioning mechanism.</td>
     * </tr>
     * <tr>
     * <td><b>dwOutputFlags</b></td>
     * <td>RESULT_IS_ALIAS flag indicates this is an alias result.</td>
     * </tr>
     * <tr>
     * <td><b>lpszServiceInstanceName</b></td>
     * <td>Referenced string contains service name.</td>
     * </tr>
     * <tr>
     * <td><b>lpServiceClassId</b></td>
     * <td>The GUID corresponding to the service class.</td>
     * </tr>
     * <tr>
     * <td><b>lpVersion</b></td>
     * <td>References version number of the particular service instance.</td>
     * </tr>
     * <tr>
     * <td><b>lpszComment</b></td>
     * <td>Optional comment string specified by service instance.</td>
     * </tr>
     * <tr>
     * <td><b>dwNameSpace</b></td>
     * <td>Namespace in which the service instance was found.</td>
     * </tr>
     * <tr>
     * <td><b>lpNSProviderId</b></td>
     * <td>Identifies the specific namespace provider that supplied this query result.</td>
     * </tr>
     * <tr>
     * <td><b>lpszContext</b></td>
     * <td>Specifies the context point in a hierarchical namespace at which the service is located.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfProtocols</b></td>
     * <td>Undefined for results.</td>
     * </tr>
     * <tr>
     * <td><b>lpafpProtocols</b></td>
     * <td>Undefined for results, all needed protocol information is in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures.</td>
     * </tr>
     * <tr>
     * <td><b>lpszQueryString</b></td>
     * <td>When <i>dwControlFlags</i> includes LUP_RETURN_QUERY_STRING, this parameter returns the unparsed remainder of the <i>lpszServiceInstanceName</i> specified in the original query. For example, in a namespace that identifies services by hierarchical names that specify a host name and a file path within that host, the address returned might be the host address and the unparsed remainder might be the file path. If the <i>lpszServiceInstanceName</i> is fully parsed and LUP_RETURN_QUERY_STRING is used, this parameter is <b>NULL</b> or points to a zero-length string.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfCsAddrs</b></td>
     * <td>Indicates the number of elements in the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures.</td>
     * </tr>
     * <tr>
     * <td><b>lpcsaBuffer</b></td>
     * <td>A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures, with one complete transport address contained within each element.</td>
     * </tr>
     * <tr>
     * <td><b>lpBlob</b></td>
     * <td>(Optional) This is a pointer to a provider-specific entity.</td>
     * </tr>
     * </table>
     *  
     * 
     * <b>Windows Phone 8:</b> The <b>WSALookupServiceNextW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSALookupServiceNextW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSALookupServiceNext as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<HANDLE>} hLookup A handle returned from the previous call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * @param {Integer} dwControlFlags A set of flags that controls the operation. The values passed in the <i>dwControlFlags</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function determine the possible criteria. Any values passed in the <i>dwControlFlags</i> parameter to the <b>WSALookupServiceNext</b> function further restrict the criteria for the service lookup. 
     * 
     * Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result set—which was too large—and move on to the next set for this call.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <b>WSALookupServiceNext</b>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <b>WSALookupServiceNext</b>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, then it contains the minimum number of bytes to pass for the <i>lpqsResults</i> to retrieve the record.
     * @param {Pointer<WSAQUERYSETW>} lpqsResults A pointer to a block of memory, which will contain one result set in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure on return.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsalookupservicenextw
     * @since windows8.1
     */
    static WSALookupServiceNextW(hLookup, dwControlFlags, lpdwBufferLength, lpqsResults) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSALookupServiceNextW", "ptr", hLookup, "uint", dwControlFlags, "ptr", lpdwBufferLength, "ptr", lpqsResults)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Enables developers to make I/O control calls to a registered namespace.
     * @remarks
     * The 
     * <b>WSANSPIoctl</b> function is used to set or retrieve operating parameters associated with a query handle to a namespace provider. The <i>hLookup</i> parameter is a handle to the namespace provider query previously returned by 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function (not  a socket handle).
     * 
     * Any IOCTL sent to a namespace provider may block indefinitely, depending upon the implementation of the namespace. If an application cannot tolerate blocking in a 
     * <b>WSANSPIoctl</b> function call, overlapped I/O should be used and the <i>lpCompletion</i> parameter should point to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsacompletion">WSACOMPLETION</a> structure. To make a 
     * <b>WSANSPIoctl</b> function call nonblocking and return immediately, set the <b>Type</b> member of the <b>WSACOMPLETION</b> structure to <b>NSP_NOTIFY_IMMEDIATELY</b>.
     * 
     *  If <i>lpCompletion</i> is <b>NULL</b>, the 
     * <b>WSANSPIoctl</b> function executes as a blocking call. The namespace provider should return immediately and should not block. But each namespace is responsible for enforcing this behavior. 
     * 
     * The following IOCTL code is supported by several Microsoft name space provider:
     * 
     * <dl>
     * <dt><a id="SIO_NSP_NOTIFY_CHANGE"></a><a id="sio_nsp_notify_change"></a><b>SIO_NSP_NOTIFY_CHANGE</b></dt>
     * <dd>
     * This operation checks if the results returned with previous calls using the <i>hLookup</i> parameter are still valid.  These previous calls include the initial call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function to retrieve the <i>hLookup</i> parameter.  These previous calls may also include calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> function using the <i>hLookup</i> parameter. 
     * 
     * The Microsoft namespace providers that support this IOCTL include the following<ul>
     * <li>NS_NLA - The Network Location Awareness (NLA) namespace provider.</li>
     * <li>NS_PNRPNAME - The Peer Name Resolution Protocol (PNRP) namespace provider.</li>
     * <li>NS_PNRPCLOUD - The Peer Name Resolution Protocol (PNRP) cloud namespace provider.</li>
     * </ul>
     * 
     * 
     * Other non-Microsoft namespace providers may be installed that also support this IOCTL.
     * 
     * When the <i>lpCompletion</i> parameter is <b>NULL</b>, this IOCTL implements a  special behavior. If the <i>lpCompletion</i> parameter is <b>NULL</b> for this IOCTL, this operation is a poll and returns immediately. If the query set remains valid, 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> is returned as notification that the query set remains valid. If the query set has changed and is invalid, <b>NO_ERROR</b> is returned indicating success in polling for invalidation of the query set. 
     * 
     * If the <i>lpCompletion</i> parameter is not <b>NULL</b> and points to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsacompletion">WSACOMPLETION</a> structure, then the  <b>WSANSPIoctl</b> function returns <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a> if the  overlapped operation was successfully initiated and completion will be indicated at a later time. The method specified in the <b>WSACOMPLETION</b> structure is used to notify the application if the query set is still valid. 
     * 
     * Not all name resolution protocols are able to support this feature, and therefore, this function call may fail with 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a>. A query containing data from multiple providers cannot call this IOCTL, and will return 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a>.
     * 
     * The <i>lpvInBuffer</i>, <i>cbInBuffer</i>, <i>lpvOutBuffer</i>, and <i>cbOutBuffer</i> parameters are currently ignored by Microsoft namespace providers.
     * 
     * For single-threaded applications, a typical method to use the <b>WSANSPIoctl</b> function is as follows. Call the <b>WSANSPIoctl</b> function with the <i>dwControlCode</i> parameter set to <b>SIO_NSP_NOTIFY_CHANGE</b> with no completion routine (the <i>lpCompletion</i> parameter set to <b>NULL</b>) after every <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> function  call to make sure the query data is still valid. If the data becomes invalid, call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupserviceend">WSALookupServiceEnd</a> function to close the query handle. Call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function to retrieve a new query handle and begin the query again.
     * 
     * For multi-threaded applications, a typical method to use the <b>WSANSPIoctl</b> function is as follows. Call the <b>WSANSPIoctl</b> function with the <i>dwControlCode</i> parameter set to <b>SIO_NSP_NOTIFY_CHANGE</b> with a completion routine after the initial call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function. The application would use the mechanism for notification specified in the completion routine to be notified when data is no longer valid. One common mechanism is to use an event specified in the completion routine. If the data becomes invalid, call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupserviceend">WSALookupServiceEnd</a> function to close the query handle. Call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> and the <b>WSANSPIoctl</b> functions to retrieve a new query handle and begin the query again.
     * 
     * Some protocols may simply cache the information locally and invalidate it after some time, in which case notification may be issued to indicate the local cache has been invalidated.
     * 
     * For name resolution protocols where changes are infrequent, it is possible for a namespace provider to indicate a global change event that may not be applicable to the query on which change notification was requested and issued.
     * 
     * </dd>
     * </dl>
     * 
     * 
     * Immediate poll operations are usually much less expensive since they do not require a notification object. In most cases, this is implemented as a simple Boolean variable check. Asynchronous notification, however, may necessitate the creation of dedicated worker threads and/or inter-process communication channels, depending on the implementation of the namespace provider service, and will incur processing overhead related to the notification object involved with signaling the change event.
     * 
     * To cancel an asynchronous notification request, end the original query with a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupserviceend">WSALookupServiceEnd</a> function call on the affected query handle. Canceling the asynchronous notification for LUP_NOTIFY_HWND will not post any message, however, an overlapped operation will be completed and notification will be delivered with the error 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a>.
     * 
     * <div class="alert"><b>Note</b>   All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. See <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> for more information.</div>
     * <div> </div>
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<HANDLE>} hLookup The lookup handle returned from a previous call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function.
     * @param {Integer} dwControlCode The control code of the operation to perform.
     * 
     * 
     * The values that may be used for the <i>dwControlCode</i> parameter are determined by the namespace provider. 
     * 
     * The following value is supported by several Microsoft namespace providers including the Network Location Awareness (NS_NLA) namespace provider. This IOCTL is defined in the Winsock2.h header file.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SIO_NSP_NOTIFY_CHANGE"></a><a id="sio_nsp_notify_change"></a><dl>
     * <dt><b>SIO_NSP_NOTIFY_CHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This operation checks if the results returned with previous calls using the <i>hLookup</i> parameter are still valid.  These previous calls include the initial call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function to retrieve the <i>hLookup</i> parameter.  These previous calls may also include calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> function using the <i>hLookup</i> parameter. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpvInBuffer A pointer to the input buffer.
     * @param {Integer} cbInBuffer The size, in bytes, of the input buffer.
     * @param {Pointer<Void>} lpvOutBuffer A pointer to the output buffer.
     * @param {Integer} cbOutBuffer The size, in bytes, of the output buffer.
     * @param {Pointer<UInt32>} lpcbBytesReturned A pointer to the number of bytes returned.
     * @param {Pointer<WSACOMPLETION>} lpCompletion A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsacompletion">WSACOMPLETION</a> structure, used for asynchronous processing. Set <i>lpCompletion</i> to <b>NULL</b> to force blocking (synchronous) execution.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsanspioctl
     * @since windows8.1
     */
    static WSANSPIoctl(hLookup, dwControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpCompletion) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSANSPIoctl", "ptr", hLookup, "uint", dwControlCode, "ptr", lpvInBuffer, "uint", cbInBuffer, "ptr", lpvOutBuffer, "uint", cbOutBuffer, "ptr", lpcbBytesReturned, "ptr", lpCompletion)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSALookupServiceEnd function is called to free the handle after previous calls to WSALookupServiceBegin and WSALookupServiceNext.
     * @remarks
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<HANDLE>} hLookup Handle previously obtained by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsalookupserviceend
     * @since windows8.1
     */
    static WSALookupServiceEnd(hLookup) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSALookupServiceEnd", "ptr", hLookup)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAInstallServiceClass function registers a service class schema within a namespace. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winsock2.h header defines WSAInstallServiceClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<WSASERVICECLASSINFOA>} lpServiceClassInfo Service class to namespace specific–type mapping information. Multiple mappings can be handled at one time. 
     * 
     * 
     * 
     * 
     * See the section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/name-resolution-data-structures-2">Service Class Data Structures</a> for a description of pertinent data structures.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsainstallserviceclassa
     * @deprecated
     * @since windows5.0
     */
    static WSAInstallServiceClassA(lpServiceClassInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAInstallServiceClassA", "ptr", lpServiceClassInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAInstallServiceClass function registers a service class schema within a namespace. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winsock2.h header defines WSAInstallServiceClass as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<WSASERVICECLASSINFOW>} lpServiceClassInfo Service class to namespace specific–type mapping information. Multiple mappings can be handled at one time. 
     * 
     * 
     * 
     * 
     * See the section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/name-resolution-data-structures-2">Service Class Data Structures</a> for a description of pertinent data structures.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsainstallserviceclassw
     * @since windows5.0
     */
    static WSAInstallServiceClassW(lpServiceClassInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAInstallServiceClassW", "ptr", lpServiceClassInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSARemoveServiceClass function permanently removes the service class schema from the registry.
     * @param {Pointer<Guid>} lpServiceClassId Pointer to the GUID for the service class you want to remove.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaremoveserviceclass
     * @since windows5.0
     */
    static WSARemoveServiceClass(lpServiceClassId) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSARemoveServiceClass", "ptr", lpServiceClassId)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAGetServiceClassInfo function retrieves the class information (schema) pertaining to a specified service class from a specified namespace provider. (ANSI)
     * @remarks
     * The 
     * <b>WSAGetServiceClassInfo</b> function retrieves service class information from a namespace provider. The service class information retrieved from a particular namespace provider might not be the complete set of class information that was specified when the service class was installed. Individual namespace providers are only required to retain service class information that is applicable to the namespaces that they support. See the section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/service-class-data-structures-in-the-spi-2">Service Class Data Structures</a> for more information.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAGetServiceClassInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID that identifies a specific namespace provider.
     * @param {Pointer<Guid>} lpServiceClassId A pointer to a GUID identifying the service class.
     * @param {Pointer<UInt32>} lpdwBufSize On input, the number of bytes contained in the buffer pointed to by the <i>lpServiceClassInfo</i> parameter. 
     * 
     * On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, this parameter specifies the minimum size, in bytes, of the buffer pointed to <i>lpServiceClassInfo</i> needed to retrieve the record.
     * @param {Pointer<WSASERVICECLASSINFOA>} lpServiceClassInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaserviceclassinfow">WSASERVICECLASSINFO</a> structure that contains the service class information from the indicated namespace provider for the specified service class.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsagetserviceclassinfoa
     * @deprecated
     * @since windows5.0
     */
    static WSAGetServiceClassInfoA(lpProviderId, lpServiceClassId, lpdwBufSize, lpServiceClassInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAGetServiceClassInfoA", "ptr", lpProviderId, "ptr", lpServiceClassId, "ptr", lpdwBufSize, "ptr", lpServiceClassInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAGetServiceClassInfo function retrieves the class information (schema) pertaining to a specified service class from a specified namespace provider. (Unicode)
     * @remarks
     * The 
     * <b>WSAGetServiceClassInfo</b> function retrieves service class information from a namespace provider. The service class information retrieved from a particular namespace provider might not be the complete set of class information that was specified when the service class was installed. Individual namespace providers are only required to retain service class information that is applicable to the namespaces that they support. See the section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/service-class-data-structures-in-the-spi-2">Service Class Data Structures</a> for more information.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAGetServiceClassInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID that identifies a specific namespace provider.
     * @param {Pointer<Guid>} lpServiceClassId A pointer to a GUID identifying the service class.
     * @param {Pointer<UInt32>} lpdwBufSize On input, the number of bytes contained in the buffer pointed to by the <i>lpServiceClassInfo</i> parameter. 
     * 
     * On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, this parameter specifies the minimum size, in bytes, of the buffer pointed to <i>lpServiceClassInfo</i> needed to retrieve the record.
     * @param {Pointer<WSASERVICECLASSINFOW>} lpServiceClassInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaserviceclassinfow">WSASERVICECLASSINFO</a> structure that contains the service class information from the indicated namespace provider for the specified service class.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsagetserviceclassinfow
     * @since windows5.0
     */
    static WSAGetServiceClassInfoW(lpProviderId, lpServiceClassId, lpdwBufSize, lpServiceClassInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAGetServiceClassInfoW", "ptr", lpProviderId, "ptr", lpServiceClassId, "ptr", lpdwBufSize, "ptr", lpServiceClassInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAEnumNameSpaceProviders function retrieves information on available namespace providers. (ANSI)
     * @remarks
     * The <b>WSAEnumNameSpaceProviders</b> function returns information on available namespace providers in the buffer pointed to by the <i>lpnspBuffer</i> parameter. The returned buffer contains an array of <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures located consecutively at the head of the buffer. Variable sized information referenced by pointers in the <b>WSANAMESPACE_INFO</b> structures point to locations within the buffer located between the end of the fixed <b>WSANAMESPACE_INFO</b> structures and the end of the buffer. The number of <b>WSANAMESPACE_INFO</b> structures filled in is returned by the  
     * <b>WSAEnumNameSpaceProviders</b> function.
     * 
     * Each <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a>  structure entry contains the provider-specific information on the namespace entry
     *                      passed to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace">WSCInstallNameSpace</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace32">WSCInstallNameSpace32</a> functions when the namespace provider was installed.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa">WSAEnumNameSpaceProvidersEx</a>  function is an enhanced version of the <b>WSAEnumNameSpaceProviders</b> function. The  <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceprovidersex32">WSCEnumNameSpaceProvidersEx32</a> function is an enhanced version of the <b>WSAEnumNameSpaceProviders</b> function that returns information on available 32-bit namespace providers for use on 64-bit platforms.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSAEnumNameSpaceProviders</b> function to retrieve information on available namespace providers.
     * 
     * 
     * ```cpp
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to pass for the <i>lpnspBuffer</i> to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProviders</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer<WSANAMESPACE_INFOA>} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProviders</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa
     * @deprecated
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersA(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersA", "ptr", lpdwBufferLength, "ptr", lpnspBuffer)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAEnumNameSpaceProviders function retrieves information on available namespace providers. (Unicode)
     * @remarks
     * The <b>WSAEnumNameSpaceProviders</b> function returns information on available namespace providers in the buffer pointed to by the <i>lpnspBuffer</i> parameter. The returned buffer contains an array of <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures located consecutively at the head of the buffer. Variable sized information referenced by pointers in the <b>WSANAMESPACE_INFO</b> structures point to locations within the buffer located between the end of the fixed <b>WSANAMESPACE_INFO</b> structures and the end of the buffer. The number of <b>WSANAMESPACE_INFO</b> structures filled in is returned by the  
     * <b>WSAEnumNameSpaceProviders</b> function.
     * 
     * Each <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a>  structure entry contains the provider-specific information on the namespace entry
     *                      passed to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace">WSCInstallNameSpace</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace32">WSCInstallNameSpace32</a> functions when the namespace provider was installed.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa">WSAEnumNameSpaceProvidersEx</a>  function is an enhanced version of the <b>WSAEnumNameSpaceProviders</b> function. The  <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumnamespaceprovidersex32">WSCEnumNameSpaceProvidersEx32</a> function is an enhanced version of the <b>WSAEnumNameSpaceProviders</b> function that returns information on available 32-bit namespace providers for use on 64-bit platforms.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>WSAEnumNameSpaceProviders</b> function to retrieve information on available namespace providers.
     * 
     * 
     * ```cpp
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to pass for the <i>lpnspBuffer</i> to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProviders</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer<WSANAMESPACE_INFOW>} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProviders</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersw
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersW(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersW", "ptr", lpdwBufferLength, "ptr", lpnspBuffer)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information on available namespace providers. (ANSI)
     * @remarks
     * The <b>WSAEnumNameSpaceProvidersEx</b>  function is an enhanced version of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function. The provider-specific data blob associated with the namespace entry
     *                      passed in the <i>lpProviderInfo</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespaceex">WSCInstallNameSpaceEx</a> function can be queried using <b>WSAEnumNameSpaceProvidersEx</b> function. 
     * 
     * Currently, the only namespace provider included with Windows that sets information in the <b>ProviderSpecific</b> member of the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structure is the NS_EMAIL provider. The format of the <b>ProviderSpecific</b> member for an NS_EMAIL namespace provider is a <a href="https://docs.microsoft.com/windows/desktop/api/nsemail/ns-nsemail-napi_provider_installation_blob">NAPI_PROVIDER_INSTALLATION_BLOB</a> structure. 
     * 
     * When UNICODE or _UNICODE is defined, <b>WSAEnumNameSpaceProvidersEx</b> is defined to <b>WSAEnumNameSpaceProvidersExW</b>, the Unicode version of this function. The <i>lpnspBuffer</i> parameter is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">LPSAWSANAMESPACE_INFOEXW</a> data type and <b>WSANAMESPACE_INFOEXW</b> structures are returned on success.
     * 
     * When UNICODE or _UNICODE is not defined, <b>WSAEnumNameSpaceProvidersEx</b> is defined to <b>WSAEnumNameSpaceProvidersExA</b>, the ANSI version of this function. The <i>lpnspBuffer</i> parameter is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">LPSAWSANAMESPACE_INFOEXA</a> data type and <b>WSANAMESPACE_INFOEXA</b> structures are returned on success.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>WSAEnumNameSpaceProvidersExW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAEnumNameSpaceProvidersEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProvidersEx</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer<WSANAMESPACE_INFOEXA>} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProvidersEx</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa
     * @deprecated
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersExA(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersExA", "ptr", lpdwBufferLength, "ptr", lpnspBuffer)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Retrieves information on available namespace providers. (Unicode)
     * @remarks
     * The <b>WSAEnumNameSpaceProvidersEx</b>  function is an enhanced version of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function. The provider-specific data blob associated with the namespace entry
     *                      passed in the <i>lpProviderInfo</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespaceex">WSCInstallNameSpaceEx</a> function can be queried using <b>WSAEnumNameSpaceProvidersEx</b> function. 
     * 
     * Currently, the only namespace provider included with Windows that sets information in the <b>ProviderSpecific</b> member of the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structure is the NS_EMAIL provider. The format of the <b>ProviderSpecific</b> member for an NS_EMAIL namespace provider is a <a href="https://docs.microsoft.com/windows/desktop/api/nsemail/ns-nsemail-napi_provider_installation_blob">NAPI_PROVIDER_INSTALLATION_BLOB</a> structure. 
     * 
     * When UNICODE or _UNICODE is defined, <b>WSAEnumNameSpaceProvidersEx</b> is defined to <b>WSAEnumNameSpaceProvidersExW</b>, the Unicode version of this function. The <i>lpnspBuffer</i> parameter is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">LPSAWSANAMESPACE_INFOEXW</a> data type and <b>WSANAMESPACE_INFOEXW</b> structures are returned on success.
     * 
     * When UNICODE or _UNICODE is not defined, <b>WSAEnumNameSpaceProvidersEx</b> is defined to <b>WSAEnumNameSpaceProvidersExA</b>, the ANSI version of this function. The <i>lpnspBuffer</i> parameter is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">LPSAWSANAMESPACE_INFOEXA</a> data type and <b>WSANAMESPACE_INFOEXA</b> structures are returned on success.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>WSAEnumNameSpaceProvidersExW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSAEnumNameSpaceProvidersEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProvidersEx</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer<WSANAMESPACE_INFOEXW>} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProvidersEx</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexw
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersExW(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersExW", "ptr", lpdwBufferLength, "ptr", lpnspBuffer)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAGetServiceClassNameByClassId function retrieves the name of the service associated with the specified type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The winsock2.h header defines WSAGetServiceClassNameByClassId as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} lpServiceClassId A pointer to the GUID for the service class.
     * @param {Pointer<PSTR>} lpszServiceClassName A pointer to the service name.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the length of the buffer returned by <i>lpszServiceClassName</i>, in characters. On output, the length of the service name copied into <i>lpszServiceClassName</i>, in characters.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsagetserviceclassnamebyclassida
     * @deprecated
     * @since windows5.0
     */
    static WSAGetServiceClassNameByClassIdA(lpServiceClassId, lpszServiceClassName, lpdwBufferLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAGetServiceClassNameByClassIdA", "ptr", lpServiceClassId, "ptr", lpszServiceClassName, "ptr", lpdwBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAGetServiceClassNameByClassId function retrieves the name of the service associated with the specified type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The winsock2.h header defines WSAGetServiceClassNameByClassId as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} lpServiceClassId A pointer to the GUID for the service class.
     * @param {Pointer<PWSTR>} lpszServiceClassName A pointer to the service name.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, the length of the buffer returned by <i>lpszServiceClassName</i>, in characters. On output, the length of the service name copied into <i>lpszServiceClassName</i>, in characters.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsagetserviceclassnamebyclassidw
     * @since windows5.0
     */
    static WSAGetServiceClassNameByClassIdW(lpServiceClassId, lpszServiceClassName, lpdwBufferLength) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAGetServiceClassNameByClassIdW", "ptr", lpServiceClassId, "ptr", lpszServiceClassName, "ptr", lpdwBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSASetService function registers or removes from the registry a service instance within one or more namespaces. (ANSI)
     * @remarks
     * The <b>WSASetService</b> function can be used to affect a specific namespace provider, all providers associated with a specific namespace, or all providers across all namespaces.
     * 
     * The available values for <i>essOperation</i> and <i>dwControlFlags</i> combine to control operation of the <b>WSASetService</b> function as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Operation</th>
     * <th>Flags</th>
     * <th>Service already exists</th>
     * <th>Service does not exist</th>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_REGISTER</td>
     * <td>None</td>
     * <td>Overwrites the object. Uses only addresses specified. The object is REGISTERED.</td>
     * <td>Creates a new object. Uses only addresses specified. Object is REGISTERED.</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_REGISTER</td>
     * <td>SERVICE_MULTIPLE</td>
     * <td>Updates the object. Adds new addresses to the existing set. The object is REGISTERED.</td>
     * <td>Creates a new object. Uses all addresses specified. Object is REGISTERED.</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DEREGISTER</td>
     * <td>None</td>
     * <td>Removes all addresses, but does not remove the object from the namespace. The object is removed from the registry.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DEREGISTER</td>
     * <td>SERVICE_MULTIPLE</td>
     * <td>Updates the object. Removes only addresses that are specified. Only marks the object as DEREGISTERED if no addresses are present. Does not remove the object from the namespace.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DELETE</td>
     * <td>None</td>
     * <td>Removes the object from the namespace.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DELETE</td>
     * <td>SERVICE_MULTIPLE</td>
     * <td>Removes only addresses that are specified. Only removes object from the namespace if no addresses remain.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * </table>
     *  
     * 
     * Publishing services to directories, such as Active Directory Services, is restricted based on access control lists (ACLs). For more information, see <a href="https://docs.microsoft.com/windows/desktop/AD/security-issues-for-service-publication">Security Issues for Service Publication</a>.
     * 
     * When the <i>dwControlFlags</i> parameter is set to <b>SERVICE_MULTIPLE</b>, an application can manage its addresses independently. This is useful when the application wants to manage its protocols individually or when the service resides on more than one computer. For instance, when a service uses more than one protocol, it may find that one listening socket aborts but the other sockets remain operational. In this case, the service could remove the aborted address from the registry without affecting the other addresses.
     * 
     * When the <i>dwControlFlags</i> parameter is set to <b>SERVICE_MULTIPLE</b>, an application must not let stale addresses remain in the object. This can happen if the application aborts without issuing a DEREGISTER request. When a service registers, it should store its addresses. On its next invocation, the service should explicitly remove these old stale addresses from the registry before registering new addresses.
     * 
     * <div class="alert"><b>Note</b>  If ANSI character strings are used, there is a chance that the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> data in <i>lpqsRegInfo</i> may not contain any results after this function returns. This is because the ANSI version of this method, <b>WSASetServiceA</b>, converts the ANSI data in <b>WSAQUERYSET</b> to Unicode internally, but does not convert the results back to ANSI. This primarily impacts transports that return a "service record handle" used to uniquely identify a record. To work around this issue, applications should use Unicode string data in <b>WSAQUERYSET</b> when calling this function.</div>
     * <div> </div>
     * <h3><a id="Service_Properties"></a><a id="service_properties"></a><a id="SERVICE_PROPERTIES"></a>Service Properties</h3>
     * The following table describes how service property data is represented in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure. Fields labeled as (Optional) can contain a null pointer.
     * 
     * <table>
     * <tr>
     * <th>WSAQUERYSET member</th>
     * <th>Service property description</th>
     * </tr>
     * <tr>
     * <td><b>dwSize</b></td>
     * <td>Must be set to sizeof (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a>). This is a versioning mechanism.</td>
     * </tr>
     * <tr>
     * <td><b>dwOutputFlags</b></td>
     * <td>Not applicable and ignored.</td>
     * </tr>
     * <tr>
     * <td><b>lpszServiceInstanceName</b></td>
     * <td>Referenced string contains the service instance name.</td>
     * </tr>
     * <tr>
     * <td><b>lpServiceClassId</b></td>
     * <td>The GUID corresponding to this service class.</td>
     * </tr>
     * <tr>
     * <td><b>lpVersion</b></td>
     * <td>(Optional) Supplies service instance version number.</td>
     * </tr>
     * <tr>
     * <td><b>lpszComment</b></td>
     * <td>(Optional) An optional comment string.</td>
     * </tr>
     * <tr>
     * <td><b>dwNameSpace</b></td>
     * <td>See table that follows.</td>
     * </tr>
     * <tr>
     * <td><b>lpNSProviderId</b></td>
     * <td>See table that follows.</td>
     * </tr>
     * <tr>
     * <td><b>lpszContext</b></td>
     * <td>(Optional) Specifies the starting point of the query in a hierarchical namespace.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfProtocols</b></td>
     * <td>Ignored.</td>
     * </tr>
     * <tr>
     * <td><b>lpafpProtocols</b></td>
     * <td>Ignored.</td>
     * </tr>
     * <tr>
     * <td><b>lpszQueryString</b></td>
     * <td>Ignored.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfCsAddrs</b></td>
     * <td>The number of elements in the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures referenced by <b>lpcsaBuffer</b>.</td>
     * </tr>
     * <tr>
     * <td><b>lpcsaBuffer</b></td>
     * <td>A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures that contain the address(es) that the service is listening on.</td>
     * </tr>
     * <tr>
     * <td><b>lpBlob</b></td>
     * <td>(Optional) This is a pointer to a provider-specific entity.</td>
     * </tr>
     * </table>
     *  
     * 
     * As illustrated in the following, the combination of the <b>dwNameSpace</b> and <b>lpNSProviderId</b> members determine that namespace providers are affected by this function.
     * 
     * <table>
     * <tr>
     * <th><b>dwNameSpace</b></th>
     * <th><b>lpNSProviderId</b></th>
     * <th>Scope of impact</th>
     * </tr>
     * <tr>
     * <td>Ignored</td>
     * <td>Non-null</td>
     * <td>The specified name-space provider.</td>
     * </tr>
     * <tr>
     * <td>A valid name- space identifier</td>
     * <td>Null</td>
     * <td>All name-space providers that support the indicated namespace.</td>
     * </tr>
     * <tr>
     * <td>NS_ALL</td>
     * <td>Null</td>
     * <td>All name-space providers.</td>
     * </tr>
     * </table>
     *  
     * 
     * <b>Windows Phone 8:</b> The <b>WSASetServiceW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSASetServiceW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSASetService as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<WSAQUERYSETA>} lpqsRegInfo A pointer to the service information for registration or deregistration.
     * @param {Integer} essoperation A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration type defined in the <i>Winsock2.h</i> header file. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
     * <dt><b>RNRSERVICE_REGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Register the service. For SAP, this means sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores, this means updating the address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a id="rnrservice_deregister"></a><dl>
     * <dt><b>RNRSERVICE_DEREGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Remove the service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores this means deleting address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl>
     * <dt><b>RNRSERVICE_DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the service from dynamic name and persistent spaces. For services represented by multiple 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding 
     * <b>CSADDR_INFO</b> structure that was specified when the service was registered.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwControlFlags Service install flags value that further controls the operation performed of the <b>WSASetService</b> function. The possible values for this parameter are defined in the <i>Winsock2.h</i> header file.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_MULTIPLE"></a><a id="service_multiple"></a><dl>
     * <dt><b>SERVICE_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Controls scope of operation. When this flag is not set, service addresses are managed as a group. A register or removal from the registry invalidates all existing addresses before adding the given address set. When set, the action is only performed on the given address set. A register does not invalidate existing addresses and a removal from the registry only invalidates the given set of addresses.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasetservicea
     * @deprecated
     * @since windows8.1
     */
    static WSASetServiceA(lpqsRegInfo, essoperation, dwControlFlags) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASetServiceA", "ptr", lpqsRegInfo, "int", essoperation, "uint", dwControlFlags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSASetService function registers or removes from the registry a service instance within one or more namespaces. (Unicode)
     * @remarks
     * The <b>WSASetService</b> function can be used to affect a specific namespace provider, all providers associated with a specific namespace, or all providers across all namespaces.
     * 
     * The available values for <i>essOperation</i> and <i>dwControlFlags</i> combine to control operation of the <b>WSASetService</b> function as shown in the following table.
     * 
     * <table>
     * <tr>
     * <th>Operation</th>
     * <th>Flags</th>
     * <th>Service already exists</th>
     * <th>Service does not exist</th>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_REGISTER</td>
     * <td>None</td>
     * <td>Overwrites the object. Uses only addresses specified. The object is REGISTERED.</td>
     * <td>Creates a new object. Uses only addresses specified. Object is REGISTERED.</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_REGISTER</td>
     * <td>SERVICE_MULTIPLE</td>
     * <td>Updates the object. Adds new addresses to the existing set. The object is REGISTERED.</td>
     * <td>Creates a new object. Uses all addresses specified. Object is REGISTERED.</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DEREGISTER</td>
     * <td>None</td>
     * <td>Removes all addresses, but does not remove the object from the namespace. The object is removed from the registry.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DEREGISTER</td>
     * <td>SERVICE_MULTIPLE</td>
     * <td>Updates the object. Removes only addresses that are specified. Only marks the object as DEREGISTERED if no addresses are present. Does not remove the object from the namespace.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DELETE</td>
     * <td>None</td>
     * <td>Removes the object from the namespace.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * <tr>
     * <td>RNRSERVICE_DELETE</td>
     * <td>SERVICE_MULTIPLE</td>
     * <td>Removes only addresses that are specified. Only removes object from the namespace if no addresses remain.</td>
     * <td>WSASERVICE_NOT_FOUND</td>
     * </tr>
     * </table>
     *  
     * 
     * Publishing services to directories, such as Active Directory Services, is restricted based on access control lists (ACLs). For more information, see <a href="https://docs.microsoft.com/windows/desktop/AD/security-issues-for-service-publication">Security Issues for Service Publication</a>.
     * 
     * When the <i>dwControlFlags</i> parameter is set to <b>SERVICE_MULTIPLE</b>, an application can manage its addresses independently. This is useful when the application wants to manage its protocols individually or when the service resides on more than one computer. For instance, when a service uses more than one protocol, it may find that one listening socket aborts but the other sockets remain operational. In this case, the service could remove the aborted address from the registry without affecting the other addresses.
     * 
     * When the <i>dwControlFlags</i> parameter is set to <b>SERVICE_MULTIPLE</b>, an application must not let stale addresses remain in the object. This can happen if the application aborts without issuing a DEREGISTER request. When a service registers, it should store its addresses. On its next invocation, the service should explicitly remove these old stale addresses from the registry before registering new addresses.
     * 
     * <div class="alert"><b>Note</b>  If ANSI character strings are used, there is a chance that the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> data in <i>lpqsRegInfo</i> may not contain any results after this function returns. This is because the ANSI version of this method, <b>WSASetServiceA</b>, converts the ANSI data in <b>WSAQUERYSET</b> to Unicode internally, but does not convert the results back to ANSI. This primarily impacts transports that return a "service record handle" used to uniquely identify a record. To work around this issue, applications should use Unicode string data in <b>WSAQUERYSET</b> when calling this function.</div>
     * <div> </div>
     * <h3><a id="Service_Properties"></a><a id="service_properties"></a><a id="SERVICE_PROPERTIES"></a>Service Properties</h3>
     * The following table describes how service property data is represented in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure. Fields labeled as (Optional) can contain a null pointer.
     * 
     * <table>
     * <tr>
     * <th>WSAQUERYSET member</th>
     * <th>Service property description</th>
     * </tr>
     * <tr>
     * <td><b>dwSize</b></td>
     * <td>Must be set to sizeof (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a>). This is a versioning mechanism.</td>
     * </tr>
     * <tr>
     * <td><b>dwOutputFlags</b></td>
     * <td>Not applicable and ignored.</td>
     * </tr>
     * <tr>
     * <td><b>lpszServiceInstanceName</b></td>
     * <td>Referenced string contains the service instance name.</td>
     * </tr>
     * <tr>
     * <td><b>lpServiceClassId</b></td>
     * <td>The GUID corresponding to this service class.</td>
     * </tr>
     * <tr>
     * <td><b>lpVersion</b></td>
     * <td>(Optional) Supplies service instance version number.</td>
     * </tr>
     * <tr>
     * <td><b>lpszComment</b></td>
     * <td>(Optional) An optional comment string.</td>
     * </tr>
     * <tr>
     * <td><b>dwNameSpace</b></td>
     * <td>See table that follows.</td>
     * </tr>
     * <tr>
     * <td><b>lpNSProviderId</b></td>
     * <td>See table that follows.</td>
     * </tr>
     * <tr>
     * <td><b>lpszContext</b></td>
     * <td>(Optional) Specifies the starting point of the query in a hierarchical namespace.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfProtocols</b></td>
     * <td>Ignored.</td>
     * </tr>
     * <tr>
     * <td><b>lpafpProtocols</b></td>
     * <td>Ignored.</td>
     * </tr>
     * <tr>
     * <td><b>lpszQueryString</b></td>
     * <td>Ignored.</td>
     * </tr>
     * <tr>
     * <td><b>dwNumberOfCsAddrs</b></td>
     * <td>The number of elements in the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures referenced by <b>lpcsaBuffer</b>.</td>
     * </tr>
     * <tr>
     * <td><b>lpcsaBuffer</b></td>
     * <td>A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures that contain the address(es) that the service is listening on.</td>
     * </tr>
     * <tr>
     * <td><b>lpBlob</b></td>
     * <td>(Optional) This is a pointer to a provider-specific entity.</td>
     * </tr>
     * </table>
     *  
     * 
     * As illustrated in the following, the combination of the <b>dwNameSpace</b> and <b>lpNSProviderId</b> members determine that namespace providers are affected by this function.
     * 
     * <table>
     * <tr>
     * <th><b>dwNameSpace</b></th>
     * <th><b>lpNSProviderId</b></th>
     * <th>Scope of impact</th>
     * </tr>
     * <tr>
     * <td>Ignored</td>
     * <td>Non-null</td>
     * <td>The specified name-space provider.</td>
     * </tr>
     * <tr>
     * <td>A valid name- space identifier</td>
     * <td>Null</td>
     * <td>All name-space providers that support the indicated namespace.</td>
     * </tr>
     * <tr>
     * <td>NS_ALL</td>
     * <td>Null</td>
     * <td>All name-space providers.</td>
     * </tr>
     * </table>
     *  
     * 
     * <b>Windows Phone 8:</b> The <b>WSASetServiceW</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>WSASetServiceW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The winsock2.h header defines WSASetService as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<WSAQUERYSETW>} lpqsRegInfo A pointer to the service information for registration or deregistration.
     * @param {Integer} essoperation A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration type defined in the <i>Winsock2.h</i> header file. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
     * <dt><b>RNRSERVICE_REGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Register the service. For SAP, this means sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores, this means updating the address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a id="rnrservice_deregister"></a><dl>
     * <dt><b>RNRSERVICE_DEREGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Remove the service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores this means deleting address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl>
     * <dt><b>RNRSERVICE_DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the service from dynamic name and persistent spaces. For services represented by multiple 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding 
     * <b>CSADDR_INFO</b> structure that was specified when the service was registered.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwControlFlags Service install flags value that further controls the operation performed of the <b>WSASetService</b> function. The possible values for this parameter are defined in the <i>Winsock2.h</i> header file.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_MULTIPLE"></a><a id="service_multiple"></a><dl>
     * <dt><b>SERVICE_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Controls scope of operation. When this flag is not set, service addresses are managed as a group. A register or removal from the registry invalidates all existing addresses before adding the given address set. When set, the action is only performed on the given address set. A register does not invalidate existing addresses and a removal from the registry only invalidates the given set of addresses.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsasetservicew
     * @since windows8.1
     */
    static WSASetServiceW(lpqsRegInfo, essoperation, dwControlFlags) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASetServiceW", "ptr", lpqsRegInfo, "int", essoperation, "uint", dwControlFlags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAProviderConfigChange function notifies the application when the provider configuration is changed.
     * @remarks
     * The 
     * <b>WSAProviderConfigChange</b> function notifies the application of provider (both transport and namespace) installation or removal in Windows operating environments that support such configuration change without requiring a restart. When called for the first time (<i>lpNotificationHandle</i> parameter points to <b>NULL</b> handle), this function completes immediately and returns notification handle in the location pointed by <i>lpNotificationHandle</i> that can be used in subsequent calls to receive notifications of provider installation and removal. The second and any subsequent calls only complete when provider information changes since the time the call was made It is expected (but not required) that the application uses overlapped I/O on second and subsequent calls to 
     * <b>WSAProviderConfigChange</b>, in which case the call will return immediately and application will be notified of provider configuration changes using the completion mechanism chosen through specified overlapped completion parameters.
     * 
     * Notification handle returned by 
     * <b>WSAProviderConfigChange</b> is like any regular operating system handle that should be closed (when no longer needed) using Windows 
     * <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> call.
     * 
     * The following sequence of actions can be used to guarantee that application always has current protocol configuration information:
     * 
     * <ul>
     * <li>Call <b>WSAProviderConfigChange</b></li>
     * <li>Call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> and/or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a>
     * </li>
     * <li>Whenever 
     * <b>WSAProviderConfigChange</b> notifies application of provider configuration change (through blocking or overlapped I/O), the whole sequence of actions should be repeated.</li>
     * </ul>
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<HANDLE>} lpNotificationHandle Pointer to notification handle. If the notification handle is set to <b>NULL</b> (the handle value not the pointer itself), this function returns a notification handle in the location pointed to by <i>lpNotificationHandle</i>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * Pointer to the completion routine called when the provider change notification is received.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsaproviderconfigchange
     * @since windows8.1
     */
    static WSAProviderConfigChange(lpNotificationHandle, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAProviderConfigChange", "ptr", lpNotificationHandle, "ptr", lpOverlapped, "ptr", lpCompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The WSAPoll function determines status of one or more sockets.
     * @remarks
     * The <b>WSAPoll</b> function is defined on Windows Vista and later. 
     * 
     * The [WSAPOLLFD](./ns-winsock2-wsapollfd.md) structures.  An application sets the appropriate flags in the <b>events</b> member of the <b>WSAPOLLFD</b> structure to specify the type of status requested for each corresponding socket.  The <b>WSAPoll</b> function returns the status of a socket in the <b>revents</b> member of the <b>WSAPOLLFD</b> structure.
     * 
     * For each socket, a caller can request information on read or write status.  Error conditions are always returned, so information on them need not be requested.
     * 
     * The [WSAPOLLFD](./ns-winsock2-wsapollfd.md) structure pointed to by the <i>fdarray</i> parameter. All sockets that do not meet these criteria and have no error condition will have the corresponding  <b>revents</b> member set to 0.
     * 
     * A combination of the following flags can be set in the [WSAPOLLFD](./ns-winsock2-wsapollfd.md) structure for a given socket when requesting status for that socket:<table>
     * <tr>
     * <th>Flag</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>POLLPRI</td>
     * <td>Priority data may be read without blocking. This flag is not supported by the Microsoft Winsock provider.</td>
     * </tr>
     * <tr>
     * <td>POLLRDBAND</td>
     * <td>Priority band (out-of-band) data may be read without blocking.</td>
     * </tr>
     * <tr>
     * <td>POLLRDNORM</td>
     * <td>Normal data may be read without blocking.</td>
     * </tr>
     * <tr>
     * <td>POLLWRNORM</td>
     * <td>Normal data may be written without blocking.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * The <b>POLLIN</b> flag is defined as the combination of the <b>POLLRDNORM</b>  and <b>POLLRDBAND</b> flag values. The <b>POLLOUT</b> flag is defined as the same as the <b>POLLWRNORM</b>  flag value.
     * 
     * The [WSAPOLLFD](./ns-winsock2-wsapollfd.md) structure must only contain a combination of the above flags that are supported by the Winsock provider. Any other values are considered errors and  <b>WSAPoll</b> will return <b>SOCKET_ERROR</b>. A subsequent call to  the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function will retrieve the extended error code of <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a>. If the <b>POLLPRI</b> flag is set on a socket for the Microsoft Winsock provider, the <b>WSAPoll</b> function will fail.  
     * 
     * When the [WSAPOLLFD](./ns-winsock2-wsapollfd.md) structures pointed to by the <i>fdarray</i> parameter to indicate socket  status:<table>
     * <tr>
     * <th>Flag</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>POLLERR</td>
     * <td>An error has occurred.</td>
     * </tr>
     * <tr>
     * <td>POLLHUP</td>
     * <td>A stream-oriented connection was either disconnected or aborted.</td>
     * </tr>
     * <tr>
     * <td>POLLNVAL</td>
     * <td>An invalid socket was used.</td>
     * </tr>
     * <tr>
     * <td>POLLPRI</td>
     * <td>Priority data may be read without blocking. This flag is not returned by the Microsoft Winsock provider.</td>
     * </tr>
     * <tr>
     * <td>POLLRDBAND</td>
     * <td>Priority band (out-of-band) data may be read without blocking.</td>
     * </tr>
     * <tr>
     * <td>POLLRDNORM</td>
     * <td>Normal data may be read without blocking.</td>
     * </tr>
     * <tr>
     * <td>POLLWRNORM</td>
     * <td>Normal data may be written without blocking.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * 
     * With regard to TCP and UDP sockets:
     * 
     * <ul>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure as normal data as <b>POLLRDNORM</b>.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure, a subsequent <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> operation is guaranteed to complete without blocking.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure by <b>POLLWRNORM</b>.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a>  structure by <b>POLLRDNORM</b>. A subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> is guaranteed to complete without blocking.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure by <b>POLLRDBAND</b>.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure when a remote peer shuts down a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a> operation (a TCP FIN was received). A subsequent <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function request will return zero bytes.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure when the remote peer initiates a graceful disconnect.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure returned when a remote peer suddenly disconnects.</li>
     * <li><a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structure when the local socket is closed.</li>
     * </ul>
     * 
     * 
     * The number of elements (not sockets) in <i>fdarray</i> is indicated by <i>nfds</i>. Members of <i>fdarray</i> which have their <b>fd</b> member set to a negative value are ignored and their <b>revents</b> will be set to <b>POLLNVAL</b> upon return. This behavior is useful to an application which maintains a fixed <i>fdarray</i> allocation and will not compact the array to remove unused entries or to reallocate memory. It is not necessary to clear <b>revents</b> for any element prior to calling <b>WSAPoll</b>.
     * 
     * The timeout argument specifies how long the function is to wait before returning. A positive value contains the number of milliseconds to wait before returning. A zero value forces <b>WSAPoll</b> to return immediately, and a negative value indicates that <b>WSAPoll</b> should wait indefinitely.
     * 
     * <div class="alert"><b>Note</b>  When issuing a blocking Winsock call such as <b>WSAPoll</b> with the <i>timeout</i> parameter set to a negative number, Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients. </div>
     * <div> </div>
     * 
     * <div class="alert"><b>Note</b>  As of Windows 10 version 2004, when a TCP socket fails to connect, (POLLHUP \| POLLERR \| POLLWRNORM) is indicated. </div>
     * <div> </div>
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This   function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<WSAPOLLFD>} fdArray An array of one or more <b>POLLFD</b> structures specifying the set  of sockets for which status is requested. The   array must contain at least one structure with a valid socket. Upon return, this parameter receives the updated sockets with the <b>revents</b> status flags member set on each one that matches the status query criteria.
     * @param {Integer} fds The number of <b>WSAPOLLFD</b> structures in <i>fdarray</i>. This is not necessarily the number of sockets for which status is requested.
     * @param {Integer} timeout A value that specifies the wait behavior, based on the following values.
     * 			
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>Greater than zero</td>
     * <td>The time, in milliseconds, to wait.</td>
     * </tr>
     * <tr>
     * <td>Zero</td>
     * <td>Return immediately.</td>
     * </tr>
     * <tr>
     * <td>Less than zero</td>
     * <td>Wait indefinitely.</td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-wsapoll
     * @since windows8.1
     */
    static WSAPoll(fdArray, fds, timeout) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAPoll", "ptr", fdArray, "uint", fds, "int", timeout)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Associates a set of sockets with a completion port, and retrieves any notifications that are already pending on that port. Once associated, the completion port receives the socket state notifications that were specified.
     * @remarks
     * See [SocketNotificationRetrieveEvents](/windows/win32/api/winsock2/nf-winsock2-socketnotificationretrieveevents) for the events that are possible when a notification is received.
     * @param {Pointer<HANDLE>} completionPort Type: \_In\_ **[HANDLE](/windows/win32/winprog/windows-data-types)**
     * 
     * A handle to an I/O completion port created using the [CreateIoCompletionPort](/windows/win32/fileio/createiocompletionport) function. The port will be used in the *CompletionPort* parameter of the [PostQueuedCompletionStatus](/windows/win32/fileio/postqueuedcompletionstatus) function when messages are sent on behalf of the socket.
     * @param {Integer} registrationCount Type: \_In\_ **[UINT32](/windows/win32/winprog/windows-data-types)**
     * 
     * The number of registrations supplied by *registrationInfos*.
     * @param {Pointer<SOCK_NOTIFY_REGISTRATION>} registrationInfos Type: \_Inout\_updates\_opt\_(registrationCount) **[SOCK_NOTIFY_REGISTRATION](/windows/win32/api/winsock2/ns-winsock2-sock_notify_registration)\***
     * 
     * A pointer to an array of [SOCK_NOTIFY_REGISTRATION](/windows/win32/api/winsock2/ns-winsock2-sock_notify_registration) structures that define the notification registration parameters. These include the socket of interest, the notification events of interest, and the operation flags. On success, you must inspect the elements for whether the registration was processed successfully. This argument must be **NULL** if *registrationCount* is 0.
     * @param {Integer} timeoutMs Type: \_In\_ **[UINT32](/windows/win32/winprog/windows-data-types)**
     * 
     * The time in milliseconds that you're willing to wait for a completion packet to appear at the completion port. If a completion packet doesn't appear within the specified time, then the function times out and returns **ERROR_TIMEOUT**.
     * 
     * If *timeoutMs* is **INFINITE** (0xFFFFFFFF), then the function will never time out. If *timeoutMs* is 0, and there is no I/O operation to dequeue, then the function will time out immediately.
     * 
     * The value of *timeoutMs* must be 0 if *completionCount* is 0.
     * @param {Integer} completionCount Type: \_In\_ **[ULONG](/windows/win32/winprog/windows-data-types)**
     * 
     * The maximum number of [OVERLAPPED_ENTRY](/windows/win32/api/minwinbase/ns-minwinbase-overlapped_entry) structures to remove. If 0 is specified, then only registration operations will be processed.
     * @param {Pointer<OVERLAPPED_ENTRY>} completionPortEntries Type: \_Out\_writes\_to\_opt\_(completionCount, *receivedEntryCount) **[OVERLAPPED_ENTRY](/windows/win32/api/minwinbase/ns-minwinbase-overlapped_entry)\***
     * 
     * On input, points to a pre-allocated array of [OVERLAPPED_ENTRY](/windows/win32/api/minwinbase/ns-minwinbase-overlapped_entry) structures. The array mustn't overlap with the *registrationInfos* array. The value of *completionPortEntries* must be **NULL** if *completionCount* is 0.
     * 
     * On output, receives an array of OVERLAPPED_ENTRY structures that hold the entries. The number of array elements is provided by ReceivedEntryCount. The dwNumberOfBytesTransferred fields of the structures are integer masks of received events. The lpOverlapped fields are reserved and must not be used as pointers.
     * @param {Pointer<UInt32>} receivedEntryCount Type: \_Out\_opt\_ **[UINT32](/windows/win32/winprog/windows-data-types)\***
     * 
     * A pointer to a variable that receives the number of entries removed. Must be **NULL** if *completionCount* is 0.
     * @returns {Integer} If successful, returns **ERROR_SUCCESS**. If the function succeeded and you supplied a non-0 *completionCount*, but no completion packets appeared within the specified time, returns **WAIT_TIMEOUT**. Otherwise, returns an appropriate **WSAE\*** error code.
     * 
     * If **ERROR_SUCCESS** or **WAIT_TIMEOUT** is returned, then you must inspect the individual registration infos' registration results. Otherwise, the entire operation failed, and no changes occurred.
     * @see https://learn.microsoft.com/windows/win32/api/winsock2/nf-winsock2-processsocketnotifications
     */
    static ProcessSocketNotifications(completionPort, registrationCount, registrationInfos, timeoutMs, completionCount, completionPortEntries, receivedEntryCount) {
        result := DllCall("WS2_32.dll\ProcessSocketNotifications", "ptr", completionPort, "uint", registrationCount, "ptr", registrationInfos, "uint", timeoutMs, "uint", completionCount, "ptr", completionPortEntries, "ptr", receivedEntryCount, "uint")
        return result
    }

    /**
     * Converts an IPv4 address to a string in Internet standard dotted-decimal format. (ANSI)
     * @remarks
     * The <b>RtlIpv4AddressToString</b> function is used to convert an IPv4 address to the string representation of the IPv4 address in Internet dotted-decimal format. 
     * 
     * <b>RtlIpv4AddressToString</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4AddressToString</b> is defined to <b>RtlIpv4AddressToStringW</b>, the Unicode version of this function. The string parameter <i>S</i> and the function return value are defined to the PWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv4AddressToString</b> is defined to <b>RtlIpv4AddressToStringA</b>, the ANSI version of this function. The string parameter <i>S</i> and the function return value are defined to the PSTR data type.
     * 
     * 
     * 
     * The <b>IN_ADDR</b> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4AddressToString</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4AddressToString</b> function  is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv4AddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<IN_ADDR>} Addr The IPv4 address in network byte order.
     * @param {Pointer<PSTR>} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv4 address. This buffer should be large enough to hold at least 16 characters.
     * @returns {Pointer<PSTR>} A pointer to the NULL character inserted at the end of the string representation of the IPv4 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4addresstostringa
     * @since windows6.0.6000
     */
    static RtlIpv4AddressToStringA(Addr, S) {
        result := DllCall("ntdll.dll\RtlIpv4AddressToStringA", "ptr", Addr, "ptr", S, "ptr")
        return result
    }

    /**
     * Converts an IPv4 address and port number to a string in Internet standard format. (ANSI)
     * @remarks
     * The <b>RtlIpv4AddressToStringEx</b> function is used to convert an IPv4 address and port number to the string representation of the IPv4 address in Internet dotted-decimal format followed by a colon character and a string representation of the port.
     * 
     * <b>RtlIpv4AddressToStringEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion.
     * 
     * If the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv4 address and port, <b>RtlIpv4AddressToStringEx</b> returns <b>ERROR_INVALID_PARAMETER</b> and sets the <i>AddressStringLength</i> parameter to the buffer length required.
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4AddressToStringEx</b> is defined to <b>RtlIpv4AddressToStringExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PWSTR data type.
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv4AddressToStringEx</b> is defined to <b>RtlIpv4AddressToStringExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PSTR data type.
     * 
     * The <b>IN_ADDR</b> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4AddressToStringEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4AddressToStringEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<IN_ADDR>} Address The IPv4 address in network byte order.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {Pointer<PSTR>} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IPv4 address and port. This buffer should be large enough to hold at least INET_ADDRSTRLEN characters. The INET_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<UInt32>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     * 
     * On output, this parameter contains the number of characters actually written to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv4 address and port.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4addresstostringexa
     */
    static RtlIpv4AddressToStringExA(Address, Port, AddressString, AddressStringLength) {
        result := DllCall("ntdll.dll\RtlIpv4AddressToStringExA", "ptr", Address, "ushort", Port, "ptr", AddressString, "ptr", AddressStringLength, "int")
        return result
    }

    /**
     * Converts an IPv4 address to a string in Internet standard dotted-decimal format. (Unicode)
     * @remarks
     * The <b>RtlIpv4AddressToString</b> function is used to convert an IPv4 address to the string representation of the IPv4 address in Internet dotted-decimal format. 
     * 
     * <b>RtlIpv4AddressToString</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4AddressToString</b> is defined to <b>RtlIpv4AddressToStringW</b>, the Unicode version of this function. The string parameter <i>S</i> and the function return value are defined to the PWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv4AddressToString</b> is defined to <b>RtlIpv4AddressToStringA</b>, the ANSI version of this function. The string parameter <i>S</i> and the function return value are defined to the PSTR data type.
     * 
     * 
     * 
     * The <b>IN_ADDR</b> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4AddressToString</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4AddressToString</b> function  is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv4AddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<IN_ADDR>} Addr The IPv4 address in network byte order.
     * @param {Pointer<PWSTR>} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv4 address. This buffer should be large enough to hold at least 16 characters.
     * @returns {Pointer<PWSTR>} A pointer to the NULL character inserted at the end of the string representation of the IPv4 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4addresstostringw
     * @since windows6.0.6000
     */
    static RtlIpv4AddressToStringW(Addr, S) {
        result := DllCall("ntdll.dll\RtlIpv4AddressToStringW", "ptr", Addr, "ptr", S, "ptr")
        return result
    }

    /**
     * Converts an IPv4 address and port number to a string in Internet standard format. (Unicode)
     * @remarks
     * The <b>RtlIpv4AddressToStringEx</b> function is used to convert an IPv4 address and port number to the string representation of the IPv4 address in Internet dotted-decimal format followed by a colon character and a string representation of the port. 
     * 
     * <b>RtlIpv4AddressToStringEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. 
     * 
     * If the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv4 address and port, <b>RtlIpv4AddressToStringEx</b> returns <b>ERROR_INVALID_PARAMETER</b> and sets the <i>AddressStringLength</i> parameter to the buffer length required. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4AddressToStringEx</b> is defined to <b>RtlIpv4AddressToStringExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv4AddressToStringEx</b> is defined to <b>RtlIpv4AddressToStringExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PSTR data type.
     * 
     * 
     * 
     * The <b>IN_ADDR</b> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4AddressToStringEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4AddressToStringEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<IN_ADDR>} Address The IPv4 address in network byte order.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {Pointer<PWSTR>} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IPv4 address and port. This buffer should be large enough to hold at least INET_ADDRSTRLEN characters. The INET_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<UInt32>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     *         On output, this parameter contains the number of characters actually written
     *         to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv4 address and port. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4addresstostringexw
     * @since windows6.0.6000
     */
    static RtlIpv4AddressToStringExW(Address, Port, AddressString, AddressStringLength) {
        result := DllCall("ntdll.dll\RtlIpv4AddressToStringExW", "ptr", Address, "ushort", Port, "ptr", AddressString, "ptr", AddressStringLength, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address to a binary IPv4 address. (ANSI)
     * @remarks
     * The <b>RtlIpv4StringToAddress</b> function is used to convert a string representation of the IPv4 address to an IPv4 address returned in network order (bytes ordered from
     *     left to right). 
     * 
     * <b>RtlIpv4StringToAddress</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. 
     * 
     * If the <i>Strict</i> parameter is set to <b>TRUE</b>, then the string pointed to by the <i>S</i> parameter must be in strict dotted-decimal notation. This strict format requires that four parts are specified. Each part is interpreted as a decimal byte of data
     *     and assigned, from left to right, to the four bytes of an IPv4
     *     address.   
     * 
     * When the <i>Strict</i> parameter is set to <b>FALSE</b>, the string pointed to by <i>S</i> parameter may be in any of the several possible formats. When the buffer pointed to by <i>S</i> parameter contains a three-part address string, the last part is interpreted
     *     as a 16-bit quantity and placed in the right most two bytes of the
     *     network address.  This makes the three-part address format
     *     convenient for specifying Class B network addresses as
     *     "128.net.host". When the buffer pointed to by <i>S</i> parameter contains a two-part address string, the last part is interpreted
     *     as a 24-bit quantity and placed in the right most three bytes of the
     *     network address.  This makes the two part address format convenient
     *     for specifying Class A network addresses as "net.host". When the buffer pointed to by <i>S</i> parameter contains only a one-part address string, the value is stored directly in the
     *     network address without any byte rearrangement.
     * 
     * 
     *  
     * 
     * On success, the <i>Terminator</i> parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains an IP address plus additional information to the <b>RtlIpv4StringToAddress</b> function and then parse the remaining information. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4StringToAddress</b> is defined to <b>RtlIpv4StringToAddressW</b>, the Unicode version of this function. The <i>S</i> parameter is defined to the PCWSTR data type and the <i>Terminator</i> parameter is defined to the LPCWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv4StringToAddress</b> is defined to <b>RtlIpv4StringToAddressA</b>, the ANSI version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the PCSTR data type.
     * 
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4StringToAddress</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4StringToAddress</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv4StringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address.
     * @param {Integer} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts.
     *              If this parameter is <b>FALSE</b>, any of four possible forms are allowed, with decimal,
     *              octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<PSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN_ADDR>} Addr A pointer where the binary representation of the IPv4 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>S</i> parameter did not contain a four-part dotted decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4stringtoaddressa
     * @since windows6.0.6000
     */
    static RtlIpv4StringToAddressA(S, Strict, Terminator, Addr) {
        result := DllCall("ntdll.dll\RtlIpv4StringToAddressA", "ptr", S, "char", Strict, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address and port number to a binary IPv4 address and port. (ANSI)
     * @remarks
     * The <b>RtlIpv4StringToAddressEx</b> function is used to convert a string representation of the IPv4 address and port number to a binary IPv4 address and a port number. The IPv4 address is returned in network order (bytes ordered from left to right). The port number is returned in network order.
     * 
     * <b>RtlIpv4StringToAddressEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion.
     * 
     * If the <i>Strict</i> parameter is set to <b>TRUE</b>, then the string pointed to by the <i>AddressString</i> parameter must be in strict dotted-decimal notation. This strict format requires that four parts are specified. Each part is interpreted as a decimal byte of data and assigned, from left to right, to the four bytes of an IPv4 address.
     * 
     * When the <i>Strict</i> parameter is set to <b>FALSE</b>, the string pointed to by the <i>AddressString</i> parameter may be in any of the several possible formats. When the buffer pointed to by <i>AddressString</i> parameter contains a three-part address string, the last part is interpreted as a 16-bit quantity and placed in the right most two bytes of the network address. This makes the three-part address format convenient for specifying Class B network addresses as "128.net.host".
     * 
     * When the buffer pointed to by <i>AddressString</i> parameter contains a two-part address string, the last part is interpreted as a 24-bit quantity and placed in the right most three bytes of the network address.  This makes the two part address format convenient for specifying Class A network addresses as "net.host". When the buffer pointed to by <i>AddressString</i> parameter contains only a one-part address string, the value is stored directly in the network address without any byte rearrangement.
     * 
     * The buffer pointed to by the <i>AddressString</i> parameter may contain the IPv4 address string followed by an optional  colon and the string representation of a  port number. If a port number string is included in the buffer pointed to by <i>AddressString</i> parameter, the binary representation of the port number is returned in the <i>Port</i> parameter. If the buffer pointed to by <i>AddressString</i> parameter does not contain a port number, a zero is returned in the <i>Port</i> parameter. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4StringToAddressEx</b> is defined to <b>RtlIpv4StringToAddressExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PCWSTR data type.
     * 
     * When both UNICODE and  _UNICODE are not defined, <b>RtlIpv4StringToAddressEx</b> is defined to <b>RtlIpv4StringToAddressExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PCSTR data type.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4StringToAddressEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4StringToAddressEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<PSTR>} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address followed by an optional colon and string representation of a port number.
     * @param {Integer} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts. If this parameter is <b>FALSE</b>, any of four forms are allowed for the string representation of the Ipv4 address, with decimal, octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<IN_ADDR>} Address A pointer where the binary representation of the IPv4 address is to be stored. The IPv4 address is stored in network byte order.
     * @param {Pointer<UInt16>} Port A pointer where the binary representation of the port number is to be stored. The port number is returned in network byte order. If no port was specified in the string pointed to by the <i>AddressString</i> parameter, then the <i>Port</i> parameter is set to zero.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>AddressString</i> parameter did not contain a four-part dotted-decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the <i>AddressString</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4stringtoaddressexa
     */
    static RtlIpv4StringToAddressExA(AddressString, Strict, Address, Port) {
        result := DllCall("ntdll.dll\RtlIpv4StringToAddressExA", "ptr", AddressString, "char", Strict, "ptr", Address, "ptr", Port, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address to a binary IPv4 address. (Unicode)
     * @remarks
     * The <b>RtlIpv4StringToAddress</b> function is used to convert a string representation of the IPv4 address to an IPv4 address returned in network order (bytes ordered from
     *     left to right). 
     * 
     * <b>RtlIpv4StringToAddress</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. 
     * 
     * If the <i>Strict</i> parameter is set to <b>TRUE</b>, then the string pointed to by the <i>S</i> parameter must be in strict dotted-decimal notation. This strict format requires that four parts are specified. Each part is interpreted as a decimal byte of data
     *     and assigned, from left to right, to the four bytes of an IPv4
     *     address.   
     * 
     * When the <i>Strict</i> parameter is set to <b>FALSE</b>, the string pointed to by <i>S</i> parameter may be in any of the several possible formats. When the buffer pointed to by <i>S</i> parameter contains a three-part address string, the last part is interpreted
     *     as a 16-bit quantity and placed in the right most two bytes of the
     *     network address.  This makes the three-part address format
     *     convenient for specifying Class B network addresses as
     *     "128.net.host". When the buffer pointed to by <i>S</i> parameter contains a two-part address string, the last part is interpreted
     *     as a 24-bit quantity and placed in the right most three bytes of the
     *     network address.  This makes the two part address format convenient
     *     for specifying Class A network addresses as "net.host". When the buffer pointed to by <i>S</i> parameter contains only a one-part address string, the value is stored directly in the
     *     network address without any byte rearrangement.
     * 
     * 
     *  
     * 
     * On success, the <i>Terminator</i> parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains an IP address plus additional information to the <b>RtlIpv4StringToAddress</b> function and then parse the remaining information. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4StringToAddress</b> is defined to <b>RtlIpv4StringToAddressW</b>, the Unicode version of this function. The <i>S</i> parameter is defined to the PCWSTR data type and the <i>Terminator</i> parameter is defined to the LPCWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv4StringToAddress</b> is defined to <b>RtlIpv4StringToAddressA</b>, the ANSI version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the PCSTR data type.
     * 
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4StringToAddress</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4StringToAddress</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv4StringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address.
     * @param {Integer} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts.
     *              If this parameter is <b>FALSE</b>, any of four possible forms are allowed, with decimal,
     *              octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<PWSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN_ADDR>} Addr A pointer where the binary representation of the IPv4 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>S</i> parameter did not contain a four-part dotted decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4stringtoaddressw
     * @since windows6.0.6000
     */
    static RtlIpv4StringToAddressW(S, Strict, Terminator, Addr) {
        result := DllCall("ntdll.dll\RtlIpv4StringToAddressW", "ptr", S, "char", Strict, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address and port number to a binary IPv4 address and port. (Unicode)
     * @remarks
     * The <b>RtlIpv4StringToAddressEx</b> function is used to convert a string representation of the IPv4 address and port number to a binary IPv4 address and a port number. The IPv4 address is returned in network order (bytes ordered from
     *     left to right). The port number is returned in network order. 
     * 
     * <b>RtlIpv4StringToAddressEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. 
     * 
     * If the <i>Strict</i> parameter is set to <b>TRUE</b>, then the string pointed to by the <i>AddressString</i> parameter must be in strict dotted-decimal notation. This strict format requires that four parts are specified. Each part is interpreted as a decimal byte of data
     *     and assigned, from left to right, to the four bytes of an IPv4
     *     address.   
     * 
     * When the <i>Strict</i> parameter is set to <b>FALSE</b>, the string pointed to by the <i>AddressString</i> parameter may be in any of the several possible formats. When the buffer pointed to by <i>AddressString</i> parameter contains a three-part address string, the last part is interpreted
     *     as a 16-bit quantity and placed in the right most two bytes of the
     *     network address.  This makes the three-part address format
     *     convenient for specifying Class B network addresses as
     *     "128.net.host". When the buffer pointed to by <i>AddressString</i> parameter contains a two-part address string, the last part is interpreted
     *     as a 24-bit quantity and placed in the right most three bytes of the
     *     network address.  This makes the two part address format convenient
     *     for specifying Class A network addresses as "net.host". When the buffer pointed to by <i>AddressString</i> parameter contains only a one-part address string, the value is stored directly in the
     *     network address without any byte rearrangement.
     * 
     * 
     *  
     * 
     * The buffer pointed to by the <i>AddressString</i> parameter may contain the IPv4 address string followed by an optional  colon and the string representation of a  port number. If a port number string is included in the buffer pointed to by <i>AddressString</i> parameter, the binary representation of the port number is returned in the <i>Port</i> parameter. If the buffer pointed to by <i>AddressString</i> parameter does not contain a port number, a zero is returned in the <i>Port</i> parameter.  
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv4StringToAddressEx</b> is defined to <b>RtlIpv4StringToAddressExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PCWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and  _UNICODE are not defined, <b>RtlIpv4StringToAddressEx</b> is defined to <b>RtlIpv4StringToAddressExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PCSTR data type.
     * 
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv4StringToAddressEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv4StringToAddressEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<PWSTR>} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address followed by an optional colon and string representation of a port number.
     * @param {Integer} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts. If this parameter is <b>FALSE</b>, any of four forms are allowed for the string representation of the Ipv4 address, with decimal,
     *              octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<IN_ADDR>} Address A pointer where the binary representation of the IPv4 address is to be stored. The IPv4 address is stored in network byte order.
     * @param {Pointer<UInt16>} Port A pointer where the binary representation of the port number is to be stored. The port number is returned in network byte order. If no port was specified in the string pointed to by the <i>AddressString</i> parameter, then the <i>Port</i> parameter is set to zero.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>AddressString</i> parameter did not contain a four-part dotted-decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the  <i>AddressString</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv4stringtoaddressexw
     * @since windows6.0.6000
     */
    static RtlIpv4StringToAddressExW(AddressString, Strict, Address, Port) {
        result := DllCall("ntdll.dll\RtlIpv4StringToAddressExW", "ptr", AddressString, "char", Strict, "ptr", Address, "ptr", Port, "int")
        return result
    }

    /**
     * Converts an IPv6 address to a string in Internet standard format. (ANSI)
     * @remarks
     * The <b>RtlIpv6AddressToString</b> function is used to convert an IPv6 address to the string representation of the IPv6 address in Internet standard format. 
     * 
     * The basic string representation consists of 8 hexadecimal numbers
     *     separated by colons. A string of consecutive zero numbers is replaced
     *     with a double-colon.
     *     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation
     *     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF. 
     * 
     * <b>RtlIpv6AddressToString</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6AddressToString</b> is defined to <b>RtlIpv6AddressToStringW</b>, the Unicode version of this function. The string parameter <i>S</i> and the function return value are defined to the PWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6AddressToString</b> is defined to <b>RtlIpv6AddressToStringA</b>, the ANSI version of this function. The string parameter <i>S</i> and the function return value are defined to the PSTR data type.
     * 
     * 
     * 
     * The <b>IN6_ADDR</b> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv6AddressToString</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6AddressToString</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv6AddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<IN6_ADDR>} Addr The IPv6 address in network byte order.
     * @param {Pointer<PSTR>} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv6 address. This buffer should be large enough to hold at least 46 characters.
     * @returns {Pointer<PSTR>} A pointer to the NULL character inserted at the end of the string representation of the IPv6 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringa
     * @since windows6.0.6000
     */
    static RtlIpv6AddressToStringA(Addr, S) {
        result := DllCall("ntdll.dll\RtlIpv6AddressToStringA", "ptr", Addr, "ptr", S, "ptr")
        return result
    }

    /**
     * Converts an IPv6 address, scope ID, and port number to a string. (ANSI)
     * @remarks
     * The <b>RtlIpv6AddressToStringEx</b> function is used to convert an IPv6 address, scope ID, and port number to the string representation of the IPv6 address in Internet format followed by a string representation of the scope ID followed by a string representation of the port. The scope ID and port number are optional parameters.
     * 
     * The basic string representation of the IPv6 address returned consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero hexadecimal numbers is replaced with a double colon. There can only be one double colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF.
     * 
     * If a scope ID is provided, the string representation of the scope ID is separated from the string representation of the IPv6 address by a percent character ('%'). If a port number is provided, the string representation of the IPv6 address and the scope ID are surrounded by square braces (a leading '[' character followed by the IPv6 address followed by a '% character followed by the scope ID with a trailing ']' character). The port number is represented as a colon following the right square brace character followed by the string representation of the port number in decimal.
     * 
     * <b>RtlIpv6AddressToStringEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion.
     * 
     * If the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IP address, scope ID, and port, <b>RtlIpv6AddressToStringEx</b> returns <b>ERROR_INVALID_PARAMETER</b> and sets the <i>AddressStringLength</i> parameter to the buffer length required.
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6AddressToStringEx</b> is defined to <b>RtlIpv6AddressToStringExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PWSTR data type.
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6AddressToStringEx</b> is defined to <b>RtlIpv6AddressToStringExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PSTR data type.
     * 
     * The <b>IN6_ADDR</b> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv6AddressToStringEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6AddressToStringEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<IN6_ADDR>} Address The IPv6 address in network byte order.
     * @param {Integer} ScopeId The scope ID of the IPv6 address in network byte order. This parameter is optional.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {Pointer<PSTR>} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IP address, scope ID, and port. This buffer should be large enough to hold at least INET6_ADDRSTRLEN characters. The INET6_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<UInt32>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     * 
     * On output, this parameter contains the number of characters actually written to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv6 address, scope ID, and port.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringexa
     */
    static RtlIpv6AddressToStringExA(Address, ScopeId, Port, AddressString, AddressStringLength) {
        result := DllCall("ntdll.dll\RtlIpv6AddressToStringExA", "ptr", Address, "uint", ScopeId, "ushort", Port, "ptr", AddressString, "ptr", AddressStringLength, "int")
        return result
    }

    /**
     * Converts an IPv6 address to a string in Internet standard format. (Unicode)
     * @remarks
     * The <b>RtlIpv6AddressToString</b> function is used to convert an IPv6 address to the string representation of the IPv6 address in Internet standard format. 
     * 
     * The basic string representation consists of 8 hexadecimal numbers
     *     separated by colons. A string of consecutive zero numbers is replaced
     *     with a double-colon.
     *     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation
     *     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF. 
     * 
     * <b>RtlIpv6AddressToString</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6AddressToString</b> is defined to <b>RtlIpv6AddressToStringW</b>, the Unicode version of this function. The string parameter <i>S</i> and the function return value are defined to the PWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6AddressToString</b> is defined to <b>RtlIpv6AddressToStringA</b>, the ANSI version of this function. The string parameter <i>S</i> and the function return value are defined to the PSTR data type.
     * 
     * 
     * 
     * The <b>IN6_ADDR</b> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv6AddressToString</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6AddressToString</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv6AddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<IN6_ADDR>} Addr The IPv6 address in network byte order.
     * @param {Pointer<PWSTR>} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv6 address. This buffer should be large enough to hold at least 46 characters.
     * @returns {Pointer<PWSTR>} A pointer to the NULL character inserted at the end of the string representation of the IPv6 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringw
     * @since windows6.0.6000
     */
    static RtlIpv6AddressToStringW(Addr, S) {
        result := DllCall("ntdll.dll\RtlIpv6AddressToStringW", "ptr", Addr, "ptr", S, "ptr")
        return result
    }

    /**
     * Converts an IPv6 address, scope ID, and port number to a string. (Unicode)
     * @remarks
     * The <b>RtlIpv6AddressToStringEx</b> function is used to convert an IPv6 address, scope ID, and port number to the string representation of the IPv6 address in Internet format followed by a string representation of the scope ID followed by a string representation of the port. The scope ID and port number are optional parameters. 
     * 
     * The basic string representation of the IPv6 address returned consists of 8 hexadecimal numbers
     *     separated by colons. A string of consecutive zero hexadecimal numbers is replaced
     *     with a double colon.
     *     There can only be one double colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation
     *     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF. 
     * 
     * If a scope ID is provided, the string representation of the scope ID is separated from the string representation of the IPv6 address by a percent character ('%'). If a port number is provided, the string representation of the IPv6 address and the scope ID are surrounded by square braces (a leading '[' character followed by the IPv6 address followed by a '% character followed by the scope ID with a trailing ']' character). The port number is represented as a colon following the right square brace character followed by the string representation of the port number in decimal.
     * 
     * <b>RtlIpv6AddressToStringEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform IP address to string conversion. 
     * 
     * If the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IP address, scope ID, and port, <b>RtlIpv6AddressToStringEx</b> returns <b>ERROR_INVALID_PARAMETER</b> and sets the <i>AddressStringLength</i> parameter to the buffer length required. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6AddressToStringEx</b> is defined to <b>RtlIpv6AddressToStringExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6AddressToStringEx</b> is defined to <b>RtlIpv6AddressToStringExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PSTR data type.
     * 
     * 
     * 
     * The <b>IN6_ADDR</b> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * An import library containing the <b>RtlIpv6AddressToStringEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6AddressToStringEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<IN6_ADDR>} Address The IPv6 address in network byte order.
     * @param {Integer} ScopeId The scope ID of the IPv6 address in network byte order. This parameter is optional.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {Pointer<PWSTR>} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IP address, scope ID, and port. This buffer should be large enough to hold at least INET6_ADDRSTRLEN characters. The INET6_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<UInt32>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     *         On output, this parameter contains the number of characters actually written
     *         to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv6 address, scope ID, and port. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringexw
     * @since windows6.0.6000
     */
    static RtlIpv6AddressToStringExW(Address, ScopeId, Port, AddressString, AddressStringLength) {
        result := DllCall("ntdll.dll\RtlIpv6AddressToStringExW", "ptr", Address, "uint", ScopeId, "ushort", Port, "ptr", AddressString, "ptr", AddressStringLength, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address to a binary IPv6 address. (ANSI)
     * @remarks
     * The <b>RtlIpv6StringToAddress</b> function is used to convert a string representation of the IPv6 address to an IPv6 address returned in network order (bytes ordered from
     *     left to right). 
     * 
     * <b>RtlIpv6StringToAddress</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. 
     * 
     * The string pointed to by the <i>S</i> parameter must be represented in the form for an IPv6 address string. The basic string representation of an IPv6 address consists of 8 hexadecimal numbers
     *     separated by colons. A string of consecutive zero numbers may be replaced
     *     with a double-colon.
     *     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation
     *     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF. 
     * 
     * On success, the <i>Terminator</i> parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains and IP address plus additional information to the <b>RtlIpv6StringToAddress</b> function and then parse the remaining information. 
     * 
     * <div class="alert"><b>Note</b>  Some malformed IPv6 addresses (::::, for example) start with a valid IPv6 address.  The <b>RtlIpv6StringToAddress</b> function will return success, having parsed the valid part of the IPv6 address as the double colon (::).  The terminator then points to the third colon.  To validate that the entire passed-in string is a valid IPv6 address, you need to ensure that the terminator points to the correct character. If the  <i>S</i> parameter contains only an  IPv6 address, then the terminator should point to the <b>NULL</b> character at the end of the string.</div>
     * <div> </div>
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6StringToAddress</b> is defined to <b>RtlIpv6StringToAddressW</b>, the Unicode version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the PCWSTR data type.
     * 
     * 
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6StringToAddress</b> is defined to <b>RtlIpv6StringToAddressA</b>, the ANSI version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the PCSTR data type.
     * 
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the In6addr.h header file.
     * 
     * An import library containing the <b>RtlIpv6StringToAddress</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6StringToAddress</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv6StringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address.
     * @param {Pointer<PSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN6_ADDR>} Addr A pointer where the binary representation of the IPv6 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressa
     * @since windows6.0.6000
     */
    static RtlIpv6StringToAddressA(S, Terminator, Addr) {
        result := DllCall("ntdll.dll\RtlIpv6StringToAddressA", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port. (ANSI)
     * @remarks
     * The <b>RtlIpv6StringToAddressEx</b> function is used to convert a string representation of the IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port number.  The IPv6 address is returned in network order (bytes ordered from left to right). The port number and scope ID are returned in network order.
     * 
     * <b>RtlIpv6StringToAddressEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion.
     * 
     * The string pointed to by the <i>AddressString</i> parameter must be represented in the form for an IPv6 address string followed by an optional percent character and scope ID string. The IPv6 address and scope ID string must be enclosed  in square brackets. The right square bracket after the IPv6 address and scope ID  string may be followed by an optional colon and a string representation of a port number. The basic string representation of an IPv6 address consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF.
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6StringToAddressEx</b> is defined to <b>RtlIpv6StringToAddressExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PCWSTR data type.
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6StringToAddressEx</b> is defined to <b>RtlIpv6StringToAddressExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PCSTR data type.
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the In6addr.h header file.
     * 
     * An import library containing the <b>RtlIpv6StringToAddressEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6StringToAddressEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<PSTR>} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address, scope ID, and port number.
     * @param {Pointer<IN6_ADDR>} Address A pointer where the binary representation of the IPv6 address is to be stored.
     * @param {Pointer<UInt32>} ScopeId A pointer to where scope ID of the IPv6 address is stored. If <i>AddressString</i> parameter does not contain the string representation of a scope ID, then zero is returned in this parameter.
     * @param {Pointer<UInt16>} Port A pointer where the port number is stored. The port number is in network byte order format. If <i>AddressString</i> parameter does not contain the string representation of a port number, then zero is returned in this parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the  <i>AddressString</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressexa
     */
    static RtlIpv6StringToAddressExA(AddressString, Address, ScopeId, Port) {
        result := DllCall("ntdll.dll\RtlIpv6StringToAddressExA", "ptr", AddressString, "ptr", Address, "ptr", ScopeId, "ptr", Port, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address to a binary IPv6 address. (Unicode)
     * @remarks
     * The <b>RtlIpv6StringToAddress</b> function is used to convert a string representation of the IPv6 address to an IPv6 address returned in network order (bytes ordered from
     *     left to right). 
     * 
     * <b>RtlIpv6StringToAddress</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. 
     * 
     * The string pointed to by the <i>S</i> parameter must be represented in the form for an IPv6 address string. The basic string representation of an IPv6 address consists of 8 hexadecimal numbers
     *     separated by colons. A string of consecutive zero numbers may be replaced
     *     with a double-colon.
     *     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation
     *     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF. 
     * 
     * On success, the <i>Terminator</i> parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains and IP address plus additional information to the <b>RtlIpv6StringToAddress</b> function and then parse the remaining information. 
     * 
     * <div class="alert"><b>Note</b>  Some malformed IPv6 addresses (::::, for example) start with a valid IPv6 address.  The <b>RtlIpv6StringToAddress</b> function will return success, having parsed the valid part of the IPv6 address as the double colon (::).  The terminator then points to the third colon.  To validate that the entire passed-in string is a valid IPv6 address, you need to ensure that the terminator points to the correct character. If the  <i>S</i> parameter contains only an  IPv6 address, then the terminator should point to the <b>NULL</b> character at the end of the string.</div>
     * <div> </div>
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6StringToAddress</b> is defined to <b>RtlIpv6StringToAddressW</b>, the Unicode version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the PCWSTR data type.
     * 
     * 
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6StringToAddress</b> is defined to <b>RtlIpv6StringToAddressA</b>, the ANSI version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the PCSTR data type.
     * 
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the In6addr.h header file.
     * 
     * An import library containing the <b>RtlIpv6StringToAddress</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6StringToAddress</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlIpv6StringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address.
     * @param {Pointer<PWSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN6_ADDR>} Addr A pointer where the binary representation of the IPv6 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressw
     * @since windows6.0.6000
     */
    static RtlIpv6StringToAddressW(S, Terminator, Addr) {
        result := DllCall("ntdll.dll\RtlIpv6StringToAddressW", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port. (Unicode)
     * @remarks
     * The <b>RtlIpv6StringToAddressEx</b> function is used to convert a string representation of the IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port number.  The IPv6 address is returned in network order (bytes ordered from
     *     left to right). The port number and scope ID are returned in network order. 
     * 
     * <b>RtlIpv6StringToAddressEx</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to IP address conversion. 
     * 
     * The string pointed to by the <i>AddressString</i> parameter must be represented in the form for an IPv6 address string followed by an optional percent character and scope ID string. The IPv6 address and scope ID string must be enclosed  in square brackets. The right square bracket after the IPv6 address and scope ID  string may be followed by an optional colon and a string representation of a port number. The basic string representation of an IPv6 address consists of 8 hexadecimal numbers
     *     separated by colons. A string of consecutive zero numbers may be replaced
     *     with a double-colon.
     *     There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation
     *     if the address is an IPv4-compatible address, an IPv4-mapped IPv6 address, or an ISATAP address. For more information, see section 5 of <a href="http://tools.ietf.org/html/rfc5952">RFC 5942</a> published by the IETF.
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlIpv6StringToAddressEx</b> is defined to <b>RtlIpv6StringToAddressExW</b>, the Unicode version of this function. The <i>AddressString</i> parameter is defined to the PCWSTR data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlIpv6StringToAddressEx</b> is defined to <b>RtlIpv6StringToAddressExA</b>, the ANSI version of this function. The <i>AddressString</i> parameter is defined to the PCSTR data type.
     * 
     * 
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the In6addr.h header file.
     * 
     * An import library containing the <b>RtlIpv6StringToAddressEx</b> function is not included in the Microsoft Windows Software Development Kit (SDK) released for Windows Vista. The <b>RtlIpv6StringToAddressEx</b> function is included in the <i>Ntdll.lib</i> import library included in the Windows Driver Kit (WDK). An application could also use the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> functions to retrieve the function pointer from the <i>Ntdll.dll</i> and call this function.
     * @param {Pointer<PWSTR>} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address, scope ID, and port number.
     * @param {Pointer<IN6_ADDR>} Address A pointer where the binary representation of the IPv6 address is to be stored.
     * @param {Pointer<UInt32>} ScopeId A pointer to where scope ID of the IPv6 address is stored. If <i>AddressString</i> parameter does not contain the string representation of a scope ID, then zero is returned in this parameter.
     * @param {Pointer<UInt16>} Port A pointer where the port number is stored. The port number is in network byte order format. If <i>AddressString</i> parameter does not contain the string representation of a port number, then zero is returned in this parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the  <i>AddressString</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressexw
     * @since windows6.0.6000
     */
    static RtlIpv6StringToAddressExW(AddressString, Address, ScopeId, Port) {
        result := DllCall("ntdll.dll\RtlIpv6StringToAddressExW", "ptr", AddressString, "ptr", Address, "ptr", ScopeId, "ptr", Port, "int")
        return result
    }

    /**
     * Converts a binary Ethernet address to a string representation of the Ethernet MAC address. (ANSI)
     * @remarks
     * The <b>RtlEthernetAddressToString</b> function is used to convert a binary Ethernet address to the string representation of the Ethernet address in Ethernet EUI-48 data-link layer address format (also commonly known as a MAC address). The string represents a numeric Ethernet address
     *     expressed in the non-DIX standard "-'' notation.
     * 
     * The string returned in the <i>S</i> parameter is represented in the form for an Ethernet MAC address string in the non-DIX standard "-" notation. The basic string representation of an Ethernet MAC address consists of 6 pairs of hexadecimal numbers
     *     separated by dashes (F4-CE-46-2D-90-8C, for example). 
     * 
     * <b>RtlEthernetAddressToString</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to Ethernet address conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlEthernetAddressToString</b> is defined to <b>RtlEthernetAddressToStringW</b>, the Unicode version of this function. The string parameter <i>S</i> and the function return value are defined to the <b>PWSTR</b> data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlEthernetAddressToString</b> is defined to <b>RtlEthernetAddressToStringA</b>, the ANSI version of this function. The string parameter <i>S</i> and the function return value are defined to the <b>PSTR</b> data type.
     * 
     * 
     * 
     * The <b>DL_EUI48</b> data type is defined in the <i>Mstcpip.h</i>  header file.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlEthernetAddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DL_EUI48>} Addr The Ethernet address in binary format. The Ethernet address is in network order (bytes ordered from
     *     left to right).
     * @param {Pointer<PSTR>} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the Ethernet address. This buffer should be large enough to hold at least 18 characters.
     * @returns {Pointer<PSTR>} A pointer to the NULL character inserted at the end of the string representation of the Ethernet MAC address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlethernetaddresstostringa
     * @since windows6.1
     */
    static RtlEthernetAddressToStringA(Addr, S) {
        result := DllCall("ntdll.dll\RtlEthernetAddressToStringA", "ptr", Addr, "ptr", S, "ptr")
        return result
    }

    /**
     * Converts a binary Ethernet address to a string representation of the Ethernet MAC address. (Unicode)
     * @remarks
     * The <b>RtlEthernetAddressToString</b> function is used to convert a binary Ethernet address to the string representation of the Ethernet address in Ethernet EUI-48 data-link layer address format (also commonly known as a MAC address). The string represents a numeric Ethernet address
     *     expressed in the non-DIX standard "-'' notation.
     * 
     * The string returned in the <i>S</i> parameter is represented in the form for an Ethernet MAC address string in the non-DIX standard "-" notation. The basic string representation of an Ethernet MAC address consists of 6 pairs of hexadecimal numbers
     *     separated by dashes (F4-CE-46-2D-90-8C, for example). 
     * 
     * <b>RtlEthernetAddressToString</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to Ethernet address conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlEthernetAddressToString</b> is defined to <b>RtlEthernetAddressToStringW</b>, the Unicode version of this function. The string parameter <i>S</i> and the function return value are defined to the <b>PWSTR</b> data type.
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlEthernetAddressToString</b> is defined to <b>RtlEthernetAddressToStringA</b>, the ANSI version of this function. The string parameter <i>S</i> and the function return value are defined to the <b>PSTR</b> data type.
     * 
     * 
     * 
     * The <b>DL_EUI48</b> data type is defined in the <i>Mstcpip.h</i>  header file.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlEthernetAddressToString as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<DL_EUI48>} Addr The Ethernet address in binary format. The Ethernet address is in network order (bytes ordered from
     *     left to right).
     * @param {Pointer<PWSTR>} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the Ethernet address. This buffer should be large enough to hold at least 18 characters.
     * @returns {Pointer<PWSTR>} A pointer to the NULL character inserted at the end of the string representation of the Ethernet MAC address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlethernetaddresstostringw
     * @since windows6.1
     */
    static RtlEthernetAddressToStringW(Addr, S) {
        result := DllCall("ntdll.dll\RtlEthernetAddressToStringW", "ptr", Addr, "ptr", S, "ptr")
        return result
    }

    /**
     * Converts a string representation of an Ethernet MAC address to a binary format of the Ethernet address. (ANSI)
     * @remarks
     * The <b>RtlEthernetStringToAddress</b> function is used to convert a string representation of an Ethernet EUI-48 data-link layer address (also commonly known as a MAC address) to binary format of the Ethernet address. The string represents a numeric Ethernet address
     *     expressed in the non-DIX standard "-'' notation.  The value
     *     returned is a number suitable for use as an Ethernet address.  All
     *     Ethernet addresses are returned in network order (bytes ordered from
     *     left to right).
     * 
     * 
     * The string pointed to by the <i>S</i> parameter must be represented in the form for an Ethernet MAC address string in the non-DIX standard "-" notation. The basic string representation of an Ethernet MAC address consists of 6 pairs of hexadecimal numbers
     *     separated by dashes (F4-CE-46-2D-90-8C, for example). 
     * 
     * On success, the <i>Terminator</i> parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains an Ethernet address plus additional information to the <b>RtlEthernetStringToAddress</b> function and then parse the remaining information. 
     * 
     * <b>RtlEthernetStringToAddress</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to Ethernet address conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlEthernetStringToAddress</b> is defined to <b>RtlEthernetStringToAddressW</b>, the Unicode version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the <b>PCWSTR</b> data type.
     * 
     * 
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlEthernetStringToAddress</b> is defined to <b>RtlEthernetStringToAddressA</b>, the ANSI version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the <b>PCSTR</b> data type.
     * 
     * 
     * 
     * The <b>DL_EUI48</b> data type is defined in the <i>Mstcpip.h</i>  header file.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlEthernetStringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the Ethernet MAC  address.
     * @param {Pointer<PSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<DL_EUI48>} Addr A pointer where the binary representation of the Ethernet MAC address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an Ethernet MAC address.
     * 
     * This error code is defined in the <i>Ntstatus.h</i> header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlethernetstringtoaddressa
     * @since windows6.1
     */
    static RtlEthernetStringToAddressA(S, Terminator, Addr) {
        result := DllCall("ntdll.dll\RtlEthernetStringToAddressA", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an Ethernet MAC address to a binary format of the Ethernet address. (Unicode)
     * @remarks
     * The <b>RtlEthernetStringToAddress</b> function is used to convert a string representation of an Ethernet EUI-48 data-link layer address (also commonly known as a MAC address) to binary format of the Ethernet address. The string represents a numeric Ethernet address
     *     expressed in the non-DIX standard "-'' notation.  The value
     *     returned is a number suitable for use as an Ethernet address.  All
     *     Ethernet addresses are returned in network order (bytes ordered from
     *     left to right).
     * 
     * 
     * The string pointed to by the <i>S</i> parameter must be represented in the form for an Ethernet MAC address string in the non-DIX standard "-" notation. The basic string representation of an Ethernet MAC address consists of 6 pairs of hexadecimal numbers
     *     separated by dashes (F4-CE-46-2D-90-8C, for example). 
     * 
     * On success, the <i>Terminator</i> parameter points to the character that terminated the string that was converted. This allows an application to pass a string that contains an Ethernet address plus additional information to the <b>RtlEthernetStringToAddress</b> function and then parse the remaining information. 
     * 
     * <b>RtlEthernetStringToAddress</b> is a convenience function that does not require that the Windows Sockets DLL be loaded to access a function provided in Windows Sockets to perform string to Ethernet address conversion. 
     * 
     * When either UNICODE or _UNICODE is defined, <b>RtlEthernetStringToAddress</b> is defined to <b>RtlEthernetStringToAddressW</b>, the Unicode version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the <b>PCWSTR</b> data type.
     * 
     * 
     * 
     * 
     * 
     * When both UNICODE and _UNICODE are not defined, <b>RtlEthernetStringToAddress</b> is defined to <b>RtlEthernetStringToAddressA</b>, the ANSI version of this function. The <i>S</i> and <i>Terminator</i> parameters are defined to the <b>PCSTR</b> data type.
     * 
     * 
     * 
     * The <b>DL_EUI48</b> data type is defined in the <i>Mstcpip.h</i>  header file.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ip2string.h header defines RtlEthernetStringToAddress as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the Ethernet MAC  address.
     * @param {Pointer<PWSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<DL_EUI48>} Addr A pointer where the binary representation of the Ethernet MAC address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an Ethernet MAC address.
     * 
     * This error code is defined in the <i>Ntstatus.h</i> header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ip2string/nf-ip2string-rtlethernetstringtoaddressw
     * @since windows6.1
     */
    static RtlEthernetStringToAddressW(S, Terminator, Addr) {
        result := DllCall("ntdll.dll\RtlEthernetStringToAddressW", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * The WSARecvEx function (mswsock.h) receives data from a connected socket or a bound connectionless socket.
     * @remarks
     * The 
     * <b>WSARecvEx</b> function that is part of the Microsoft implementation of Windows Sockets 2 is similar to the more common 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function except that the <i>flags</i> parameter is used for a single specific purpose. The <i>flags</i> parameter is used to indicate whether a partial or complete message is received when a message-oriented protocol is being used. 
     * 
     * The value pointed to by the <i>flags</i> parameter is ignored on input. So no flags can be passed to the  <b>WSARecvEx</b> function to modify its behavior. The value pointed to by the <i>flags</i> parameter is set on output. This differs from the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> and <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> functions where the  value pointed to by the <i>flags</i> parameter on input can modify the behavior of the function.
     * 
     * The 
     * <b>WSARecvEx</b> and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> functions behave identically for stream-oriented protocols.
     * 
     * The <i>flags</i> parameter accommodates two common situations in which a partial message will be received:
     * 
     * <ul>
     * <li>When the application's data buffer size is smaller than the message size and the message coincidentally arrives in two pieces.</li>
     * <li>When the message is rather large and must arrive in several pieces.</li>
     * </ul>
     * The MSG_PARTIAL bit is set in the value pointed to by the <i>flags</i> parameter on return from 
     * <b>WSARecvEx</b> when a partial message was received. If a complete message was received, MSG_PARTIAL is not set in the value pointed to by the <i>flags</i> parameter.
     * 
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function is different from the  
     * <b>WSARecvEx</b> and <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> functions in that the 
     * <b>recv</b> function always receives a single message for each call for message-oriented transport protocols. The 
     * <b>recv</b> function also does not have a means to indicate to the application that the data received is only a partial message. An application must build its own protocol for checking whether a message is partial or complete by checking for the error code 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a> after each call to 
     * <b>recv</b>. When the application buffer is smaller than the data being sent, as much of the message as will fit is copied into the user's buffer and 
     * <b>recv</b> returns with the error code WSAEMSGSIZE. A subsequent call to 
     * <b>recv</b> will get the next part of the message.
     * 
     * Applications written for message-oriented transport protocols should be coded for this possibility if message sizing is not guaranteed by the application's data transfer protocol. An application can use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a> and manage the protocol itself. Alternatively, an application can use 
     * <b>WSARecvEx</b> and check that the MSG_PARTIAL bit is set in the <i>flags</i> parameter.
     * 
     * The 
     * <b>WSARecvEx</b> function provides the developer with a more effective way of checking whether a message received is partial or complete when a very large message arrives incrementally. For example, if an application sends a one-megabyte message, the transport protocol must break up the message in order to send it over the physical network. It is theoretically possible for the transport protocol on the receiving side to buffer all the data in the message, but this would be quite expensive in terms of resources. Instead, 
     * <b>WSARecvEx</b> can be used, minimizing overhead and eliminating the need for an application-based protocol.
     * 
     * <div class="alert"><b>Note</b>   All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. See the <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> function for more information.</div>
     * <div> </div>
     * @param {Pointer} s A descriptor that identifies a connected socket.
     * @param {Pointer<PSTR>} buf A pointer to the buffer to receive the incoming data.
     * @param {Integer} len The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
     * @param {Pointer<Int32>} flags An indicator specifying whether the message is fully or partially received for datagram sockets.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/mswsock/nf-mswsock-wsarecvex
     * @deprecated
     * @since windows5.0
     */
    static WSARecvEx(s, buf, len, flags) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\WSARecvEx", "ptr", s, "ptr", buf, "int", len, "ptr", flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The TransmitFile function (mswsock.h) transmits file data over a connected socket handle.
     * @remarks
     * The <b>TransmitFile</b> function uses the operating system's cache manager to retrieve the file data, and provide high-performance file data transfer over sockets.
     * 
     * The <b>TransmitFile</b> function only supports connection-oriented sockets of type <b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>, and <b>SOCK_RDM</b>. Sockets of type <b>SOCK_DGRAM</b> and <b>SOCK_RAW</b> are not supported. The <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_transmitpackets">TransmitPackets</a> function can be used with sockets of type <b>SOCK_DGRAM</b>. 
     * 
     * The maximum number of bytes that can be transmitted using a single call to the <b>TransmitFile</b> function is 2,147,483,646, the maximum value for a 32-bit integer minus 1. The maximum number of bytes to send in a single call includes any  data sent before or after the file data pointed to by the <i>lpTransmitBuffers</i> parameter plus the value specified in the <i>nNumberOfBytesToWrite</i> parameter for the length of file data to send. If an application needs to transmit a file larger than 2,147,483,646 bytes, then multiple calls to the <b>TransmitFile</b> function can be used with each call transferring no more than 2,147,483,646 bytes. Setting the <i>nNumberOfBytesToWrite</i> parameter to zero for a file larger than 2,147,483,646 bytes will also fail since in this case the <b>TransmitFile</b> function will use the size of the file as the value for the number of bytes to transmit.
     * 
     * 
     * <div class="alert"><b>Note</b>  The function pointer for the 
     * <b>TransmitFile</b> function must be obtained at run time by making a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with the <b>SIO_GET_EXTENSION_FUNCTION_POINTER</b> opcode specified. The input buffer passed to the <b>WSAIoctl</b> function must contain <b>WSAID_TRANSMITFILE</b>, a globally unique identifier (GUID) whose value identifies the <b>TransmitFile</b> extension function. On success, the output returned by the <b>WSAIoctl</b> function contains a pointer to the <b>TransmitFile</b> function. The <b>WSAID_TRANSMITFILE</b> GUID is defined in the <i>Mswsock.h</i> header file.</div>
     * <div> </div>
     * 
     * 
     * <div class="alert"><b>Note</b>  <b>TransmitFile</b> is not functional on transports that perform their own buffering. Transports with the TDI_SERVICE_INTERNAL_BUFFERING flag set, such as ADSP, perform their own buffering. Because 
     * <b>TransmitFile</b> achieves its performance gains by sending data directly from the file cache. Transports that run out of buffer space on a particular connection are not handled by 
     * <b>TransmitFile</b>, and as a result of running out of buffer space on the connection, 
     * <b>TransmitFile</b> returns STATUS_DEVICE_NOT_READY.</div>
     * <div> </div>
     * The <b>TransmitFile</b> function was primarily added to Winsock for use by high-performance server applications (web and ftp servers, for example). 
     * 
     * Workstation and client versions of Windows optimize the <b>TransmitFile</b> function for minimum memory and resource utilization by limiting the number of concurrent <b>TransmitFile</b> operations allowed on the system to a maximum of two. On Windows Vista,  Windows XP,
     *   Windows 2000 Professional, and 
     *   Windows NT Workstation 3.51 and later only two outstanding <b>TransmitFile</b> requests are handled simultaneously; the third request will wait until one of the previous requests is completed. 
     * 
     * Server versions of Windows optimize the 
     * <b>TransmitFile</b> function for high performance.  On server versions, there are no default limits placed on the number of concurrent <b>TransmitFile</b> operations allowed on the system. Expect better performance results when using 
     * <b>TransmitFile</b> on server versions of Windows. On server versions of Windows, it is possible to set a limit on the maximum number of concurrent <b>TransmitFile</b> operations by creating a registry entry and setting a value for the following <b>REG_DWORD</b>:
     * 
     * 
     * <b>HKEY_LOCAL_MACHINE</b>&#92;<b>CurrentControlSet</b>&#92;<b>Services</b>&#92;<b>AFD</b>&#92;<b>Parameters</b>&#92;<b>MaxActiveTransmitFileCount</b>
     * 
     * 
     * 
     * If the <b>TransmitFile</b> function is called with TCP socket (protocol of IPPROTO_TCP) with both the <b>TF_DISCONNECT</b> and <b>TF_REUSE_SOCKET</b> flags specified, the call will not complete until the two following conditions are met.<ul>
     * <li>All pending receive data sent by remote side (received prior to a FIN from the remote side) on the TCP socket has been read.
     * </li>
     * <li> The remote side has closed the connection (completed the graceful TCP connection closure).</li>
     * </ul>
     * 
     * 
     * If the <b>TransmitFile</b> function is called with the <i>lpOverlapped</i> parameter set to <b>NULL</b>, the operation is executed as synchronous I/O. The function will not complete until the file has been sent. 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * <h3><a id="Notes_for_QoS"></a><a id="notes_for_qos"></a><a id="NOTES_FOR_QOS"></a>Notes for QoS</h3>
     * The 
     * <b>TransmitFile</b> function allows the setting of two flags, TF_DISCONNECT or TF_REUSE_SOCKET, that return the socket to a "disconnected, reusable" state after the file has been transmitted. These flags should not be used on a socket where quality of service has been requested, since the service provider may immediately delete any quality of service associated with the socket before the file transfer has completed. The best approach for a QoS-enabled socket is to simply call the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a> function when the file transfer has completed, rather than relying on these flags.
     * @param {Pointer} hSocket A handle to a connected socket. The 
     * <b>TransmitFile</b> function will transmit the file data over this socket. The socket specified by the <i>hSocket</i> parameter must be a connection-oriented socket of type <b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>, or <b>SOCK_RDM</b>.
     * @param {Pointer<HANDLE>} hFile A handle to the open file that the 
     * <b>TransmitFile</b> function transmits. Since the operating system reads the file data sequentially, you can improve caching performance by opening the handle with FILE_FLAG_SEQUENTIAL_SCAN. 
     * 
     * The <i>hFile</i> parameter is optional. If the <i>hFile</i> parameter is <b>NULL</b>, only data in the header and/or the tail buffer is transmitted. Any additional action, such as socket disconnect or reuse, is performed as specified by the <i>dwFlags</i> parameter.
     * @param {Integer} nNumberOfBytesToWrite The number of bytes in the file to transmit. The 
     * <b>TransmitFile</b> function completes when it has sent the specified number of bytes, or when an error occurs, whichever occurs first. 
     * 
     * 
     * 
     * 
     * Set this parameter to zero in order to transmit the entire file.
     * @param {Integer} nNumberOfBytesPerSend The size, in bytes, of each block of data sent in each send operation. This parameter is used by Windows' sockets layer to determine the block size for send operations. To select the default send size, set this parameter to zero.
     * 
     * The <i>nNumberOfBytesPerSend</i> parameter is useful for protocols that have limitations on the size of individual send requests.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If the socket handle has been opened as overlapped, specify this parameter in order to achieve an overlapped (asynchronous) I/O operation. By default, socket handles are opened as overlapped. 
     * 
     * 
     * 
     * 
     * You can use the <i>lpOverlapped</i> parameter to specify a 64-bit offset within the file at which to start the file data transfer by setting the <b>Offset</b> and <b>OffsetHigh</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If <i>lpOverlapped</i> is a <b>NULL</b> pointer, the transmission of data always starts at the current byte offset in the file.
     * 
     * When the <i>lpOverlapped</i> is not <b>NULL</b>, the overlapped I/O might not finish before 
     * <b>TransmitFile</b> returns. In that case, the 
     * <b>TransmitFile</b> function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> returns ERROR_IO_PENDING or <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a>. This enables the caller to continue processing while the file transmission operation completes. Windows will set the event specified by the <b>hEvent</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, or the socket specified by <i>hSocket</i>, to the signaled state upon completion of the data transmission request.
     * @param {Pointer<TRANSMIT_FILE_BUFFERS>} lpTransmitBuffers A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/ns-mswsock-transmit_file_buffers">TRANSMIT_FILE_BUFFERS</a> data structure that contains pointers to data to send before and after the file data is sent. This parameter should be set to a <b>NULL</b> pointer if you want to transmit only the file data.
     * @param {Integer} dwReserved A set of flags used to modify the behavior of the <b>TransmitFile</b> function call. The <i>dwFlags</i> parameter can contain a combination of the following options defined in the <i>Mswsock.h</i> header file: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_DISCONNECT"></a><a id="tf_disconnect"></a><dl>
     * <dt><b>TF_DISCONNECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Start a transport-level disconnect after all the file data has been queued for transmission.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_REUSE_SOCKET"></a><a id="tf_reuse_socket"></a><dl>
     * <dt><b>TF_REUSE_SOCKET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Prepare the socket handle to be reused. This flag is valid only if <b>TF_DISCONNECT</b> is also specified.
     * 
     * When the <b>TransmitFile</b> request completes, the socket handle can be passed to the 
     * function call previously used to establish the connection, such as <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>  or <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>. Such reuse is mutually exclusive; for example, if the <b>AcceptEx</b> function was called for the socket, reuse is allowed only for subsequent calls to the <b>AcceptEx</b>  function, and not allowed for a subsequent call to <b>ConnectEx</b>. 
     * 
     * <div class="alert"><b>Note</b>  The socket level file transmit is subject to the behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing  the <b>TransmitFile</b> call to be delayed.</div>
     * <div> </div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_USE_DEFAULT_WORKER"></a><a id="tf_use_default_worker"></a><dl>
     * <dt><b>TF_USE_DEFAULT_WORKER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Directs the Windows Sockets service provider to use the system's default thread to process long <b>TransmitFile</b> requests. The system default thread can be adjusted using the following registry parameter as a <b>REG_DWORD</b>:
     * 
     * 
     * <b>HKEY_LOCAL_MACHINE</b>&#92;<b>CurrentControlSet</b>&#92;<b>Services</b>&#92;<b>AFD</b>&#92;<b>Parameters</b>&#92;<b>TransmitWorker</b>
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_USE_SYSTEM_THREAD"></a><a id="tf_use_system_thread"></a><dl>
     * <dt><b>TF_USE_SYSTEM_THREAD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Directs the Windows Sockets service provider to use system threads to process long 
     * <b>TransmitFile</b> requests.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_USE_KERNEL_APC"></a><a id="tf_use_kernel_apc"></a><dl>
     * <dt><b>TF_USE_KERNEL_APC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Directs the driver to use kernel asynchronous procedure calls (APCs) instead of worker threads to process long 
     * <b>TransmitFile</b> requests. Long <b>TransmitFile</b> requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.
     * 
     * Use of TF_USE_KERNEL_APC can deliver significant performance benefits. It is possible (though unlikely), however, that the thread in which context 
     * <b>TransmitFile</b> is initiated is being used for heavy computations; this situation may prevent APCs from launching. Note that the Winsock kernel mode driver uses normal kernel APCs, which launch whenever a thread is in a wait state, which differs from user-mode APCs, which launch whenever a thread is in an alertable wait state initiated in user mode).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_WRITE_BEHIND"></a><a id="tf_write_behind"></a><dl>
     * <dt><b>TF_WRITE_BEHIND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Complete the 
     * <b>TransmitFile</b> request immediately, without pending. If this flag is specified and 
     * <b>TransmitFile</b> succeeds, then the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this setting with the TF_DISCONNECT and TF_REUSE_SOCKET flags.
     * 
     * <div class="alert"><b>Note</b>  If the file being sent is not in the file system cache, the request  pends.</div>
     * <div> </div>
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the 
     * <b>TransmitFile</b> function succeeds, the return value is <b>TRUE</b>. Otherwise, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. An error code 
     * of <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a> or ERROR_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur. Applications should handle either ERROR_IO_PENDING or WSA_IO_PENDING in this case.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An established connection was aborted by the software in your host machine. This error is returned if the virtual circuit was terminated due to a time-out or other failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An existing connection was forcibly closed by the remote host. This error is returned for a stream socket when the virtual circuit was reset by the remote side. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned if the <i>lpTransmitBuffers</i> or <i>lpOverlapped</i> parameter is not totally contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied. This error is returned if the <i>hSocket</i> parameter specified a socket of type <b>SOCK_DGRAM</b> or <b>SOCK_RAW</b>. This error is returned if the <i>dwFlags</i> parameter has the  <b>TF_REUSE_SOCKET</b> flag set, but the <b>TF_DISCONNECT</b> flag was not set. This error is also returned if the offset specified in the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure pointed to by the <i>lpOverlapped</i> is not within the file. This error is also returned if the <i>nNumberOfBytesToWrite</i> parameter is set to a value greater than  2,147,483,646, the maximum value for a 32-bit integer minus 1.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation encountered a dead network.This error is returned if the network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. This error is also returned if the Windows Sockets provider reports a buffer deadlock.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A request to send or receive data was disallowed because the socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation was attempted on something that is not a socket. This error is returned if the <i>hSocket</i> parameter is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call. This error is returned if the socket has been shut down for sending. It is not possible to 
     * call <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> on a socket after 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> function has been called on the socket with the <i>how</i> parameter set to <b>SD_SEND</b> or <b>SD_BOTH</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the application has not called the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function, or <b>WSAStartup</b> failed. A successful 
     * <b>WSAStartup</b> call must occur before using the <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped I/O operation is in progress. This value is returned if an overlapped I/O operation was successfully initiated and indicates that completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The I/O operation has been aborted because of either a thread exit or an application request. This error is returned if the overlapped operation has been canceled due to the closure of the socket, the execution of the "SIO_FLUSH" command in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>, or the thread that initiated the overlapped request exited before the operation completed.
     * 
     * <div class="alert"><b>Note</b>  All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  asynchronous operations complete. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a>.</div>
     * <div> </div>
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/mswsock/nf-mswsock-transmitfile
     * @since windows8.1
     */
    static TransmitFile(hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved) {
        result := DllCall("MSWSOCK.dll\TransmitFile", "ptr", hSocket, "ptr", hFile, "uint", nNumberOfBytesToWrite, "uint", nNumberOfBytesPerSend, "ptr", lpOverlapped, "ptr", lpTransmitBuffers, "uint", dwReserved, "int")
        return result
    }

    /**
     * The AcceptEx function (mswsock.h) accepts a new connection, returns the local and remote address, and receives the first block of data sent by the client application.
     * @remarks
     * The 
     * <b>AcceptEx</b> function combines several socket functions into a single API/kernel transition. The 
     * <b>AcceptEx</b> function, when successful, performs three tasks:
     * 
     * <ul>
     * <li>A new connection is accepted.</li>
     * <li>Both the local and remote addresses for the connection are returned.</li>
     * <li>The first block of data sent by the remote is received.</li>
     * </ul>
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>  The function pointer for the 
     * <b>AcceptEx</b> function must be obtained at run time by making a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with the <b>SIO_GET_EXTENSION_FUNCTION_POINTER</b> opcode specified. The input buffer passed to the <b>WSAIoctl</b> function must contain <b>WSAID_ACCEPTEX</b>, a globally unique identifier (GUID) whose value identifies the <b>AcceptEx</b> extension function. On success, the output returned by the <b>WSAIoctl</b> function contains a pointer to the <b>AcceptEx</b> function. The <b>WSAID_ACCEPTEX</b> GUID is defined in the <i>Mswsock.h</i> header file.</div>
     * <div> </div>
     * 
     * 
     * A program can make a connection to a socket more quickly using 
     * <b>AcceptEx</b> instead of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function.
     * 
     * A single output buffer receives the data, the local socket address (the server), and the remote socket address (the client).
     * 
     * Using a single buffer improves performance. When using 
     * <b>AcceptEx</b>, the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-getacceptexsockaddrs">GetAcceptExSockaddrs</a> function must be called to parse the buffer into its three distinct parts (data, local socket address, and remote socket address). On Windows XP and later, once the 
     * <b>AcceptEx</b> function completes and the <b>SO_UPDATE_ACCEPT_CONTEXT</b> option is set on the accepted socket, the local address associated with the accepted socket can also be retrieved using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function. Likewise, the remote address associated with the accepted socket can be retrieved using the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getpeername">getpeername</a> function.
     * 
     * The buffer size for the local and remote address must be 16 bytes more than the size of the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the transport protocol in use because the addresses are written in an internal format. For example, the size of a <b>sockaddr_in</b> (the address structure for TCP/IP) is 16 bytes. Therefore, a buffer size of at least 32 bytes must be specified for the local and remote addresses.
     * 
     * The 
     * <b>AcceptEx</b> function uses overlapped I/O, unlike the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function. If your application uses 
     * <b>AcceptEx</b>, it can service a large number of clients with a relatively small number of threads. As with all overlapped Windows functions, either Windows events or completion ports can be used as a completion notification mechanism.
     * 
     * 
     * Another key difference between the 
     * <b>AcceptEx</b> function and the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> function is that 
     * <b>AcceptEx</b> requires the caller to already have two sockets:
     * 
     * <ul>
     * <li>One that specifies the socket on which to listen.</li>
     * <li>One that specifies the socket on which to accept the connection.</li>
     * </ul>
     * 
     * 
     * The <i>sAcceptSocket</i> parameter must be an open socket that is neither bound nor connected.
     * 
     * The <i>lpNumberOfBytesTransferred</i> parameter of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> function or the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> function indicates the number of bytes received in the request.
     * 
     * 
     * When this operation is successfully completed, <i>sAcceptSocket</i> can be passed, but to the following functions only:
     * 
     * <dl>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-readfile">ReadFile</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-send">send</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>
     * </dd>
     * <dd>
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a>(only for SO_UPDATE_ACCEPT_CONTEXT)</dd>
     * </dl>
     * <div class="alert"><b>Note</b>  If the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> function is called with both the TF_DISCONNECT and TF_REUSE_SOCKET flags, the specified socket has been returned to a state in which it is neither bound nor connected. The socket handle can then be passed to the 
     * <b>AcceptEx</b> function in the <i>sAcceptSocket</i> parameter, but the socket cannot be passed to the <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a> function.</div>
     * <div> </div>
     * 
     * 
     * When the 
     * <b>AcceptEx</b> function returns, the socket <i>sAcceptSocket</i> is in the default state for a connected socket. The socket <i>sAcceptSocket</i> does not inherit the properties of the socket associated with <i>sListenSocket</i> parameter until SO_UPDATE_ACCEPT_CONTEXT is set on the socket. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function to set the SO_UPDATE_ACCEPT_CONTEXT option, specifying <i>sAcceptSocket</i> as the socket handle and <i>sListenSocket</i> as the option value.
     * 
     * For example:
     * 
     * 
     * ```cpp
     * //Need to #include <mswsock.h> for SO_UPDATE_ACCEPT_CONTEXT
     * 
     * int iResult = 0;
     * 
     * iResult =  setsockopt( sAcceptSocket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT, 
     *     (char *)&sListenSocket, sizeof(sListenSocket) );
     *    
     * 
     * ```
     * 
     * 
     * If a receive buffer is provided, the overlapped operation will not complete until a connection is accepted and data is read. Use the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> function with the SO_CONNECT_TIME option to check whether a connection has been accepted. If it has been accepted, you can determine how long the connection has been established. The return value is the number of seconds that the socket has been connected. If the socket is not connected, the 
     * <b>getsockopt</b> returns 0xFFFFFFFF. Applications that check whether the overlapped operation has completed, in combination with the SO_CONNECT_TIME option, can determine that a connection has been accepted but no data has been received. Scrutinizing a connection in this manner enables an application to determine whether connections that have been established for a while have received no data. It is recommended such connections be terminated by closing the accepted socket, which forces the 
     * <b>AcceptEx</b> function call to complete with an error.
     * 
     * For example:
     * 
     * 
     * ```cpp
     * 
     * INT seconds;
     * INT bytes = sizeof(seconds);
     * int iResult = 0;
     * 
     * iResult = getsockopt( sAcceptSocket, SOL_SOCKET, SO_CONNECT_TIME,
     *                       (char *)&seconds, (PINT)&bytes );
     * 
     * if ( iResult != NO_ERROR ) {
     *     printf( "getsockopt(SO_CONNECT_TIME) failed: %u\n", WSAGetLastError( ) );
     *     exit(1);
     * }
     * 
     * ```
     * 
     * 
     * 
     * <div class="alert"><b>Note</b>   All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  operations complete. See <a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a> for more information.</div>
     * <div> </div>
     * 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example uses the <b>AcceptEx</b> function using overlapped I/O and completion ports.
     * 
     * 
     * ```cpp
     * @param {Pointer} sListenSocket A descriptor identifying a socket that has already been called with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function. A server application waits for attempts to connect on this socket.
     * @param {Pointer} sAcceptSocket A descriptor identifying a socket on which to accept an incoming connection. This socket must not be bound or connected.
     * @param {Pointer<Void>} lpOutputBuffer A pointer to a buffer that receives the first block of data sent on a new connection, the local address of the server, and the remote address of the client. The receive data is written to the first part of the buffer starting at offset zero, while the addresses are written to the latter part of the buffer. This parameter must be specified.
     * @param {Integer} dwReceiveDataLength The number of bytes in <i>lpOutputBuffer</i> that will be used for actual receive data at the beginning of the buffer. This size should not include the size of the local address of the server, nor the remote address of the client; they are appended to the output buffer. If <i>dwReceiveDataLength</i> is zero, accepting the connection will not result in a receive operation. Instead, 
     * <b>AcceptEx</b> completes as soon as a connection arrives, without waiting for any data.
     * @param {Integer} dwLocalAddressLength The number of bytes reserved for the local address information. This value must be at least 16 bytes more than the maximum address length for the transport protocol in use.
     * @param {Integer} dwRemoteAddressLength The number of bytes reserved for the remote address information. This value must be at least 16 bytes more than the maximum address length for the transport protocol in use. Cannot be zero.
     * @param {Pointer<UInt32>} lpdwBytesReceived A pointer to a <b>DWORD</b> that receives the count of bytes received. This parameter is set only if the operation completes synchronously. If it returns ERROR_IO_PENDING and is completed later, then this <b>DWORD</b> is never set and you must obtain the number of bytes read from the completion notification mechanism.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An 
     * <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is used to process the request. This parameter must be specified; it cannot be <b>NULL</b>.
     * @returns {Integer} If no error occurs, the 
     * <b>AcceptEx</b> function completed successfully and a value of <b>TRUE</b> is returned.
     * 
     * If the function fails, 
     * <b>AcceptEx</b> returns <b>FALSE</b>. The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function can then be called to return extended error information. If 
     * <b>WSAGetLastError</b> returns <b>ERROR_IO_PENDING</b>, then the operation was successfully initiated and is still in progress. If the error is WSAECONNRESET, an incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.
     * @see https://learn.microsoft.com/windows/win32/api/mswsock/nf-mswsock-acceptex
     * @since windows8.1
     */
    static AcceptEx(sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped) {
        result := DllCall("MSWSOCK.dll\AcceptEx", "ptr", sListenSocket, "ptr", sAcceptSocket, "ptr", lpOutputBuffer, "uint", dwReceiveDataLength, "uint", dwLocalAddressLength, "uint", dwRemoteAddressLength, "ptr", lpdwBytesReceived, "ptr", lpOverlapped, "int")
        return result
    }

    /**
     * The GetAcceptExSockaddrs function (mswsock.h) parses data obtained from a call to the AcceptEx function and passes local and remote addresses to a sockaddr structure.
     * @remarks
     * The 
     * <b>GetAcceptExSockaddrs</b> function is used exclusively with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> function to parse the first data that the socket receives into local and remote addresses. The 
     * <b>AcceptEx</b> function returns local and remote address information in an internal format. Application developers need to use the <b>GetAcceptExSockaddrs</b> function if there is a need for the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structures containing the local or remote addresses.
     * 
     * 
     * <div class="alert"><b>Note</b>  The function pointer for the 
     * <b>GetAcceptExSockaddrs</b> function must be obtained at run time by making a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with the <b>SIO_GET_EXTENSION_FUNCTION_POINTER</b> opcode specified. The input buffer passed to the <b>WSAIoctl</b> function must contain <b>WSAID_GETACCEPTEXSOCKADDRS</b>, a globally unique identifier (GUID) whose value identifies the <b>GetAcceptExSockaddrs</b> extension function. On success, the output returned by the <b>WSAIoctl</b> function contains a pointer to the <b>GetAcceptExSockaddrs</b> function. The <b>WSAID_GETACCEPTEXSOCKADDRS</b> GUID is defined in the <i>Mswsock.h</i> header file.</div>
     * <div> </div>
     * 
     * 
     * <b>Windows Phone 8:</b> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<Void>} lpOutputBuffer A pointer to a buffer that receives the first block of data sent on a connection resulting from an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> call. Must be the same <i>lpOutputBuffer</i> parameter that was passed to the 
     * <b>AcceptEx</b> function.
     * @param {Integer} dwReceiveDataLength The number of bytes in the buffer used for receiving the first data. This value must be equal to the <i>dwReceiveDataLength</i> parameter that was passed to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> function.
     * @param {Integer} dwLocalAddressLength The number of bytes reserved for the local address information. This value must be equal to the <i>dwLocalAddressLength</i> parameter that was passed to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> function.
     * @param {Integer} dwRemoteAddressLength The number of bytes reserved for the remote address information. This value must be equal to the <i>dwRemoteAddressLength</i> parameter that was passed to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> function.
     * @param {Pointer<SOCKADDR>} LocalSockaddr A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that receives the local address of the connection (the same information that would be returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function). This parameter must be specified.
     * @param {Pointer<Int32>} LocalSockaddrLength The size, in bytes, of the local address. This parameter must be specified.
     * @param {Pointer<SOCKADDR>} RemoteSockaddr A pointer to the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that receives the remote address of the connection (the same information that would be returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getpeername">getpeername</a> function). This parameter must be specified.
     * @param {Pointer<Int32>} RemoteSockaddrLength The size, in bytes, of the local address. This parameter must be specified.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/mswsock/nf-mswsock-getacceptexsockaddrs
     * @since windows8.1
     */
    static GetAcceptExSockaddrs(lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength) {
        DllCall("MSWSOCK.dll\GetAcceptExSockaddrs", "ptr", lpOutputBuffer, "uint", dwReceiveDataLength, "uint", dwLocalAddressLength, "uint", dwRemoteAddressLength, "ptr", LocalSockaddr, "ptr", LocalSockaddrLength, "ptr", RemoteSockaddr, "ptr", RemoteSockaddrLength)
    }

    /**
     * The WSCEnumProtocols function retrieves information about available transport protocols.
     * @remarks
     * The **WSCEnumProtocols** function is used to discover information about the collection of transport protocols installed on the local computer. This function differs from its API counterpart (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a>) in that 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures for all installed protocols are returned. This includes protocols that the service provider has set the **PFL_HIDDEN** flag in the **dwProviderFlags** member of the **WSAPROTOCOL_INFOW** structure to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by **WSAEnumProtocols** function.  In addition, the **WSCEnumProtocols** also returns data for **WSAPROTOCOL_INFOW** structures that have a chain length of zero ( a dummy LSP provider).   The **WSAEnumProtocols** only returns information on base protocols and protocol chains that lack the **PFL_HIDDEN** flag  and don't have a protocol chain length of zero. 
     * 
     * <div class="alert">**Note**  Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server 2012, use <a href="https://docs.microsoft.com/windows/desktop/FWP/windows-filtering-platform-start-page">Windows Filtering Platform</a>.</div>
     * <div> </div>
     * The <i>lpiProtocols</i> parameter can be used as a filter to constrain the amount of information provided. Typically, a null pointer is supplied so the function will return information on all available transport protocols.
     * 
     * A 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structure is provided in the buffer pointed to by <i>lpProtocolBuffer</i> for each requested protocol. If the supplied buffer is not large enough (as indicated by the input value of <i>lpdwBufferLength</i>), the value pointed to by <i>lpdwBufferLength</i> will be updated to indicate the required buffer size. The Windows Sockets SPI client should then obtain a large enough buffer and call this function again. The 
     * **WSCEnumProtocols** function cannot enumerate over multiple calls; the passed-in buffer must be large enough to hold all expected entries in order for the function to succeed. This reduces the complexity of the function and should not pose a problem because the number of protocols loaded on a local computer is typically small.
     * 
     * The order in which the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures appear in the buffer coincides with the order in which the protocol entries were registered by the service provider with the WS2_32.dll, or with any subsequent reordering that may have occurred through the Windows Sockets applet supplied for establishing default transport providers.
     * @param {Pointer<Int32>} lpiProtocols A **NULL**-terminated array of <i>iProtocol</i> values. This parameter is optional; if <i>lpiProtocols</i> is NULL, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolBuffer A pointer to a buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures.
     * @param {Pointer<UInt32>} lpdwBufferLength On input, size of the <i>lpProtocolBuffer</i> buffer passed to 
     * **WSCEnumProtocols**, in bytes. On output, the minimum buffer size, in bytes, that can be passed to 
     * **WSCEnumProtocols** to retrieve all the requested information.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscenumprotocols
     * @since windows5.0
     */
    static WSCEnumProtocols(lpiProtocols, lpProtocolBuffer, lpdwBufferLength, lpErrno) {
        DllCall("WS2_32.dll\WSCEnumProtocols", "ptr", lpiProtocols, "ptr", lpProtocolBuffer, "ptr", lpdwBufferLength, "ptr", lpErrno)
    }

    /**
     * Removes the specified transport provider from the system configuration database.
     * @remarks
     * The 
     * **WSCDeinstallProvider** function removes the common Windows Sockets 2 configuration information for the specified provider. After this routine completes successfully, the configuration information stored in the registry will be changed. However, any Ws2_32.dll instances currently in memory will not be able to recognize this change.
     * 
     * On success, **WSCDeinstallProvider** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCDeinstallProvider** function can only be called by a user logged on as a member of the Administrators group. If **WSCDeinstallProvider** is called by a user that is not a member of the Administrators group, the function call will fail and **WSANO_RECOVERY** is returned in the <i>lpErrno</i> parameter. 
     *  
     * 
     * For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * 
     * 
     * 
     * The caller of this function must remove any additional files or service provider–specific configuration information that is needed to completely uninstall the service provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider. This value is stored within each 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscdeinstallprovider
     * @since windows5.0
     */
    static WSCDeinstallProvider(lpProviderId, lpErrno) {
        DllCall("WS2_32.dll\WSCDeinstallProvider", "ptr", lpProviderId, "ptr", lpErrno)
    }

    /**
     * Installs the specified transport provider into the system configuration database.
     * @remarks
     * **WSCInstallProvider** is used to install a single transport service provider.   This routine creates the necessary common Windows Sockets 2 configuration information for the specified provider. It is applicable to base protocols, layered protocols, and protocol chains. If a layered service provider is being installed, then <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallproviderandchains">WSCInstallProviderAndChains</a> should be used. **WSCInstallProviderAndChains** can install a layered protocol and one or more protocol chains with a single function call. To accomplish the same work using **WSCInstallProvider** would require multiple function calls.
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol would be a security layer that adds a protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * The <i>lpProtocolInfoList</i> parameter contains a list of protocol entries to install. Callers of **WSCInstallProvider** are responsible for setting up the proper protocol entries. The <i>lpProtocolInfoList</i> parameter must not be **NULL**. 
     * 
     * Upon successful completion of this call, any subsequent calls to <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> or <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a> will return the newly-created protocol entries. Be aware that in Windows environments, only instances of Ws_32.dll created by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> after the successful completion  of **WSCInstallProvider** will include the new entries when **WSAEnumProtocols** and  **WSCEnumProtocols** returns. <div class="alert">**Note**   The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function does not enumerate a layered protocol entry while <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a> does.</div>
     * <div> </div>
     * 
     * 
     * On success, **WSCInstallProvider** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCInstallProvider** function can only be called by a user logged on as a member of the Administrators group. If **WSCInstallProvider** is called by a user that is not a member of the Administrators group, the function call will fail and <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a> is returned in the <i>lpErrno</i> parameter. 
     *  For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (**RunAs administrator**) for this function to succeed.
     * 
     * Any file installation or service provider-specific configuration must be performed by the caller.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Pointer<PWSTR>} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure defines a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallprovider
     * @since windows5.0
     */
    static WSCInstallProvider(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        DllCall("WS2_32.dll\WSCInstallProvider", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "ptr", lpErrno)
    }

    /**
     * The WSCGetProviderPath function retrieves the DLL path for the specified provider.
     * @remarks
     * The 
     * **WSCGetProviderPath** function retrieves the DLL path for the specified provider. The DLL path can contain embedded environment strings, such as %SystemRoot%, and thus should be expanded prior to being used with the Windows <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function. For more information, see **LoadLibrary**.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider. This value is obtained by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>.
     * @param {Pointer<PWSTR>} lpszProviderDllPath A pointer to a buffer into which the provider DLL's path string is returned. The path is a null-terminated string and any embedded environment strings, such as %SystemRoot%, have not been expanded.
     * @param {Pointer<Int32>} lpProviderDllPathLen The size, in characters, of the buffer pointed to by the <i>lpszProviderDllPath</i> parameter.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscgetproviderpath
     * @since windows5.0
     */
    static WSCGetProviderPath(lpProviderId, lpszProviderDllPath, lpProviderDllPathLen, lpErrno) {
        DllCall("WS2_32.dll\WSCGetProviderPath", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProviderDllPathLen, "ptr", lpErrno)
    }

    /**
     * Modifies the specified transport provider in the system configuration database.
     * @remarks
     * The 
     * **WSCUpdateProvider** function modifies Windows Sockets 2 configuration information for the specified provider. It is applicable to base protocols, layered protocols, and protocol chains.
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * On success, **WSCUpdateProvider** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCUpdateProvider** function can only be called by a user logged on as a member of the Administrators group. If **WSCUpdateProvider** is called by a user that is not a member of the Administrators group, the function call will fail. 
     *  
     * 
     * For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * 
     * Any file installation or service provider-specific configuration must be performed by the caller.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Pointer<PWSTR>} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure specifies or modifies a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscupdateprovider
     * @since windows5.1.2600
     */
    static WSCUpdateProvider(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        DllCall("WS2_32.dll\WSCUpdateProvider", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "ptr", lpErrno)
    }

    /**
     * Sets the data value for the specified information class for a layered service provider (LSP).
     * @remarks
     * **WSCSetProviderInfo** is used to set the information class data for a layered service provider. When the <i>InfoType</i> parameter is set to **ProviderInfoLspCategories**, on success **WSCSetProviderInfo** sets appropriate LSP category flags implemented by the provider based on the value passed in the <i>Info</i> parameter. 
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions.  These functions will be called during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.dll).  
     * 
     * An LSP that implements an installable file system (IFS) can  selectively choose to provide pointers to functions which are implemented by itself, or pass back the pointers provided by the layer directly below the LSP.  Non-IFS LSPs, because they provide their own handles, must implement all of the Winsock SPI functions.  This is because each SPI will require the LSP to map all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
     * 
     * However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.
     * 
     * It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra processing performed for each of those functions.
     * 
     * By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine if an LSP should be involved in a given process at runtime.
     * 
     * On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP category is an identifiable group of behaviors on a subset of Winsock SPI functions.  For example, an HTTP content filter would be categorized as a data inspector (the **LSP_INSPECTOR** category). The **LSP_INSPECTOR** category will inspect, but not alter, parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP based on the LSP category and the application's set of permitted LSP categories.
     * 
     * The following table lists categories into which an LSP can be classified.<table>
     * <tr>
     * <th>LSP Category</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>**LSP_CRYPTO_COMPRESS**</td>
     * <td>The LSP is a cryptography or data compression provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_FIREWALL**</td>
     * <td>The LSP is a firewall provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_LOCAL_CACHE**</td>
     * <td>The LSP is a local cache provider.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_INBOUND_MODIFY**</td>
     * <td>The LSP modifies inbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_INSPECTOR**</td>
     * <td>The LSP inspects or filters data.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_OUTBOUND_MODIFY**</td>
     * <td>The LSP modifies outbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_PROXY**</td>
     * <td>The LSP acts as a proxy and redirects packets.</td>
     * </tr>
     * <tr>
     * <td>**LSP_REDIRECTOR**</td>
     * <td>The LSP is a network redirector.</td>
     * </tr>
     * <tr>
     * <td>**LSP_SYSTEM**</td>
     * <td>The LSP is acceptable for use in services and system processes.</td>
     * </tr>
     * </table>
     *  
     * An LSP may belong to more than one category.  For example, firewall/security LSP could belong to both the inspector (**LSP_INSPECTOR**) and firewall (**LSP_FIREWALL**) categories.
     * 
     * If an LSP does not have category set, it is considered to be in the All Other category. This LSP category will not be loaded in services or system processes (for example, lsass, winlogon, and many svchost processes).
     * 
     * The **WSCSetProviderInfo** function can only be called by a user logged on as a member of the Administrators group. If **WSCSetProviderInfo** is called by a user that is not a member of the Administrators group, the function call will fail and **WSANO_RECOVERY** is returned in the <i>lpErrno</i> parameter. 
     *  This function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * 
     * <div class="alert">**Note**  The TDI feature is deprecated and will be removed in future versions of Microsoft
     *     Windows. Depending on how you use TDI, use either the Winsock Kernel (WSK) or Windows Filtering Platform
     *     (WFP). For more information about WFP and WSK, see 
     *     
     * <a href="https://docs.microsoft.com/windows/win32/fwp/windows-filtering-platform-start-page">Windows Filtering Platform</a> and 
     *     
     * <a href="https://docs.microsoft.com/windows-hardware/drivers/ddi/content/_netvista/">Winsock Kernel</a>. For a Windows Core Networking
     *     blog entry about WSK and TDI, see 
     *     
     * <a href="https://docs.microsoft.com/archive/blogs/wndp/">Introduction to Winsock Kernel
     *     (WSK)</a>.
     * </div>
     * <div> </div>
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class to be set for this LSP protocol entry.
     * @param {Pointer<Byte>} Info A pointer to a buffer that contains the information class data to set for the LSP protocol entry.
     * @param {Pointer} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info</i> parameter.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCSetProviderInfo** function call.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscsetproviderinfo
     * @since windows6.0.6000
     */
    static WSCSetProviderInfo(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        DllCall("WS2_32.dll\WSCSetProviderInfo", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr", InfoSize, "uint", Flags, "ptr", lpErrno)
    }

    /**
     * Retrieves the data associated with an information class for a layered service provider (LSP).
     * @remarks
     * **WSCGetProviderInfo** is used to retrieve information class data for a layered service provider. When the <i>InfoType</i> parameter is set to **ProviderInfoLspCategories**, on success **WSCGetProviderInfo** returns with the <i>Info</i> parameter set with appropriate LSP category flags implemented by the LSP. 
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  A protocol chain would then be defined as one or more layered protocols strung together and anchored by a base protocol.
     * A base protocol has the **ChainLen** member of the <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure set to  **BASE_PROTOCOL** which is defined to be 1. A layered protocol has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to **LAYERED_PROTOCOL** which is defined to be zero. A protocol chain has the **ChainLen** member of the **WSAPROTOCOL_INFO** structure set to greater than 1.
     * 
     * During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions.  These functions will be called during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.DLL).  
     * 
     * An LSP that implements an installable file system (IFS) can  selectively choose to provide pointers to functions which are implemented by itself, or pass back the pointers provided by the layer directly below the LSP.  Non-IFS LSPs, because they provide their own handles, must implement all of the Winsock SPI functions.  This is because each SPI will require the LSP to map all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
     * 
     * However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.  
     * 
     * It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra processing performed for each of those functions.
     * 
     * By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine if an LSP should be involved in a given process at runtime.
     * 
     * 
     * On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP category is an identifiable group of behaviors on a subset of Winsock SPI functions.  For example, an HTTP content filter would be categorized as a data inspector (the LSP_INSPECTOR category). The LSP_INSPECTOR category will inspect (but not alter) parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP based on the LSP category and the application's set of permitted LSP categories.  
     * 
     * The following table lists categories into which an LSP can be classified.<table>
     * <tr>
     * <th>LSP Category</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>**LSP_CRYPTO_COMPRESS**</td>
     * <td>The LSP is a cryptography or data compression provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_FIREWALL**</td>
     * <td>The LSP is a firewall provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_LOCAL_CACHE**</td>
     * <td>The LSP is a local cache provider.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_INBOUND_MODIFY**</td>
     * <td>The LSP modifies inbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_INSPECTOR**</td>
     * <td>The LSP inspects or filters data.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_OUTBOUND_MODIFY**</td>
     * <td>The LSP modifies outbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_PROXY**</td>
     * <td>The LSP acts as a proxy and redirects packets.</td>
     * </tr>
     * <tr>
     * <td>**LSP_REDIRECTOR**</td>
     * <td>The LSP is a network redirector.</td>
     * </tr>
     * <tr>
     * <td>**LSP_SYSTEM**</td>
     * <td>The LSP is acceptable for use in services and system processes.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * An LSP may belong to more than one category.  For example, a firewall/security LSP could belong to both the inspector (**LSP_INSPECTOR**) and firewall (**LSP_FIREWALL**) categories.
     * 
     * If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded in services or system processes (for example, lsass, winlogon, and many svchost processes).
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class that is requested for this LSP protocol entry.
     * @param {Pointer<Byte>} Info A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is **NULL**, then **WSCGetProviderInfo** returns failure and the size required for this buffer is returned in the <i>InfoSize</i> parameter.
     * @param {Pointer<UIntPtr>} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info </i> parameter. If the Info parameter is **NULL**, then  **WSCGetProviderInfo** returns failure and the <i>InfoSize</i> parameter will receive the size of the required buffer.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCGetProviderInfo** function call.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscgetproviderinfo
     * @since windows6.0.6000
     */
    static WSCGetProviderInfo(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        DllCall("WS2_32.dll\WSCGetProviderInfo", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr", InfoSize, "uint", Flags, "ptr", lpErrno)
    }

    /**
     * Sets the permitted layered service provider (LSP) categories associated with an application.
     * @remarks
     * **WSCSetApplicationCategory** is used to set the LSP category flags associated with an application instance. Applications can determine which LSP behaviors are acceptable within the application's context.  Therefore, through specifying permitted LSP categories, an application can permit only those layered service providers  which implement acceptable behaviors to be loaded.
     * 
     * The <i>Extra</i> parameter is required when the command line is used to distinguish between different instances of an application or service hosted within the same executable. Each instance can have different application categorization needs.  Svchost.exe and Rundll32.exe are two examples where the command line is required to differentiate between different process instances.  For SvcHost.exe, the **-k &lt;svcinstance&gt;** switch defines the process instance.
     * 
     * For services, using the Service Name is not sufficient,  because the Winsock Catalog is global to a given process, and a process may host several services.
     * 
     * If the **WSCSetApplicationCategory** function is called on the same application (the same fullpath, EXE name, and parameters) multiple times, then the categories are ORed together. For example if you categorized "c:\foo.exe -param" with LSP_SYSTEM and then called the **WSCSetApplicationCategory** function again with LSP_REDIRECTOR, the resulting entry for htis application contains LSP_SYSTEM | LSP_REDIRECTOR. This behavior is designed to support a single executable file that hosts multiple applications in a single EXE (the Windows system services svchost.exe, for example).
     * 
     * 
     * Window sockets determine an application's identity and retrieves the permitted LSP categories during the first call to <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a>.  This will be the set of permitted LSP categories for the duration of the application instance.  Subsequent changes to the permitted LSP categories for a given application identity will not be picked up until the next instance of the application.  The permitted LSP categories is not mutable during the lifetime of the application instance.
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.
     * 
     * During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions.  These functions will be called during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.dll).  
     * 
     * An LSP that implements an installable file system (IFS) can  selectively choose to provide pointers to functions which are implemented by itself, or pass back the pointers provided by the layer directly below the LSP.  Non-IFS LSPs, because they provide their own handles, must implement all of the Winsock SPI functions.  This is because each SPI will require the LSP to map all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
     * 
     * However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.
     * 
     * It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra processing performed for each of those functions.
     * 
     * By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine if an LSP should be involved in a given process at runtime.
     * 
     * On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP category is an identifiable group of behaviors on a subset of Winsock SPI functions.  For example, an HTTP content filter would be categorized as a data inspector (the **LSP_INSPECTOR** category). The **LSP_INSPECTOR** category will inspect (but not alter) parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP based on the LSP category and the application's set of permitted LSP categories.
     * 
     * The following table lists categories into which an LSP can be classified.<table>
     * <tr>
     * <th>LSP Category</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>**LSP_CRYPTO_COMPRESS**</td>
     * <td>The LSP is a cryptography or data compression provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_FIREWALL**</td>
     * <td>The LSP is a firewall provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_LOCAL_CACHE**</td>
     * <td>The LSP is a local cache provider.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_INBOUND_MODIFY**</td>
     * <td>The LSP modifies inbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_INSPECTOR**</td>
     * <td>The LSP inspects or filters data.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_OUTBOUND_MODIFY**</td>
     * <td>The LSP modifies outbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_PROXY**</td>
     * <td>The LSP acts as a proxy and redirects packets.</td>
     * </tr>
     * <tr>
     * <td>**LSP_REDIRECTOR**</td>
     * <td>The LSP is a network redirector.</td>
     * </tr>
     * <tr>
     * <td>**LSP_SYSTEM**</td>
     * <td>The LSP is acceptable for use in services and system processes.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * An LSP may belong to more than one category.  For example, a firewall/security LSP could belong to both the inspector (**LSP_INSPECTOR**) and firewall (**LSP_FIREWALL**) categories.
     * 
     * If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded in services or system processes (for example, lsass, winlogon, and many svchost processes).
     * 
     * The **WSCSetApplicationCategory** function can only be called by a user logged on as a member of the Administrators group. If **WSCSetApplicationCategory** is called by a user that is not a member of the Administrators group, the function call will fail and **WSANO_RECOVERY** is returned in the <i>lpErrno</i> parameter. 
     *  This function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * 
     * Any file installation or service provider-specific configuration must be performed by the caller.
     * @param {Pointer<PWSTR>} Path A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>).
     * @param {Integer} PathLength The length, in characters, of the <i>Path</i> parameter. This length does not include the terminating **NULL**.
     * @param {Pointer<PWSTR>} Extra A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the <i>Path</i> parameter. The <i>Extra</i> parameter is used to distinguish between multiple, distinct instances of an application when launched with a consistent command line.  This is to support different application categorizations for different instances of Svchost.exe or Rundll32.exe. If only the <i>Path</i> parameter is required and no command line arguments are needed to further distinguish between instances of an application, then the <i>Extra</i> parameter should be set to **NULL**.
     * @param {Integer} ExtraLength The length, in characters, of the <i>Extra</i> parameter. This length does not include the terminating **NULL**.
     * @param {Integer} PermittedLspCategories A DWORD value of the LSP categories which are permitted for all instances of this application. The application is identified by the combination of the values of the <i>Path</i> and <i>Extra</i> parameters.
     * @param {Pointer<UInt32>} pPrevPermLspCat A pointer to receive the previous set of permitted LSP categories which were permitted for all instances of this application. This parameter is optional can  be **NULL**.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscsetapplicationcategory
     * @since windows6.0.6000
     */
    static WSCSetApplicationCategory(Path, PathLength, Extra, ExtraLength, PermittedLspCategories, pPrevPermLspCat, lpErrno) {
        DllCall("WS2_32.dll\WSCSetApplicationCategory", "ptr", Path, "uint", PathLength, "ptr", Extra, "uint", ExtraLength, "uint", PermittedLspCategories, "ptr", pPrevPermLspCat, "ptr", lpErrno)
    }

    /**
     * Retrieves the layered service provider (LSP) categories associated with an application.
     * @remarks
     * **WSCGetApplicationCategory** is used to retrieve the LSP category flags associated with an application instance. Applications can determine which LSP behaviors are acceptable within the application's context.  Therefore, by specifying permitted LSP categories, an application can permit only those layered service providers  which implement acceptable behaviors to be loaded. 
     * 
     * The <i>Extra</i> parameter is required when the command line is used to distinguish between different instances of an application or service hosted within the same executable. Each instance can have different application categorization needs.  Svchost.exe and Rundll32.exe are two examples where the command line is required to differentiate between different process instances.  For SvcHost.exe, the **-k &lt;svcinstance&gt;** switch defines the process instance.
     * 
     * For services, using the Service Name is not sufficient,  since the Winsock Catalog is global to a given process, and a process may host several services.  
     * 
     * Window sockets determine an application's identity and retrieves the permitted LSP categories during the first call to <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a>.  This will be the set of permitted LSP categories for the duration of the application instance.  Subsequent changes to the permitted LSP categories for a given application identity will not be picked up until the next instance of the application.  The permitted LSP categories are not mutable during the lifetime of the application instance.
     * 
     * Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions, while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in order to perform authentication and to establish a mutually agreed upon encryption scheme.  Such a security protocol would generally require the services of an underlying reliable transport protocol such as TCP or SPX.  The term base protocol refers to a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol that cannot stand alone.  
     * 
     * During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions.  These functions will be called during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.DLL).  
     * 
     * An LSP that implements an installable file system (IFS) can  selectively choose to provide pointers to functions which are implemented by itself, or pass back the pointers provided by the layer directly below the LSP.  Non-IFS LSPs, because they provide their own handles, must implement all of the Winsock SPI functions.  This is because each SPI will require the LSP to map all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
     * 
     * However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.  
     * 
     * It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra processing performed for each of those functions.
     * 
     * By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine if an LSP should be involved in a given process at runtime.
     * 
     * 
     * On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP category is an identifiable group of behaviors on a subset of Winsock SPI functions.  For example, an HTTP content filter would be categorized as a data inspector (the LSP_INSPECTOR category). The LSP_INSPECTOR category will inspect (but not alter) parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP based on the LSP category and the application's set of permitted LSP categories.  
     * 
     * The following table lists categories that an LSP can be classified into.<table>
     * <tr>
     * <th>LSP Category</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>**LSP_CRYPTO_COMPRESS**</td>
     * <td>The LSP is a cryptography or data compression provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_FIREWALL**</td>
     * <td>The LSP is a firewall provider.</td>
     * </tr>
     * <tr>
     * <td>**LSP_LOCAL_CACHE**</td>
     * <td>The LSP is a local cache provider.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_INBOUND_MODIFY**</td>
     * <td>The LSP modifies inbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_INSPECTOR**</td>
     * <td>The LSP inspects or filters data.
     * </td>
     * </tr>
     * <tr>
     * <td>**LSP_OUTBOUND_MODIFY**</td>
     * <td>The LSP modifies outbound data.</td>
     * </tr>
     * <tr>
     * <td>**LSP_PROXY**</td>
     * <td>The LSP acts as a proxy and redirects packets.</td>
     * </tr>
     * <tr>
     * <td>**LSP_REDIRECTOR**</td>
     * <td>The LSP is a network redirector.</td>
     * </tr>
     * <tr>
     * <td>**LSP_SYSTEM**</td>
     * <td>The LSP is acceptable for use in services and system processes.</td>
     * </tr>
     * </table>
     *  
     * 
     * 
     * 
     * An LSP may belong to more than one category.  For example, a firewall/security LSP could belong to both the inspector (**LSP_INSPECTOR**) and firewall (**LSP_FIREWALL**) categories.
     * 
     * If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded in services or system processes (for example, lsass, winlogon, and many svchost processes).
     * @param {Pointer<PWSTR>} Path A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>).
     * @param {Integer} PathLength The length, in characters, of the <i>Path</i> parameter. This length does not include the terminating **NULL**.
     * @param {Pointer<PWSTR>} Extra A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the <i>Path</i> parameter. The <i>Extra</i> parameter is used to distinguish between multiple, distinct instances of an application when launched with a consistent command line.  This is to support different application categorizations for different instances of Svchost.exe or Rundll32.exe. If only the <i>Path</i> parameter is required and no command line arguments are needed to further distinguish between instances of an application, then the <i>Extra</i> parameter should be set to **NULL**.
     * @param {Integer} ExtraLength The length, in characters, of the <i>Extra</i> parameter. This length does not include the terminating **NULL**.
     * @param {Pointer<UInt32>} pPermittedLspCategories A pointer to a DWORD value of permitted LSP categories which are permitted for all instances of this application. The application is identified by the combination of the values of the <i>Path</i> and <i>Extra</i> parameters.
     * @param {Pointer<Int32>} lpErrno A pointer to the error code if the function fails.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscgetapplicationcategory
     * @since windows6.0.6000
     */
    static WSCGetApplicationCategory(Path, PathLength, Extra, ExtraLength, pPermittedLspCategories, lpErrno) {
        DllCall("WS2_32.dll\WSCGetApplicationCategory", "ptr", Path, "uint", PathLength, "ptr", Extra, "uint", ExtraLength, "ptr", pPermittedLspCategories, "ptr", lpErrno)
    }

    /**
     * The WPUCompleteOverlappedRequest function performs overlapped I/O completion notification for overlapped I/O operations.
     * @remarks
     * The 
     * **WPUCompleteOverlappedRequest** function performs overlapped I/O completion notification for overlapped I/O operations where the client-specified completion mechanism is something other than user mode–asynchronous procedure call (APC). This function can only be used for socket handles created by 
     * <a href="https://docs.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wpucreatesockethandle">WPUCreateSocketHandle</a>.
     * 
     * <div class="alert">**Note**  This function is different from other functions with the "WPU" prefix in that it is not accessed through the upcall table. Instead, it is exported directly by Ws2_32.dll. Service providers that need to call this function should link with WS2_32.lib or use appropriate operating system functions such as <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> and <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> to retrieve the function pointer.</div>
     * <div> </div>
     * The function 
     * **WPUCompleteOverlappedRequest** is used by service providers that do not implement Installable File System (IFS) functionality directly for the socket handles they expose. It performs completion notification for any overlapped I/O request for which the specified completion notification is other than a user-mode APC. 
     * **WPUCompleteOverlappedRequest** is supported only for the socket handles created by 
     * <a href="https://docs.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wpucreatesockethandle">WPUCreateSocketHandle</a> and not for sockets created by a service provider directly.
     * 
     * If the client selects a user-mode APC as the notification method, the service provider should use 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wpuqueueapc">WPUQueueApc</a> or another appropriate operating system function to perform the completion notification. If user-mode APC is not selected by the client, a service provider that does not implement IFS functionality directly cannot determine whether or not the client has associated a completion port with the socket handle. Thus, it cannot determine whether the completion notification method should be queuing a completion status record to a completion port or signaling an event found in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure. The Windows Socket 2 architecture keeps track of any completion port association with a socket created by 
     * <a href="https://docs.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wpucreatesockethandle">WPUCreateSocketHandle</a> and can make a correct decision between completion port-based notification or event-based notification.
     * 
     * When 
     * **WPUCompleteOverlappedRequest** queues a completion indication, it sets the **InternalHigh** member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure to the count of bytes transferred. Then, it sets the **Internal** member to some OS-dependent value other than the special value WSS_OPERATION_IN_PROGRESS. There may be some slight delay after 
     * **WPUCompleteOverlappedRequest** returns before these values appear, since processing may occur asynchronously. However, the **InternalHigh** value (byte count) is guaranteed to be set by the time **Internal** is set.
     * 
     * **WPUCompleteOverlappedRequest** works as stated (performs the completion notification as requested by the client) whether or not the socket handle has been associated with a completion port.
     * 
     * **Interaction with WSPGetOverlappedResult**
     * 
     * The behavior of 
     * **WPUCompleteOverlappedRequest** places some constraints on how a service provider implements 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nc-ws2spi-lpwspgetoverlappedresult">WSPGetOverlappedResult</a> since only the **Offset** and **OffsetHigh** members of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure are exclusively controlled by the service provider, yet three values (byte count, flags, and error) must be retrieved from the structure by 
     * **WSPGetOverlappedResult**. A service provider may accomplish this any way it chooses as long as it interacts with the behavior of 
     * **WPUCompleteOverlappedRequest** properly. However, a typical implementation is as follows:
     * 
     *  
     * - At the start of overlapped processing, the service provider sets **Internal** to WSS_OPERATION_IN_PROGRESS. 
     * - When the I/O operation has been completed, the provider sets **OffsetHigh** to the Windows Socket 2 error code resulting from the operation, sets **Offset** to the flags resulting from the I/O operation, and calls 
     * **WPUCompleteOverlappedRequest**, passing the transfer byte count as one of the parameters. 
     * **WPUCompleteOverlappedRequest** eventually sets **InternalHigh** to the transfer byte count, then sets **Internal** to a value other than WSS_OPERATION_IN_PROGRESS. 
     * - When 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nc-ws2spi-lpwspgetoverlappedresult">WSPGetOverlappedResult</a> is called, the service provider checks **Internal**. If it is WSS_OPERATION_IN_PROGRESS, the provider waits on the event handle in the **hEvent** member or returns an error, based on the setting of the FWAIT flag of 
     * **WSPGetOverlappedResult**. If not in progress, or after completion of waiting, the provider returns the values from **InternalHigh**, **OffsetHigh**, and **Offset** as the transfer count, operation result error code, and flags respectively.
     * @param {Pointer} s The service provider socket created by 
     * <a href="https://docs.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wpucreatesockethandle">WPUCreateSocketHandle</a>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure associated with the overlapped I/O operation whose completion is to be notified.
     * @param {Integer} dwError The completion status of the overlapped I/O operation whose completion is to be notified.
     * @param {Integer} cbTransferred The number of bytes transferred to or from client buffers (the direction of the transfer depends on the send or receive nature of the overlapped I/O operation whose completion is to be notified).
     * @param {Pointer<Int32>} lpErrno A pointer to the error code resulting from execution of this function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wpucompleteoverlappedrequest
     * @since windows5.0
     */
    static WPUCompleteOverlappedRequest(s, lpOverlapped, dwError, cbTransferred, lpErrno) {
        DllCall("WS2_32.dll\WPUCompleteOverlappedRequest", "ptr", s, "ptr", lpOverlapped, "uint", dwError, "uint", cbTransferred, "ptr", lpErrno)
    }

    /**
     * Installs a namespace provider. (WSCInstallNameSpace)
     * @remarks
     * The namespace–configuration functions do not affect applications that are already running. Newly installed namespace providers will not be visible to applications nor will the changes in a namespace provider's activation state. Applications launched after the call to 
     * **WSCInstallNameSpace** will see the changes.
     * 
     * The **WSCInstallNameSpace** function can only be called by a user logged on as a member of the Administrators group. If **WSCInstallNameSpace** is called by a user that is not a member of the Administrators group, the function call will fail. 
     *  For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * @param {Pointer<PWSTR>} lpszIdentifier A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the <i>lpProviderId</i> parameter.
     * @param {Pointer<PWSTR>} lpszPathName A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Integer} dwNameSpace The namespace supported by this provider.
     * @param {Integer} dwVersion The version number of the provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID  for the provider. This GUID should be generated by Uuidgen.exe.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallnamespace
     * @since windows5.0
     */
    static WSCInstallNameSpace(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId) {
        DllCall("WS2_32.dll\WSCInstallNameSpace", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId)
    }

    /**
     * Uninstalls the indicated name-space provider.
     * @remarks
     * The namespace configuration functions do not affect applications that are already running. Newly installed name-space providers will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched after the call to 
     * **WSCUnInstallNameSpace** will see the changes.
     * 
     * On success, **WSCUnInstallNameSpace** will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The **WSCUnInstallNameSpace** function can only be called by a user logged on as a member of the Administrators group. If **WSCUnInstallNameSpace** is called by a user that is not a member of the Administrators group, the function call will fail and **WSANO_RECOVERY** is returned in the <i>lpErrno</i> parameter. 
     *  
     * 
     * For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * 
     * 
     * 
     * The caller of this function must remove any additional files or service provider–specific configuration information that is required to completely uninstall the service provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the name-space provider to be uninstalled.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscuninstallnamespace
     * @since windows5.0
     */
    static WSCUnInstallNameSpace(lpProviderId) {
        DllCall("WS2_32.dll\WSCUnInstallNameSpace", "ptr", lpProviderId)
    }

    /**
     * Installs a namespace provider. (WSCInstallNameSpaceEx)
     * @remarks
     * The namespace–configuration functions do not affect applications that are already running. Newly installed name-space providers will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched after the call to 
     * **WSCInstallNameSpaceEx** will see the changes.
     * 
     * The provider-specific data blob associated with namespace entry
     *                      passed in the <i>lpProviderInfo</i> parameter can be queried using the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersexa">WSAEnumNameSpaceProvidersEx</a> function.
     * 
     * Currently, the only namespace provider included with Windows that uses the <i>lpProviderInfo</i> parameter is the NS_EMAIL provider. The format of the buffer pointed to by the <i>lpProviderInfo</i> parameter for an NS_EMAIL namespace provider is a <a href="https://docs.microsoft.com/windows/desktop/api/nsemail/ns-nsemail-napi_provider_installation_blob">NAPI_PROVIDER_INSTALLATION_BLOB</a> structure. 
     * 
     * The **WSCInstallNameSpaceEx** function can only be called by a user logged on as a member of the Administrators group. If **WSCInstallNameSpaceEx** is called by a user that is not a member of the Administrators group, the function call will fail. 
     *  For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * @param {Pointer<PWSTR>} lpszIdentifier A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the <i>lpProviderId</i> parameter.
     * @param {Pointer<PWSTR>} lpszPathName A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Integer} dwNameSpace The namespace supported by this provider.
     * @param {Integer} dwVersion The version number of the provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID  for the provider. This GUID should be generated by Uuidgen.exe.
     * @param {Pointer<BLOB>} lpProviderSpecific A provider-specific data blob associated with namespace entry.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallnamespaceex
     * @since windows6.0.6000
     */
    static WSCInstallNameSpaceEx(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId, lpProviderSpecific) {
        DllCall("WS2_32.dll\WSCInstallNameSpaceEx", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId, "ptr", lpProviderSpecific)
    }

    /**
     * Changes the state of a given namespace provider.
     * @remarks
     * The 
     * **WSCEnableNSProvider** function is intended to be used to change the state of the namespace providers. An independent software vendor (ISV) should not normally de-activate another ISV namespace provider in order to activate its own. The choice should be left to the user.    
     * 
     * The **WSCEnableNSProvider** function does not affect applications that are already running. Newly installed namespace providers will not be visible to applications nor will the changes in a namespace provider's activation state be visible. Applications launched after the call to 
     * **WSCEnableNSProvider** will see the changes.
     * 
     * The **WSCEnableNSProvider** function can only be called by a user logged on as a member of the Administrators group. If **WSCEnableNSProvider** is called by a user that is not a member of the Administrators group, the function call will fail. 
     *  
     * 
     * For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a **requestedExecutionLevel** set to **requireAdministrator**. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the namespace provider.
     * @param {Integer} fEnable A Boolean value that, if **TRUE**, the provider is set to the active state. If **FALSE**, the provider is disabled and will not be available for query operations or service registration.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscenablensprovider
     * @since windows5.0
     */
    static WSCEnableNSProvider(lpProviderId, fEnable) {
        DllCall("WS2_32.dll\WSCEnableNSProvider", "ptr", lpProviderId, "int", fEnable)
    }

    /**
     * Makes a specific namespace version-2 provider available for all eligible clients.
     * @remarks
     * The 
     * **WSAAdvertiseProvider** function is used as part of the namespace service provider version-2 (NSPv2) architecture available on Windows Vista and later. 
     * 
     * On Windows Vista and Windows Server 2008, the **WSAAdvertiseProvider** function can only be used for operations on NS_EMAIL namespace providers.
     * 
     * The 
     * **WSAAdvertiseProvider** function advertises an instance of a NSPv2 provider for clients to find. If the instance to be advertised is an instance of an application-type provider (a namespace provider where the **dwProvideType** member of the <a href="https://docs.microsoft.com/windows/desktop/api/nsemail/ns-nsemail-napi_provider_installation_blob">NAPI_PROVIDER_INSTALLATION_BLOB</a> structure is **ProviderType_Application**), the advertised provider instance will be visible to all the client processes running under the same user and in the same session as the caller of **WSAAdvertiseProvider**. 
     * 
     * In general, NSPv2 providers are implemented in processes other than the calling applications. NSPv2 providers are not activated as a result of client activity. Each provider hosting application decides when to make a specific provider available or unavailable by calling the **WSAAdvertiseProvider** and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wsaunadvertiseprovider">WSAUnadvertiseProvider</a> functions. The client activity only results in attempts to contact the provider, when available (when the namespace provider is advertised).
     * 
     * The 
     * **WSAAdvertiseProvider** function is called by any application that wants to make a specific provider available for all eligible clients (currently all the applications running with the same credentials as the hosting application, and in the same user session). 
     * 
     * 
     * 
     * A process can implement and advertise multiple providers at the same time. Windows Sockets will manage the namespace providers by dispatching calls to the correct one. It will also hide RPC interface details and translates cross-process calls into in-process calls. So that the NSPv2 provider has only to implement a table of entry point functions similar to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/ns-ws2spi-nsp_routine">NSP_ROUTINE</a> structure used by an NSPv1 provider. A NSPv2 provider does not have to worry about RPC specific requirements (data marshalling and serialization, for example).
     * 
     * 
     * 
     * The **WSAAdvertiseProvider** caller passes a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/ns-ws2spi-nspv2_routine">NSPV2_ROUTINE</a>  structure in the <i>pNSPv2Routine</i> parameter with the NSPv2 entry points supported by the provider. 
     * 
     * 
     * The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wsaunadvertiseprovider">WSAUnadvertiseProvider</a> function makes a specific namespace provider no longer available for clients.
     * @param {Pointer<Guid>} puuidProviderId A pointer to the provider ID of the namespace provider to be advertised.
     * @param {Pointer<NSPV2_ROUTINE>} pNSPv2Routine A pointer to a **NSPV2_ROUTINE** structure with the namespace service provider version-2 entry points supported by the provider.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wsaadvertiseprovider
     * @since windows6.0.6000
     */
    static WSAAdvertiseProvider(puuidProviderId, pNSPv2Routine) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAAdvertiseProvider", "ptr", puuidProviderId, "ptr", pNSPv2Routine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Makes a specific namespace version-2 provider no longer available for clients.
     * @remarks
     * The 
     * **WSAUnadvertiseProvider** function is used as part of the namespace service provider version-2 (NSPv2) architecture available on Windows Vista and later. 
     * 
     * On Windows Vista and Windows Server 2008, the **WSAUnadvertiseProvider** function can only be used for operations on NS_EMAIL namespace providers.
     * 
     * In general, NSPv2 providers are implemented in processes other than the calling applications. NSPv2 providers are not activated as result of client activity. Each provider hosting application decides when to make a specific provider available or unavailable by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wsaadvertiseprovider">WSAAdvertiseProvider</a> and **WSAUnadvertiseProvider** functions. The client activity only results in attempts to contact the provider, when available (when the namespace provider is advertised).
     * @param {Pointer<Guid>} puuidProviderId A pointer to the provider ID of the namespace provider.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wsaunadvertiseprovider
     * @since windows6.0.6000
     */
    static WSAUnadvertiseProvider(puuidProviderId) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAUnadvertiseProvider", "ptr", puuidProviderId)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Notifies a client when an asynchronous call to a namespace version-2 provider is completed.
     * @remarks
     * The 
     * **WSAProviderCompleteAsyncCall** function is used as part of the namespace service provider version-2 (NSPv2) architecture available on Windows Vista and later. 
     * 
     * On Windows Vista and Windows Server 2008, the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wsaunadvertiseprovider">WSAUnadvertiseProvider</a> function can only be used for operations on NS_EMAIL namespace providers. Asynchronous calls to NSPv2 providers are not supported on Windows Vista and Windows Server 2008. So the **WSAProviderCompleteAsyncCall** is not currently applicable. This function is planned for use in later versions of Windows when asynchronous calls to namespace providers are supported. 
     * 
     * In general, NSPv2 providers are implemented in processes other than the calling applications. NSPv2 providers are not activated as result of client activity. Each provider hosting application decides when to make a specific provider available or unavailable by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wsaadvertiseprovider">WSAAdvertiseProvider</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wsaunadvertiseprovider">WSAUnadvertiseProvider</a> functions. The client activity only results in attempts to contact the provider, when available (when the namespace provider is advertised).
     * @param {Pointer<HANDLE>} hAsyncCall The handle passed to the asynchronous call being completed. This handle is passed by the client to the namespace version-2 provider in the asynchronous function call.
     * @param {Integer} iRetCode The return code for the asynchronous call to the namespace version-2 provider.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wsaprovidercompleteasynccall
     * @since windows6.0.6000
     */
    static WSAProviderCompleteAsyncCall(hAsyncCall, iRetCode) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSAProviderCompleteAsyncCall", "ptr", hAsyncCall, "int", iRetCode)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The EnumProtocols function retrieves information about a specified set of network protocols that are active on a local host. (ANSI)
     * @remarks
     * In the following sample code, the 
     * <b>EnumProtocols</b> function retrieves information about all protocols that are available on a system. The code then examines each of the protocols in greater detail.
     * 
     * 
     * ```cpp
     * @param {Pointer<Int32>} lpiProtocols A pointer to a <b>null</b>-terminated array of protocol identifiers. The 
     * <b>EnumProtocols</b> function retrieves information about the protocols specified by this array. 
     * 
     * 
     * 
     * 
     * If <i>lpiProtocols</i> is <b>NULL</b>, the function retrieves information about all available protocols.
     * 
     * The following protocol identifier values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP), a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP), a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ISOPROTO_TP4"></a><a id="isoproto_tp4"></a><dl>
     * <dt><b>ISOPROTO_TP4</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The ISO connection-oriented transport protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_IPX"></a><a id="nsproto_ipx"></a><dl>
     * <dt><b>NSPROTO_IPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Packet Exchange (IPX) protocol, a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPX"></a><a id="nsproto_spx"></a><dl>
     * <dt><b>NSPROTO_SPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPXII"></a><a id="nsproto_spxii"></a><dl>
     * <dt><b>NSPROTO_SPXII</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol version 2, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpProtocolBuffer A pointer to a buffer that the function fills with an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> data structures.
     * @param {Pointer<UInt32>} lpdwBufferLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpProtocolBuffer</i>. 
     * 
     * 
     * 
     * 
     * On output, the function sets this variable to the minimum buffer size needed to retrieve all of the requested information. For the function to succeed, the buffer must be at least this size.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-enumprotocolsa
     * @since windows5.0
     */
    static EnumProtocolsA(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\EnumProtocolsA", "ptr", lpiProtocols, "ptr", lpProtocolBuffer, "ptr", lpdwBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The EnumProtocols function retrieves information about a specified set of network protocols that are active on a local host. (Unicode)
     * @remarks
     * In the following sample code, the 
     * <b>EnumProtocols</b> function retrieves information about all protocols that are available on a system. The code then examines each of the protocols in greater detail.
     * 
     * 
     * ```cpp
     * @param {Pointer<Int32>} lpiProtocols A pointer to a <b>null</b>-terminated array of protocol identifiers. The 
     * <b>EnumProtocols</b> function retrieves information about the protocols specified by this array. 
     * 
     * 
     * 
     * 
     * If <i>lpiProtocols</i> is <b>NULL</b>, the function retrieves information about all available protocols.
     * 
     * The following protocol identifier values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP), a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP), a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ISOPROTO_TP4"></a><a id="isoproto_tp4"></a><dl>
     * <dt><b>ISOPROTO_TP4</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The ISO connection-oriented transport protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_IPX"></a><a id="nsproto_ipx"></a><dl>
     * <dt><b>NSPROTO_IPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Packet Exchange (IPX) protocol, a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPX"></a><a id="nsproto_spx"></a><dl>
     * <dt><b>NSPROTO_SPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPXII"></a><a id="nsproto_spxii"></a><dl>
     * <dt><b>NSPROTO_SPXII</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol version 2, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpProtocolBuffer A pointer to a buffer that the function fills with an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> data structures.
     * @param {Pointer<UInt32>} lpdwBufferLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpProtocolBuffer</i>. 
     * 
     * 
     * 
     * 
     * On output, the function sets this variable to the minimum buffer size needed to retrieve all of the requested information. For the function to succeed, the buffer must be at least this size.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-enumprotocolsw
     * @since windows5.0
     */
    static EnumProtocolsW(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\EnumProtocolsW", "ptr", lpiProtocols, "ptr", lpProtocolBuffer, "ptr", lpdwBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * GetAddressByName is no longer available for use as of Windows Sockets 2. (ANSI)
     * @remarks
     * This function is a more powerful version of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a> function. The 
     * <b>GetAddressByName</b> function works with multiple name services.
     * 
     * 
     * <div class="alert"><b>Note</b>  The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a> function has been deprecated by the introduction of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a> function. Developers creating Windows Sockets 2 applications are urged to use the 
     * <b>getaddrinfo</b> function instead of 
     * <b>gethostbyname</b>.</div>
     * <div> </div>
     * 
     * 
     * The 
     * <b>GetAddressByName</b> function lets a client obtain a Windows Sockets address for a network service. The client specifies the service of interest by its service type and service name.
     * 
     * Many name services support a default prefix or suffix that the name service provider considers when resolving service names. For example, in the DNS namespace, if a domain is named "nt.microsoft.com", and "ftp millikan" is provided as input, the DNS software fails to resolve "millikan", but successfully resolves "millikan.nt.microsoft.com".
     * 
     * Note that the 
     * <b>GetAddressByName</b> function can search for a service address in two ways: within a particular namespace, or within a set of default namespaces. Using a default namespace, an administrator can specify that certain namespaces will be searched for service addresses only if specified by name. An administrator or namespace—setup program can also control the ordering of namespace searches.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The nspapi.h header defines GetAddressByName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwNameSpace The namespace, or set of default namespaces, that the operating system should query for network address information.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. This is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System (DNS) used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Most calls to 
     * <b>GetAddressByName</b> should use the special value NS_DEFAULT. This lets a client get by with no knowledge of which namespaces are available on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The Svcguid.h header file is not automatically included by the Winsock2.h header file.
     * @param {Pointer<PSTR>} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER".
     * 
     * Setting <i>lpServiceName</i> to <b>NULL</b> is the equivalent of setting <i>dwResolution</i> to RES_SERVICE. The function operates in its second mode, obtaining the local address to which a service of the specified type should bind. The function stores the local address within the <b>LocalAddr</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures stored into *<i>lpCsaddrBuffer</i>.
     * 
     * If <i>dwResolution</i> is set to RES_SERVICE, the function ignores the <i>lpServiceName</i> parameter.
     * 
     * If <i>dwNameSpace</i> is set to NS_DNS, *<i>lpServiceName</i> is the name of the host.
     * @param {Pointer<Int32>} lpiProtocols A pointer to a zero-terminated array of protocol identifiers. The function restricts a name resolution attempt to namespace providers that offer these protocols. This lets the caller limit the scope of the search.
     * 
     * If <i>lpiProtocols</i> is set to <b>NULL</b>, the function retrieves information on all available protocols.
     * @param {Integer} dwResolution A set of bit flags that specify aspects of the service name resolution process. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SERVICE"></a><a id="res_service"></a><dl>
     * <dt><b>RES_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the function retrieves the address to which a service of the specified type should bind. This is the equivalent to setting the <i>lpServiceName</i> parameter to <b>NULL</b>.
     * 
     * If this flag is clear, normal name resolution occurs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_FIND_MULTIPLE"></a><a id="res_find_multiple"></a><dl>
     * <dt><b>RES_FIND_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the operating system performs an extensive search of all namespaces for the service. It asks every appropriate namespace to resolve the service name. If this flag is clear, the operating system stops looking for service addresses as soon as one is found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SOFT_SEARCH"></a><a id="res_soft_search"></a><dl>
     * <dt><b>RES_SOFT_SEARCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is valid if the namespace supports multiple levels of searching.
     * 
     * If this flag is valid and set, the operating system performs a simple and quick search of the namespace. This is useful if an application only needs to obtain easy-to-find addresses for the service.
     * 
     * If this flag is valid and clear, the operating system performs a more extensive search of the namespace.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use; must be set to <b>NULL</b>.
     * @param {Pointer<Void>} lpCsaddrBuffer A pointer to a buffer to receive one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> data structures. The number of structures written to the buffer depends on the amount of information found in the resolution attempt. You should assume that multiple structures will be written, although in many cases there will only be one.
     * @param {Pointer<UInt32>} lpdwBufferLength A pointer to a variable that, upon input, specifies the size, in bytes, of the buffer pointed to by <i>lpCsaddrBuffer</i>.
     * 
     * Upon output, this variable contains the total number of bytes required to store the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures. If this value is less than or equal to the input value of *<i>lpdwBufferLength</i>, and the function is successful, this is the number of bytes actually stored in the buffer. If this value is greater than the input value of *<i>lpdwBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwBufferLength</i> is the minimal required buffer size.
     * @param {Pointer<PSTR>} lpAliasBuffer A pointer to a buffer to receive alias information for the network service.
     * 
     * If a namespace supports aliases, the function stores an array of zero-terminated name strings into the buffer pointed to by <i>lpAliasBuffer</i>. There is a double zero-terminator at the end of the list. The first name in the array is the service's primary name. Names that follow are aliases. An example of a namespace that supports aliases is DNS.
     * 
     * If a namespace does not support aliases, it stores a double zero-terminator into the buffer.
     * 
     * This parameter is optional, and can be set to <b>NULL</b>.
     * @param {Pointer<UInt32>} lpdwAliasBufferLength A pointer to a variable that, upon input, specifies the size, in elements (characters), of the buffer pointed to by <i>lpAliasBuffer</i>.
     * 
     * Upon output, this variable contains the total number of elements (characters) required to store the array of name strings. If this value is less than or equal to the input value of *<i>lpdwAliasBufferLength</i>, and the function is successful, this is the number of elements actually stored in the buffer. If this value is greater than the input value of *<i>lpdwAliasBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwAliasBufferLength</i> is the minimal required buffer size.
     * 
     * If <i>lpAliasBuffer</i> is <b>NULL</b>, <i>lpdwAliasBufferLength</i> is meaningless and can also be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-getaddressbynamea
     * @since windows5.0
     */
    static GetAddressByNameA(dwNameSpace, lpServiceType, lpServiceName, lpiProtocols, dwResolution, lpServiceAsyncInfo, lpCsaddrBuffer, lpdwBufferLength, lpAliasBuffer, lpdwAliasBufferLength) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetAddressByNameA", "uint", dwNameSpace, "ptr", lpServiceType, "ptr", lpServiceName, "ptr", lpiProtocols, "uint", dwResolution, "ptr", lpServiceAsyncInfo, "ptr", lpCsaddrBuffer, "ptr", lpdwBufferLength, "ptr", lpAliasBuffer, "ptr", lpdwAliasBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * GetAddressByName is no longer available for use as of Windows Sockets 2. (Unicode)
     * @remarks
     * This function is a more powerful version of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a> function. The 
     * <b>GetAddressByName</b> function works with multiple name services.
     * 
     * 
     * <div class="alert"><b>Note</b>  The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-gethostbyname">gethostbyname</a> function has been deprecated by the introduction of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a> function. Developers creating Windows Sockets 2 applications are urged to use the 
     * <b>getaddrinfo</b> function instead of 
     * <b>gethostbyname</b>.</div>
     * <div> </div>
     * 
     * 
     * The 
     * <b>GetAddressByName</b> function lets a client obtain a Windows Sockets address for a network service. The client specifies the service of interest by its service type and service name.
     * 
     * Many name services support a default prefix or suffix that the name service provider considers when resolving service names. For example, in the DNS namespace, if a domain is named "nt.microsoft.com", and "ftp millikan" is provided as input, the DNS software fails to resolve "millikan", but successfully resolves "millikan.nt.microsoft.com".
     * 
     * Note that the 
     * <b>GetAddressByName</b> function can search for a service address in two ways: within a particular namespace, or within a set of default namespaces. Using a default namespace, an administrator can specify that certain namespaces will be searched for service addresses only if specified by name. An administrator or namespace—setup program can also control the ordering of namespace searches.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The nspapi.h header defines GetAddressByName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwNameSpace The namespace, or set of default namespaces, that the operating system should query for network address information.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. This is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System (DNS) used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Most calls to 
     * <b>GetAddressByName</b> should use the special value NS_DEFAULT. This lets a client get by with no knowledge of which namespaces are available on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The Svcguid.h header file is not automatically included by the Winsock2.h header file.
     * @param {Pointer<PWSTR>} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER".
     * 
     * Setting <i>lpServiceName</i> to <b>NULL</b> is the equivalent of setting <i>dwResolution</i> to RES_SERVICE. The function operates in its second mode, obtaining the local address to which a service of the specified type should bind. The function stores the local address within the <b>LocalAddr</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures stored into *<i>lpCsaddrBuffer</i>.
     * 
     * If <i>dwResolution</i> is set to RES_SERVICE, the function ignores the <i>lpServiceName</i> parameter.
     * 
     * If <i>dwNameSpace</i> is set to NS_DNS, *<i>lpServiceName</i> is the name of the host.
     * @param {Pointer<Int32>} lpiProtocols A pointer to a zero-terminated array of protocol identifiers. The function restricts a name resolution attempt to namespace providers that offer these protocols. This lets the caller limit the scope of the search.
     * 
     * If <i>lpiProtocols</i> is set to <b>NULL</b>, the function retrieves information on all available protocols.
     * @param {Integer} dwResolution A set of bit flags that specify aspects of the service name resolution process. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SERVICE"></a><a id="res_service"></a><dl>
     * <dt><b>RES_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the function retrieves the address to which a service of the specified type should bind. This is the equivalent to setting the <i>lpServiceName</i> parameter to <b>NULL</b>.
     * 
     * If this flag is clear, normal name resolution occurs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_FIND_MULTIPLE"></a><a id="res_find_multiple"></a><dl>
     * <dt><b>RES_FIND_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the operating system performs an extensive search of all namespaces for the service. It asks every appropriate namespace to resolve the service name. If this flag is clear, the operating system stops looking for service addresses as soon as one is found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SOFT_SEARCH"></a><a id="res_soft_search"></a><dl>
     * <dt><b>RES_SOFT_SEARCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is valid if the namespace supports multiple levels of searching.
     * 
     * If this flag is valid and set, the operating system performs a simple and quick search of the namespace. This is useful if an application only needs to obtain easy-to-find addresses for the service.
     * 
     * If this flag is valid and clear, the operating system performs a more extensive search of the namespace.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use; must be set to <b>NULL</b>.
     * @param {Pointer<Void>} lpCsaddrBuffer A pointer to a buffer to receive one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> data structures. The number of structures written to the buffer depends on the amount of information found in the resolution attempt. You should assume that multiple structures will be written, although in many cases there will only be one.
     * @param {Pointer<UInt32>} lpdwBufferLength A pointer to a variable that, upon input, specifies the size, in bytes, of the buffer pointed to by <i>lpCsaddrBuffer</i>.
     * 
     * Upon output, this variable contains the total number of bytes required to store the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures. If this value is less than or equal to the input value of *<i>lpdwBufferLength</i>, and the function is successful, this is the number of bytes actually stored in the buffer. If this value is greater than the input value of *<i>lpdwBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwBufferLength</i> is the minimal required buffer size.
     * @param {Pointer<PWSTR>} lpAliasBuffer A pointer to a buffer to receive alias information for the network service.
     * 
     * If a namespace supports aliases, the function stores an array of zero-terminated name strings into the buffer pointed to by <i>lpAliasBuffer</i>. There is a double zero-terminator at the end of the list. The first name in the array is the service's primary name. Names that follow are aliases. An example of a namespace that supports aliases is DNS.
     * 
     * If a namespace does not support aliases, it stores a double zero-terminator into the buffer.
     * 
     * This parameter is optional, and can be set to <b>NULL</b>.
     * @param {Pointer<UInt32>} lpdwAliasBufferLength A pointer to a variable that, upon input, specifies the size, in elements (characters), of the buffer pointed to by <i>lpAliasBuffer</i>.
     * 
     * Upon output, this variable contains the total number of elements (characters) required to store the array of name strings. If this value is less than or equal to the input value of *<i>lpdwAliasBufferLength</i>, and the function is successful, this is the number of elements actually stored in the buffer. If this value is greater than the input value of *<i>lpdwAliasBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwAliasBufferLength</i> is the minimal required buffer size.
     * 
     * If <i>lpAliasBuffer</i> is <b>NULL</b>, <i>lpdwAliasBufferLength</i> is meaningless and can also be <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-getaddressbynamew
     * @since windows5.0
     */
    static GetAddressByNameW(dwNameSpace, lpServiceType, lpServiceName, lpiProtocols, dwResolution, lpServiceAsyncInfo, lpCsaddrBuffer, lpdwBufferLength, lpAliasBuffer, lpdwAliasBufferLength) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetAddressByNameW", "uint", dwNameSpace, "ptr", lpServiceType, "ptr", lpServiceName, "ptr", lpiProtocols, "uint", dwResolution, "ptr", lpServiceAsyncInfo, "ptr", lpCsaddrBuffer, "ptr", lpdwBufferLength, "ptr", lpAliasBuffer, "ptr", lpdwAliasBufferLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetTypeByName function retrieves a service type GUID for a network service specified by name. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines GetTypeByName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} lpServiceName A pointer to a zero-terminated string that uniquely represents the name of the service. For example, "MY SNA SERVER."
     * @param {Pointer<Guid>} lpServiceType A pointer to a variable to receive a globally unique identifier (<b>GUID</b>) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several <b>GUID</b> service types and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-gettypebynamea
     * @since windows5.0
     */
    static GetTypeByNameA(lpServiceName, lpServiceType) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetTypeByNameA", "ptr", lpServiceName, "ptr", lpServiceType)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetTypeByName function retrieves a service type GUID for a network service specified by name. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines GetTypeByName as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} lpServiceName A pointer to a zero-terminated string that uniquely represents the name of the service. For example, "MY SNA SERVER."
     * @param {Pointer<Guid>} lpServiceType A pointer to a variable to receive a globally unique identifier (<b>GUID</b>) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several <b>GUID</b> service types and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-gettypebynamew
     * @since windows5.0
     */
    static GetTypeByNameW(lpServiceName, lpServiceType) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetTypeByNameW", "ptr", lpServiceName, "ptr", lpServiceType)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetNameByType function retrieves the name of a network service for the specified service type. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines GetNameByType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {Pointer<PSTR>} lpServiceName A pointer to a buffer to receive a zero-terminated string that uniquely represents the name of the network service.
     * @param {Integer} dwNameLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpServiceName</i>. On output, the variable contains the actual size of the service name string, in bytes.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-getnamebytypea
     * @since windows5.0
     */
    static GetNameByTypeA(lpServiceType, lpServiceName, dwNameLength) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetNameByTypeA", "ptr", lpServiceType, "ptr", lpServiceName, "uint", dwNameLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetNameByType function retrieves the name of a network service for the specified service type. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines GetNameByType as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {Pointer<PWSTR>} lpServiceName A pointer to a buffer to receive a zero-terminated string that uniquely represents the name of the network service.
     * @param {Integer} dwNameLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpServiceName</i>. On output, the variable contains the actual size of the service name string, in bytes.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-getnamebytypew
     * @since windows5.0
     */
    static GetNameByTypeW(lpServiceType, lpServiceName, dwNameLength) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetNameByTypeW", "ptr", lpServiceType, "ptr", lpServiceName, "uint", dwNameLength)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetService function registers or removes from the registry a network service within one or more namespaces. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines SetService as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, within which the function will operate. 
     * 
     * 
     * 
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet to resolve the name of the host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl>
     * <dt><b>NS_NDS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare 4 provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All Windows systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery, if appropriate. NS_SAP is a dynamic namespace that enables the registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\posts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and lookup value in the cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwOperation 
     * @param {Integer} dwFlags A set of bit flags that modify the function's operation. You can set one or more of the following bit flags: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_DEFER"></a><a id="service_flag_defer"></a><dl>
     * <dt><b>SERVICE_FLAG_DEFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider should defer the registration or deregistration operation until a SERVICE_FLUSH operation is requested.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_HARD"></a><a id="service_flag_hard"></a><dl>
     * <dt><b>SERVICE_FLAG_HARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider updates any relevant persistent store information when the operation is performed.
     * 
     * For example: If the operation involves deregistration in a namespace that uses a persistent store, the namespace provider would remove the relevant persistent store information.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_INFOA>} lpServiceInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure that contains information about the network service or service type.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @param {Pointer<UInt32>} lpdwStatusFlags A set of bit flags that receive function status information. The following bit flag is defined: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SET_SERVICE__PARTIAL_SUCCESS"></a><a id="set_service__partial_success"></a><dl>
     * <dt><b>SET_SERVICE_
     * PARTIAL_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more namespace providers were unable to successfully perform the requested operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-setservicea
     * @since windows5.0
     */
    static SetServiceA(dwNameSpace, dwOperation, dwFlags, lpServiceInfo, lpServiceAsyncInfo, lpdwStatusFlags) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\SetServiceA", "uint", dwNameSpace, "uint", dwOperation, "uint", dwFlags, "ptr", lpServiceInfo, "ptr", lpServiceAsyncInfo, "ptr", lpdwStatusFlags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The SetService function registers or removes from the registry a network service within one or more namespaces. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines SetService as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, within which the function will operate. 
     * 
     * 
     * 
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet to resolve the name of the host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl>
     * <dt><b>NS_NDS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare 4 provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All Windows systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery, if appropriate. NS_SAP is a dynamic namespace that enables the registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\posts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and lookup value in the cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwOperation 
     * @param {Integer} dwFlags A set of bit flags that modify the function's operation. You can set one or more of the following bit flags: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_DEFER"></a><a id="service_flag_defer"></a><dl>
     * <dt><b>SERVICE_FLAG_DEFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider should defer the registration or deregistration operation until a SERVICE_FLUSH operation is requested.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_HARD"></a><a id="service_flag_hard"></a><dl>
     * <dt><b>SERVICE_FLAG_HARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider updates any relevant persistent store information when the operation is performed.
     * 
     * For example: If the operation involves deregistration in a namespace that uses a persistent store, the namespace provider would remove the relevant persistent store information.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_INFOW>} lpServiceInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure that contains information about the network service or service type.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @param {Pointer<UInt32>} lpdwStatusFlags A set of bit flags that receive function status information. The following bit flag is defined: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SET_SERVICE__PARTIAL_SUCCESS"></a><a id="set_service__partial_success"></a><dl>
     * <dt><b>SET_SERVICE_
     * PARTIAL_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more namespace providers were unable to successfully perform the requested operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-setservicew
     * @since windows5.0
     */
    static SetServiceW(dwNameSpace, dwOperation, dwFlags, lpServiceInfo, lpServiceAsyncInfo, lpdwStatusFlags) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\SetServiceW", "uint", dwNameSpace, "uint", dwOperation, "uint", dwFlags, "ptr", lpServiceInfo, "ptr", lpServiceAsyncInfo, "ptr", lpdwStatusFlags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetService function retrieves information about a network service in the context of a set of default namespaces or a specified namespace. (ANSI)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines GetService as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, that the operating system should query for information about the specified network service.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The operating system queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to resolve a computer name into an IP address using this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Looks up host names and IP addresses in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Most calls to 
     * <b>GetService</b> should use the special value NS_DEFAULT. This lets a client get by without knowing available namespaces on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpGuid A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes GUID service types from many well-known services within the DNS and SAP namespaces.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {Pointer<PSTR>} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER."
     * @param {Integer} dwProperties A set of bit flags that specify the service information that the function retrieves. Each of these bit flag constants, other than PROP_ALL, corresponds to a particular member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> data structure. If the flag is set, the function puts information into the corresponding member of the data structures stored in *<i>lpBuffer</i>. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_COMMENT"></a><a id="prop_comment"></a><dl>
     * <dt><b>PROP_COMMENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpComment</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_LOCALE"></a><a id="prop_locale"></a><dl>
     * <dt><b>PROP_LOCALE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpLocale</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_DISPLAY_HINT"></a><a id="prop_display_hint"></a><dl>
     * <dt><b>PROP_DISPLAY_HINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwDisplayHint</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_VERSION"></a><a id="prop_version"></a><dl>
     * <dt><b>PROP_VERSION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwVersion</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_START_TIME"></a><a id="prop_start_time"></a><dl>
     * <dt><b>PROP_START_TIME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwTime</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_MACHINE"></a><a id="prop_machine"></a><dl>
     * <dt><b>PROP_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpMachineName</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ADDRESSES"></a><a id="prop_addresses"></a><dl>
     * <dt><b>PROP_ADDRESSES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpServiceAddress</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_SD"></a><a id="prop_sd"></a><dl>
     * <dt><b>PROP_SD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>ServiceSpecificInfo</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ALL"></a><a id="prop_all"></a><dl>
     * <dt><b>PROP_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in all of the members of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpBuffer A pointer to a buffer to receive an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures and associated service information. Each 
     * <b>NS_SERVICE_INFO</b> structure contains service information in the context of a particular namespace. Note that if <i>dwNameSpace</i> is NS_DEFAULT, the function stores more than one structure into the buffer; otherwise, just one structure is stored.
     * 
     * Each 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structure contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure. The members of these 
     * <b>SERVICE_INFO</b> structures will contain valid data based on the bit flags that are set in the <i>dwProperties</i> parameter. If a member's corresponding bit flag is not set in <i>dwProperties</i>, the member's value is undefined.
     * 
     * The function stores the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures in a consecutive array, starting at the beginning of the buffer. The pointers in the contained 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structures point to information that is stored in the buffer between the end of the 
     * <b>NS_SERVICE_INFO</b> structures and the end of the buffer.
     * @param {Pointer<UInt32>} lpdwBufferSize A pointer to a variable that, on input, contains the size, in bytes, of the buffer pointed to by <i>lpBuffer</i>. On output, this variable contains the number of bytes required to store the requested information. If this output value is greater than the input value, the function has failed due to insufficient buffer size.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-getservicea
     * @since windows5.0
     */
    static GetServiceA(dwNameSpace, lpGuid, lpServiceName, dwProperties, lpBuffer, lpdwBufferSize, lpServiceAsyncInfo) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetServiceA", "uint", dwNameSpace, "ptr", lpGuid, "ptr", lpServiceName, "uint", dwProperties, "ptr", lpBuffer, "ptr", lpdwBufferSize, "ptr", lpServiceAsyncInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The GetService function retrieves information about a network service in the context of a set of default namespaces or a specified namespace. (Unicode)
     * @remarks
     * > [!NOTE]
     * > The nspapi.h header defines GetService as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, that the operating system should query for information about the specified network service.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The operating system queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to resolve a computer name into an IP address using this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Looks up host names and IP addresses in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     *  
     * 
     * Most calls to 
     * <b>GetService</b> should use the special value NS_DEFAULT. This lets a client get by without knowing available namespaces on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpGuid A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes GUID service types from many well-known services within the DNS and SAP namespaces.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {Pointer<PWSTR>} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER."
     * @param {Integer} dwProperties A set of bit flags that specify the service information that the function retrieves. Each of these bit flag constants, other than PROP_ALL, corresponds to a particular member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> data structure. If the flag is set, the function puts information into the corresponding member of the data structures stored in *<i>lpBuffer</i>. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_COMMENT"></a><a id="prop_comment"></a><dl>
     * <dt><b>PROP_COMMENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpComment</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_LOCALE"></a><a id="prop_locale"></a><dl>
     * <dt><b>PROP_LOCALE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpLocale</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_DISPLAY_HINT"></a><a id="prop_display_hint"></a><dl>
     * <dt><b>PROP_DISPLAY_HINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwDisplayHint</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_VERSION"></a><a id="prop_version"></a><dl>
     * <dt><b>PROP_VERSION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwVersion</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_START_TIME"></a><a id="prop_start_time"></a><dl>
     * <dt><b>PROP_START_TIME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwTime</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_MACHINE"></a><a id="prop_machine"></a><dl>
     * <dt><b>PROP_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpMachineName</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ADDRESSES"></a><a id="prop_addresses"></a><dl>
     * <dt><b>PROP_ADDRESSES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpServiceAddress</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_SD"></a><a id="prop_sd"></a><dl>
     * <dt><b>PROP_SD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>ServiceSpecificInfo</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ALL"></a><a id="prop_all"></a><dl>
     * <dt><b>PROP_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in all of the members of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} lpBuffer A pointer to a buffer to receive an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures and associated service information. Each 
     * <b>NS_SERVICE_INFO</b> structure contains service information in the context of a particular namespace. Note that if <i>dwNameSpace</i> is NS_DEFAULT, the function stores more than one structure into the buffer; otherwise, just one structure is stored.
     * 
     * Each 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structure contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure. The members of these 
     * <b>SERVICE_INFO</b> structures will contain valid data based on the bit flags that are set in the <i>dwProperties</i> parameter. If a member's corresponding bit flag is not set in <i>dwProperties</i>, the member's value is undefined.
     * 
     * The function stores the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures in a consecutive array, starting at the beginning of the buffer. The pointers in the contained 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structures point to information that is stored in the buffer between the end of the 
     * <b>NS_SERVICE_INFO</b> structures and the end of the buffer.
     * @param {Pointer<UInt32>} lpdwBufferSize A pointer to a variable that, on input, contains the size, in bytes, of the buffer pointed to by <i>lpBuffer</i>. On output, this variable contains the number of bytes required to store the requested information. If this output value is greater than the input value, the function has failed due to insufficient buffer size.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/nspapi/nf-nspapi-getservicew
     * @since windows5.0
     */
    static GetServiceW(dwNameSpace, lpGuid, lpServiceName, dwProperties, lpBuffer, lpdwBufferSize, lpServiceAsyncInfo) {
        A_LastError := 0

        DllCall("MSWSOCK.dll\GetServiceW", "uint", dwNameSpace, "ptr", lpGuid, "ptr", lpServiceName, "uint", dwProperties, "ptr", lpBuffer, "ptr", lpdwBufferSize, "ptr", lpServiceAsyncInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Provides protocol-independent translation from an ANSI host name to an address.
     * @remarks
     * The <b>getaddrinfo</b> function is the ANSI version of a function that provides protocol-independent translation from host name to address. The Unicode version of this function is <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a>. Developers are encouraged to use the <b>GetAddrInfoW</b> Unicode function rather than the <b>getaddrinfo</b> ANSI function.
     * 
     * The <b>getaddrinfo</b> function returns results for the <b>NS_DNS</b> namespace. The <b>getaddrinfo</b> function aggregates all responses if more than
     *     one namespace provider returns information. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local <i>hosts</i> file, or by other naming mechanisms for the <b>NS_DNS</b> namespace. 
     * 
     * Another name that can be used for the <b>getaddrinfo</b> function is <b>GetAddrInfoA</b>. Macros in the <i>Ws2tcpip.h</i> header file define <b>GetAddrInfoA</b> to <b>getaddrinfo</b>.
     * 
     * Macros in the <i>Ws2tcpip.h</i> header file define a mixed-case function name of <b>GetAddrInfo</b> and a <b>ADDRINFOT</b> structure. This <b>GetAddrInfo</b> function should be called with the <i>pNodeName</i> and <i>pServiceName</i> parameters of a pointer of type  <b>TCHAR</b> and the <i>pHints</i> and <i>ppResult</i> parameters of a pointer of type <b>ADDRINFOT</b>. When UNICODE or _UNICODE is not defined, <b>GetAddrInfo</b> is defined to <b>getaddrinfo</b>, the ANSI version of the function, and  <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure. When <b>UNICODE</b> or <b>_UNICODE</b> is defined, <b>GetAddrInfo</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a>, the Unicode version of the function, and  <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure.
     * 
     * The parameter names and parameter types for the <b>getaddrinfo</b> function defined in the <i>Ws2tcpip.h</i> header file on the Platform Software Development Kit (SDK) for   Windows Server 2003, and Windows XP were different. 
     * 
     * One or both of the <i>pNodeName</i> or <i>pServiceName</i> parameters must point to a <b>NULL</b>-terminated ANSI string; generally both are provided.
     * 
     * Upon success, a linked list of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structures is returned in the <i>ppResult</i> parameter. The list can be processed by following the pointer provided in the <b>ai_next</b> member of each returned 
     * <b>addrinfo</b> structure until a <b>NULL</b> pointer is encountered. In each returned 
     * <b>addrinfo</b> structure, the <b>ai_family</b>, <b>ai_socktype</b>, and <b>ai_protocol</b> members correspond to respective arguments in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a>   or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function call. Also, the <b>ai_addr</b> member in each returned 
     * <b>addrinfo</b> structure points to a filled-in socket address structure, the length of which is specified in its <b>ai_addrlen</b> member.
     * 
     * If the <i>pNodeName</i> parameter points to a computer name, all permanent addresses for the computer that can be used as a source address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to false in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. 
     * 
     * If the <i>pNodeName</i> parameter points to a string equal to "localhost", all loopback addresses on the local computer are returned. 
     * 
     * If the <i>pNodeName</i> parameter contains an empty string, all registered addresses on the local computer are returned. 
     * 
     * On Windows Server 2003 and later if the <i>pNodeName</i> parameter points to a string equal to "..localmachine", all registered addresses on the local computer are returned. 
     * 
     * If the <i>pNodeName</i> parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to true in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. See <a href="https://docs.microsoft.com/previous-versions/windows/desktop/mscs/windows-clustering">Windows Clustering</a> for more information about clustering.
     * 
     * Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This also changes the behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  
     * 
     * A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address.  This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  For more information, see <a href="https://support.microsoft.com/kb/2386184">Knowledge Base (KB) 2386184</a>.   
     * 
     * A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2) that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS. 
     * 
     * 
     * Callers of the 
     * <b>getaddrinfo</b> function can provide hints about the type of socket supported through an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure pointed to by the <i>pHints</i> parameter. When the <i>pHints</i> parameter is used, the following rules apply to its associated 
     * <b>addrinfo</b> structure:
     * 
     * <ul>
     * <li>A value of <b>AF_UNSPEC</b> for <b>ai_family</b> indicates the caller will accept only the <b>AF_INET</b> and <b>AF_INET6</b> address families. Note that <b>AF_UNSPEC</b> and <b>PF_UNSPEC</b> are the same.</li>
     * <li>A value of zero for <b>ai_socktype</b> indicates the caller will accept any socket type.</li>
     * <li>A value of zero for <b>ai_protocol</b> indicates the caller will accept any protocol.</li>
     * <li>The <b>ai_addrlen</b> member must be set to zero.</li>
     * <li>The <b>ai_canonname</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_addr</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_next</b> member must be set to <b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * A value of <b>AF_UNSPEC</b> for <b>ai_family</b> indicates the caller will accept any protocol family. This value can be used to return both IPv4 and IPv6 addresses for the host name pointed to by the <i>pNodeName</i> parameter. On Windows Server 2003 and Windows XP, IPv6 addresses are returned only if IPv6 is installed on the local computer. 
     * 
     * Other values in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure provided in the <i>pHints</i> parameter indicate specific requirements. For example, if the caller handles only IPv4 and does not handle IPv6, the <b>ai_family</b> member should be set to AF_INET. For another example, if the caller handles only TCP and does not handle UDP, the <b>ai_socktype</b> member should be set to <b>SOCK_STREAM</b>.
     * 
     * If the <i>pHints</i> parameter is a <b>NULL</b> pointer, the 
     * <b>getaddrinfo</b> function treats it as if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure in <i>pHints</i> were initialized with its <b>ai_family</b> member set to <b>AF_UNSPEC</b> and all other members set to zero.
     * 
     * On Windows Vista and later when <b>getaddrinfo</b> is called from a service, if the operation is the result of a user process calling the service, then the service should impersonate the user.  This is to allow security to be properly enforced.
     * 
     * 
     * The 
     * <b>getaddrinfo</b> function can be used to convert a text string representation of an IP address to an <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure that contains a <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the IP address and other information. To be used in this way, the string pointed to by the <i>pNodeName</i> parameter must contain a text representation of an IP address and the <b>addrinfo</b> structure pointed to by the <i>pHints</i> parameter must have the AI_NUMERICHOST flag set in the <b>ai_flags</b> member. The string pointed to by the <i>pNodeName</i> parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an <b>addrinfo</b> structure pointed to by the <i>ppResult</i> parameter. The returned <b>addrinfo</b> structure contains a <b>sockaddr</b> structure for the IP address along with addition information about the IP address. For this method to work with an IPv6 address string on Windows Server 2003 and Windows XP, the IPv6 protocol must be installed on the local computer. Otherwise, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a> error is returned.
     * 
     * <h3><a id="Freeing_Address_Information_from_Dynamic_Allocation"></a><a id="freeing_address_information_from_dynamic_allocation"></a><a id="FREEING_ADDRESS_INFORMATION_FROM_DYNAMIC_ALLOCATION"></a>Freeing Address Information from Dynamic Allocation</h3>
     * All information returned by the 
     * <b>getaddrinfo</b> function pointed to by the <i>ppResult</i> parameter is dynamically allocated, including all 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structures, socket address structures, and canonical host name strings pointed to by 
     * <b>addrinfo</b> structures. Memory allocated by a successful call to this function must be released with a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfo">freeaddrinfo</a>.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following code example shows how to use the <b>getaddrinfo</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer<PSTR>} pNodeName A pointer to a <b>NULL</b>-terminated ANSI string that contains a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {Pointer<PSTR>} pServiceName A pointer to a <b>NULL</b>-terminated ANSI string that contains either a service name or port number represented as a string.
     * 
     * A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<ADDRINFOA>} pHints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<ADDRINFOA>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structures that contains response information about the host.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo
     * @since windows8.1
     */
    static getaddrinfo(pNodeName, pServiceName, pHints, ppResult) {
        A_LastError := 0

        DllCall("WS2_32.dll\getaddrinfo", "ptr", pNodeName, "ptr", pServiceName, "ptr", pHints, "ptr", ppResult)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Provides protocol-independent translation from a Unicode host name to an address.
     * @remarks
     * The <b>GetAddrInfoW</b> function is the Unicode version of a function that provides protocol-independent translation from host name to address. The ANSI version of this function is <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a>.
     * 
     * The <b>GetAddrInfoW</b> function returns results for the <b>NS_DNS</b> namespace. The <b>GetAddrInfoW</b> function aggregates all responses if more than
     *     one namespace provider returns information. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local <i>hosts</i> file, or by other naming mechanisms  for the <b>NS_DNS</b> namespace.
     * 
     * Macros in the Winsock header file define a mixed-case function name of <b>GetAddrInfo</b> and a <b>ADDRINFOT</b> structure. This <b>GetAddrInfo</b> function should be called with the <i>pNodeName</i> and <i>pServiceName</i> parameters of a pointer of type  <b>TCHAR</b> and the <i>pHints</i> and <i>ppResult</i> parameters of a pointer of type <b>ADDRINFOT</b>. When UNICODE or _UNICODE is defined, <b>GetAddrInfo</b> is defined to <b>GetAddrInfoW</b>, the Unicode version of the function, and <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure. When UNICODE or _UNICODE is not defined, <b>GetAddrInfo</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a>, the ANSI version of the function, and <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure.
     * 
     * One or both of the <i>pNodeName</i> or <i>pServiceName</i> parameters must point to a <b>NULL</b>-terminated Unicode string; generally both are provided.
     * 
     * Upon success, a linked list of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structures is returned in the <i>ppResult</i> parameter. The list can be processed by following the pointer provided in the <b>ai_next</b> member of each returned 
     * <b>addrinfoW</b> structure until a <b>NULL</b> pointer is encountered. In each returned 
     * <b>addrinfoW</b> structure, the <b>ai_family</b>, <b>ai_socktype</b>, and <b>ai_protocol</b> members correspond to respective arguments in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a>  or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function call. Also, the <b>ai_addr</b> member in each returned 
     * <b>addrinfoW</b> structure points to a filled-in socket address structure, the length of which is specified in its <b>ai_addrlen</b> member.
     * 
     * If the <i>pNodeName</i> parameter points to a computer name, all permanent addresses for the computer that can be used as a source address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to false in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. 
     * 
     * If the <i>pNodeName</i> parameter points to a string equal to "localhost", all loopback addresses on the local computer are returned. 
     * 
     * If the <i>pNodeName</i> parameter contains an empty string, all registered addresses on the local computer are returned. 
     * 
     * On Windows Server 2003 and later if the <i>pNodeName</i> parameter points to a string equal to "..localmachine", all registered addresses on the local computer are returned. 
     * 
     * If the <i>pNodeName</i> parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to true in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. See <a href="https://docs.microsoft.com/previous-versions/windows/desktop/mscs/windows-clustering">Windows Clustering</a> for more information about clustering.
     * 
     * Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This also changes the behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  
     * 
     * A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address.  This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  For more information, see <a href="https://support.microsoft.com/kb/2386184">Knowledge Base (KB) 2386184</a>.   
     * 
     * A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2) that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.
     * 
     * 
     * Callers of the 
     * <b>GetAddrInfoW</b> function can provide hints about the type of socket supported through an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure pointed to by the <i>pHints</i> parameter. When the <i>pHints</i> parameter is used, the following rules apply to its associated 
     * <b>addrinfoW</b> structure:
     * 
     * <ul>
     * <li>A value of <b>AF_UNSPEC</b> for <b>ai_family</b> indicates the caller will accept only the <b>AF_INET</b> and <b>AF_INET6</b> address families. Note that <b>AF_UNSPEC</b> and <b>PF_UNSPEC</b> are the same.</li>
     * <li>A value of zero for <b>ai_socktype</b> indicates the caller will accept any socket type.</li>
     * <li>A value of zero for <b>ai_protocol</b> indicates the caller will accept any protocol.</li>
     * <li>The <b>ai_addrlen</b> member must be set to zero.</li>
     * <li>The <b>ai_canonname</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_addr</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_next</b> member must be set to <b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * Other values in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure provided in the <i>pHints</i> parameter indicate specific requirements. For example, if the caller handles only IPv4 and does not handle IPv6, the <b>ai_family</b> member should be set to <b>AF_INET</b>. For another example, if the caller handles only TCP and does not handle UDP, the <b>ai_socktype</b> member should be set to <b>SOCK_STREAM</b>.
     * 
     * If the <i>pHints</i> parameter is a <b>NULL</b> pointer, the 
     * <b>GetAddrInfoW</b> function handles it as if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure in <i>pHints</i> were initialized with its <b>ai_family</b> member set to <b>AF_UNSPEC</b> and all other members set to zero.
     * 
     * On Windows Vista and later when <b>GetAddrInfoW</b> is called from a service, if the operation is the result of a user process calling the service, then the service should impersonate the user.  This is to allow security to be properly enforced.
     * 
     * The 
     * <b>GetAddrInfoW</b> function can be used to convert a text string representation of an IP address to an <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure that contains a <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the IP address and other information. To be used in this way, the string pointed to by the <i>pNodeName</i> parameter must contain a text representation of an IP address and the <b>addrinfoW</b> structure pointed to by the <i>pHints</i> parameter must have the <b>AI_NUMERICHOST</b> flag set in the <b>ai_flags</b> member. The string pointed to by the <i>pNodeName</i> parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an <b>addrinfoW</b> structure pointed to by the <i>ppResult</i> parameter. The returned <b>addrinfoW</b> structure contains a <b>sockaddr</b> structure for the IP address along with additional information about the IP address. For this method to work with an IPv6 address string on Windows Server 2003 and Windows XP, the IPv6 protocol must be installed on the local computer. Otherwise, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a> error is returned.
     * 
     * <h3><a id="Freeing_Address_Information_from_Dynamic_Allocation"></a><a id="freeing_address_information_from_dynamic_allocation"></a><a id="FREEING_ADDRESS_INFORMATION_FROM_DYNAMIC_ALLOCATION"></a>Freeing Address Information from Dynamic Allocation</h3>
     * All information returned by the 
     * <b>GetAddrInfoW</b> function pointed to by the <i>ppResult</i> parameter is dynamically allocated, including all 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structures, socket address structures, and canonical host name strings pointed to by 
     * <b>addrinfoW</b> structures. Memory allocated by a successful call to this function must be released with a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfow">FreeAddrInfoW</a>.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following code example shows how to use the <b>GetAddrInfoW</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer<PWSTR>} pNodeName A pointer to a <b>NULL</b>-terminated Unicode string that contains a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {Pointer<PWSTR>} pServiceName A pointer to a <b>NULL</b>-terminated Unicode string that contains either a service name or port number represented as a string. 
     * 
     * A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<ADDRINFOW>} pHints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<ADDRINFOW>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structures that contains response information about the host.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfow
     * @since windows8.1
     */
    static GetAddrInfoW(pNodeName, pServiceName, pHints, ppResult) {
        DllCall("WS2_32.dll\GetAddrInfoW", "ptr", pNodeName, "ptr", pServiceName, "ptr", pHints, "ptr", ppResult)
    }

    /**
     * Provides protocol-independent name resolution with additional parameters to qualify which namespace providers should handle the request. (ANSI)
     * @remarks
     * The <b>GetAddrInfoEx</b>  function provides protocol-independent translation from host name to address and from service name to port number. The <b>GetAddrInfoEx</b>  function is an enhanced version of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a> functions. The <b>GetAddrInfoEx</b>  function allows specifying the namespace provider to resolve the query. 
     * 
     * The <b>GetAddrInfoEx</b>  function aggregates and returns results from multiple namespace providers, unless a specific namespace provider is specified. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local <i>hosts</i> file, an email provider (the <b>NS_EMAIL</b> namespace), or by other naming mechanisms.
     * 
     * When UNICODE or _UNICODE is defined, <b>GetAddrInfoEx</b> is defined to <b>GetAddrInfoExW</b>, the Unicode version of this function. The string parameters are defined to the <b>PWSTR</b> data type and the <b>ADDRINFOEXW</b> structure is used. On Windows 8 and Windows Server 2012, the <i>timeout</i>, <i>lpOverlapped</i>, <i>lpCompletionRoutine</i>, and <i>lpNameHandle</i> parameters may be used to call the <b>GetAddrInfoEx</b> function so that it can complete asynchronously. 
     * 
     * When UNICODE or _UNICODE is not defined, <b>GetAddrInfoEx</b> is defined to <b>GetAddrInfoExA</b>, the ANSI version of this function. The string parameters are of the <b>PCSTR</b> data type and the <b>ADDRINFOEXA</b> structure is used. The <i>timeout</i>, <i>lpOverlapped</i>, <i>lpCompletionRoutine</i>, and <i>lpNameHandle</i> parameters must be set to <b>NULL</b>.
     * 
     * One or both of the <i>pName</i> or <i>pServiceName</i> parameters must point to a <b>NULL</b>-terminated string. Generally both are provided.
     * 
     * Upon success, a linked list of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures is returned in the <i>ppResult</i> parameter. The list can be processed by following the pointer provided in the <b>ai_next</b> member of each returned 
     * <b>addrinfoex</b> structure until a <b>NULL</b> pointer is encountered. In each returned 
     * <b>addrinfoex</b> structure, the <b>ai_family</b>, <b>ai_socktype</b>, and <b>ai_protocol</b> members correspond to respective arguments in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function call. Also, the <b>ai_addr</b> member in each returned 
     * <b>addrinfoex</b> structure points to a filled-in socket address structure, the length of which is specified in its <b>ai_addrlen</b> member.
     * 
     * If the <i>pName</i> parameter points to a computer name, all permanent addresses for the computer that can be used as a source address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to false in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. 
     * 
     * If the <i>pName</i> parameter points to a string equal to "localhost", all loopback addresses on the local computer are returned. 
     * 
     * If the <i>pName</i> parameter contains an empty string, all registered addresses on the local computer are returned. 
     * 
     * On Windows Server 2003 and later if the <i>pName</i> parameter points to a string equal to "..localmachine", all registered addresses on the local computer are returned. 
     * 
     * If the <i>pName</i> parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to true in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. See <a href="https://docs.microsoft.com/previous-versions/windows/desktop/mscs/windows-clustering">Windows Clustering</a> for more information about clustering.
     * 
     * Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This also changes the behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  
     * 
     * A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address.  This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  For more information, see <a href="https://support.microsoft.com/kb/2386184">Knowledge Base (KB) 2386184</a>.   
     * 
     * A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2) that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS. 
     * 
     * Callers of the 
     * <b>GetAddrInfoEx</b> function can provide hints about the type of socket supported through an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter. When the <i>pHints</i> parameter is used, the following rules apply to its associated 
     * <b>addrinfoex</b> structure:
     * 
     * <ul>
     * <li>A value of <b>AF_UNSPEC</b> for <b>ai_family</b> indicates the caller will accept only the <b>AF_INET</b> and <b>AF_INET6</b> address families. Note that <b>AF_UNSPEC</b> and <b>PF_UNSPEC</b> are the same.</li>
     * <li>A value of zero for <b>ai_socktype</b> indicates the caller will accept any socket type. </li>
     * <li>A value of zero for <b>ai_protocol</b> indicates the caller will accept any protocol.</li>
     * <li>The <b>ai_addrlen</b> member must be set to zero.</li>
     * <li>The <b>ai_canonname</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_addr</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_next</b> member must be set to <b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * Other values in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure provided in the <i>pHints</i> parameter indicate specific requirements. For example, if the caller handles only IPv4 and does not handle IPv6, the <b>ai_family</b> member should be set to <b>AF_INET</b>. For another example, if the caller handles only TCP and does not handle UDP, the <b>ai_socktype</b> member should be set to <b>SOCK_STREAM</b>. 
     * 
     * If the <i>pHints</i> parameter is a <b>NULL</b> pointer, the 
     * <b>GetAddrInfoEx</b> function treats it as if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure in <i>pHints</i> were initialized with its <b>ai_family</b> member set to <b>AF_UNSPEC</b> and all other members set to <b>NULL</b> or zero.
     * 
     * When <b>GetAddrInfoEx</b> is called from a service, if the operation is the result of a user process calling the service, the service should impersonate the user.  This is to allow security to be properly enforced.
     * 
     * 
     * The 
     * <b>GetAddrInfoEx</b> function can be used to convert a text string representation of an IP address to an <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure that contains a   <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the IP address and other information. To be used in this way, the string pointed to by the <i>pName</i> parameter must contain a text representation of an IP address and the <b>addrinfoex</b> structure pointed to by the <i>pHints</i> parameter must have the AI_NUMERICHOST flag set in the <b>ai_flags</b> member. The string pointed to by the <i>pName</i> parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an <b>addrinfoex</b> structure pointed to by the <i>ppResult</i> parameter. The returned <b>addrinfoex</b> structure contains a <b>sockaddr</b> structure for the IP address along with additional information about the IP address. 
     * 
     * Multiple namespace providers may be installed on a local computer for the same namespace. For example, the base Windows TCP/IP networking software registers for the NS_DNS namespace. The Microsoft Forefront Threat Management Gateway (TMG) and the older Microsoft Internet Security and Acceleration (ISA) Server include Firewall Client software that also registers for the NS_DNS namespace. When the <i>dwNameSpace</i> parameter is set to a value (NS_DNS, for example) and the <i>lpNspId</i> parameter is <b>NULL</b>, the results returned by the <b>GetAddrInfoEx</b> function are the merged results from all namespace providers that register for the specified namespace with duplicate results eliminated. The <i>lpNspId</i> parameter should be set to the GUID of the specific namespace provider if only a single namespace provider is to be queried. 
     * 
     * If the <i>pNameSpace</i> parameter is set to NS_ALL, then the results from querying all namespace providers is merged and returned. In this case, duplicate responses may be returned in the results pointed to by the <i>ppResult</i> parameter if multiple namespace providers return the same information.
     * 
     * On Windows 8 and Windows Server 2012, if the <b>GetAddrInfoEx</b> function will complete asynchronously, the pointer returned in the <i>lpNameHandle</i> parameter may be used with the <b>GetAddrInfoExCancel</b> function. The handle returned is valid when <b>GetAddrInfoEx</b> returns until the completion routine is called, the event is triggered, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexcancel">GetAddrInfoExCancel</a> function is called with this handle.
     * 
     * <h3><a id="Freeing_Address_Information_from_Dynamic_Allocation"></a><a id="freeing_address_information_from_dynamic_allocation"></a><a id="FREEING_ADDRESS_INFORMATION_FROM_DYNAMIC_ALLOCATION"></a>Freeing Address Information from Dynamic Allocation</h3>
     * All information returned by the 
     * <b>GetAddrInfoEx</b> function pointed to by the <i>ppResult</i> parameter is dynamically allocated, including all 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures, socket address structures, and canonical host name strings pointed to by 
     * <b>addrinfoex</b> structures. Memory allocated by a successful call to this function must be released with a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoex">FreeAddrInfoEx</a>.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>GetAddrInfoEx</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer<PSTR>} pName A pointer to a <b>NULL</b>-terminated string containing a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {Pointer<PSTR>} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains either a service name or port number represented as a string.
     * 
     * A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Integer} dwNameSpace An optional namespace identifier that determines which namespace providers are queried.  Passing a specific namespace identifier will result in only namespace providers that support the specified namespace being queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are added on Windows Vista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many other values are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * <dt>12</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * <dt>13</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP (NETBT) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_WINS"></a><a id="ns_wins"></a><dl>
     * <dt><b>NS_WINS</b></dt>
     * <dt>14</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Internet Naming Service (NS_WINS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * <dt>15</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. 
     * 
     * This namespace identifier is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NTDS"></a><a id="ns_ntds"></a><dl>
     * <dt><b>NS_NTDS</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows NT Directory Services (NS_NTDS) namespace. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * <dt>37</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * <dt>38</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * <dt>39</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to query in the case where  multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for specific namespace provider will result in only the specified namespace provider being queried. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<ADDRINFOEXA>} hints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <b>GetAddrInfoEx</b> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<ADDRINFOEXA>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures that contains response information about the host.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function. Otherwise, this parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows 8 and Windows Server 2012, if no <i>lpCompletionRoutine</i> parameter is specified, the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure must be set to a manual-reset event to be called upon completion of an asynchronous call. If a completion routine has been specified, the <b>hEvent</b> member must be NULL. When the event specified by <b>hEvent</b> has been set, the result of the operation can be retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexoverlappedresult">GetAddrInfoExOverlappedResult</a> function.
     * 
     * On Windows 8 and Windows Server 2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine An optional pointer to a function to be invoked upon successful completion for asynchronous operations. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows 8 and Windows Server 2012, if this parameter is specified, it must be a pointer to a function with the following signature:
     * 
     * 
     * ```cpp
     * typedef   
     * void   
     * (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(   
     *     __in      DWORD    dwError,   
     *     __in      DWORD    dwBytes,   
     *     __in      LPWSAOVERLAPPED lpOverlapped   
     *     );   
     * 
     * ```
     * 
     * 
     * When the asynchronous operation has completed, the completion routine will be invoked with <i>lpOverlapped</i> parameter set to the value of <i>lpOverlapped</i> parameter passed to <b>GetAddrInfoEx</b>. The <b>Pointer</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the value of the <i>ppResult</i> parameter of the original call. If the <b>Pointer</b> member points to a non-NULL pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure, it is the caller’s responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoex">FreeAddrInfoEx</a> to free the <b>addrinfoex</b>  structure. The <i>dwError</i> parameter passed to the completion routine will be set to a Winsock error code. The <i>dwBytes</i> parameter is reserved for future use and must be ignored.
     * 
     * On Windows 8 and Windows Server 2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpNameHandle An optional pointer used only for asynchronous operations.  
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows 8 and Windows Server 2012, if the <b>GetAddrInfoEx</b> function will complete asynchronously, the pointer returned in this field may be used with the <b>GetAddrInfoExCancel</b> function. The handle returned is valid when <b>GetAddrInfoEx</b> returns until the completion routine is called, the event is triggered, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexcancel">GetAddrInfoExCancel</a> function is called with this handle.
     * 
     * On Windows 8 and Windows Server 2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa
     * @deprecated
     * @since windows6.0.6000
     */
    static GetAddrInfoExA(pName, pServiceName, dwNameSpace, lpNspId, hints, ppResult, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle) {
        DllCall("WS2_32.dll\GetAddrInfoExA", "ptr", pName, "ptr", pServiceName, "uint", dwNameSpace, "ptr", lpNspId, "ptr", hints, "ptr", ppResult, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpNameHandle)
    }

    /**
     * Provides protocol-independent name resolution with additional parameters to qualify which namespace providers should handle the request. (Unicode)
     * @remarks
     * The <b>GetAddrInfoEx</b>  function provides protocol-independent translation from host name to address and from service name to port number. The <b>GetAddrInfoEx</b>  function is an enhanced version of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a> functions. The <b>GetAddrInfoEx</b>  function allows specifying the namespace provider to resolve the query. 
     * 
     * The <b>GetAddrInfoEx</b>  function aggregates and returns results from multiple namespace providers, unless a specific namespace provider is specified. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local <i>hosts</i> file, an email provider (the <b>NS_EMAIL</b> namespace), or by other naming mechanisms.
     * 
     * When UNICODE or _UNICODE is defined, <b>GetAddrInfoEx</b> is defined to <b>GetAddrInfoExW</b>, the Unicode version of this function. The string parameters are defined to the <b>PWSTR</b> data type and the <b>ADDRINFOEXW</b> structure is used. On Windows 8 and Windows Server 2012, the <i>timeout</i>, <i>lpOverlapped</i>, <i>lpCompletionRoutine</i>, and <i>lpNameHandle</i> parameters may be used to call the <b>GetAddrInfoEx</b> function so that it can complete asynchronously. 
     * 
     * When UNICODE or _UNICODE is not defined, <b>GetAddrInfoEx</b> is defined to <b>GetAddrInfoExA</b>, the ANSI version of this function. The string parameters are of the <b>PCSTR</b> data type and the <b>ADDRINFOEXA</b> structure is used. The <i>timeout</i>, <i>lpOverlapped</i>, <i>lpCompletionRoutine</i>, and <i>lpNameHandle</i> parameters must be set to <b>NULL</b>.
     * 
     * One or both of the <i>pName</i> or <i>pServiceName</i> parameters must point to a <b>NULL</b>-terminated string. Generally both are provided.
     * 
     * Upon success, a linked list of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures is returned in the <i>ppResult</i> parameter. The list can be processed by following the pointer provided in the <b>ai_next</b> member of each returned 
     * <b>addrinfoex</b> structure until a <b>NULL</b> pointer is encountered. In each returned 
     * <b>addrinfoex</b> structure, the <b>ai_family</b>, <b>ai_socktype</b>, and <b>ai_protocol</b> members correspond to respective arguments in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> function call. Also, the <b>ai_addr</b> member in each returned 
     * <b>addrinfoex</b> structure points to a filled-in socket address structure, the length of which is specified in its <b>ai_addrlen</b> member.
     * 
     * If the <i>pName</i> parameter points to a computer name, all permanent addresses for the computer that can be used as a source address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to false in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. 
     * 
     * If the <i>pName</i> parameter points to a string equal to "localhost", all loopback addresses on the local computer are returned. 
     * 
     * If the <i>pName</i> parameter contains an empty string, all registered addresses on the local computer are returned. 
     * 
     * On Windows Server 2003 and later if the <i>pName</i> parameter points to a string equal to "..localmachine", all registered addresses on the local computer are returned. 
     * 
     * If the <i>pName</i> parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the  <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddresstable">GetUnicastIpAddressTable</a> or <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/nf-netioapi-getunicastipaddressentry">GetUnicastIpAddressEntry</a> functions in which the <b>SkipAsSource</b> member is set to true in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure. See <a href="https://docs.microsoft.com/previous-versions/windows/desktop/mscs/windows-clustering">Windows Clustering</a> for more information about clustering.
     * 
     * Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This also changes the behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  
     * 
     * A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address.  This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS.  For more information, see <a href="https://support.microsoft.com/kb/2386184">Knowledge Base (KB) 2386184</a>.   
     * 
     * A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2) that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such that if the <b>SkipAsSource</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/netioapi/ns-netioapi-mib_unicastipaddress_row">MIB_UNICASTIPADDRESS_ROW</a> structure is set to false, the IP address will be registered in DNS. If the <b>SkipAsSource</b> member is set to true, the IP address is not registered in DNS. 
     * 
     * 
     * Callers of the 
     * <b>GetAddrInfoEx</b> function can provide hints about the type of socket supported through an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter. When the <i>pHints</i> parameter is used, the following rules apply to its associated 
     * <b>addrinfoex</b> structure:
     * 
     * <ul>
     * <li>A value of <b>AF_UNSPEC</b> for <b>ai_family</b> indicates the caller will accept only the <b>AF_INET</b> and <b>AF_INET6</b> address families. Note that <b>AF_UNSPEC</b> and <b>PF_UNSPEC</b> are the same.</li>
     * <li>A value of zero for <b>ai_socktype</b> indicates the caller will accept any socket type. </li>
     * <li>A value of zero for <b>ai_protocol</b> indicates the caller will accept any protocol.</li>
     * <li>The <b>ai_addrlen</b> member must be set to zero.</li>
     * <li>The <b>ai_canonname</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_addr</b> member must be set to <b>NULL</b>.</li>
     * <li>The <b>ai_next</b> member must be set to <b>NULL</b>.</li>
     * </ul>
     * 
     * 
     * Other values in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure provided in the <i>pHints</i> parameter indicate specific requirements. For example, if the caller handles only IPv4 and does not handle IPv6, the <b>ai_family</b> member should be set to <b>AF_INET</b>. For another example, if the caller handles only TCP and does not handle UDP, the <b>ai_socktype</b> member should be set to <b>SOCK_STREAM</b>. 
     * 
     * If the <i>pHints</i> parameter is a <b>NULL</b> pointer, the 
     * <b>GetAddrInfoEx</b> function treats it as if the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure in <i>pHints</i> were initialized with its <b>ai_family</b> member set to <b>AF_UNSPEC</b> and all other members set to <b>NULL</b> or zero.
     * 
     * When <b>GetAddrInfoEx</b> is called from a service, if the operation is the result of a user process calling the service, the service should impersonate the user.  This is to allow security to be properly enforced.
     * 
     * 
     * The 
     * <b>GetAddrInfoEx</b> function can be used to convert a text string representation of an IP address to an <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure that contains a   <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the IP address and other information. To be used in this way, the string pointed to by the <i>pName</i> parameter must contain a text representation of an IP address and the <b>addrinfoex</b> structure pointed to by the <i>pHints</i> parameter must have the AI_NUMERICHOST flag set in the <b>ai_flags</b> member. The string pointed to by the <i>pName</i> parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an <b>addrinfoex</b> structure pointed to by the <i>ppResult</i> parameter. The returned <b>addrinfoex</b> structure contains a <b>sockaddr</b> structure for the IP address along with additional information about the IP address. 
     * 
     * Multiple namespace providers may be installed on a local computer for the same namespace. For example, the base Windows TCP/IP networking software registers for the NS_DNS namespace. The Microsoft Forefront Threat Management Gateway (TMG) and the older Microsoft Internet Security and Acceleration (ISA) Server include Firewall Client software that also registers for the NS_DNS namespace. When the <i>dwNameSpace</i> parameter is set to a value (NS_DNS, for example) and the <i>lpNspId</i> parameter is <b>NULL</b>, the results returned by the <b>GetAddrInfoEx</b> function are the merged results from all namespace providers that register for the specified namespace with duplicate results eliminated. The <i>lpNspId</i> parameter should be set to the GUID of the specific namespace provider if only a single namespace provider is to be queried. 
     * 
     * If the <i>pNameSpace</i> parameter is set to NS_ALL, then the results from querying all namespace providers is merged and returned. In this case, duplicate responses may be returned in the results pointed to by the <i>ppResult</i> parameter if multiple namespace providers return the same information.
     * 
     * On Windows 8 and Windows Server 2012, if the <b>GetAddrInfoEx</b> function will complete asynchronously, the pointer returned in the <i>lpNameHandle</i> parameter may be used with the <b>GetAddrInfoExCancel</b> function. The handle returned is valid when <b>GetAddrInfoEx</b> returns until the completion routine is called, the event is triggered, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexcancel">GetAddrInfoExCancel</a> function is called with this handle.
     * 
     * <h3><a id="Freeing_Address_Information_from_Dynamic_Allocation"></a><a id="freeing_address_information_from_dynamic_allocation"></a><a id="FREEING_ADDRESS_INFORMATION_FROM_DYNAMIC_ALLOCATION"></a>Freeing Address Information from Dynamic Allocation</h3>
     * All information returned by the 
     * <b>GetAddrInfoEx</b> function pointed to by the <i>ppResult</i> parameter is dynamically allocated, including all 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures, socket address structures, and canonical host name strings pointed to by 
     * <b>addrinfoex</b> structures. Memory allocated by a successful call to this function must be released with a subsequent call to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoex">FreeAddrInfoEx</a>.
     * 
     * <h3><a id="Example_Code"></a><a id="example_code"></a><a id="EXAMPLE_CODE"></a>Example Code</h3>
     * The following example demonstrates the use of the <b>GetAddrInfoEx</b> function.
     * 
     * 
     * ```cpp
     * @param {Pointer<PWSTR>} pName A pointer to a <b>NULL</b>-terminated string containing a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {Pointer<PWSTR>} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains either a service name or port number represented as a string.
     * 
     * A service name is a string alias for a port number. For example, “http” is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Integer} dwNameSpace An optional namespace identifier that determines which namespace providers are queried.  Passing a specific namespace identifier will result in only namespace providers that support the specified namespace being queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are added on Windows Vista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many other values are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * <dt>12</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * <dt>13</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP (NETBT) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_WINS"></a><a id="ns_wins"></a><dl>
     * <dt><b>NS_WINS</b></dt>
     * <dt>14</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Internet Naming Service (NS_WINS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * <dt>15</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. 
     * 
     * This namespace identifier is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NTDS"></a><a id="ns_ntds"></a><dl>
     * <dt><b>NS_NTDS</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows NT Directory Services (NS_NTDS) namespace. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * <dt>37</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * <dt>38</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * <dt>39</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. 
     * 
     * This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to query in the case where  multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for specific namespace provider will result in only the specified namespace provider being queried. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<ADDRINFOEXW>} hints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <b>GetAddrInfoEx</b> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<ADDRINFOEXW>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures that contains response information about the host.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function. Otherwise, this parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows 8 and Windows Server 2012, if no <i>lpCompletionRoutine</i> parameter is specified, the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure must be set to a manual-reset event to be called upon completion of an asynchronous call. If a completion routine has been specified, the <b>hEvent</b> member must be NULL. When the event specified by <b>hEvent</b> has been set, the result of the operation can be retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexoverlappedresult">GetAddrInfoExOverlappedResult</a> function.
     * 
     * On Windows 8 and Windows Server 2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * An optional pointer to a function to be invoked upon successful completion for asynchronous operations. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows 8 and Windows Server 2012, if this parameter is specified, it must be a pointer to a function with the following signature:
     * 
     * 
     * ```cpp
     * typedef   
     * void   
     * (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(   
     *     __in      DWORD    dwError,   
     *     __in      DWORD    dwBytes,   
     *     __in      LPWSAOVERLAPPED lpOverlapped   
     *     );   
     * 
     * ```
     * 
     * 
     * When the asynchronous operation has completed, the completion routine will be invoked with <i>lpOverlapped</i> parameter set to the value of <i>lpOverlapped</i> parameter passed to <b>GetAddrInfoEx</b>. The <b>Pointer</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the value of the <i>ppResult</i> parameter of the original call. If the <b>Pointer</b> member points to a non-NULL pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure, it is the caller’s responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoex">FreeAddrInfoEx</a> to free the <b>addrinfoex</b>  structure. The <i>dwError</i> parameter passed to the completion routine will be set to a Winsock error code. The <i>dwBytes</i> parameter is reserved for future use and must be ignored.
     * 
     * On Windows 8 and Windows Server 2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpHandle TBD
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexw
     * @since windows6.0.6000
     */
    static GetAddrInfoExW(pName, pServiceName, dwNameSpace, lpNspId, hints, ppResult, timeout, lpOverlapped, lpCompletionRoutine, lpHandle) {
        DllCall("WS2_32.dll\GetAddrInfoExW", "ptr", pName, "ptr", pServiceName, "uint", dwNameSpace, "ptr", lpNspId, "ptr", hints, "ptr", ppResult, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpHandle)
    }

    /**
     * Cancels an asynchronous operation by the GetAddrInfoEx function.
     * @remarks
     * The <b>GetAddrInfoExCancel</b> function cancels an asynchronous <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> operation. The result is that the user's completion
     *     mechanism, either a callback or an event, is immediately invoked. No results are returned,
     *     and the error code returned for the <b>GetAddrInfoEx</b> asynchronous operation is set to <b>WSA_E_CANCELLED</b>. If the <b>GetAddrInfoEx</b> request has already completed or timed out,
     *     or the handle is invalid, and <b>WSA_INVALID_HANDLE</b> will be returned by <b>GetAddrInfoExCancel</b> function.
     * 
     * 
     * Since many of the underlying operations (legacy name service providers, for example) are synchronous, these operations
     *     will not actually be cancelled. These operations will continue running and consuming resources. Once the
     *     last outstanding name service provider request has completed, the resources will be released. 
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<HANDLE>} lpHandle The handle of the asynchronous operation to cancel. This is the handle returned in the <i>lpNameHandle</i> parameter by the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexcancel
     * @since windows8.1
     */
    static GetAddrInfoExCancel(lpHandle) {
        DllCall("WS2_32.dll\GetAddrInfoExCancel", "ptr", lpHandle)
    }

    /**
     * Gets the return code for an OVERLAPPED structure used by an asynchronous operation for the GetAddrInfoEx function.
     * @remarks
     * The 
     * <b>GetAddrInfoExOverlappedResult</b> function is used with the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function for asynchronous operations.
     * 
     * If the <b>GetAddrInfoExOverlappedResult</b> function returns <b>WSAEINVAL</b>, the only way to distinguish whether <b>GetAddrInfoExOverlappedResult</b> function or the asynchronous operation returned  the
     *     error is to check that the <i>lpOverlapped</i> parameter was not NULL. If the <i>lpOverlapped</i> parameter was NULL, then the <b>GetAddrInfoExOverlappedResult</b> function was passed a NULL pointer and failed. 
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <b>OVERLAPPED</b> structure for the asynchronous operation.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexoverlappedresult
     * @since windows8.1
     */
    static GetAddrInfoExOverlappedResult(lpOverlapped) {
        DllCall("WS2_32.dll\GetAddrInfoExOverlappedResult", "ptr", lpOverlapped)
    }

    /**
     * Registers or deregisters a name, a service name, and associated addresses with a specific namespace provider. (ANSI)
     * @remarks
     * The <b>SetAddrInfoEx</b>  function provides a protocol-independent method to register or deregister a name and one or more addresses with a namespace provider. The NS_EMAIL namespace provider in Windows Vista and later supports registration and deregistration of addresses. The default NS_DNS, NS_PNRPNAME, and NS_PNRPNAME namespace providers do not currently support name registration.
     * 
     * If the <b>SetAddrInfoEx</b>  function is called with NS_ALL set as the <i>dwNameSpace</i> parameter and the <i>lpNspId</i> parameter unspecified, then <b>SetAddrInfoEx</b> will attempt to register or deregister the name and associated addresses with all installed and active namespaces. The <b>SetAddrInfoEx</b> function will return success if any of the namespace providers successfully registered or deregistered the name, but there will not be any indication of which namespace provider succeeded or which ones failed the request. 
     * 
     * When <b>UNICODE</b> or <b>_UNICODE</b> is defined, <b>SetAddrInfoEx</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">SetAddrInfoExW</a>, the Unicode version of this function. The string parameters are defined to the <b>PWSTR</b> data type.
     * 
     * When <b>UNICODE</b> or <b>_UNICODE</b> is not defined, <b>SetAddrInfoEx</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">SetAddrInfoExA</a>, the ANSI version of this function. The string parameters are of the <b>PCSTR</b> data type.
     * 
     * Information  that is registered with a namespace provider can be returned by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a>,   <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a> functions.  The <b>GetAddrInfoEx</b> function is an enhanced version of the <b>getaddrinfo</b> and <b>GetAddrInfoW</b> functions. 
     * 
     * On Windows Vista and later, when <b>SetAddrInfoEx</b> is called from a service, if the operation is the result of a user process calling the service, then the service should impersonate the user.  This is to allow security and routing compartments to be properly enforced.
     * 
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>SetAddrInfoExW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ws2tcpip.h header defines SetAddrInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PSTR>} pName A pointer to a <b>NULL</b>-terminated string containing a name under which addresses are to be registered or deregistered. The interpretation of this parameter specific to the namespace provider.
     * @param {Pointer<PSTR>} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains the service name  associated with the name being registered. The interpretation of this parameter is specific to the namespace provider.
     * @param {Pointer<SOCKET_ADDRESS>} pAddresses A pointer to an optional list of addresses to register with the namespace provider.
     * @param {Integer} dwAddressCount The number of addresses passed in <i>pAddresses</i> parameter.
     * If this parameter is zero, the <i>pName</i> parameter is deregistered from the namespace provider.
     * @param {Pointer<BLOB>} lpBlob An optional pointer to data that is used to set provider-specific namespace information that is associated with the <i>pName</i> parameter beyond a list of addresses. Any information that cannot be passed in the <i>pAddresses</i> parameter can be passed in the <i>lpBlob</i> parameter. The format of this information is specific to the namespace provider.
     * @param {Integer} dwFlags A set of flags controlling how the <i>pName</i> and <i>pServiceName</i> parameters are to be  registered with the namespace provider. The interpretation of this information is specific to the namespace provider.
     * @param {Integer} dwNameSpace A namespace identifier that determines which namespace provider to register this information with.  Passing a specific namespace identifier will result in registering this information only with the namespace providers that support the specified namespace. Specifying NS_ALL will result in registering the information with all installed and active namespace providers. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with Windows Vista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many others are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to register this information with in the case where  multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a specific namespace provider will result in the information being registered with only the specified namespace provider. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. This parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpNameHandle An optional pointer used only for asynchronous operations.  This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-setaddrinfoexa
     * @deprecated
     * @since windows8.1
     */
    static SetAddrInfoExA(pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle) {
        DllCall("WS2_32.dll\SetAddrInfoExA", "ptr", pName, "ptr", pServiceName, "ptr", pAddresses, "uint", dwAddressCount, "ptr", lpBlob, "uint", dwFlags, "uint", dwNameSpace, "ptr", lpNspId, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpNameHandle)
    }

    /**
     * Registers or deregisters a name, a service name, and associated addresses with a specific namespace provider. (Unicode)
     * @remarks
     * The <b>SetAddrInfoEx</b>  function provides a protocol-independent method to register or deregister a name and one or more addresses with a namespace provider. The NS_EMAIL namespace provider in Windows Vista and later supports registration and deregistration of addresses. The default NS_DNS, NS_PNRPNAME, and NS_PNRPNAME namespace providers do not currently support name registration.
     * 
     * If the <b>SetAddrInfoEx</b>  function is called with NS_ALL set as the <i>dwNameSpace</i> parameter and the <i>lpNspId</i> parameter unspecified, then <b>SetAddrInfoEx</b> will attempt to register or deregister the name and associated addresses with all installed and active namespaces. The <b>SetAddrInfoEx</b> function will return success if any of the namespace providers successfully registered or deregistered the name, but there will not be any indication of which namespace provider succeeded or which ones failed the request. 
     * 
     * When <b>UNICODE</b> or <b>_UNICODE</b> is defined, <b>SetAddrInfoEx</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">SetAddrInfoExW</a>, the Unicode version of this function. The string parameters are defined to the <b>PWSTR</b> data type.
     * 
     * When <b>UNICODE</b> or <b>_UNICODE</b> is not defined, <b>SetAddrInfoEx</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">SetAddrInfoExA</a>, the ANSI version of this function. The string parameters are of the <b>PCSTR</b> data type.
     * 
     * Information  that is registered with a namespace provider can be returned by calling the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a>,   <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a> functions.  The <b>GetAddrInfoEx</b> function is an enhanced version of the <b>getaddrinfo</b> and <b>GetAddrInfoW</b> functions. 
     * 
     * On Windows Vista and later, when <b>SetAddrInfoEx</b> is called from a service, if the operation is the result of a user process calling the service, then the service should impersonate the user.  This is to allow security and routing compartments to be properly enforced.
     * 
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>SetAddrInfoExW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ws2tcpip.h header defines SetAddrInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<PWSTR>} pName A pointer to a <b>NULL</b>-terminated string containing a name under which addresses are to be registered or deregistered. The interpretation of this parameter specific to the namespace provider.
     * @param {Pointer<PWSTR>} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains the service name  associated with the name being registered. The interpretation of this parameter is specific to the namespace provider.
     * @param {Pointer<SOCKET_ADDRESS>} pAddresses A pointer to an optional list of addresses to register with the namespace provider.
     * @param {Integer} dwAddressCount The number of addresses passed in <i>pAddresses</i> parameter.
     * If this parameter is zero, the <i>pName</i> parameter is deregistered from the namespace provider.
     * @param {Pointer<BLOB>} lpBlob An optional pointer to data that is used to set provider-specific namespace information that is associated with the <i>pName</i> parameter beyond a list of addresses. Any information that cannot be passed in the <i>pAddresses</i> parameter can be passed in the <i>lpBlob</i> parameter. The format of this information is specific to the namespace provider.
     * @param {Integer} dwFlags A set of flags controlling how the <i>pName</i> and <i>pServiceName</i> parameters are to be  registered with the namespace provider. The interpretation of this information is specific to the namespace provider.
     * @param {Integer} dwNameSpace A namespace identifier that determines which namespace provider to register this information with.  Passing a specific namespace identifier will result in registering this information only with the namespace providers that support the specified namespace. Specifying NS_ALL will result in registering the information with all installed and active namespace providers. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with Windows Vista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many others are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to register this information with in the case where  multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a specific namespace provider will result in the information being registered with only the specified namespace provider. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. This parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpNameHandle An optional pointer used only for asynchronous operations.  This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-setaddrinfoexw
     * @since windows8.1
     */
    static SetAddrInfoExW(pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle) {
        DllCall("WS2_32.dll\SetAddrInfoExW", "ptr", pName, "ptr", pServiceName, "ptr", pAddresses, "uint", dwAddressCount, "ptr", lpBlob, "uint", dwFlags, "uint", dwNameSpace, "ptr", lpNspId, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpNameHandle)
    }

    /**
     * Frees address information that the getaddrinfo function dynamically allocates in addrinfo structures.
     * @remarks
     * The 
     * <b>freeaddrinfo</b> function frees <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structures dynamically allocated by the ANSI <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfo">getaddrinfo</a> function. The <b>freeaddrinfo</b> function frees the initial 
     * <b>addrinfo</b> structure pointed to in the <i>ai</i> parameter, including any buffers to which structure members point, then continues freeing any 
     * <b>addrinfo</b> structures linked by the <b>ai_next</b> member of the <b>addrinfo</b> structure. The 
     * <b>freeaddrinfo</b> function continues freeing linked structures until a <b>NULL</b> <b>ai_next</b> member is encountered.
     * 
     * Macros in the Winsock header file define a mixed-case function name of <b>FreeAddrInfo</b> and an <b>ADDRINFOT</b> structure. This <b>FreeAddrInfo</b> function should be called with the <i>ai</i> parameter of a pointer of type <b>ADDRINFOT</b>. When UNICODE or _UNICODE is not defined, <b>FreeAddrInfo</b> is defined to <b>freeaddrinfo</b>, the ANSI version of the function, and <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure. When UNICODE or _UNICODE is defined, <b>FreeAddrInfo</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfow">FreeAddrInfoW</a>, the Unicode version of the function, and <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure.
     * 
     * <h3><a id="Support_for_freeaddrinfo_on_earlier_versions_of_Windows_"></a><a id="support_for_freeaddrinfo_on_earlier_versions_of_windows_"></a><a id="SUPPORT_FOR_FREEADDRINFO_ON_EARLIER_VERSIONS_OF_WINDOWS_"></a>Support for freeaddrinfo on earlier versions of Windows
     * </h3>
     * The <b>freeaddrinfo</b> function was added to the <i>Ws2_32.dll</i> on Windows XP and later. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfow">FreeAddrInfoW</a> function is the Unicode version of  <b>freeaddrinfo</b>.  The <b>FreeAddrInfoW</b> function was added to the <i>Ws2_32.dll</i> in Windows XP with Service Pack 2 (SP2). The <b>FreeAddrInfoW</b> function cannot be used on versions of Windows earlier than Windows XP with SP2.
     * 
     * <b>Windows Phone 8:</b> The <b>freeaddrinfo</b> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>freeaddrinfo</b> and  <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfow">FreeAddrInfoW</a> functions are supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<ADDRINFOA>} pAddrInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure or linked list of 
     * <b>addrinfo</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfo</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-freeaddrinfo
     * @since windows8.1
     */
    static freeaddrinfo(pAddrInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\freeaddrinfo", "ptr", pAddrInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Frees address information that the GetAddrInfoW function dynamically allocates in addrinfoW structures.
     * @remarks
     * The 
     * <b>FreeAddrInfoW</b> function frees <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structures dynamically allocated by the Unicode <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfow">GetAddrInfoW</a> function. The <b>FreeAddrInfoW</b> function frees the initial 
     * <b>addrinfoW</b> structure pointed to in the <i>pAddrInfo</i> parameter, including any buffers to which structure members point, then continues freeing any 
     * <b>addrinfoW</b> structures linked by the <b>ai_next</b> member of the <b>addrinfoW</b> structure. The 
     * <b>FreeAddrInfoW</b> function continues freeing linked structures until a <b>NULL</b> <b>ai_next</b> member is encountered.
     * 
     * Macros in the Winsock header file define a mixed-case function name of <b>FreeAddrInfo</b> and an <b>ADDRINFOT</b> structure. This <b>FreeAddrInfo</b> function should be called with the <i>pAddrInfo</i> parameter of a pointer of type <b>ADDRINFOT</b>. When UNICODE or _UNICODE is defined, <b>FreeAddrInfo</b> is defined to <b>FreeAddrInfoW</b>, the Unicode version of the function, and <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure. When UNICODE or _UNICODE is not defined, <b>FreeAddrInfo</b> is defined to <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfo">freeaddrinfo</a>, the ANSI version of the function, and <b>ADDRINFOT</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: This function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ws2tcpip.h header defines FreeAddrInfo as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<ADDRINFOW>} pAddrInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure or linked list of 
     * <b>addrinfoW</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfoW</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-freeaddrinfow
     * @since windows8.1
     */
    static FreeAddrInfoW(pAddrInfo) {
        DllCall("WS2_32.dll\FreeAddrInfoW", "ptr", pAddrInfo)
    }

    /**
     * The FreeAddrInfoEx function (ws2tcpip.h) frees address information that the GetAddrInfoEx function dynamically allocates in addrinfoex structures.
     * @remarks
     * The 
     * <b>FreeAddrInfoEx</b> function frees <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures dynamically allocated by the  <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function. The <b>FreeAddrInfoEx</b> function frees the initial 
     * <b>addrinfoex</b> structure pointed to in the <i>pAddrInfo</i> parameter, including any buffers to which structure members point, then continues freeing any 
     * <b>addrinfoex</b> structures linked by the <b>ai_next</b> member of the <b>addrinfoex</b> structure. The 
     * <b>FreeAddrInfoEx</b> function continues freeing linked structures until a <b>NULL</b> <b>ai_next</b> member is encountered.
     * 
     * When UNICODE or _UNICODE is defined, <b>FreeAddrInfoEx</b> is defined to <b>FreeAddrInfoExW</b>, the Unicode version of the function, and <b>ADDRINFOEX</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoexW</a> structure. When UNICODE or _UNICODE is not defined, <b>FreeAddrInfoEx</b> is defined to <b>FreeAddrInfoExA</b>, the ANSI version of the function, and <b>ADDRINFOEX</b> is defined to the <b>addrinfoexA</b> structure. 
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>FreeAddrInfoExW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Pointer<ADDRINFOEXA>} pAddrInfoEx A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure or linked list of 
     * <b>addrinfoex</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfoex</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoex
     * @deprecated
     * @since windows8.1
     */
    static FreeAddrInfoEx(pAddrInfoEx) {
        DllCall("WS2_32.dll\FreeAddrInfoEx", "ptr", pAddrInfoEx)
    }

    /**
     * The FreeAddrInfoExW (Unicode) function (ws2tcpip.h) frees address information that the GetAddrInfoEx function dynamically allocates in addrinfoex structures.
     * @remarks
     * The 
     * <b>FreeAddrInfoEx</b> function frees <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures dynamically allocated by the  <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function. The <b>FreeAddrInfoEx</b> function frees the initial 
     * <b>addrinfoex</b> structure pointed to in the <i>pAddrInfo</i> parameter, including any buffers to which structure members point, then continues freeing any 
     * <b>addrinfoex</b> structures linked by the <b>ai_next</b> member of the <b>addrinfoex</b> structure. The 
     * <b>FreeAddrInfoEx</b> function continues freeing linked structures until a <b>NULL</b> <b>ai_next</b> member is encountered.
     * 
     * When UNICODE or _UNICODE is defined, <b>FreeAddrInfoEx</b> is defined to <b>FreeAddrInfoExW</b>, the Unicode version of the function, and <b>ADDRINFOEX</b> is defined to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoexW</a> structure. When UNICODE or _UNICODE is not defined, <b>FreeAddrInfoEx</b> is defined to <b>FreeAddrInfoExA</b>, the ANSI version of the function, and <b>ADDRINFOEX</b> is defined to the <b>addrinfoexA</b> structure. 
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The <b>FreeAddrInfoExW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * 
     * 
     * 
     * 
     * 
     * > [!NOTE]
     * > The ws2tcpip.h header defines FreeAddrInfoEx as an alias which automatically selects the ANSI or Unicode version of this function based on the definition of the UNICODE preprocessor constant. Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches that result in compilation or runtime errors. For more information, see [Conventions for Function Prototypes](/windows/win32/intl/conventions-for-function-prototypes).
     * @param {Pointer<ADDRINFOEXW>} pAddrInfoEx A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure or linked list of 
     * <b>addrinfoex</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfoex</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoexw
     * @since windows8.1
     */
    static FreeAddrInfoExW(pAddrInfoEx) {
        DllCall("WS2_32.dll\FreeAddrInfoExW", "ptr", pAddrInfoEx)
    }

    /**
     * Provides protocol-independent name resolution from an address to an ANSI host name and from a port number to the ANSI service name.
     * @remarks
     * The <b>getnameinfo</b> function is the ANSI version of a function that provides protocol-independent name resolution. The <b>getnameinfo</b> function is used to translate the contents of a socket address structure to a node name and/or a service name.
     * 
     * For IPv6 and IPv4 protocols, Name resolution can be by the Domain Name System (DNS), a local <i>hosts</i> file, or by other naming mechanisms. This function can be used to determine the host name for an IPv4 or IPv6  address, a reverse DNS lookup, or determine the service name for a port number. The <b>getnameinfo</b> function can also be used to convert an IP address or  a port number in a <b>sockaddr</b> structure to an ANSI string. This function can also be used to determine the IP address for a host name.
     * 
     * Another name that can be used for the <b>getnameinfo</b> function is <b>GetNameInfoA</b>. Macros in the <i>Ws2tcpip.h</i> header file define <b>GetNameInfoA</b> to <b>getnameinfo</b>.
     * 
     * The Unicode version of this function available on Windows XP with Service Pack 2 (SP2) and later is <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getnameinfow">GetNameInfoW</a>.
     * 
     * Macros in the Winsock header file define a mixed-case function name of <b>GetNameInfo</b> that can be used when the application is targeted for  Windows XP with SP2 and later (_WIN32_WINNT &gt;= 0x0502). This <b>GetNameInfo</b> function should be called with the <i>host</i> and <i>serv</i> parameters of a pointer of type  <b>TCHAR</b>. When UNICODE or _UNICODE is not defined, <b>GetNameInfo</b> is defined to the ANSI version and <b>getnameinfo</b> is called with the <i>host</i> and <i>serv</i> parameters of a pointer of type <b>char</b>. When UNICODE or _UNICODE is defined, <b>GetNameInfo</b> is defined to the Unicode version and <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getnameinfow">GetNameInfoW</a> is called with the <i>pNodeBuffer</i> and <i>pServiceBuffer</i> parameters of a pointer of type <b>PWCHAR</b>.
     * 
     * To simplify determining buffer requirements for the <i>host</i> and <i>serv</i> parameters, the following values for maximum host name length and maximum service name are defined in the <i>Ws2tcpip.h</i> header file.
     * 
     * 
     * ```cpp
     * @param {Pointer<SOCKADDR>} pSockaddr A pointer to a socket address structure that contains the address and port number of the socket. For IPv4, the <i>sa</i> parameter points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr_in</a> structure. For IPv6, the <i>sa</i> parameter points to a <b>sockaddr_in6</b> structure.
     * @param {Integer} SockaddrLength The length, in bytes, of the structure pointed to by the <i>sa</i> parameter.
     * @param {Pointer<PSTR>} pNodeBuffer A pointer to  an ANSI string used to hold the host name. On success, the host name is returned as a Fully Qualified Domain Name (FQDN) by default. If the <i>host</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a host name string.
     * @param {Integer} NodeBufferSize The length, in bytes, of the buffer pointed to by the <i>host</i> parameter. The caller must provide a buffer large enough to hold the host name, including the terminating <b>NULL</b> character.
     * @param {Pointer<PSTR>} pServiceBuffer A pointer to  an ANSI string to hold the service name. On success, an ANSI string that represents the service name associated with the port number is returned. If the <i>serv</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a service name string.
     * @param {Integer} ServiceBufferSize The length, in bytes, of the buffer pointed to by the <i>serv</i> parameter. The caller must provide a buffer large enough to hold the service name, including the terminating <b>NULL</b> character.
     * @param {Integer} Flags A value used to customize processing of the 
     * <b>getnameinfo</b> function. See the Remarks section.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getnameinfo
     * @since windows8.1
     */
    static getnameinfo(pSockaddr, SockaddrLength, pNodeBuffer, NodeBufferSize, pServiceBuffer, ServiceBufferSize, Flags) {
        A_LastError := 0

        DllCall("WS2_32.dll\getnameinfo", "ptr", pSockaddr, "int", SockaddrLength, "ptr", pNodeBuffer, "uint", NodeBufferSize, "ptr", pServiceBuffer, "uint", ServiceBufferSize, "int", Flags)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Provides protocol-independent name resolution from an address to a Unicode host name and from a port number to the Unicode service name.
     * @remarks
     * The <b>GetNameInfoW</b> function is the Unicode version of a function that provides protocol-independent name resolution. The <b>GetNameInfoW</b> function is used to translate the contents of a socket address structure to a node name and/or a service name.
     * 
     * For the IPv6 and IPv4 protocols, name resolution can be by the Domain Name System (DNS), a local <i>hosts</i> file, or by other naming mechanisms. This function can be used to determine the host name for an IPv4 or IPv6  address, a reverse DNS lookup, or determine the service name for a port number. The <b>GetNameInfoW</b> function can also be used to convert an IP address or  a port number in a <b>SOCKADDR</b> structure to an Unicode string. This function can also be used to determine the IP address for a host name.
     * 
     * The ANSI version of this function is <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getnameinfo">getnameinfo</a>.
     * 
     * Macros in the Winsock header file define a mixed-case function name of <b>GetNameInfo</b> that can be used when the application is targeted for  Windows XP with Service Pack 2 (SP2) and later (_WIN32_WINNT &gt;= 0x0502). This <b>GetNameInfo</b> function should be called with the <i>pNodeBuffer</i> and <i>pServiceBuffer</i> parameters of a pointer of type  <b>TCHAR</b>. When UNICODE or _UNICODE is defined, <b>GetNameInfo</b> is defined to the Unicode version and <b>GetNameInfoW</b> is called with the <i>host</i> and <i>serv</i> parameters of a pointer of type <b>char</b>. When UNICODE or _UNICODE is not defined, <b>GetNameInfo</b> is defined to the ANSI version and <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getnameinfo">getnameinfo</a> is called with the <i>pNodeBuffer</i> and <i>pServiceBuffer</i> parameters of a pointer of type <b>PWCHAR</b>.
     * 
     * To simplify determining buffer requirements for the <i>pNodeBuffer</i> and <i>pServiceBuffer</i> parameters, the following values for maximum host name length and maximum service name are defined in the <i>Ws2tcpip.h</i> header file:
     * 
     * 
     * ```cpp
     * @param {Pointer<SOCKADDR>} pSockaddr A pointer to a socket address structure containing the IP address and port number of the socket. For IPv4, the <i>pSockaddr</i> parameter points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr_in</a> structure. For IPv6, the <i>pSockaddr</i> parameter points to a <b>sockaddr_in6</b> structure.
     * @param {Integer} SockaddrLength The length, in bytes, of the structure pointed to by the <i>pSockaddr</i> parameter.
     * @param {Pointer<PWSTR>} pNodeBuffer A pointer to  a Unicode string to hold the host name. On success, a pointer to the Unicode host name is returned as a Fully Qualified Domain Name (FQDN) by default. If the <i>pNodeBuffer</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a host name string.
     * @param {Integer} NodeBufferSize The number of <b>WCHAR</b> characters in the buffer pointed to by the <i>pNodeBuffer</i> parameter. The caller must provide a buffer large enough to hold the Unicode host name, including the terminating <b>NULL</b> character.
     * @param {Pointer<PWSTR>} pServiceBuffer A pointer to  a Unicode string to hold the service name. On success, a pointer is returned to a Unicode string representing the service name associated with the port number. If the <i>pServiceBuffer</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a service name string.
     * @param {Integer} ServiceBufferSize The number of <b>WCHAR</b> characters in the buffer pointed to by the <i>pServiceBuffer</i> parameter. The caller must provide a buffer large enough to hold the Unicode service name, including the terminating <b>NULL</b> character.
     * @param {Integer} Flags A value used to customize processing of the 
     * <b>GetNameInfoW</b> function. See the Remarks section.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-getnameinfow
     * @since windows8.1
     */
    static GetNameInfoW(pSockaddr, SockaddrLength, pNodeBuffer, NodeBufferSize, pServiceBuffer, ServiceBufferSize, Flags) {
        DllCall("WS2_32.dll\GetNameInfoW", "ptr", pSockaddr, "int", SockaddrLength, "ptr", pNodeBuffer, "uint", NodeBufferSize, "ptr", pServiceBuffer, "uint", ServiceBufferSize, "int", Flags)
    }

    /**
     * The InetPton function converts an IPv4 or IPv6 Internet network address in its standard text presentation form into its numeric binary form. The ANSI version of this function is inet_pton. (InetPtonA or inet_pton)
     * @remarks
     * The 
     * <b>InetPton</b> function is supported on Windows Vista and later.
     * 
     * The 
     * <b>InetPton</b> function provides a protocol-independent conversion of an Internet network address in its standard text   presentation form into its numeric binary form. The 
     * <b>InetPton</b> function takes a text representation of an Internet address pointed to  by the <i>pszAddrString</i> parameter and returns a pointer to the numeric binary IP address in the <i>pAddrBuf</i> parameter. While the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-inet_addr">inet_addr</a> function works only with IPv4 address strings, the <b>InetPton</b> function works with either IPv4 or IPv6 address strings.
     * 
     * The ANSI version of this function is <b>inet_pton</b> as defined in RFC 2553. For more information, see RFC 2553 available at the <a href="http://tools.ietf.org/html/rfc2553">IETF website</a>.
     * 
     * The 
     * <b>InetPton</b> function does not require that the Windows Sockets DLL be loaded to perform conversion of a text string that represents an IP address to a numeric binary IP address.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET</b>, then the <i>pszAddrString</i> parameter must point a text string of an IPv4 address  in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET6</b>, then the <i>pszAddrString</i> parameter must point a text string of an IPv6 address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
     * 
     * When UNICODE or _UNICODE is defined, <b>InetPton</b> is defined to <b>InetPtonW</b>, the Unicode version of this function. The <i>pszAddrString</i> parameter is defined to the <b>PCWSTR</b> data type.
     * 
     * When UNICODE or _UNICODE is not defined, <b>InetPton</b> is defined to <b>InetPtonA</b>, the ANSI version of this function. The ANSI version of this function is always defined as inet_pton. The <i>pszAddrString</i> parameter is defined to the <b>PCSTR</b> data type.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4stringtoaddressa">RtlIpv4StringToAddress</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4stringtoaddressexw">RtlIpv4StringToAddressEx</a> functions can be used to convert a text representation of an IPv4 address in Internet standard dotted-decimal notation to a numeric binary address represented as an  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure. On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6stringtoaddressa">RtlIpv6StringToAddress</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6stringtoaddressexw">RtlIpv6StringToAddressEx</a> functions can be used to convert a string representation of an IPv6 address to a numeric binary IPv6 address represented as an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure. The <b>RtlIpv6StringToAddressEx</b> function is more flexible since it also converts a string representation of an IPv6 address that can include a scope ID and port in standard notation to a numeric binary form.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>InetPtonW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} Family The address family. 
     * 
     * Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The values currently supported are <b>AF_INET</b> and <b>AF_INET6</b>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  the <i>pszAddrString</i> parameter must point to a text representation of an IPv4 address and the <i>pAddrBuf</i> parameter  returns a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure that represents the IPv4 address. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  the <i>pszAddrString</i> parameter must point to a text representation of an IPv6 address and the <i>pAddrBuf</i> parameter  returns a pointer to an  <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure that represents the IPv6 address.  
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PSTR>} pszAddrString A pointer to the <b>NULL</b>-terminated string that contains the text representation of the IP address to convert to numeric binary form.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pszAddrString</i> parameter must point to a text representation of an IPv4 address in standard dotted-decimal notation.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pszAddrString</i> parameter must point to a text representation of an IPv6 address in standard notation.
     * @param {Pointer<Void>} pAddrBuf A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in network byte order.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, this buffer should be large enough to hold an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>,  this buffer should be large enough to hold an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton
     * @since windows8.1
     */
    static inet_pton(Family, pszAddrString, pAddrBuf) {
        A_LastError := 0

        DllCall("WS2_32.dll\inet_pton", "int", Family, "ptr", pszAddrString, "ptr", pAddrBuf)
        if(A_LastError)
            throw OSError()

    }

    /**
     * The InetPton function converts an IPv4 or IPv6 Internet network address in its standard text presentation form into its numeric binary form. The ANSI version of this function is inet_pton. (InetPtonW)
     * @remarks
     * The 
     * <b>InetPton</b> function is supported on Windows Vista and later.
     * 
     * The 
     * <b>InetPton</b> function provides a protocol-independent conversion of an Internet network address in its standard text   presentation form into its numeric binary form. The 
     * <b>InetPton</b> function takes a text representation of an Internet address pointed to  by the <i>pszAddrString</i> parameter and returns a pointer to the numeric binary IP address in the <i>pAddrBuf</i> parameter. While the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-inet_addr">inet_addr</a> function works only with IPv4 address strings, the <b>InetPton</b> function works with either IPv4 or IPv6 address strings.
     * 
     * The ANSI version of this function is <b>inet_pton</b> as defined in RFC 2553. For more information, see RFC 2553 available at the <a href="http://tools.ietf.org/html/rfc2553">IETF website</a>.
     * 
     * The 
     * <b>InetPton</b> function does not require that the Windows Sockets DLL be loaded to perform conversion of a text string that represents an IP address to a numeric binary IP address.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET</b>, then the <i>pszAddrString</i> parameter must point a text string of an IPv4 address  in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET6</b>, then the <i>pszAddrString</i> parameter must point a text string of an IPv6 address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
     * 
     * When UNICODE or _UNICODE is defined, <b>InetPton</b> is defined to <b>InetPtonW</b>, the Unicode version of this function. The <i>pszAddrString</i> parameter is defined to the <b>PCWSTR</b> data type.
     * 
     * When UNICODE or _UNICODE is not defined, <b>InetPton</b> is defined to <b>InetPtonA</b>, the ANSI version of this function. The ANSI version of this function is always defined as <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-inetntopw">inet_pton</a>. The <i>pszAddrString</i> parameter is defined to the <b>PCSTR</b> data type.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4stringtoaddressa">RtlIpv4StringToAddress</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4stringtoaddressexw">RtlIpv4StringToAddressEx</a> functions can be used to convert a text representation of an IPv4 address in Internet standard dotted-decimal notation to a numeric binary address represented as an  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure. On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6stringtoaddressa">RtlIpv6StringToAddress</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6stringtoaddressexw">RtlIpv6StringToAddressEx</a> functions can be used to convert a string representation of an IPv6 address to a numeric binary IPv6 address represented as an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure. The <b>RtlIpv6StringToAddressEx</b> function is more flexible since it also converts a string representation of an IPv6 address that can include a scope ID and port in standard notation to a numeric binary form.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>InetPtonW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} Family The address family. 
     * 
     * Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The values currently supported are <b>AF_INET</b> and <b>AF_INET6</b>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  the <i>pszAddrString</i> parameter must point to a text representation of an IPv4 address and the <i>pAddrBuf</i> parameter  returns a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure that represents the IPv4 address. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  the <i>pszAddrString</i> parameter must point to a text representation of an IPv6 address and the <i>pAddrBuf</i> parameter  returns a pointer to an  <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure that represents the IPv6 address.  
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<PWSTR>} pszAddrString A pointer to the <b>NULL</b>-terminated string that contains the text representation of the IP address to convert to numeric binary form.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pszAddrString</i> parameter must point to a text representation of an IPv4 address in standard dotted-decimal notation.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pszAddrString</i> parameter must point to a text representation of an IPv6 address in standard notation.
     * @param {Pointer<Void>} pAddrBuf A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in network byte order.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, this buffer should be large enough to hold an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>,  this buffer should be large enough to hold an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetptonw
     * @since windows8.1
     */
    static InetPtonW(Family, pszAddrString, pAddrBuf) {
        DllCall("WS2_32.dll\InetPtonW", "int", Family, "ptr", pszAddrString, "ptr", pAddrBuf)
    }

    /**
     * The InetNtop function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The ANSI version of this function is inet_ntop. (InetNtopA or inet_ntop)
     * @remarks
     * The 
     * <b>InetNtop</b> function is supported on Windows Vista and later.
     * 
     * The 
     * <b>InetNtop</b> function provides a protocol-independent address-to-string translation. The 
     * <b>InetNtop</b> function takes an Internet address structure specified by the <i>pAddr</i> parameter and returns a <b>NULL</b>-terminated string that represents the IP address. While the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-inet_ntoa">inet_ntoa</a> function works only with IPv4 addresses, the <b>InetNtop</b> function works with either IPv4 or IPv6 addresses.
     * 
     * The ANSI version of this function is <b>inet_ntop</b> as defined in RFC 2553. For more information, see RFC 2553 available at the <a href="http://tools.ietf.org/html/rfc2553">IETF website</a>. 
     * 
     * The 
     * <b>InetNtop</b> function does not require that the Windows Sockets DLL be loaded to perform IP address to string conversion.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure with the IPv4 address to convert. The address string returned in the buffer pointed to by the <i>pStringBuf</i> parameter is  in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET6</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure with the IPv6 address to convert. The address string returned in the buffer pointed to by the <i>pStringBuf</i> parameter is in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
     * 
     * If the length of the buffer pointed to by the <i>pStringBuf</i> parameter is not large enough to receive the string representation of the IP address, <b>InetNtop</b> returns ERROR_INVALID_PARAMETER.
     * 
     * When UNICODE or _UNICODE is defined, <b>InetNtop</b> is defined to <b>InetNtopW</b>, the Unicode version of this function. The <i>pStringBuf</i> parameter is defined to the <b>PSTR</b> data type.
     * 
     * When UNICODE or _UNICODE is not defined, <b>InetNtop</b> is defined to <b>InetNtopA</b>, the ANSI version of this function. The ANSI version of this function is always defined as <b>inet_ntop</b>. The <i>pStringBuf</i> parameter is defined to the <b>PWSTR</b> data type.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4addresstostringa">RtlIpv4AddressToString</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4addresstostringexw">RtlIpv4AddressToStringEx</a> functions can be used to convert an IPv4 address represented as an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure to a string representation of an IPv4 address in Internet standard dotted-decimal notation. On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6addresstostringa">RtlIpv6AddressToString</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6addresstostringexw">RtlIpv6AddressToStringEx</a> functions can be used to convert an IPv6 address represented as an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure to a string representation of an IPv6 address. The <b>RtlIpv6AddressToStringEx</b> function is more flexible since it also converts an IPv6 address, scope ID, and port to a IPv6 string in standard format.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>InetNtopW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} Family The address family.
     * 
     * Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The values currently supported are <b>AF_INET</b> and <b>AF_INET6</b>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns an IPv4 address string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns an IPv6 address string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pAddr A pointer to the IP address in network byte to convert to a string.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure with the IPv4 address to convert.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure with the IPv6 address to convert.
     * @param {Pointer<PSTR>} pStringBuf A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IP address.
     * 
     * For an IPv4 address, this buffer should be large enough to hold at least 16 characters.
     * 
     * For an IPv6 address, this buffer should be large enough to hold at least 46 characters.
     * @param {Pointer} StringBufSize On input, the length, in characters, of the buffer pointed to by the <i>pStringBuf</i> parameter.
     * @returns {Pointer<PSTR>} If no error occurs, 
     * <b>InetNtop</b> function returns a pointer to a buffer containing the string representation of IP address in standard format.
     * 
     * Otherwise, a value of <b>NULL</b> is returned, and a specific error code can be retrieved by calling the  
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> for extended error information.
     * 
     * If the function fails, the extended error code returned by <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family specified in the <i>Family</i> parameter is not supported. This error is returned if the <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pStringBuf</i> or the  <i>StringBufSize</i> parameter is zero. This error is also returned if the length of the buffer pointed to by the <i>pStringBuf</i> parameter is not large enough to receive the string representation of the IP address.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_ntop
     * @since windows8.1
     */
    static inet_ntop(Family, pAddr, pStringBuf, StringBufSize) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\inet_ntop", "int", Family, "ptr", pAddr, "ptr", pStringBuf, "ptr", StringBufSize, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The InetNtop function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The ANSI version of this function is inet_ntop. (InetNtopW)
     * @remarks
     * The 
     * <b>InetNtop</b> function is supported on Windows Vista and later.
     * 
     * The 
     * <b>InetNtop</b> function provides a protocol-independent address-to-string translation. The 
     * <b>InetNtop</b> function takes an Internet address structure specified by the <i>pAddr</i> parameter and returns a <b>NULL</b>-terminated string that represents the IP address. While the <a href="https://docs.microsoft.com/windows/desktop/api/wsipv6ok/nf-wsipv6ok-inet_ntoa">inet_ntoa</a> function works only with IPv4 addresses, the <b>InetNtop</b> function works with either IPv4 or IPv6 addresses.
     * 
     * The ANSI version of this function is <b>inet_ntop</b> as defined in RFC 2553. For more information, see RFC 2553 available at the <a href="http://tools.ietf.org/html/rfc2553">IETF website</a>. 
     * 
     * The 
     * <b>InetNtop</b> function does not require that the Windows Sockets DLL be loaded to perform IP address to string conversion.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure with the IPv4 address to convert. The address string returned in the buffer pointed to by the <i>pStringBuf</i> parameter is  in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
     * 
     * If the <i>Family</i> parameter specified is <b>AF_INET6</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure with the IPv6 address to convert. The address string returned in the buffer pointed to by the <i>pStringBuf</i> parameter is in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address. The last 32 bits are represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
     * 
     * If the length of the buffer pointed to by the <i>pStringBuf</i> parameter is not large enough to receive the string representation of the IP address, <b>InetNtop</b> returns ERROR_INVALID_PARAMETER.
     * 
     * When UNICODE or _UNICODE is defined, <b>InetNtop</b> is defined to <b>InetNtopW</b>, the Unicode version of this function. The <i>pStringBuf</i> parameter is defined to the <b>PSTR</b> data type.
     * 
     * When UNICODE or _UNICODE is not defined, <b>InetNtop</b> is defined to <b>InetNtopA</b>, the ANSI version of this function. The ANSI version of this function is always defined as <b>inet_ntop</b>. The <i>pStringBuf</i> parameter is defined to the <b>PWSTR</b> data type.
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure is defined in the <i>Inaddr.h</i> header file.
     * 
     * The <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure is defined in the <i>In6addr.h</i> header file.
     * 
     * On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4addresstostringa">RtlIpv4AddressToString</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv4addresstostringexw">RtlIpv4AddressToStringEx</a> functions can be used to convert an IPv4 address represented as an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure to a string representation of an IPv4 address in Internet standard dotted-decimal notation. On Windows Vista and later, the <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6addresstostringa">RtlIpv6AddressToString</a> and <a href="https://docs.microsoft.com/windows/desktop/api/ip2string/nf-ip2string-rtlipv6addresstostringexw">RtlIpv6AddressToStringEx</a> functions can be used to convert an IPv6 address represented as an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure to a string representation of an IPv6 address. The <b>RtlIpv6AddressToStringEx</b> function is more flexible since it also converts an IPv6 address, scope ID, and port to a IPv6 string in standard format.
     * 
     * <b>Windows 8.1</b> and <b>Windows Server 2012 R2</b>: The  <b>InetNtopW</b> function is supported for Windows Store apps on Windows 8.1, Windows Server 2012 R2, and later.
     * @param {Integer} Family The address family.
     * 
     * Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The values currently supported are <b>AF_INET</b> and <b>AF_INET6</b>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns an IPv4 address string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns an IPv6 address string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pAddr A pointer to the IP address in network byte to convert to a string.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure with the IPv4 address to convert.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure with the IPv6 address to convert.
     * @param {Pointer<PWSTR>} pStringBuf A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IP address.
     * 
     * For an IPv4 address, this buffer should be large enough to hold at least 16 characters.
     * 
     * For an IPv6 address, this buffer should be large enough to hold at least 46 characters.
     * @param {Pointer} StringBufSize On input, the length, in characters, of the buffer pointed to by the <i>pStringBuf</i> parameter.
     * @returns {Pointer<PWSTR>} If no error occurs, 
     * <b>InetNtop</b> function returns a pointer to a buffer containing the string representation of IP address in standard format.
     * 
     * Otherwise, a value of <b>NULL</b> is returned, and a specific error code can be retrieved by calling the  
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> for extended error information.
     * 
     * If the function fails, the extended error code returned by <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family specified in the <i>Family</i> parameter is not supported. This error is returned if the <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pStringBuf</i> or the  <i>StringBufSize</i> parameter is zero. This error is also returned if the length of the buffer pointed to by the <i>pStringBuf</i> parameter is not large enough to receive the string representation of the IP address.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetntopw
     * @since windows8.1
     */
    static InetNtopW(Family, pAddr, pStringBuf, StringBufSize) {
        result := DllCall("WS2_32.dll\InetNtopW", "int", Family, "ptr", pAddr, "ptr", pStringBuf, "ptr", StringBufSize, "ptr")
        return result
    }

    /**
     * Enables and applies security for a socket.
     * @remarks
     * The primary purpose of the <b>WSASetSocketSecurity</b> function is to turn on security for a socket if it is not already enabled by administrative policy. For IPsec, this means  that appropriate IPsec filters and policies will be instantiated that will be used to secure this socket. the <b>WSASetSocketSecurity</b> function can also be used to set specific security requirements for the socket.
     * 
     * This function simplifies having to call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with a <i>dwIoControlCode</i> parameter set to <b>SIO_SET_SECURITY</b>.
     * 
     * The <b>WSASetSocketSecurity</b> function may be called on a <i>Socket</i> parameter created with an address family of <b>AF_INET</b> or <b>AF_INET6</b>.   
     * 
     * For a client application using connection-oriented sockets (protocol of <b>IPPROTO_TCP</b>), the <b>WSASetSocketSecurity</b> function should be called before the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> function is called.  If the <b>WSASetSocketSecurity</b> function is called after the <b>connect</b>, <b>ConnectEx</b>, or <b>WSAConnect</b> function,  <b>WSASetSocketSecurity</b> should fail.
     * 
     * For a server application using connection-oriented sockets (protocol of <b>IPPROTO_TCP</b>), the <b>WSASetSocketSecurity</b> function should be called before the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function is called.  If the <b>WSASetSocketSecurity</b> function is called after the <b>bind</b> function,  <b>WSASetSocketSecurity</b> should fail.
     * 
     * For connectionless sockets (protocol of <b>IPPROTO_UDP</b>), the application should call the <b>WSASetSocketSecurity</b> function immediately after <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasocketa">WSASocket</a> call returns.
     * 
     * Server applications should call the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> function to acquire exclusive access to the port used by the socket. This prevents other applications from using the same port. The <b>setsockopt</b> function would be called with the <i>level</i> parameter set to SOL_SOCKET,  the <i>optname</i> parameter set to <a href="https://docs.microsoft.com/windows/desktop/WinSock/so-exclusiveaddruse">SO_EXCLUSIVEADDRUSE</a>, and the <i>value </i> parameter set to nonzero. The <b>WSASetSocketSecurity</b> function internally calls the <b>setsockopt</b> with SO_EXCLUSIVEADDRUSE to obtain exclusive access to the port. This is to ensure that the socket is not vulnerable to attacks by other applications running on the local computer.
     * 
     * Security settings not set using the <b>WSASetSocketSecurity</b> are derived from the system default policy or the administratively configured policy. It is recommended that most applications specify a value of  <b>SOCKET_SECURITY_PROTOCOL_DEFAULT</b> for the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ne-mstcpip-socket_security_protocol">SOCKET_SECURITY_PROTOCOL</a> enumeration in the <b>SecurityProtocol</b> member of the <b>SOCKET_SECURITY_PROTOCOL</b> pointed to by the <i>SecuritySettings</i> parameter.  This makes the application neutral to security protocols and allows easier deployments among different systems.
     * 
     * When the <i>SecuritySettings</i> parameter points to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_settings_ipsec">SOCKET_SECURITY_SETTINGS_IPSEC</a>  structure, the <b>SecurityProtocol</b> 
     * member of the structure must be set to <b>SOCKET_SECURITY_PROTOCOL_IPSEC</b>, not <b>SOCKET_SECURITY_PROTOCOL_DEFAULT</b>.
     * 
     * An error will be returned if the following conditions are not met.<ul>
     * <li>The address family of the <i>Socket</i> parameter must be either AF_INET or AF_INET6.</li>
     * <li>The socket type must be either SOCK_STREAM or SOCK_DGRAM.</li>
     * <li>The application must set its security settings before calling the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> functions.</li>
     * <li>The <b>WSASetSocketSecurity</b> function can only be called once per socket.</li>
     * </ul>
     * 
     * 
     * <h3><a id="Default_Secure_Socket_IPsec_Policy"></a><a id="default_secure_socket_ipsec_policy"></a><a id="DEFAULT_SECURE_SOCKET_IPSEC_POLICY"></a>Default Secure Socket IPsec Policy</h3>
     * If the <i>SecuritySettings</i> parameter is set to <b>NULL</b>, and there is no other administratively specified IPsec policy on the computer, a default security policy based on IPsec will be used to secure the application's traffic.  Some type of authentication credential (a user certificate or domain membership, for example) must be present for IPsec to succeed with a default policy.
     * 
     * 
     * The default IPsec policy has been designed so that IPsec security can be negotiated in as many scenarios as possible.
     * 
     * 
     * ``` syntax
     * Authip MM policy = 
     * {
     *  Auth methods = {IKE_ANONYMOUS}
     *  No impersonation
     *  Proposals = 
     *  {
     *    {
     *      Crypto algos = 
     *      IKE_CIPHER_AES_128,
     *      IKE_INTEGRITY_SHA1, 
     *      IKE_DH_ECP_256
     *      MM lifetime = 2 hrs
     *      QM = 0 (infinite)
     *    }
     *    {
     *      Crypto algos = 
     *      IKE_CIPHER_3DES, 
     *      IKE_INTEGRITY_SHA1, 
     *      IKE_DH_GROUP_2
     *      MM lifetime = 2 hrs
     *      QM = 0 (infinite)
     *    }
     *  }
     * }
     * 
     * Authip QM policy =
     * {
     *  QM proposals = 
     *  {
     *    QM lifetime = 1 hr, 55GB,
     *    Crypto algos = 
     *    IPSEC_TRANSFORM_ESP_AUTH, 
     *    IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96
     *    No PFS
     *  }
     *  {
     *    QM lifetime = 1 hr, 55GB,
     *    Crypto algos = 
     *    IPSEC_TRANSFORM_ESP_AUTH_AND_CIPHER,
     *    IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96,
     *    IPSEC_CIPHER_TRANSFORM_ID_AES_128
     *    No PFS
     *  }
     *  {
     *    QM lifetime = 1 hr, 55GB,
     *    Crypto algos = 
     *    IPSEC_TRANSFORM_ESP_AUTH_AND_CIPHER,
     *    IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96,
     *    IPSEC_CIPHER_TRANSFORM_ID_CBC_3DES
     *    No PFS
     *  }
     *  {
     *    QM lifetime = 1 hr, 55GB,
     *    Crypto algos = 
     *    IPSEC_TRANSFORM_AH,
     *    IPSEC_AUTH_TRANSFORM_ID_HMAC_SHA_1_96
     *    No PFS
     *  }
     *  IPSEC_POLICY_FLAG_ND_BOUNDARY
     *  ndAllowClearTimeoutSeconds = 10
     *  saIdleTimeout = {5mins, 1min}
     *  UM policy = 
     *  {
     *    {IKE_SSL, Null-Root-Config}
     *    {IKE_KERBEROS}
     *    {IKE_SSL, Null-Root-Config}
     *    No impersonation
     *  } 
     * }
     * 
     * ```
     * @param {Pointer} Socket A descriptor that identifies a socket on which security settings are being applied.
     * @param {Pointer<SOCKET_SECURITY_SETTINGS>} SecuritySettings A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_settings">SOCKET_SECURITY_SETTINGS</a> structure that specifies the security settings to be applied to the socket's traffic. If this parameter is <b>NULL</b>, default settings will be applied to the socket.
     * @param {Integer} SecuritySettingsLen The size, in bytes, of the <i>SecuritySettings</i> parameter.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-wsasetsocketsecurity
     * @since windows6.0.6000
     */
    static WSASetSocketSecurity(Socket, SecuritySettings, SecuritySettingsLen, Overlapped, CompletionRoutine) {
        A_LastError := 0

        DllCall("fwpuclnt.dll\WSASetSocketSecurity", "ptr", Socket, "ptr", SecuritySettings, "uint", SecuritySettingsLen, "ptr", Overlapped, "ptr", CompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Queries information about the security applied to a connection on a socket.
     * @remarks
     * The <b>WSAQuerySocketSecurity</b> function provides a method to query the current security settings on a socket. After a connection is established, the <b>WSAQuerySocketSecurity</b> function allows an application to query the security properties of the connection, which can include information on peer access tokens.
     * 
     * For connection-oriented sockets, it is preferred to call the <b>WSAQuerySocketSecurity</b> function immediately after a connection is established. For connectionless sockets, it is preferred to call the <b>WSAQuerySocketSecurity</b> function immediately after data is sent to a new peer address or received from a new peer address. The <b>WSAQuerySocketSecurity</b> function can be called multiple times on a single socket.
     * 
     * This function simplifies having to call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with a <i>dwIoControlCode</i> parameter set to <b>SIO_QUERY_SECURITY</b>.
     * 
     * The <b>WSAQuerySocketSecurity</b> function may be called on a <i>Socket</i> parameter created with an address family of <b>AF_INET</b> or <b>AF_INET6</b>.
     * 
     * If the <i>Socket</i> parameter was created with a protocol of <b>IPPROTO_TCP</b>, the <i>SecurityQueryTemplate</i> parameter may be <b>NULL</b> and the <i>SecurityQueryTemplateLen</i> parameter may be zero. Otherwise, the <i>SecurityQueryTemplate</i> parameter must point to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure.
     * 
     * For a client application using connection-oriented sockets (socket created with a protocol of <b>IPPROTO_TCP</b>), the <b>WSAQuerySocketSecurity</b> function should be called after the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> function returns.  For a server application using connection-oriented sockets (protocol of <b>IPPROTO_TCP</b>), the <b>WSAQuerySocketSecurity</b> function should be called after the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> function returns.
     * 
     * For connectionless sockets (socket created with a protocol of <b>IPPROTO_UDP</b>), the application should call the <b>WSAQuerySocketSecurity</b> function immediately after <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a> call returns for a new peer address.
     * 
     * An error will be returned if the following conditions are not met.<ul>
     * <li>The address family of the <i>Socket</i> parameter must be either AF_INET or AF_INET6.</li>
     * <li>The socket type must be either SOCK_STREAM or SOCK_DGRAM.</li>
     * </ul>
     * @param {Pointer} Socket A descriptor identifying a socket for which security information is being queried.
     * @param {Pointer<SOCKET_SECURITY_QUERY_TEMPLATE>} SecurityQueryTemplate A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure that specifies the type of query information to return. 
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure pointed to by this parameter may contain zeroes for all members to request default security information. On successful return, only the <b>Flags</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_info">SOCKET_SECURITY_QUERY_INFO</a> will be set in the returned  <i>SecurityQueryInfo</i> parameter. 
     * 
     * This parameter may be a <b>NULL</b> pointer if the <i>Socket</i> parameter was created with a protocol of <b>IPPROTO_TCP</b>. In this case, the information returned is the same as if a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure with all values set to zero was passed. This parameter should be specified for a socket with protocol of <b>IPPROTO_TCP</b> if more than the default security information is required. 
     * 
     * If the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure  is specified with the <b>PeerTokenAccessMask</b> member not specified (set to zero), then the <b>WSAQuerySocketSecurity</b> function will not return the <b>PeerApplicationAccessTokenHandle</b> and <b>PeerMachineAccessTokenHandle</b> members in the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_info">SOCKET_SECURITY_QUERY_INFO</a> structure.
     * 
     * If a <i>Socket</i> parameter was created with a protocol not equal to <b>IPPROTO_TCP</b>, the <i>SecurityQueryTemplate</i> parameter must be specified. In these cases, the <b>PeerAddress</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure must specify an address family of AF_INET or AF_INET6 along with peer IP address and port number.
     * @param {Integer} SecurityQueryTemplateLen The size, in bytes, of the <i>SecurityQueryTemplate</i> parameter. 
     * 
     * This parameter may be a zero if the <i>Socket</i> parameter was created with a protocol of <b>IPPROTO_TCP</b>. Otherwise, this parameter must be the size of a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure.
     * @param {Pointer<SOCKET_SECURITY_QUERY_INFO>} SecurityQueryInfo A pointer to a buffer that will receive a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_info">SOCKET_SECURITY_QUERY_INFO</a> structure containing the information queried.  This value can be set to <b>NULL</b> to query the size of the output buffer.
     * @param {Pointer<UInt32>} SecurityQueryInfoLen On input, a pointer to the size, in bytes, of the <i>SecurityQueryInfo</i> parameter.   If the buffer is too small to receive the queried information, the call will return SOCKET_ERROR, and the number of bytes needed to return the queried information will be set in the value pointed to by this parameter.  On a successful call, the number of bytes copied is returned.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-wsaquerysocketsecurity
     * @since windows6.0.6000
     */
    static WSAQuerySocketSecurity(Socket, SecurityQueryTemplate, SecurityQueryTemplateLen, SecurityQueryInfo, SecurityQueryInfoLen, Overlapped, CompletionRoutine) {
        A_LastError := 0

        DllCall("fwpuclnt.dll\WSAQuerySocketSecurity", "ptr", Socket, "ptr", SecurityQueryTemplate, "uint", SecurityQueryTemplateLen, "ptr", SecurityQueryInfo, "ptr", SecurityQueryInfoLen, "ptr", Overlapped, "ptr", CompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Is used to specify the peer target name (SPN) that corresponds to a peer IP address. This target name is meant to be specified by client applications to securely identify the peer that should be authenticated.
     * @remarks
     * The <b>WSASetSocketPeerTargetName</b> function provides a method to specify the target name that corresponds to a peer security principal. This function is meant to be used by a client application to identify the peer that should be authenticated. A client application should specify the peer target name in order to prevent trusted man-in-the-middle attacks. For connectionless sockets, an application can call the <b>WSASetSocketPeerTargetName</b> function multiple times to specify different target names for different peer IP addresses.
     * 
     * This function simplifies having to call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with a <i>dwIoControlCode</i> parameter set to <b>SIO_SET_PEER_TARGET_NAME</b>. 
     * 
     * For connection-oriented sockets, the <b>WSASetSocketPeerTargetName</b> function should be called before <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>.  For connectionless sockets, this function should be called before <b>WSAConnect</b> or before the first <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> call directed to the peer address.
     * 
     * An error will be returned if the following conditions are not met.<ul>
     * <li>The address family of the <i>Socket</i> parameter must be either AF_INET or AF_INET6.</li>
     * <li>The socket type must be either SOCK_STREAM or SOCK_DGRAM.</li>
     * </ul>
     * @param {Pointer} Socket A descriptor identifying a socket on which the peer target name is being assigned.
     * @param {Pointer<SOCKET_PEER_TARGET_NAME>} PeerTargetName A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_peer_target_name">SOCKET_PEER_TARGET_NAME</a> structure that defines the peer target name.
     * @param {Integer} PeerTargetNameLen The size, in bytes, of the <i>PeerTargetName</i> parameter.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-wsasetsocketpeertargetname
     * @since windows6.0.6000
     */
    static WSASetSocketPeerTargetName(Socket, PeerTargetName, PeerTargetNameLen, Overlapped, CompletionRoutine) {
        A_LastError := 0

        DllCall("fwpuclnt.dll\WSASetSocketPeerTargetName", "ptr", Socket, "ptr", PeerTargetName, "uint", PeerTargetNameLen, "ptr", Overlapped, "ptr", CompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Removes the association between a peer target name and an IP address for a socket. After a successful return, there will be no future association between the IP address and the target name.
     * @remarks
     * The <b>WSADeleteSocketPeerTargetName</b> function provides a method to remove the association between a peer target name and an IP address for a socket. This function is used to delete a peer target name that was previously set with the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-wsasetsocketpeertargetname">WSASetSocketPeerTargetName</a> function.  After the <b>WSADeleteSocketPeerTargetName</b> function returns, no future authentication to the IP address will use the previously specified target name. This function is primarily designed to be used by connectionless clients (for example, a socket created with the type set to SOCK_DGRAM or the protocol set to IPPROTO_UDP) after they have terminated the connection with the IP	address associated with the peer target name. For connection oriented clients (for example, a socket created with the type set to SOCK_STREAM or protocol set to IPPROTO_TCP), this function should not be called.
     * 
     * The <b>WSADeleteSocketPeerTargetName</b> function  simplifies having to call the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with a <i>dwIoControlCode</i> parameter set to <b>SIO_DELETE_PEER_TARGET_NAME</b>. 
     * 
     * An error will be returned if the following conditions are not met.<ul>
     * <li>The address family of the <i>Socket</i> parameter must be either AF_INET or AF_INET6.</li>
     * <li>The socket type must be either SOCK_STREAM or SOCK_DGRAM.</li>
     * </ul>
     * @param {Pointer} Socket A descriptor identifying a socket on which the peer target name is being deleted.
     * @param {Pointer<SOCKADDR>} PeerAddr The IP address of the peer for which the target name is being deleted.
     * @param {Integer} PeerAddrLen The size, in bytes, of the <i>PeerAddr</i> parameter.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-wsadeletesocketpeertargetname
     * @since windows6.0.6000
     */
    static WSADeleteSocketPeerTargetName(Socket, PeerAddr, PeerAddrLen, Overlapped, CompletionRoutine) {
        A_LastError := 0

        DllCall("fwpuclnt.dll\WSADeleteSocketPeerTargetName", "ptr", Socket, "ptr", PeerAddr, "uint", PeerAddrLen, "ptr", Overlapped, "ptr", CompletionRoutine)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Used to impersonate the security principal corresponding to a socket peer in order to perform application-level authorization.
     * @remarks
     * The <b>WSAImpersonateSocketPeer</b> function provides an application the ability to impersonate the security principal corresponding to a socket peer in order to perform application-level authorization. If peer user (impersonation) token is available then it will be used for impersonation, otherwise the peer computer token will be used. The <b>WSAImpersonateSocketPeer</b> function can be called only for blocking, non-overlapped sockets. After performing any authorization checks, an application must call the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-wsarevertimpersonation">WSARevertImpersonation</a> function to terminate the impersonation.
     * 
     * For connection-oriented sockets, the <b>WSAImpersonateSocketPeer</b> function should be called after a connection is established. For a server application using connection-oriented sockets, the <b>WSAImpersonateSocketPeer</b> should be called after the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> function returns.  
     * 
     * For connectionless sockets, the application should call the <b>WSAImpersonateSocketPeer</b> function immediately after the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recv">recv</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-wsarecvex">WSARecvEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, or <a href="https://docs.microsoft.com/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg">LPFN_WSARECVMSG (WSARecvMsg)</a> function returns for a new peer address. 
     * 
     * The <b>WSAImpersonateSocketPeer</b> function can be called multiple times for a single socket.  
     * 
     * An error will be returned if the following conditions are not met.<ul>
     * <li>The address family of the <i>Socket</i> parameter must be either AF_INET or AF_INET6.</li>
     * <li>The socket type must be either SOCK_STREAM or SOCK_DGRAM.</li>
     * </ul>
     * 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-wsarevertimpersonation">WSARevertImpersonation</a> function must be called to end the impersonation.
     * @param {Pointer} Socket Identifies the application socket.
     * @param {Pointer<SOCKADDR>} PeerAddr The IP address of the peer to be impersonated.  For connection-oriented sockets, the connected socket uniquely identifies a peer.  In this case, this parameter is ignored.
     * @param {Integer} PeerAddrLen The size, in bytes, of the <i>PeerAddress</i> parameter.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-wsaimpersonatesocketpeer
     * @since windows6.0.6000
     */
    static WSAImpersonateSocketPeer(Socket, PeerAddr, PeerAddrLen) {
        A_LastError := 0

        DllCall("fwpuclnt.dll\WSAImpersonateSocketPeer", "ptr", Socket, "ptr", PeerAddr, "uint", PeerAddrLen)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Terminates the impersonation of a socket peer. This must be called after calling WSAImpersonateSocketPeer and finishing any access checks.
     * @remarks
     * The <b>WSARevertImpersonation</b> function causes the calling thread to discontinue
     *     the impersonation of a socket peer. If the thread is not currently
     *     impersonating a socket peer, no action is taken.
     * 
     * The <b>WSARevertImpersonation</b> function should be called after calling <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-wsaimpersonatesocketpeer">WSAImpersonateSocketPeer</a> and all access checks are finished.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-wsarevertimpersonation
     * @since windows6.0.6000
     */
    static WSARevertImpersonation() {
        A_LastError := 0

        DllCall("fwpuclnt.dll\WSARevertImpersonation")
        if(A_LastError)
            throw OSError()

    }

    /**
     * Indicates whether the network is to be used for transferring streaming media that requires quality of service.
     * @remarks
     * The 
     * <b>SetSocketMediaStreamingMode</b> function is used to indicate whether the network is to be used for transferring streaming media that requires quality of service. This function is normally used by Voice over IP (VoIP) or similar apps that require a consistent quality of service.  The <b>SetSocketMediaStreamingMode</b> function can be used by Windows Store apps or desktop apps.
     * 
     * There can be quality of service issues for media streaming when used over an 802.11 wireless network. The 802.11 network driver will periodically scan for other nearby infrastructure networks (ESS) or ad-hoc networks (IBSS). This allows the wireless network adapter to find other networks and possibly connected to a network with a stronger signal. Most current 802.11 network drivers scan all of the available channels as a series at once. When the 802.11 network driver is scanning for other networks and listening on other channels, it cannot receive packets for the app. The time spent scanning for other networks can introduce a noticeable gap (100 milliseconds or more)  when a VoIP app would be unable to receive the audio stream. This scanning process is longer for 802.11 network adapters that are dual band (2.4GHz and 5GHz) since even more channels are scanned. This can result in the audio to be perceived as stuttering.
     * 
     * When the <b>SetSocketMediaStreamingMode</b> function is called with the <i>value</i> parameter set to <b>TRUE</b> and the socket will be transferring over an 802.11 wireless network adapter, the system will notify the wireless network driver to stop scanning for other networks. This eliminates stuttering by VoIP and similar audio apps when used over 802.11 wireless networks, but also affects any apps running on the local computer or device. 
     * 
     * There are cases where turning off scans may cause problems. When scans are disabled, the local computer  stays connected to the same network even if the signal becomes weaker and weaker as the user moves away from the network. 
     * 
     * A VoIP or similar app should close all low latency sockets to restore the media streaming mode of the 802.11 wireless network driver. This will re-enable scanning for other wireless networks.
     * 
     * The <b>SetSocketMediaStreamingMode</b> function has no effect if the socket will not be sending or receiving packets over an 802.11 wireless adapter.
     * @param {Integer} value Indicates whether the network is to be used for transferring streaming media that requires quality of service. This ensures that sockets opened as low latency will get the right quality of service over 802.11 wireless networks.
     * @returns {Integer} If no error occurs, 
     * <b>SetSocketMediaStreamingMode</b> returns S_OK. Otherwise, an error code is returned as an HRESULT.
     * @see https://learn.microsoft.com/windows/win32/api/socketapi/nf-socketapi-setsocketmediastreamingmode
     * @since windows8.0
     */
    static SetSocketMediaStreamingMode(value) {
        result := DllCall("Windows.Networking.dll\SetSocketMediaStreamingMode", "int", value, "int")
        return result
    }

    /**
     * Used to reorder the available transport providers.
     * @remarks
     * The order in which transport service providers are initially installed governs the order in which they are enumerated through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a> at the service provider interface, or through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> at the application interface. More importantly, this order also governs the order in which protocols and service providers are considered when a client requests creation of a socket based on its address family, type, and protocol identifier.
     * 
     * Windows Sockets 2 includes an application called Sporder.exe that allows the catalog of installed protocols to be reordered interactively after protocols have already been installed. Windows Sockets 2 also includes an auxiliary DLL, <i>Sporder.dll</i> that exports this procedural interface for reordering protocols. This interface can be imported by linking with <i>Sporder.lib</i>.
     * 
     * 
     * The following are scenarios in which the 
     * <b>WSCWriteProviderOrder</b> function could fail:
     * 
     * <ul>
     * <li>The <i>dwNumberOfEntries</i> parameter is not equal to the number of registered service providers.</li>
     * <li>The <i>lpwdCatalogEntryId</i> contains an invalid catalog identifier.</li>
     * <li>The <i>lpwdCatalogEntryId</i> does not contain all valid catalog identifiers exactly one time.</li>
     * <li>The routine is not able to access the registry for some reason (for example, inadequate user permissions).</li>
     * <li>Another process (or thread) is currently calling the function.</li>
     * </ul>
     * 
     * 
     * On success, <b>WSCWriteProviderOrder</b> will attempt to alert all interested applications that have registered for notification of the change by calling <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaproviderconfigchange">WSAProviderConfigChange</a>.
     * 
     * The <b>WSCWriteProviderOrder</b> function can only be called by a user logged on as a member of the Administrators group. If <b>WSCWriteProviderOrder</b> is called by a user that is not a member of the Administrators group, the function call will fail and 
     * 								<a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a> is returned. 
     *  For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC). If an application  that contains this function is executed by a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to <b>requireAdministrator</b>. If the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (<b>RunAs administrator</b>) for this function to succeed.
     * @param {Pointer<UInt32>} lpwdCatalogEntryId A pointer to an array of <b>CatalogEntryId</b> elements found in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The order of the <b>CatalogEntryId</b> elements is the new priority ordering for the protocols.
     * @param {Integer} dwNumberOfEntries The number of elements in the <i>lpwdCatalogEntryId</i> array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/sporder/nf-sporder-wscwriteproviderorder
     * @since windows5.0
     */
    static WSCWriteProviderOrder(lpwdCatalogEntryId, dwNumberOfEntries) {
        DllCall("WS2_32.dll\WSCWriteProviderOrder", "ptr", lpwdCatalogEntryId, "uint", dwNumberOfEntries)
    }

    /**
     * Changes the order of available Windows Sockets (Winsock) 2 namespace providers. The order of the namespace providers determines the priority of the namespace when enumerated or queried for name resolution.
     * @remarks
     * Namespace providers are installed using the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace">WSCInstallNameSpace</a> function. The order in which namespace providers are initially installed governs the default order in which they are enumerated through 
     *  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a>.  More importantly, this order also governs the order in which namespace providers are considered when a client requests name resolution. The order of namespace providers can be changed using the <b>WSCWriteNameSpaceOrder</b> function. On 64-bit platforms, the <a href="https://docs.microsoft.com/windows/desktop/api/sporder/nf-sporder-wscwritenamespaceorder32">WSCWriteNameSpaceOrder32</a> function is provided to allow 64-bit processes to change the order of namespace providers in the 32-bit namespace provider catalog. On 64-bit platforms, namespace providers are installed in the 32-bit namespace provider catalog using the <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscinstallnamespace32">WSCInstallNameSpace32</a> function. 
     * 
     * The current namespace provider catalog is stored in the registry under the following registry key: <b>HKEY_LOCAL_MACHINE</b>&#92;<b>SYSTEM</b>&#92;<b>Current Control Set</b>&#92;<b>Services</b>&#92;<b>Winsock2</b>&#92;<b>Parameters</b>&#92;<b>NameSpace_Catalog5</b>
     * 
     * 
     * 
     * A client request for name resolution uses the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>, and <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupserviceend">WSALookupServiceEnd</a> routines. The <b>dwNameSpace</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure passed to <b>WSALookupServiceBegin</b> is set to the identifier of a single namespace (NS_DNS, for example) in which to constrain the search, or <b>NS_ALL</b> to include all namespaces. If multiple namespace providers support a specific namespace (<b>NS_DNS</b>, for example), then the results from all namespace providers that match the requested <b>dwNameSpace</b> are returned unless the <b>lpNSProviderId</b> 
     * member is set to a specific namespace provider. The results from all namespace providers is returned if NS_ALL is specified for the <b>dwNameSpace</b> member. The order that the results are returned is dependent on the namespace provider order in the catalog.  
     * 
     * The Windows SDK includes an application called SpOrder.exe that allows the catalog of installed namespace providers to be displayed. Windows Sockets 2 includes the ws2_32.dll that exports the  <b>WSCWriteNameSpaceOrder</b> function for reordering namespace providers in the catalog. This interface can be imported by linking with WS2_32.lib. For computers running on Windows XP with Service Pack 2 (SP2) and Windows Server 2003 with Service Pack 1 (SP1) and later, the <b>netsh.exe winsock show catalog</b> command will display both the protocol and namespace providers installed on the system.
     * 
     * <b>WSCWriteNameSpaceOrder</b> can only be called by a user logged on as a member of the Administrators group. If <b>WSCWriteNameSpaceOrder</b> is called by a user that is not a member of the Administrators group, the function call will fail and <b>WSANO_RECOVERY</b> is returned in the <i>lpErrno</i> parameter.
     * 
     * For computers running on Windows Vista and Windows Vista, this function can also fail because of user account control (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group other than the Administrator, this call will fail unless the application has been marked in the manifest file with a <b>requestedExecutionLevel</b> set to <b>requireAdministrator</b>. If the application on Windows Vista and Windows Vista lacks this setting in the manifest file used to build the executable file, a user logged on as a member of the Administrators group other than the Administrator must then be executing the application in an enhanced shell as the  Administrator (<b>RunAs administrator</b>) for this function to succeed.
     * 
     * The following list describes scenarios in which the 
     * <b>WSCWriteNameSpaceOrder</b> function could fail:
     * 
     * <ul>
     * <li>The <i>dwNumberOfEntries</i> parameter is not equal to the number of registered namespace providers.</li>
     * <li>The <b>NSProviderId</b> array contains an invalid namespace provider identifier.</li>
     * <li>The <b>NSProviderId</b> array does not contain all valid namespace provider identifiers exactly one time.</li>
     * <li>The function cannot access the registry (for example, insufficient user permissions).</li>
     * <li>Another process (or thread) is currently calling the function.</li>
     * </ul>
     * @param {Pointer<Guid>} lpProviderId An array of <b>NSProviderId</b> elements as found in the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structure.  The order of the <b>NSProviderId</b> elements is the new
     *       priority ordering for the namespace providers.
     * @param {Integer} dwNumberOfEntries The number of elements in the <b>NSProviderId</b> array.
     * @returns {String} Nothing - always returns an empty string
     * @see https://learn.microsoft.com/windows/win32/api/sporder/nf-sporder-wscwritenamespaceorder
     * @since windows5.0
     */
    static WSCWriteNameSpaceOrder(lpProviderId, dwNumberOfEntries) {
        DllCall("WS2_32.dll\WSCWriteNameSpaceOrder", "ptr", lpProviderId, "uint", dwNumberOfEntries)
    }

;@endregion Methods
}
