#Requires AutoHotkey v2.0.0 64-bit
#Include ..\..\..\..\Win32Handle.ahk
#Include .\SOCKET.ahk
#Include ..\..\Foundation\HANDLE.ahk
#Include .\WSAEVENT.ahk

/**
 * @namespace Windows.Win32.Networking.WinSock
 * @version v4.0.30319
 */
class WinSock {

;@region Constants

    /**
     * @type {String}
     */
    static SOCKET_DEFAULT2_QM_POLICY => "{aec2ef9c-3a4d-4d3e-8842-239942e39a47}"

    /**
     * @type {String}
     */
    static REAL_TIME_NOTIFICATION_CAPABILITY => "{6b59819a-5cae-492d-a901-2a3c2c50164f}"

    /**
     * @type {String}
     */
    static REAL_TIME_NOTIFICATION_CAPABILITY_EX => "{6843da03-154a-4616-a508-44371295f96b}"

    /**
     * @type {String}
     */
    static ASSOCIATE_NAMERES_CONTEXT => "{59a38b67-d4fe-46e1-ba3c-87ea74ca3049}"

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL => 2550136833

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_MCAST => 2550136834

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_IGMPMCAST => 2550136835

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_KEEPALIVE_VALS => 2550136836

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ABSORB_RTRALERT => 2550136837

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_UCAST_IF => 2550136838

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_LIMIT_BROADCASTS => 2550136839

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_BIND => 2550136840

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_MCASTIF => 2550136841

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_ADD_MCAST => 2550136842

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_INDEX_DEL_MCAST => 2550136843

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_MCAST_IF => 2550136845

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RCVALL_IF => 2550136846

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_LOOPBACK_FAST_PATH => 2550136848

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_INITIAL_RTO => 2550136849

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_APPLY_TRANSPORT_SETTING => 2550136851

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_TRANSPORT_SETTING => 2550136852

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_SET_ICW => 2550136854

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_SET_ACK_FREQUENCY => 2550136855

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_PRIORITY_HINT => 2550136856

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_PRIORITY_HINT => 2550136856

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TCP_INFO => 3623878695

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_CPU_AFFINITY => 2550136853

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TIMESTAMPING => 2550137067

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMPING_FLAG_RX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TIMESTAMPING_FLAG_TX => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SO_TIMESTAMP => 12298

    /**
     * @type {Integer (UInt32)}
     */
    static SO_TIMESTAMP_ID => 12299

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_TX_TIMESTAMP => 2550137066

    /**
     * @type {Integer (UInt16)}
     */
    static TCP_INITIAL_RTO_UNSPECIFIED_MAX_SYN_RETRANSMISSIONS => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static TCP_INITIAL_RTO_DEFAULT_RTT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TCP_INITIAL_RTO_DEFAULT_MAX_SYN_RETRANSMISSIONS => 0

    /**
     * @type {Integer (UInt16)}
     */
    static TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS => 65534

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ACQUIRE_PORT_RESERVATION => 2550136932

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RELEASE_PORT_RESERVATION => 2550136933

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ASSOCIATE_PORT_RESERVATION => 2550136934

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_SECURITY => 2550137032

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_SECURITY => 3623878857

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_PEER_TARGET_NAME => 2550137034

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_DELETE_PEER_TARGET_NAME => 2550137035

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_WFP_CONNECTION_REDIRECT_RECORDS => 2550137052

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_WFP_CONNECTION_REDIRECT_CONTEXT => 2550137053

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_WFP_CONNECTION_REDIRECT_RECORDS => 2550137054

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SOCKET_USAGE_NOTIFICATION => 2550137036

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_GUARANTEE_ENCRYPTION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_ALLOW_INSECURE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_SKIP_FILTER_INSTANTIATION => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_OPTIONAL_PEER_NAME_VERIFICATION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_ALLOW_FIRST_INBOUND_PKT_UNENCRYPTED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_SETTINGS_IPSEC_PEER_NAME_IS_RAW_FORMAT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_QUERY_IPSEC2_ABORT_CONNECTION_ON_FIELD_CHANGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_QUERY_IPSEC2_FIELD_MASK_MM_SA_ID => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_QUERY_IPSEC2_FIELD_MASK_QM_SA_ID => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_INFO_CONNECTION_SECURED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_INFO_CONNECTION_ENCRYPTED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCKET_INFO_CONNECTION_IMPERSONATED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_WFP_ALE_ENDPOINT_HANDLE => 1476395213

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_RSS_SCALABILITY_INFO => 1476395218

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_LOOPBACK => 16777343

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_BROADCAST => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_LOOPBACKPREFIX_LENGTH => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_LINKLOCALPREFIX_LENGTH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN4ADDR_MULTICASTPREFIX_LENGTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_COMPATIBILITY_MODE => 2550137132

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_DONT_NOTIFY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_DEFER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_WAITALL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MSG_COMMIT_ONLY => 8

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_MAX_CQ_SIZE => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static RIO_CORRUPT_CQ => 4294967295

    /**
     * @type {Integer (UInt16)}
     */
    static AF_UNIX => 1

    /**
     * @type {Integer (UInt16)}
     */
    static AF_IMPLINK => 3

    /**
     * @type {Integer (UInt16)}
     */
    static AF_PUP => 4

    /**
     * @type {Integer (UInt16)}
     */
    static AF_CHAOS => 5

    /**
     * @type {Integer (UInt16)}
     */
    static AF_NS => 6

    /**
     * @type {Integer (UInt16)}
     */
    static AF_IPX => 6

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ISO => 7

    /**
     * @type {Integer (UInt16)}
     */
    static AF_OSI => 7

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ECMA => 8

    /**
     * @type {Integer (UInt16)}
     */
    static AF_DATAKIT => 9

    /**
     * @type {Integer (UInt16)}
     */
    static AF_CCITT => 10

    /**
     * @type {Integer (UInt16)}
     */
    static AF_SNA => 11

    /**
     * @type {Integer (UInt16)}
     */
    static AF_DECnet => 12

    /**
     * @type {Integer (UInt16)}
     */
    static AF_DLI => 13

    /**
     * @type {Integer (UInt16)}
     */
    static AF_LAT => 14

    /**
     * @type {Integer (UInt16)}
     */
    static AF_HYLINK => 15

    /**
     * @type {Integer (UInt16)}
     */
    static AF_APPLETALK => 16

    /**
     * @type {Integer (UInt16)}
     */
    static AF_NETBIOS => 17

    /**
     * @type {Integer (UInt16)}
     */
    static AF_VOICEVIEW => 18

    /**
     * @type {Integer (UInt16)}
     */
    static AF_FIREFOX => 19

    /**
     * @type {Integer (UInt16)}
     */
    static AF_UNKNOWN1 => 20

    /**
     * @type {Integer (UInt16)}
     */
    static AF_BAN => 21

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ATM => 22

    /**
     * @type {Integer (UInt16)}
     */
    static AF_CLUSTER => 24

    /**
     * @type {Integer (UInt16)}
     */
    static AF_12844 => 25

    /**
     * @type {Integer (UInt16)}
     */
    static AF_IRDA => 26

    /**
     * @type {Integer (UInt16)}
     */
    static AF_NETDES => 28

    /**
     * @type {Integer (UInt16)}
     */
    static AF_MAX => 29

    /**
     * @type {Integer (UInt16)}
     */
    static AF_TCNPROCESS => 29

    /**
     * @type {Integer (UInt16)}
     */
    static AF_TCNMESSAGE => 30

    /**
     * @type {Integer (UInt16)}
     */
    static AF_ICLFXBM => 31

    /**
     * @type {Integer (UInt16)}
     */
    static AF_LINK => 33

    /**
     * @type {Integer (UInt16)}
     */
    static AF_HYPERV => 34

    /**
     * @type {Integer (Int32)}
     */
    static SOL_SOCKET => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static SOL_IP => 65531

    /**
     * @type {Integer (UInt32)}
     */
    static SOL_IPV6 => 65530

    /**
     * @type {Integer (Int32)}
     */
    static SO_DEBUG => 1

    /**
     * @type {Integer (Int32)}
     */
    static SO_ACCEPTCONN => 2

    /**
     * @type {Integer (Int32)}
     */
    static SO_REUSEADDR => 4

    /**
     * @type {Integer (Int32)}
     */
    static SO_KEEPALIVE => 8

    /**
     * @type {Integer (Int32)}
     */
    static SO_DONTROUTE => 16

    /**
     * @type {Integer (Int32)}
     */
    static SO_BROADCAST => 32

    /**
     * @type {Integer (Int32)}
     */
    static SO_USELOOPBACK => 64

    /**
     * @type {Integer (Int32)}
     */
    static SO_LINGER => 128

    /**
     * @type {Integer (Int32)}
     */
    static SO_OOBINLINE => 256

    /**
     * @type {Integer (Int32)}
     */
    static SO_SNDBUF => 4097

    /**
     * @type {Integer (Int32)}
     */
    static SO_RCVBUF => 4098

    /**
     * @type {Integer (Int32)}
     */
    static SO_SNDLOWAT => 4099

    /**
     * @type {Integer (Int32)}
     */
    static SO_RCVLOWAT => 4100

    /**
     * @type {Integer (Int32)}
     */
    static SO_SNDTIMEO => 4101

    /**
     * @type {Integer (Int32)}
     */
    static SO_RCVTIMEO => 4102

    /**
     * @type {Integer (Int32)}
     */
    static SO_ERROR => 4103

    /**
     * @type {Integer (Int32)}
     */
    static SO_TYPE => 4104

    /**
     * @type {Integer (Int32)}
     */
    static SO_BSP_STATE => 4105

    /**
     * @type {Integer (Int32)}
     */
    static SO_GROUP_ID => 8193

    /**
     * @type {Integer (Int32)}
     */
    static SO_GROUP_PRIORITY => 8194

    /**
     * @type {Integer (Int32)}
     */
    static SO_MAX_MSG_SIZE => 8195

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONDITIONAL_ACCEPT => 12290

    /**
     * @type {Integer (UInt32)}
     */
    static SO_PAUSE_ACCEPT => 12291

    /**
     * @type {Integer (UInt32)}
     */
    static SO_COMPARTMENT_ID => 12292

    /**
     * @type {Integer (Int32)}
     */
    static SO_RANDOMIZE_PORT => 12293

    /**
     * @type {Integer (Int32)}
     */
    static SO_PORT_SCALABILITY => 12294

    /**
     * @type {Integer (Int32)}
     */
    static SO_REUSE_UNICASTPORT => 12295

    /**
     * @type {Integer (Int32)}
     */
    static SO_REUSE_MULTICASTPORT => 12296

    /**
     * @type {Integer (UInt32)}
     */
    static SO_ORIGINAL_DST => 12303

    /**
     * @type {Integer (UInt32)}
     */
    static IP6T_SO_ORIGINAL_DST => 12303

    /**
     * @type {Integer (UInt32)}
     */
    static WSK_SO_BASE => 16384

    /**
     * @type {Integer (Int32)}
     */
    static TCP_NODELAY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static _SS_MAXSIZE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_UNIX => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_WS2 => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_PROTOCOL => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_VENDOR => 402653184

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ASSOCIATE_HANDLE => 2281701377

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ENABLE_CIRCULAR_QUEUEING => 671088642

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_FIND_ROUTE => 1207959555

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_FLUSH => 671088644

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_BROADCAST_ADDRESS => 1207959557

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_EXTENSION_FUNCTION_POINTER => 3355443206

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_QOS => 3355443207

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_GROUP_QOS => 3355443208

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_MULTIPOINT_LOOPBACK => 2281701385

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_MULTICAST_SCOPE => 2281701386

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_QOS => 2281701387

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SET_GROUP_QOS => 2281701388

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_TRANSLATE_HANDLE => 3355443213

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ROUTING_INTERFACE_QUERY => 3355443220

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ROUTING_INTERFACE_CHANGE => 2281701397

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ADDRESS_LIST_QUERY => 1207959574

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ADDRESS_LIST_CHANGE => 671088663

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_TARGET_PNP_HANDLE => 1207959576

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_QUERY_RSS_PROCESSOR_INFO => 1207959589

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ADDRESS_LIST_SORT => 3355443225

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RESERVED_1 => 2281701402

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_RESERVED_2 => 2281701409

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_MULTIPLE_EXTENSION_FUNCTION_POINTER => 3355443236

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TCPMUX => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_ECHO => 7

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DISCARD => 9

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SYSTAT => 11

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DAYTIME => 13

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETSTAT => 15

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_QOTD => 17

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_MSP => 18

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_CHARGEN => 19

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_FTP_DATA => 20

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_FTP => 21

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TELNET => 23

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SMTP => 25

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TIMESERVER => 37

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NAMESERVER => 42

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_WHOIS => 43

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_MTP => 57

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TFTP => 69

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_RJE => 77

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_FINGER => 79

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_TTYLINK => 87

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SUPDUP => 95

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_POP3 => 110

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NTP => 123

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_EPMAP => 135

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETBIOS_NS => 137

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETBIOS_DGM => 138

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_NETBIOS_SSN => 139

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_IMAP => 143

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SNMP => 161

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_SNMP_TRAP => 162

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_IMAP3 => 220

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_LDAP => 389

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_HTTPS => 443

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_MICROSOFT_DS => 445

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_EXECSERVER => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_LOGINSERVER => 513

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_CMDSERVER => 514

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_EFSSERVER => 520

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_BIFFUDP => 512

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_WHOSERVER => 513

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_ROUTESERVER => 520

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_RESERVED => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_REGISTERED_MIN => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_REGISTERED_MAX => 49151

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DYNAMIC_MIN => 49152

    /**
     * @type {Integer (UInt32)}
     */
    static IPPORT_DYNAMIC_MAX => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_NET => 4278190080

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_NSHIFT => 24

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_HOST => 16777215

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSA_MAX => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_NET => 4294901760

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_NSHIFT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_HOST => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSB_MAX => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSC_NET => 4294967040

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSC_NSHIFT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSC_HOST => 255

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSD_NET => 4026531840

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSD_NSHIFT => 28

    /**
     * @type {Integer (UInt32)}
     */
    static IN_CLASSD_HOST => 268435455

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_LOOPBACK => 2130706433

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_NONE => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static IOCPARM_MASK => 127

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_VOID => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_OUT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_IN => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_TRUNC => 256

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_CTRUNC => 512

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_BCAST => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_MCAST => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_ERRQUEUE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static AI_PASSIVE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_CANONNAME => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AI_NUMERICHOST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static AI_NUMERICSERV => 8

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_ONLY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static AI_FORCE_CLEAR_TEXT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static AI_BYPASS_DNS_CACHE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RETURN_TTL => 128

    /**
     * @type {Integer (UInt32)}
     */
    static AI_ALL => 256

    /**
     * @type {Integer (UInt32)}
     */
    static AI_ADDRCONFIG => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static AI_V4MAPPED => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static AI_NON_AUTHORITATIVE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static AI_SECURE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RETURN_PREFERRED_NAMES => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static AI_FQDN => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static AI_FILESERVER => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DISABLE_IDN_ENCODING => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static AI_SECURE_WITH_FALLBACK => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static AI_EXCLUSIVE_CUSTOM_SERVERS => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RETURN_RESPONSE_FLAGS => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static AI_REQUIRE_SECURE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static AI_RESOLUTION_HANDLE => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static AI_EXTENDED => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_5 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_6 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static ADDRINFOEX_VERSION_7 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_SERVER_TYPE_UDP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_SERVER_TYPE_DOH => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_SERVER_TYPE_DOT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_SERVER_UDP_FALLBACK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_RESPONSE_SECURE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AI_DNS_RESPONSE_HOSTFILE => 2

    /**
     * @type {Integer (UInt64)}
     */
    static AI_EXTRA_DNSSEC_REQUIRED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NS_ALL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NS_SAP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NDS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NS_PEER_BROWSE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static NS_SLP => 5

    /**
     * @type {Integer (UInt32)}
     */
    static NS_DHCP => 6

    /**
     * @type {Integer (UInt32)}
     */
    static NS_TCPIP_LOCAL => 10

    /**
     * @type {Integer (UInt32)}
     */
    static NS_TCPIP_HOSTS => 11

    /**
     * @type {Integer (UInt32)}
     */
    static NS_DNS => 12

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NETBT => 13

    /**
     * @type {Integer (UInt32)}
     */
    static NS_WINS => 14

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NLA => 15

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NBP => 20

    /**
     * @type {Integer (UInt32)}
     */
    static NS_MS => 30

    /**
     * @type {Integer (UInt32)}
     */
    static NS_STDA => 31

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NTDS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static NS_EMAIL => 37

    /**
     * @type {Integer (UInt32)}
     */
    static NS_X500 => 40

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NIS => 41

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NISPLUS => 42

    /**
     * @type {Integer (UInt32)}
     */
    static NS_WRQ => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NS_NETDES => 60

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NOFQDN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NUMERICHOST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NAMEREQD => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NI_NUMERICSERV => 8

    /**
     * @type {Integer (UInt32)}
     */
    static NI_DGRAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NI_MAXHOST => 1025

    /**
     * @type {Integer (UInt32)}
     */
    static NI_MAXSERV => 32

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_UP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_BROADCAST => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_LOOPBACK => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_POINTTOPOINT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IFF_MULTICAST => 16

    /**
     * @type {Integer (Int32)}
     */
    static IP_OPTIONS => 1

    /**
     * @type {Integer (Int32)}
     */
    static IP_HDRINCL => 2

    /**
     * @type {Integer (Int32)}
     */
    static IP_TOS => 3

    /**
     * @type {Integer (Int32)}
     */
    static IP_TTL => 4

    /**
     * @type {Integer (Int32)}
     */
    static IP_MULTICAST_IF => 9

    /**
     * @type {Integer (Int32)}
     */
    static IP_MULTICAST_TTL => 10

    /**
     * @type {Integer (Int32)}
     */
    static IP_MULTICAST_LOOP => 11

    /**
     * @type {Integer (Int32)}
     */
    static IP_ADD_MEMBERSHIP => 12

    /**
     * @type {Integer (Int32)}
     */
    static IP_DROP_MEMBERSHIP => 13

    /**
     * @type {Integer (Int32)}
     */
    static IP_DONTFRAGMENT => 14

    /**
     * @type {Integer (Int32)}
     */
    static IP_ADD_SOURCE_MEMBERSHIP => 15

    /**
     * @type {Integer (Int32)}
     */
    static IP_DROP_SOURCE_MEMBERSHIP => 16

    /**
     * @type {Integer (Int32)}
     */
    static IP_BLOCK_SOURCE => 17

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNBLOCK_SOURCE => 18

    /**
     * @type {Integer (Int32)}
     */
    static IP_PKTINFO => 19

    /**
     * @type {Integer (Int32)}
     */
    static IP_HOPLIMIT => 21

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVTTL => 21

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECEIVE_BROADCAST => 22

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVIF => 24

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVDSTADDR => 25

    /**
     * @type {Integer (Int32)}
     */
    static IP_IFLIST => 28

    /**
     * @type {Integer (Int32)}
     */
    static IP_ADD_IFLIST => 29

    /**
     * @type {Integer (Int32)}
     */
    static IP_DEL_IFLIST => 30

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNICAST_IF => 31

    /**
     * @type {Integer (Int32)}
     */
    static IP_RTHDR => 32

    /**
     * @type {Integer (Int32)}
     */
    static IP_GET_IFLIST => 33

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVRTHDR => 38

    /**
     * @type {Integer (Int32)}
     */
    static IP_TCLASS => 39

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVTCLASS => 40

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVTOS => 40

    /**
     * @type {Integer (Int32)}
     */
    static IP_ORIGINAL_ARRIVAL_IF => 47

    /**
     * @type {Integer (Int32)}
     */
    static IP_ECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IP_PKTINFO_EX => 51

    /**
     * @type {Integer (Int32)}
     */
    static IP_WFP_REDIRECT_RECORDS => 60

    /**
     * @type {Integer (Int32)}
     */
    static IP_WFP_REDIRECT_CONTEXT => 70

    /**
     * @type {Integer (Int32)}
     */
    static IP_MTU_DISCOVER => 71

    /**
     * @type {Integer (Int32)}
     */
    static IP_MTU => 73

    /**
     * @type {Integer (Int32)}
     */
    static IP_NRT_INTERFACE => 74

    /**
     * @type {Integer (Int32)}
     */
    static IP_RECVERR => 75

    /**
     * @type {Integer (Int32)}
     */
    static IP_USER_MTU => 76

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNSPECIFIED_TYPE_OF_SERVICE => -1

    /**
     * @type {Integer (UInt32)}
     */
    static IP_UNSPECIFIED_USER_MTU => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_LINKLOCALPREFIX_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_MULTICASTPREFIX_LENGTH => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_SOLICITEDNODEMULTICASTPREFIX_LENGTH => 104

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_V4MAPPEDPREFIX_LENGTH => 96

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_6TO4PREFIX_LENGTH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN6ADDR_TEREDOPREFIX_LENGTH => 32

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_JOIN_GROUP => 41

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_LEAVE_GROUP => 42

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_BLOCK_SOURCE => 43

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_UNBLOCK_SOURCE => 44

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_JOIN_SOURCE_GROUP => 45

    /**
     * @type {Integer (UInt32)}
     */
    static MCAST_LEAVE_SOURCE_GROUP => 46

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_HOPOPTS => 1

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_HDRINCL => 2

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_UNICAST_HOPS => 4

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MULTICAST_IF => 9

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MULTICAST_HOPS => 10

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MULTICAST_LOOP => 11

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_ADD_MEMBERSHIP => 12

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_JOIN_GROUP => 12

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_DROP_MEMBERSHIP => 13

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_LEAVE_GROUP => 13

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_DONTFRAG => 14

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_PKTINFO => 19

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_HOPLIMIT => 21

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_PROTECTION_LEVEL => 23

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVIF => 24

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVDSTADDR => 25

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_CHECKSUM => 26

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_V6ONLY => 27

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_IFLIST => 28

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_ADD_IFLIST => 29

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_DEL_IFLIST => 30

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_UNICAST_IF => 31

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RTHDR => 32

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_GET_IFLIST => 33

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVRTHDR => 38

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_TCLASS => 39

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVTCLASS => 40

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_ECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVECN => 50

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_PKTINFO_EX => 51

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_WFP_REDIRECT_RECORDS => 60

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_WFP_REDIRECT_CONTEXT => 70

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MTU_DISCOVER => 71

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_MTU => 72

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_NRT_INTERFACE => 74

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_RECVERR => 75

    /**
     * @type {Integer (Int32)}
     */
    static IPV6_USER_MTU => 76

    /**
     * @type {Integer (Int32)}
     */
    static IP_UNSPECIFIED_HOP_LIMIT => -1

    /**
     * @type {Integer (Int32)}
     */
    static IP_PROTECTION_LEVEL => 23

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_UNRESTRICTED => 10

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_EDGERESTRICTED => 20

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_RESTRICTED => 30

    /**
     * @type {Integer (UInt32)}
     */
    static PROTECTION_LEVEL_DEFAULT => 20

    /**
     * @type {Integer (UInt32)}
     */
    static INET_ADDRSTRLEN => 22

    /**
     * @type {Integer (UInt32)}
     */
    static INET6_ADDRSTRLEN => 65

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_NO_PREFERENCE => 0

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_NOT_PREFERRED => 1

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_PREFERRED => 2

    /**
     * @type {Integer (Int32)}
     */
    static TCP_EXPEDITED_1122 => 2

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPALIVE => 3

    /**
     * @type {Integer (Int32)}
     */
    static TCP_MAXSEG => 4

    /**
     * @type {Integer (Int32)}
     */
    static TCP_MAXRT => 5

    /**
     * @type {Integer (Int32)}
     */
    static TCP_STDURG => 6

    /**
     * @type {Integer (Int32)}
     */
    static TCP_NOURG => 7

    /**
     * @type {Integer (Int32)}
     */
    static TCP_ATMARK => 8

    /**
     * @type {Integer (Int32)}
     */
    static TCP_NOSYNRETRIES => 9

    /**
     * @type {Integer (Int32)}
     */
    static TCP_TIMESTAMPS => 10

    /**
     * @type {Integer (Int32)}
     */
    static TCP_OFFLOAD_PREFERENCE => 11

    /**
     * @type {Integer (Int32)}
     */
    static TCP_CONGESTION_ALGORITHM => 12

    /**
     * @type {Integer (Int32)}
     */
    static TCP_DELAY_FIN_ACK => 13

    /**
     * @type {Integer (Int32)}
     */
    static TCP_MAXRTMS => 14

    /**
     * @type {Integer (Int32)}
     */
    static TCP_FASTOPEN => 15

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPCNT => 16

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPIDLE => 3

    /**
     * @type {Integer (Int32)}
     */
    static TCP_KEEPINTVL => 17

    /**
     * @type {Integer (Int32)}
     */
    static TCP_FAIL_CONNECT_ON_ICMP_ERROR => 18

    /**
     * @type {Integer (Int32)}
     */
    static TCP_ICMP_ERROR_INFO => 19

    /**
     * @type {Integer (Int32)}
     */
    static UDP_SEND_MSG_SIZE => 2

    /**
     * @type {Integer (Int32)}
     */
    static UDP_RECV_MAX_COALESCED_SIZE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UDP_COALESCED_INFO => 3

    /**
     * @type {Integer (UInt32)}
     */
    static WINDOWS_AF_IRDA => 26

    /**
     * @type {Integer (UInt32)}
     */
    static WINDOWS_PF_IRDA => 26

    /**
     * @type {Integer (UInt32)}
     */
    static WCE_AF_IRDA => 22

    /**
     * @type {Integer (UInt32)}
     */
    static WCE_PF_IRDA => 22

    /**
     * @type {Integer (UInt32)}
     */
    static IRDA_PROTO_SOCK_STREAM => 1

    /**
     * @type {Integer (UInt16)}
     */
    static PF_IRDA => 26

    /**
     * @type {Integer (Int32)}
     */
    static SOL_IRLMP => 255

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_ENUMDEVICES => 16

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_IAS_SET => 17

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_IAS_QUERY => 18

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_SEND_PDU_LEN => 19

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_EXCLUSIVE_MODE => 20

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_IRLPT_MODE => 21

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_9WIRE_MODE => 22

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_TINYTP_MODE => 23

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_PARAMETERS => 24

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_DISCOVERY_MODE => 25

    /**
     * @type {Integer (Int32)}
     */
    static IRLMP_SHARP_MODE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_NO_CLASS => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_NO_ATTRIB => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_INT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_OCTETSEQ => 2

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_ATTRIB_STR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_USER_STRING => 256

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_OCTET_STRING => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_CLASSNAME => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IAS_MAX_ATTRIBNAME => 256

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetASCII => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_5 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_6 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_7 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_8 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetISO_8859_9 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static LmCharSetUNICODE => 255

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_1200 => 1200

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_2400 => 2400

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_9600 => 9600

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_19200 => 19200

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_38400 => 38400

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_57600 => 57600

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_115200 => 115200

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_576K => 576000

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_1152K => 1152000

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_4M => 4000000

    /**
     * @type {Integer (UInt32)}
     */
    static LM_BAUD_16M => 16000000

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNDATA => 28672

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNOPT => 28673

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCDATA => 28674

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCOPT => 28675

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNDATALEN => 28676

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNOPTLEN => 28677

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCDATALEN => 28678

    /**
     * @type {Integer (Int32)}
     */
    static SO_DISCOPTLEN => 28679

    /**
     * @type {Integer (Int32)}
     */
    static SO_OPENTYPE => 28680

    /**
     * @type {Integer (UInt32)}
     */
    static SO_SYNCHRONOUS_ALERT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static SO_SYNCHRONOUS_NONALERT => 32

    /**
     * @type {Integer (Int32)}
     */
    static SO_MAXDG => 28681

    /**
     * @type {Integer (Int32)}
     */
    static SO_MAXPATHDG => 28682

    /**
     * @type {Integer (Int32)}
     */
    static SO_UPDATE_ACCEPT_CONTEXT => 28683

    /**
     * @type {Integer (Int32)}
     */
    static SO_CONNECT_TIME => 28684

    /**
     * @type {Integer (Int32)}
     */
    static SO_UPDATE_CONNECT_CONTEXT => 28688

    /**
     * @type {Integer (Int32)}
     */
    static TCP_BSDURGENT => 28672

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_UDP_CONNRESET => 2550136844

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_SOCKET_CLOSE_NOTIFY => 2550136845

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_UDP_NETRESET => 2550136847

    /**
     * @type {Integer (UInt32)}
     */
    static TF_DISCONNECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TF_REUSE_SOCKET => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TF_WRITE_BEHIND => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TF_USE_DEFAULT_WORKER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TF_USE_SYSTEM_THREAD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TF_USE_KERNEL_APC => 32

    /**
     * @type {String}
     */
    static WSAID_TRANSMITFILE => "{b5367df0-cbac-11cf-95ca-00805f48a192}"

    /**
     * @type {String}
     */
    static WSAID_ACCEPTEX => "{b5367df1-cbac-11cf-95ca-00805f48a192}"

    /**
     * @type {String}
     */
    static WSAID_GETACCEPTEXSOCKADDRS => "{b5367df2-cbac-11cf-95ca-00805f48a192}"

    /**
     * @type {Integer (UInt32)}
     */
    static TP_ELEMENT_MEMORY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TP_ELEMENT_FILE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TP_ELEMENT_EOP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TP_DISCONNECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TP_REUSE_SOCKET => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TP_USE_DEFAULT_WORKER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TP_USE_SYSTEM_THREAD => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TP_USE_KERNEL_APC => 32

    /**
     * @type {String}
     */
    static WSAID_TRANSMITPACKETS => "{d9689da0-1f90-11d3-9971-00c04f68c876}"

    /**
     * @type {String}
     */
    static WSAID_CONNECTEX => "{25a207b9-ddf3-4660-8ee9-76e58c74063e}"

    /**
     * @type {String}
     */
    static WSAID_DISCONNECTEX => "{7fda2e11-8630-436f-a031-f536a6eec157}"

    /**
     * @type {Integer (UInt32)}
     */
    static DE_REUSE_SOCKET => 2

    /**
     * @type {String}
     */
    static NLA_NAMESPACE_GUID => "{6642243a-3ba8-4aa6-baa5-2e0bd71fdd83}"

    /**
     * @type {String}
     */
    static NLA_SERVICE_CLASS_GUID => "{0037e515-b5c9-4a43-bada-8b48a87ad239}"

    /**
     * @type {Integer (UInt32)}
     */
    static NLA_ALLUSERS_NETWORK => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NLA_FRIENDLY_NAME => 2

    /**
     * @type {String}
     */
    static WSAID_WSARECVMSG => "{f689d7c8-6f1f-436b-8a53-e54fe351c322}"

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BSP_HANDLE => 1207959579

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BSP_HANDLE_SELECT => 1207959580

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BSP_HANDLE_POLL => 1207959581

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_BASE_HANDLE => 1207959586

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_EXT_SELECT => 3355443230

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_EXT_POLL => 3355443231

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_EXT_SENDMSG => 3355443232

    /**
     * @type {String}
     */
    static WSAID_WSASENDMSG => "{a441e712-754f-43ca-84a7-0dee44cf606d}"

    /**
     * @type {String}
     */
    static WSAID_WSAPOLL => "{18c76f85-dc66-4964-972e-23c27238312b}"

    /**
     * @type {String}
     */
    static WSAID_MULTIPLE_RIO => "{8509e081-96dd-4005-b165-9e2ee8c79e3f}"

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_RESOURCE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_SERVICE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_LOCAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_FLAG_DEFER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_FLAG_HARD => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_COMMENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_LOCALE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_DISPLAY_HINT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_VERSION => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_START_TIME => 16

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_MACHINE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_ADDRESSES => 256

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_SD => 512

    /**
     * @type {Integer (UInt32)}
     */
    static PROP_ALL => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_ADDRESS_FLAG_RPC_CN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_ADDRESS_FLAG_RPC_DG => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_ADDRESS_FLAG_RPC_NB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NS_DEFAULT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NS_VNS => 50

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_HIERARCHICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_DYNAMIC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_ENUMERABLE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static NSTYPE_WORKGROUP => 8

    /**
     * @type {Integer (UInt32)}
     */
    static XP_CONNECTIONLESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static XP_GUARANTEED_DELIVERY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static XP_GUARANTEED_ORDER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static XP_MESSAGE_ORIENTED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static XP_PSEUDO_STREAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static XP_GRACEFUL_CLOSE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static XP_EXPEDITED_DATA => 64

    /**
     * @type {Integer (UInt32)}
     */
    static XP_CONNECT_DATA => 128

    /**
     * @type {Integer (UInt32)}
     */
    static XP_DISCONNECT_DATA => 256

    /**
     * @type {Integer (UInt32)}
     */
    static XP_SUPPORTS_BROADCAST => 512

    /**
     * @type {Integer (UInt32)}
     */
    static XP_SUPPORTS_MULTICAST => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static XP_BANDWIDTH_ALLOCATION => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static XP_FRAGMENTATION => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static XP_ENCRYPTS => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static RES_SOFT_SEARCH => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RES_FIND_MULTIPLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static RES_SERVICE => 4

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_SAPIDA => "SapId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_SAPIDW => "SapId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_CONNA => "ConnectionOriented"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_CONNW => "ConnectionOriented"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_TCPPORTA => "TcpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_TCPPORTW => "TcpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_UDPPORTA => "UdpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_UDPPORTW => "UdpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_SAPID => "SapId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_CONN => "ConnectionOriented"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_TCPPORT => "TcpPort"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_UDPPORT => "UdpPort"

    /**
     * @type {Integer (UInt32)}
     */
    static SET_SERVICE_PARTIAL_SUCCESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FD_SETSIZE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IMPLINK_IP => 155

    /**
     * @type {Integer (UInt32)}
     */
    static IMPLINK_LOWEXPER => 156

    /**
     * @type {Integer (UInt32)}
     */
    static IMPLINK_HIGHEXPER => 158

    /**
     * @type {Integer (UInt32)}
     */
    static WSADESCRIPTION_LEN => 256

    /**
     * @type {Integer (UInt32)}
     */
    static WSASYS_STATUS_LEN => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IP_DEFAULT_MULTICAST_TTL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IP_DEFAULT_MULTICAST_LOOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static IP_MAX_MEMBERSHIPS => 20

    /**
     * @type {Integer (Int32)}
     */
    static SOCKET_ERROR => -1

    /**
     * @type {Integer (UInt16)}
     */
    static PF_UNIX => 1

    /**
     * @type {Integer (UInt16)}
     */
    static PF_IMPLINK => 3

    /**
     * @type {Integer (UInt16)}
     */
    static PF_PUP => 4

    /**
     * @type {Integer (UInt16)}
     */
    static PF_CHAOS => 5

    /**
     * @type {Integer (UInt16)}
     */
    static PF_NS => 6

    /**
     * @type {Integer (UInt16)}
     */
    static PF_IPX => 6

    /**
     * @type {Integer (UInt16)}
     */
    static PF_ISO => 7

    /**
     * @type {Integer (UInt16)}
     */
    static PF_OSI => 7

    /**
     * @type {Integer (UInt16)}
     */
    static PF_ECMA => 8

    /**
     * @type {Integer (UInt16)}
     */
    static PF_DATAKIT => 9

    /**
     * @type {Integer (UInt16)}
     */
    static PF_CCITT => 10

    /**
     * @type {Integer (UInt16)}
     */
    static PF_SNA => 11

    /**
     * @type {Integer (UInt16)}
     */
    static PF_DECnet => 12

    /**
     * @type {Integer (UInt16)}
     */
    static PF_DLI => 13

    /**
     * @type {Integer (UInt16)}
     */
    static PF_LAT => 14

    /**
     * @type {Integer (UInt16)}
     */
    static PF_HYLINK => 15

    /**
     * @type {Integer (UInt16)}
     */
    static PF_APPLETALK => 16

    /**
     * @type {Integer (UInt16)}
     */
    static PF_VOICEVIEW => 18

    /**
     * @type {Integer (UInt16)}
     */
    static PF_FIREFOX => 19

    /**
     * @type {Integer (UInt16)}
     */
    static PF_UNKNOWN1 => 20

    /**
     * @type {Integer (UInt16)}
     */
    static PF_BAN => 21

    /**
     * @type {Integer (UInt16)}
     */
    static PF_MAX => 29

    /**
     * @type {Integer (UInt32)}
     */
    static SOMAXCONN => 5

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_MAXIOVLEN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_PARTIAL => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static MAXGETHOSTSTRUCT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static FD_READ => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FD_WRITE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FD_OOB => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ACCEPT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CONNECT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CLOSE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static INCL_WINSOCK_API_PROTOTYPES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static INCL_WINSOCK_API_TYPEDEFS => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ADDR_ANY => 0

    /**
     * @type {Integer (Int32)}
     */
    static FROM_PROTOCOL_INFO => -1

    /**
     * @type {Integer (Int32)}
     */
    static SO_PROTOCOL_INFOA => 8196

    /**
     * @type {Integer (Int32)}
     */
    static SO_PROTOCOL_INFOW => 8197

    /**
     * @type {Integer (Int32)}
     */
    static SO_PROTOCOL_INFO => 8197

    /**
     * @type {Integer (Int32)}
     */
    static PVD_CONFIG => 12289

    /**
     * @type {Integer (UInt16)}
     */
    static PF_ATM => 22

    /**
     * @type {Integer (UInt32)}
     */
    static MSG_INTERRUPT => 16

    /**
     * @type {Integer (UInt32)}
     */
    static FD_READ_BIT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static FD_WRITE_BIT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static FD_OOB_BIT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ACCEPT_BIT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CONNECT_BIT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static FD_CLOSE_BIT => 5

    /**
     * @type {Integer (UInt32)}
     */
    static FD_QOS_BIT => 6

    /**
     * @type {Integer (UInt32)}
     */
    static FD_GROUP_QOS_BIT => 7

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ROUTING_INTERFACE_CHANGE_BIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static FD_ADDRESS_LIST_CHANGE_BIT => 9

    /**
     * @type {Integer (UInt32)}
     */
    static FD_MAX_EVENTS => 10

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_MAXIMUM_WAIT_EVENTS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_WAIT_FAILED => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_WAIT_TIMEOUT => 258

    /**
     * @type {Integer (UInt32)}
     */
    static CF_ACCEPT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CF_REJECT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CF_DEFER => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SG_UNCONSTRAINED_GROUP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SG_CONSTRAINED_GROUP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_PROTOCOL_CHAIN => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BASE_PROTOCOL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LAYERED_PROTOCOL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static WSAPROTOCOL_LEN => 255

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_MULTIPLE_PROTO_ENTRIES => 1

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_RECOMMENDED_PROTO_ENTRY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_HIDDEN => 4

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_MATCHES_PROTOCOL_ZERO => 8

    /**
     * @type {Integer (UInt32)}
     */
    static PFL_NETWORKDIRECT_PROVIDER => 16

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_CONNECTIONLESS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_GUARANTEED_DELIVERY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_GUARANTEED_ORDER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_MESSAGE_ORIENTED => 8

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_PSEUDO_STREAM => 16

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_GRACEFUL_CLOSE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_EXPEDITED_DATA => 64

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_CONNECT_DATA => 128

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_DISCONNECT_DATA => 256

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_SUPPORT_BROADCAST => 512

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_SUPPORT_MULTIPOINT => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_MULTIPOINT_CONTROL_PLANE => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_MULTIPOINT_DATA_PLANE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_QOS_SUPPORTED => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_INTERRUPT => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_UNI_SEND => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_UNI_RECV => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_IFS_HANDLES => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_PARTIAL_MESSAGE => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static XP1_SAN_SUPPORT_SDP => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static BIGENDIAN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static LITTLEENDIAN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SECURITY_PROTOCOL_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static JL_SENDER_ONLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static JL_RECEIVER_ONLY => 2

    /**
     * @type {Integer (UInt32)}
     */
    static JL_BOTH => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_OVERLAPPED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_C_ROOT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_C_LEAF => 4

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_D_ROOT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_MULTIPOINT_D_LEAF => 16

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_ACCESS_SYSTEM_SECURITY => 64

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_NO_HANDLE_INHERIT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_FLAG_REGISTERED_IO => 256

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_NSP_NOTIFY_CHANGE => 2281701401

    /**
     * @type {Integer (UInt32)}
     */
    static TH_NETDEV => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TH_TAPI => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SERVICE_MULTIPLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NS_LOCALNAME => 19

    /**
     * @type {Integer (UInt32)}
     */
    static RES_UNUSED_1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RES_FLUSH_CACHE => 2

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_IPXPORTA => "IpxSocket"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_IPXPORTW => "IpxSocket"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_OBJECTIDA => "ObjectId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_OBJECTIDW => "ObjectId"

    /**
     * @type {String}
     */
    static SERVICE_TYPE_VALUE_OBJECTID => "ObjectId"

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DEEP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_CONTAINERS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_NOCONTAINERS => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_NEAREST => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_NAME => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_TYPE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_VERSION => 64

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_COMMENT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_ADDR => 256

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_BLOB => 512

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_ALIASES => 1024

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_QUERY_STRING => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_ALL => 4080

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RES_SERVICE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FLUSHCACHE => 4096

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FLUSHPREVIOUS => 8192

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_NON_AUTHORITATIVE => 16384

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_SECURE => 32768

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_PREFERRED_NAMES => 65536

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DNS_ONLY => 131072

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_RESPONSE_FLAGS => 262144

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RESERVED_UNUSED => 524288

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_ADDRCONFIG => 1048576

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DUAL_ADDR => 2097152

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FILESERVER => 4194304

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_DISABLE_IDN_ENCODING => 8388608

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_API_ANSI => 16777216

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_EXTENDED_QUERYSET => 33554432

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_SECURE_WITH_FALLBACK => 67108864

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_EXCLUSIVE_CUSTOM_SERVERS => 134217728

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_REQUIRE_SECURE => 268435456

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RETURN_TTL => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_FORCE_CLEAR_TEXT => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static LUP_RESOLUTION_HANDLE => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_ALIAS => 1

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_ADDED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_CHANGED => 32

    /**
     * @type {Integer (UInt32)}
     */
    static RESULT_IS_DELETED => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_IN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_OUT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_REGISTER_EVENT_HANGUP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_IN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_OUT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_HANGUP => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_ERR => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_EVENT_REMOVE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_NONE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_ENABLE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_DISABLE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_OP_REMOVE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_ONESHOT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_PERSISTENT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_LEVEL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SOCK_NOTIFY_TRIGGER_EDGE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AALUSER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL34 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ATMPROTO_AAL5 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ABSENT => 4294967294

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ANY => 4294967295

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ANY_AESA_SEL => 4294967290

    /**
     * @type {Integer (UInt32)}
     */
    static SAP_FIELD_ANY_AESA_REST => 4294967291

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_E164 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_NSAP => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_AESA => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ATM_ADDR_SIZE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_ISO_1745 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_Q921 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_X25L => 6

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_X25M => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_ELAPB => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_HDLC_ARM => 9

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_HDLC_NRM => 10

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_HDLC_ABM => 11

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_LLC => 12

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_X75 => 13

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_Q922 => 14

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_USER_SPECIFIED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_ISO_7776 => 17

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_X25 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_ISO_8208 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_X223 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_SIO_8473 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_T70 => 10

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_ISO_TR9577 => 11

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_USER_SPECIFIED => 16

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_IPI_SNAP => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_IPI_IP => 204

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_ISO => 0

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_UserSpecific => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_HighLayerProfile => 2

    /**
     * @type {Integer (UInt32)}
     */
    static BHLI_VendorSpecificAppId => 3

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_MODE_MESSAGE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_MODE_STREAMING => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_NULL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_SSCOP_ASSURED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_SSCOP_NON_ASSURED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static AAL5_SSCS_FRAME_RELAY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BCOB_A => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BCOB_C => 3

    /**
     * @type {Integer (UInt32)}
     */
    static BCOB_X => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TT_NOIND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TT_CBR => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TT_VBR => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TR_NOIND => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TR_END_TO_END => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TR_NO_END_TO_END => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CLIP_NOT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CLIP_SUS => 32

    /**
     * @type {Integer (UInt32)}
     */
    static UP_P2P => 0

    /**
     * @type {Integer (UInt32)}
     */
    static UP_P2MP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_MODE_NORMAL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L2_MODE_EXT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_MODE_NORMAL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_MODE_EXT => 128

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_16 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_32 => 5

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_64 => 6

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_128 => 7

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_256 => 8

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_512 => 9

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_1024 => 10

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_2048 => 11

    /**
     * @type {Integer (UInt32)}
     */
    static BLLI_L3_PACKET_4096 => 12

    /**
     * @type {Integer (UInt32)}
     */
    static PI_ALLOWED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static PI_RESTRICTED => 64

    /**
     * @type {Integer (UInt32)}
     */
    static PI_NUMBER_NOT_AVAILABLE => 128

    /**
     * @type {Integer (UInt32)}
     */
    static SI_USER_NOT_SCREENED => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SI_USER_PASSED => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SI_USER_FAILED => 2

    /**
     * @type {Integer (UInt32)}
     */
    static SI_NETWORK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_USER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PRIVATE_LOCAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PUBLIC_LOCAL => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_TRANSIT_NETWORK => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PUBLIC_REMOTE => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_PRIVATE_REMOTE => 5

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_INTERNATIONAL_NETWORK => 7

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_LOC_BEYOND_INTERWORKING => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNALLOCATED_NUMBER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_ROUTE_TO_DESTINATION => 3

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_VPI_VCI_UNACCEPTABLE => 10

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NORMAL_CALL_CLEARING => 16

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_USER_BUSY => 17

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_USER_RESPONDING => 18

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_CALL_REJECTED => 21

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NUMBER_CHANGED => 22

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_USER_REJECTS_CLIR => 23

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_DESTINATION_OUT_OF_ORDER => 27

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_NUMBER_FORMAT => 28

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_STATUS_ENQUIRY_RESPONSE => 30

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NORMAL_UNSPECIFIED => 31

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_VPI_VCI_UNAVAILABLE => 35

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NETWORK_OUT_OF_ORDER => 38

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_TEMPORARY_FAILURE => 41

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_ACCESS_INFORMAION_DISCARDED => 43

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NO_VPI_VCI_AVAILABLE => 45

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_RESOURCE_UNAVAILABLE => 47

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_QOS_UNAVAILABLE => 49

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_USER_CELL_RATE_UNAVAILABLE => 51

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_BEARER_CAPABILITY_UNAUTHORIZED => 57

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_BEARER_CAPABILITY_UNAVAILABLE => 58

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_OPTION_UNAVAILABLE => 63

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED => 65

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS => 73

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_CALL_REFERENCE => 81

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_CHANNEL_NONEXISTENT => 82

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INCOMPATIBLE_DESTINATION => 88

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_ENDPOINT_REFERENCE => 89

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_TRANSIT_NETWORK_SELECTION => 91

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_TOO_MANY_PENDING_ADD_PARTY => 92

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_AAL_PARAMETERS_UNSUPPORTED => 93

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_MANDATORY_IE_MISSING => 96

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNIMPLEMENTED_MESSAGE_TYPE => 97

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_UNIMPLEMENTED_IE => 99

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_IE_CONTENTS => 100

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INVALID_STATE_FOR_MESSAGE => 101

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_RECOVERY_ON_TIMEOUT => 102

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_INCORRECT_MESSAGE_LENGTH => 104

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_PROTOCOL_ERROR => 111

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_COND_UNKNOWN => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_COND_PERMANENT => 1

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_COND_TRANSIENT => 2

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_REASON_USER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_REASON_IE_MISSING => 4

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_REASON_IE_INSUFFICIENT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_PU_PROVIDER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_PU_USER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NA_NORMAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static CAUSE_NA_ABNORMAL => 4

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS0 => 0

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS1 => 1

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS2 => 2

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS3 => 3

    /**
     * @type {Integer (UInt32)}
     */
    static QOS_CLASS4 => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TNS_TYPE_NATIONAL => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TNS_PLAN_CARRIER_ID_CODE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_NUMBER_OF_ATM_DEVICES => 1343619073

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_ATM_ADDRESS => 3491102722

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_ASSOCIATE_PVC => 2417360899

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_GET_ATM_CONNECTION_ID => 1343619076

    /**
     * @type {Integer (UInt32)}
     */
    static WSPDESCRIPTION_LEN => 255

    /**
     * @type {Integer (Int32)}
     */
    static WSS_OPERATION_IN_PROGRESS => 259

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_SYSTEM => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_INSPECTOR => 1

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_REDIRECTOR => 2

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_PROXY => 4

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_FIREWALL => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_INBOUND_MODIFY => 16

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_OUTBOUND_MODIFY => 32

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_CRYPTO_COMPRESS => 64

    /**
     * @type {Integer (UInt32)}
     */
    static LSP_LOCAL_CACHE => 128

    /**
     * @type {Integer (Int32)}
     */
    static UDP_NOCHECKSUM => 1

    /**
     * @type {Integer (Int32)}
     */
    static UDP_CHECKSUM_COVERAGE => 20

    /**
     * @type {Integer (UInt32)}
     */
    static GAI_STRERROR_BUFFER_SIZE => 1024

    /**
     * @type {Integer (Int32)}
     */
    static IPX_PTYPE => 16384

    /**
     * @type {Integer (Int32)}
     */
    static IPX_FILTERPTYPE => 16385

    /**
     * @type {Integer (Int32)}
     */
    static IPX_STOPFILTERPTYPE => 16387

    /**
     * @type {Integer (Int32)}
     */
    static IPX_DSTYPE => 16386

    /**
     * @type {Integer (Int32)}
     */
    static IPX_EXTENDED_ADDRESS => 16388

    /**
     * @type {Integer (Int32)}
     */
    static IPX_RECVHDR => 16389

    /**
     * @type {Integer (Int32)}
     */
    static IPX_MAXSIZE => 16390

    /**
     * @type {Integer (Int32)}
     */
    static IPX_ADDRESS => 16391

    /**
     * @type {Integer (Int32)}
     */
    static IPX_GETNETINFO => 16392

    /**
     * @type {Integer (Int32)}
     */
    static IPX_GETNETINFO_NORIP => 16393

    /**
     * @type {Integer (Int32)}
     */
    static IPX_SPXGETCONNECTIONSTATUS => 16395

    /**
     * @type {Integer (Int32)}
     */
    static IPX_ADDRESS_NOTIFY => 16396

    /**
     * @type {Integer (Int32)}
     */
    static IPX_MAX_ADAPTER_NUM => 16397

    /**
     * @type {Integer (Int32)}
     */
    static IPX_RERIPNETNUMBER => 16398

    /**
     * @type {Integer (Int32)}
     */
    static IPX_RECEIVE_BROADCAST => 16399

    /**
     * @type {Integer (Int32)}
     */
    static IPX_IMMEDIATESPXACK => 16400

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_MCAST_TTL => 255

    /**
     * @type {Integer (Int32)}
     */
    static RM_OPTIONSBASE => 1000

    /**
     * @type {Integer (Int32)}
     */
    static RM_RATE_WINDOW_SIZE => 1001

    /**
     * @type {Integer (Int32)}
     */
    static RM_SET_MESSAGE_BOUNDARY => 1002

    /**
     * @type {Integer (Int32)}
     */
    static RM_FLUSHCACHE => 1003

    /**
     * @type {Integer (Int32)}
     */
    static RM_SENDER_WINDOW_ADVANCE_METHOD => 1004

    /**
     * @type {Integer (Int32)}
     */
    static RM_SENDER_STATISTICS => 1005

    /**
     * @type {Integer (Int32)}
     */
    static RM_LATEJOIN => 1006

    /**
     * @type {Integer (Int32)}
     */
    static RM_SET_SEND_IF => 1007

    /**
     * @type {Integer (Int32)}
     */
    static RM_ADD_RECEIVE_IF => 1008

    /**
     * @type {Integer (Int32)}
     */
    static RM_DEL_RECEIVE_IF => 1009

    /**
     * @type {Integer (Int32)}
     */
    static RM_SEND_WINDOW_ADV_RATE => 1010

    /**
     * @type {Integer (Int32)}
     */
    static RM_USE_FEC => 1011

    /**
     * @type {Integer (Int32)}
     */
    static RM_SET_MCAST_TTL => 1012

    /**
     * @type {Integer (Int32)}
     */
    static RM_RECEIVER_STATISTICS => 1013

    /**
     * @type {Integer (Int32)}
     */
    static RM_HIGH_SPEED_INTRANET_OPT => 1014

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_DEFAULT_RATE_KBITS_PER_SEC => 56

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_DEFAULT_WINDOW_ADV_PERCENTAGE => 15

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_WINDOW_INCREMENT_PERCENTAGE => 25

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_DEFAULT_LATE_JOINER_PERCENTAGE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static SENDER_MAX_LATE_JOINER_PERCENTAGE => 75

    /**
     * @type {Integer (UInt32)}
     */
    static BITS_PER_BYTE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static LOG2_BITS_PER_BYTE => 3

    /**
     * @type {Integer (UInt32)}
     */
    static UNIX_PATH_MAX => 108

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_AF_UNIX_GETPEERPID => 1476395264

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_AF_UNIX_SETBINDPARENTPATH => 2550137089

    /**
     * @type {Integer (UInt32)}
     */
    static SIO_AF_UNIX_SETCONNPARENTPATH => 2550137090

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP0 => 25

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP1 => 26

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP2 => 27

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP3 => 28

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP4 => 29

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_TP => 29

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_CLTP => 30

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_CLNP => 31

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_X25 => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_INACT_NL => 33

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_ESIS => 34

    /**
     * @type {Integer (UInt32)}
     */
    static ISOPROTO_INTRAISIS => 35

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_MAX_ADDR_LENGTH => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_HIERARCHICAL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_NON_HIERARCHICAL => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_EXP_DATA_USE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ISO_EXP_DATA_NUSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NSPROTO_IPX => 1000

    /**
     * @type {Integer (UInt32)}
     */
    static NSPROTO_SPX => 1256

    /**
     * @type {Integer (UInt32)}
     */
    static NSPROTO_SPXII => 1257

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_NAME_LENGTH => 16

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_UNIQUE_NAME => 0

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_GROUP_NAME => 1

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_TYPE_QUICK_UNIQUE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static NETBIOS_TYPE_QUICK_GROUP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static VNSPROTO_IPC => 1

    /**
     * @type {Integer (UInt32)}
     */
    static VNSPROTO_RELIABLE_IPC => 2

    /**
     * @type {Integer (UInt32)}
     */
    static VNSPROTO_SPP => 3

    /**
     * @type {Integer (UInt32)}
     */
    static _LITTLE_ENDIAN => 1234

    /**
     * @type {Integer (UInt32)}
     */
    static _BIG_ENDIAN => 4321

    /**
     * @type {Integer (UInt32)}
     */
    static _PDP_ENDIAN => 3412

    /**
     * @type {Integer (UInt32)}
     */
    static BYTE_ORDER => 1234

    /**
     * @type {Integer (UInt32)}
     */
    static DL_ADDRESS_LENGTH_MAXIMUM => 32

    /**
     * @type {Integer (UInt32)}
     */
    static DL_HEADER_LENGTH_MAXIMUM => 64

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_DSAP => 170

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_SSAP => 170

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_CONTROL => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SNAP_OUI => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ETH_LENGTH_OF_HEADER => 14

    /**
     * @type {Integer (UInt32)}
     */
    static ETH_LENGTH_OF_VLAN_HEADER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ETH_LENGTH_OF_SNAP_HEADER => 8

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_MINIMUM => 1536

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_IPV4 => 2048

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_ARP => 2054

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_IPV6 => 34525

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_802_1Q => 33024

    /**
     * @type {Integer (UInt32)}
     */
    static ETHERNET_TYPE_802_1AD => 34984

    /**
     * @type {Integer (UInt32)}
     */
    static IP_VER_MASK => 240

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_VERSION => 4

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IPV4_PACKET => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IPV4_HLEN => 60

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_MINIMUM_MTU => 576

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_MIN_MINIMUM_MTU => 352

    /**
     * @type {Integer (UInt32)}
     */
    static IPV4_MAX_MINIMUM_MTU => 576

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_ROUTING_HEADER => 3

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_TIMESTAMP_HEADER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_SECURITY => 11

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_STREAMIDENTIFIER => 4

    /**
     * @type {Integer (UInt32)}
     */
    static SIZEOF_IP_OPT_ROUTERALERT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static IP4_OFF_MASK => 65311

    /**
     * @type {Integer (UInt32)}
     */
    static ICMPV4_INVALID_PREFERENCE_LEVEL => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_QUERY_TYPE => 17

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_VERSION1_REPORT_TYPE => 18

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_VERSION2_REPORT_TYPE => 22

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_LEAVE_GROUP_TYPE => 23

    /**
     * @type {Integer (UInt32)}
     */
    static IGMP_VERSION3_REPORT_TYPE => 34

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_VERSION => 96

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_TRAFFIC_CLASS_MASK => 49167

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_FULL_TRAFFIC_CLASS_MASK => 61455

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_ECN_MASK => 12288

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_FLOW_LABEL_MASK => 4294905600

    /**
     * @type {Integer (UInt32)}
     */
    static MAX_IPV6_PAYLOAD => 65535

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_ECN_SHIFT => 12

    /**
     * @type {Integer (UInt32)}
     */
    static IPV6_MINIMUM_MTU => 1280

    /**
     * @type {Integer (UInt32)}
     */
    static IP6F_OFF_MASK => 63743

    /**
     * @type {Integer (UInt32)}
     */
    static IP6F_RESERVED_MASK => 1536

    /**
     * @type {Integer (UInt32)}
     */
    static IP6F_MORE_FRAG => 256

    /**
     * @type {Integer (UInt32)}
     */
    static EXT_LEN_UNIT => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_SKIP => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_DISCARD => 64

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_FORCEICMP => 128

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_TYPE_ICMP => 192

    /**
     * @type {Integer (UInt32)}
     */
    static IP6OPT_MUTABLE => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_NOROUTE => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_ADMIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_BEYONDSCOPE => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_ADDR => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_DST_UNREACH_NOPORT => 4

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_TIME_EXCEED_TRANSIT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_TIME_EXCEED_REASSEMBLY => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_HEADER => 0

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_NEXTHEADER => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_OPTION => 2

    /**
     * @type {Integer (UInt32)}
     */
    static ICMP6_PARAMPROB_FIRSTFRAGMENT => 3

    /**
     * @type {Integer (UInt32)}
     */
    static ICMPV6_ECHO_REQUEST_FLAG_REVERSE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_MANAGED => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_OTHER => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_HOME_AGENT => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ND_RA_FLAG_PREFERENCE => 24

    /**
     * @type {Integer (UInt32)}
     */
    static ND_NA_FLAG_ROUTER => 2147483648

    /**
     * @type {Integer (UInt32)}
     */
    static ND_NA_FLAG_SOLICITED => 1073741824

    /**
     * @type {Integer (UInt32)}
     */
    static ND_NA_FLAG_OVERRIDE => 536870912

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_ONLINK => 128

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_AUTO => 64

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_ROUTER_ADDR => 32

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_SITE_PREFIX => 16

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_PI_FLAG_ROUTE => 1

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_RI_FLAG_PREFERENCE => 24

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_RDNSS_MIN_LEN => 24

    /**
     * @type {Integer (UInt32)}
     */
    static ND_OPT_DNSSL_MIN_LEN => 16

    /**
     * @type {Integer (UInt32)}
     */
    static IN6_EMBEDDEDV4_UOCTET_POSITION => 8

    /**
     * @type {Integer (UInt32)}
     */
    static IN6_EMBEDDEDV4_BITS_IN_BYTE => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TH_MAX_LEN => 60

    /**
     * @type {Integer (UInt32)}
     */
    static TH_FIN => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TH_SYN => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TH_RST => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TH_PSH => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TH_ACK => 16

    /**
     * @type {Integer (UInt32)}
     */
    static TH_URG => 32

    /**
     * @type {Integer (UInt32)}
     */
    static TH_ECE => 64

    /**
     * @type {Integer (UInt32)}
     */
    static TH_CWR => 128

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_EOL => 0

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_NOP => 1

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_MSS => 2

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_WS => 3

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_SACK_PERMITTED => 4

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_SACK => 5

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_TS => 8

    /**
     * @type {Integer (UInt32)}
     */
    static TH_OPT_FASTOPEN => 34

    /**
     * @type {String}
     */
    static NMR_REG_KEY_PATH => "\Registry\Machine\System\CurrentControlSet\Control\NMR\providers"

    /**
     * @type {Integer (Int32)}
     */
    static INVALID_SOCKET => -1

    /**
     * @type {Integer (UInt32)}
     */
    static WSA_INFINITE => 4294967295

    /**
     * @type {Integer (Int32)}
     */
    static WSA_INVALID_EVENT => 0

    /**
     * @type {Integer (UInt32)}
     */
    static IOC_INOUT => 3221225472

    /**
     * @type {Integer (Int32)}
     */
    static FIONREAD => 1074030207

    /**
     * @type {Integer (Int32)}
     */
    static FIONBIO => -2147195266

    /**
     * @type {Integer (Int32)}
     */
    static FIOASYNC => -2147195267

    /**
     * @type {Integer (Int32)}
     */
    static SIOCSHIWAT => -2147192064

    /**
     * @type {Integer (Int32)}
     */
    static SIOCGHIWAT => 1074033409

    /**
     * @type {Integer (Int32)}
     */
    static SIOCSLOWAT => -2147192062

    /**
     * @type {Integer (Int32)}
     */
    static SIOCGLOWAT => 1074033411

    /**
     * @type {Integer (Int32)}
     */
    static SIOCATMARK => 1074033415

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_ANY => 0

    /**
     * @type {Integer (UInt32)}
     */
    static INADDR_BROADCAST => 4294967295

    /**
     * @type {Integer (Int32)}
     */
    static SO_DONTLINGER => -129

    /**
     * @type {Integer (Int32)}
     */
    static SO_EXCLUSIVEADDRUSE => -5

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB_Extension => 128

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_PnP => 1

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_PDA_Palmtop => 2

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Computer => 4

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Printer => 8

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Modem => 16

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_Fax => 32

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB1_LANAccess => 64

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB2_Telephony => 1

    /**
     * @type {Integer (Int32)}
     */
    static LM_HB2_FileServer => 2
;@endregion Constants

;@region Methods
    /**
     * Retrieves information about available transport protocols.NoteThis call is a strictly 32-bit version of WSCEnumProtocols for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs..
     * @param {Pointer<Integer>} lpiProtocols Null-terminated array of <i>iProtocol</i> values. This parameter is optional; if <i>lpiProtocols</i> is null, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer} lpProtocolBuffer Buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures.
     * @param {Pointer<Integer>} lpdwBufferLength On input, size of the <i>lpProtocolBuffer</i> buffer passed to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>, in bytes. On output, the minimum buffer size, in bytes, that can be passed to 
     * **WSCEnumProtocols** to retrieve all the requested information.
     * @param {Pointer<Integer>} lpErrno Pointer to the error code.
     * @returns {Integer} If no error occurs, 
     * **WSCEnumProtocols32** returns the number of protocols to be reported on. Otherwise, a value of SOCKET_ERROR is returned and a specific error code is available in <i>lpErrno</i>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One of more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that one of the specified parameters was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * Buffer length was too small to receive all the relevant 
     * <a href="/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures and associated information. Pass in a buffer at least as large as the value returned in <i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscenumprotocols32
     * @since windows6.0.6000
     */
    static WSCEnumProtocols32(lpiProtocols, lpProtocolBuffer, lpdwBufferLength, lpErrno) {
        result := DllCall("WS2_32.dll\WSCEnumProtocols32", "int*", lpiProtocols, "ptr", lpProtocolBuffer, "uint*", lpdwBufferLength, "int*", lpErrno, "int")
        return result
    }

    /**
     * Removes the specified 32-bit transport provider from the system configuration database.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider. This value is stored within each 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, 
     * **WSCDeinstallProvider32** returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error code is available in <i>lpErrno</i>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProviderId</i> parameter does not specify a valid provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpErrno</i> parameter is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the  Windows Sockets registry, or a failure occurred when opening a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscdeinstallprovider32
     * @since windows6.0.6000
     */
    static WSCDeinstallProvider32(lpProviderId, lpErrno) {
        result := DllCall("WS2_32.dll\WSCDeinstallProvider32", "ptr", lpProviderId, "int*", lpErrno, "int")
        return result
    }

    /**
     * Installs the specified transport service provider into the 32-bit and 64-bit system configuration databases on a 64-bit computer.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {PWSTR} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure defines a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If **WSCInstallProvider64_32** succeeds, it returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Memory could not be allocated for buffers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is already installed, the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when creating or installing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscinstallprovider64_32
     * @since windows5.1.2600
     */
    static WSCInstallProvider64_32(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        lpszProviderDllPath := lpszProviderDllPath is String ? StrPtr(lpszProviderDllPath) : lpszProviderDllPath

        result := DllCall("WS2_32.dll\WSCInstallProvider64_32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "int*", lpErrno, "int")
        return result
    }

    /**
     * Retrieves the DLL path for the specified 32-bit provider.NoteThis call is a strictly 32-bit version of WSCGetProviderPath for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs..
     * @param {Pointer<Guid>} lpProviderId Locally unique identifier of the provider. This value is obtained by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols32">WSCEnumProtocols32</a>.
     * @param {PWSTR} lpszProviderDllPath Pointer to a buffer into which the provider DLL's path string is returned. The path is a null-terminated string and any embedded environment strings, such as %SystemRoot%, have not been expanded.
     * @param {Pointer<Integer>} lpProviderDllPathLen Size of the buffer pointed to by the <i>lpszProviderDllPath</i> parameter, in characters.
     * @param {Pointer<Integer>} lpErrno Pointer to the error code.
     * @returns {Integer} If 
     * no error occurs, **WSCGetProviderPath32** returns zero. Otherwise, it returns SOCKET_ERROR. The specific error code is available in <i>lpErrno</i>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProviderId</i> parameter does not specify a valid provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpszProviderDllPath</i> or <i>lpErrno</i> parameter is not in a valid part of the user address space, or <i>lpProviderDllPathLen</i> is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscgetproviderpath32
     * @since windows6.0.6000
     */
    static WSCGetProviderPath32(lpProviderId, lpszProviderDllPath, lpProviderDllPathLen, lpErrno) {
        lpszProviderDllPath := lpszProviderDllPath is String ? StrPtr(lpszProviderDllPath) : lpszProviderDllPath

        result := DllCall("WS2_32.dll\WSCGetProviderPath32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "int*", lpProviderDllPathLen, "int*", lpErrno, "int")
        return result
    }

    /**
     * Modifies the specified 32-bit transport provider in the system configuration database.NoteThis call is a strictly 32-bit version of WSCUpdateProvider for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs..
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {PWSTR} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure specifies or modifies a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, 
     * **WSCUpdateProvider32** returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code is available in <i>lpErrno</i>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when opening or writing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscupdateprovider32
     * @since windows6.0.6000
     */
    static WSCUpdateProvider32(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        lpszProviderDllPath := lpszProviderDllPath is String ? StrPtr(lpszProviderDllPath) : lpszProviderDllPath

        result := DllCall("WS2_32.dll\WSCUpdateProvider32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "int*", lpErrno, "int")
        return result
    }

    /**
     * Sets the data value for specified information class for a layered service provider (LSP).
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class to be set for this LSP protocol entry.
     * @param {Pointer} Info A pointer to a buffer that contains the information class data to set for the LSP protocol entry.
     * @param {Pointer} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info </i>parameter.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCSetProviderInfo32** function call.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, **WSCSetProviderInfo32** returns **ERROR_SUCCESS** (zero). Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the <i>InfoType</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscsetproviderinfo32
     * @since windows6.0.6000
     */
    static WSCSetProviderInfo32(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        result := DllCall("WS2_32.dll\WSCSetProviderInfo32", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr", InfoSize, "uint", Flags, "int*", lpErrno, "int")
        return result
    }

    /**
     * Retrieves the data associated with an information class for a 32-bit layered service provider (LSP).NoteThis call is a strictly 32-bit version of WSCGetProviderInfo for use on 64-bit platforms.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class that is requested for this LSP protocol entry.
     * @param {Pointer} Info A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is **NULL**, then **WSCGetProviderInfo32** returns failure and the size required for this buffer is returned in the <i>InfoSize</i> parameter.
     * @param {Pointer<Pointer>} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info </i>parameter. If the Info parameter is **NULL**, then  **WSCGetProviderInfo32** returns failure and the <i>InfoSize</i> parameter will receive the size of the required buffer.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCGetProviderInfo32** function call.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, **WSCGetProviderInfo32** returns **ERROR_SUCCESS** (zero). Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the <i>InfoType</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol entry could not be found for the specified <i>lpProviderId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscgetproviderinfo32
     * @since windows6.0.6000
     */
    static WSCGetProviderInfo32(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        result := DllCall("WS2_32.dll\WSCGetProviderInfo32", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr*", InfoSize, "uint", Flags, "int*", lpErrno, "int")
        return result
    }

    /**
     * Returns information on available 32-bit namespace providers.NoteThis call is a strictly 32-bit version of WSAEnumNameSpaceProviders for use on 64-bit platforms. It is provided to allow 64-bit processes to access the 32-bit catalogs..
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to **WSCEnumNameSpaceProviders32** must be sufficient to hold all of the namespace information.
     * @param {Pointer} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFOW</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * **WSCEnumNameSpaceProviders32**.
     * @returns {Integer} The 
     * **WSCEnumNameSpaceProviders32** function returns the number of 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFOW</a> structures copied into <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpnspBuffer</i> parameter was a **NULL** pointer or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFOW</a> structures and associated information. When this error is returned, the buffer length required is returned in the <i>lpdwBufferLength</i> parameter. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscenumnamespaceproviders32
     * @since windows6.0.6000
     */
    static WSCEnumNameSpaceProviders32(lpdwBufferLength, lpnspBuffer) {
        result := DllCall("WS2_32.dll\WSCEnumNameSpaceProviders32", "uint*", lpdwBufferLength, "ptr", lpnspBuffer, "int")
        return result
    }

    /**
     * Retrieves information on available 32-bit namespace providers.
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to **WSCEnumNameSpaceProvidersEx32** must be sufficient to hold all of the namespace information.
     * @param {Pointer} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEXW</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * **WSCEnumNameSpaceProvidersEx32**.
     * @returns {Integer} The 
     * **WSCEnumNameSpaceProvidersEx32** function returns the number of 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEXW</a> structures copied into <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer length was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEXW</a> structures and associated information or the <i>lpnspBuffer</i> parameter was a **NULL** pointer. When this error is returned, the buffer length required is returned in the <i>lpdwBufferLength</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscenumnamespaceprovidersex32
     * @since windows6.0.6000
     */
    static WSCEnumNameSpaceProvidersEx32(lpdwBufferLength, lpnspBuffer) {
        result := DllCall("WS2_32.dll\WSCEnumNameSpaceProvidersEx32", "uint*", lpdwBufferLength, "ptr", lpnspBuffer, "int")
        return result
    }

    /**
     * 
     * @param {PWSTR} lpszIdentifier 
     * @param {PWSTR} lpszPathName 
     * @param {Integer} dwNameSpace 
     * @param {Integer} dwVersion 
     * @param {Pointer<Guid>} lpProviderId 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscinstallnamespace32
     * @since windows6.0.6000
     */
    static WSCInstallNameSpace32(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId) {
        lpszIdentifier := lpszIdentifier is String ? StrPtr(lpszIdentifier) : lpszIdentifier
        lpszPathName := lpszPathName is String ? StrPtr(lpszPathName) : lpszPathName

        result := DllCall("WS2_32.dll\WSCInstallNameSpace32", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId, "int")
        return result
    }

    /**
     * Installs a specified 32-bit namespace provider.
     * @param {PWSTR} lpszIdentifier A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the <i>lpProviderId</i> parameter.
     * @param {PWSTR} lpszPathName A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Integer} dwNameSpace The namespace supported by this provider.
     * @param {Integer} dwVersion The version number of the provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID  for the provider. This GUID should be generated by Uuidgen.exe.
     * @param {Pointer<BLOB>} lpProviderSpecific A provider-specific data blob associated with namespace entry.
     * @returns {Integer} If no error occurs, the 
     * **WSCInstallNameSpaceEx32** function returns **NO_ERROR** (zero). Otherwise, it returns **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to install a namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is already installed, the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when creating or installing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscinstallnamespaceex32
     * @since windows6.0.6000
     */
    static WSCInstallNameSpaceEx32(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId, lpProviderSpecific) {
        lpszIdentifier := lpszIdentifier is String ? StrPtr(lpszIdentifier) : lpszIdentifier
        lpszPathName := lpszPathName is String ? StrPtr(lpszPathName) : lpszPathName

        result := DllCall("WS2_32.dll\WSCInstallNameSpaceEx32", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId, "ptr", lpProviderSpecific, "int")
        return result
    }

    /**
     * 
     * @param {Pointer<Guid>} lpProviderId 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wscuninstallnamespace32
     * @since windows6.0.6000
     */
    static WSCUnInstallNameSpace32(lpProviderId) {
        result := DllCall("WS2_32.dll\WSCUnInstallNameSpace32", "ptr", lpProviderId, "int")
        return result
    }

    /**
     * Enables or disables a specified 32-bit namespace provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the namespace provider.
     * @param {BOOL} fEnable A Boolean value that, if **TRUE**, the namespace provider is set to the active state. If **FALSE**, the namespace provider is disabled and will not be available for query operations or service registration.
     * @returns {Integer} If no error occurs, the 
     * **WSCEnableNSProvider32** function returns **NO_ERROR** (zero). Otherwise, it returns **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProviderId</i> parameter points to memory that is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified namespace provider identifier is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscenablensprovider32
     * @since windows6.0.6000
     */
    static WSCEnableNSProvider32(lpProviderId, fEnable) {
        result := DllCall("WS2_32.dll\WSCEnableNSProvider32", "ptr", lpProviderId, "int", fEnable, "int")
        return result
    }

    /**
     * Installs the specified transport provider and its specific protocol chains into both the 32-bit and 64-bit Winsock 2 system configuration databases on a 64-bit computer.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID) for the provider.
     * @param {PWSTR} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the <i>Ws2_32.dll</i> must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the <i>Ws2_32.dll</i> passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * 
     * <div class="alert">**Note**If <i>lpszProviderDllPath32</i> is set to **NULL** then <i>lpszProviderDllPath</i> must be set to <i>%windir%\system32\&lt;dllname&gt;</i>.  If not, the call fails and returns the <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a> error code.</div>
     * <div></div>
     * @param {PWSTR} lpszProviderDllPath32 A pointer to a Unicode string that contains the fully qualified path to the provider 32-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the <i>Ws2_32.dll</i> subsequently loads the provider DLL on behalf of an application. After any embedded environment strings are expanded, the <i>Ws2_32.dll</i> passes the resulting string into the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function to load the provider into memory. For more information, see **LoadLibrary**.
     * 
     * <div class="alert">**Note**If this parameter is set to **NULL**, the 64-bit provider must exist in the <i>%windir%\system32</i> folder and the 32-bit provider must reside in the <i>%windir%\syswow64</i> folder.</div>
     * <div></div>
     * @param {PWSTR} lpszLspName A pointer to a Unicode string that contains the name of the layered service provider (LSP).
     * @param {Integer} dwServiceFlags The service flags for the type of layered protocol catalog entry to be created. A layered protocol entry is  a <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure with the **ChainLen** member set to 0. The actual catalog entry for the LSP will reference the ID of this layered protocol entry in its **ProtocolChain** member.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="XP1_IFS_HANDLES"></a><a id="xp1_ifs_handles"></a><dl>
     * <dt><b>XP1_IFS_HANDLES</b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The catalog entry is for an Installable File System (IFS) LSP, which returns IFS-specific socket handles. An IFS LSP cannot intercept the completion of Winsock calls, and does not have to implement all of the Winsock functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure defines a  protocol, address family, and socket type supported by the provider. The members of the **WSAPROTOCOL_INFO** structure that are examined are **iProtocol**, **iAddressFamily**, and  **iSocketType**.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Integer>} lpdwCatalogEntryId A pointer to the newly installed layered protocol entry for the transport provider in the Winsock 2 system configuration database. This was the ID used to build the protocol chain entries installed in the catalog for the LSP.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code generated by the call if the function fails.
     * @returns {Integer} If **WSCInstallProviderAndChains64_32** succeeds, it returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid. This error is returned for the following conditions: the <i>lpProviderId</i> parameter is **NULL**, the <i>lpszProviderDllPath</i> parameter is invalid or the path length is too large (**MAX_PATH** was exceeded), the <i>lpszLspName</i> parameter is invalid or the name length is too large (**WSAPROTOCOL_LEN** is exceeded), the <i>lpProtocolInfoList</i> is set to a non-**NULL** and the <i>dwNumberOfEntries</i> parameter is zero, a duplicate provider  ID or the layered service provider name already exist in the catalog, or a match cannot be found for the specified protocol, address family, and socket type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEINVALIDPROCTABLE</b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The provider is missing required functionality. A non-IFS provider must implement all of the Winsock 2 extension functions (<a href="/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>, <a href="/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, <a href="/previous-versions/windows/desktop/legacy/ms737757(v=vs.85)">DisconnectEx</a>, <a href="/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a>, <a href="/windows/desktop/api/mswsock/nc-mswsock-lpfn_transmitpackets">TransmitPackets</a>, and <a href="/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg">LPFN_WSARECVMSG (WSARecvMsg)</a>).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A provider installation is already in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Memory cannot be allocated for buffers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is already installed, the <i>lpProtocolInfoList</i> parameter was **NULL** and there was no base provider found, the maximum protocol chain length (**MAX_PROTOCOL_CHAIN**) was reached, the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when creating or installing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscinstallproviderandchains64_32
     * @since windows6.0.6000
     */
    static WSCInstallProviderAndChains64_32(lpProviderId, lpszProviderDllPath, lpszProviderDllPath32, lpszLspName, dwServiceFlags, lpProtocolInfoList, dwNumberOfEntries, lpdwCatalogEntryId, lpErrno) {
        lpszProviderDllPath := lpszProviderDllPath is String ? StrPtr(lpszProviderDllPath) : lpszProviderDllPath
        lpszProviderDllPath32 := lpszProviderDllPath32 is String ? StrPtr(lpszProviderDllPath32) : lpszProviderDllPath32
        lpszLspName := lpszLspName is String ? StrPtr(lpszLspName) : lpszLspName

        result := DllCall("WS2_32.dll\WSCInstallProviderAndChains64_32", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpszProviderDllPath32, "ptr", lpszLspName, "uint", dwServiceFlags, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "uint*", lpdwCatalogEntryId, "int*", lpErrno, "int")
        return result
    }

    /**
     * Used to reorder the available 32-bit transport providers.
     * @param {Pointer<Integer>} lpwdCatalogEntryId A pointer to an array of <b>CatalogEntryId</b> elements found in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The order of the <b>CatalogEntryId</b> elements is the new priority ordering for the protocols.
     * @param {Integer} dwNumberOfEntries The number of elements in the <i>lpwdCatalogEntryId</i> array.
     * @returns {Integer} The function returns <b>ERROR_SUCCESS</b> (zero) if the routine is successful. Otherwise, it returns a specific error code.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid, no action was taken.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when opening or writing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>(other)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The routine may return any registry error code.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//sporder/nf-sporder-wscwriteproviderorder32
     * @since windows6.0.6000
     */
    static WSCWriteProviderOrder32(lpwdCatalogEntryId, dwNumberOfEntries) {
        result := DllCall("WS2_32.dll\WSCWriteProviderOrder32", "uint*", lpwdCatalogEntryId, "uint", dwNumberOfEntries, "int")
        return result
    }

    /**
     * Changes the order of available Windows Sockets (Winsock) 2 namespace providers in a 32-bit catalog.
     * @param {Pointer<Guid>} lpProviderId An array of <b>NSProviderId</b> elements as found in the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a>structure.  The order of the <b>NSProviderId</b> elements is the new
     *       priority ordering for the namespace providers.
     * @param {Integer} dwNumberOfEntries The number of elements in the <b>NSProviderId</b> array.
     * @returns {Integer} The function returns <b>ERROR_SUCCESS</b> (zero) if the routine is successful. Otherwise, it returns a specific error code.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>NSProviderId</b> array is not fully contained within process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Input parameters were invalid, no action was taken.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the Winsock registry could not be opened, the user lacks the administrative privileges required to write to the  Winsock registry, or another application is currently writing to the namespace provider catalog.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2"> WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function is called by another thread or process.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory was available to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>(other)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function may return any registry error code.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//sporder/nf-sporder-wscwritenamespaceorder32
     * @since windows6.0.6000
     */
    static WSCWriteNameSpaceOrder32(lpProviderId, dwNumberOfEntries) {
        result := DllCall("WS2_32.dll\WSCWriteNameSpaceOrder32", "ptr", lpProviderId, "uint", dwNumberOfEntries, "int")
        return result
    }

    /**
     * The __WSAFDIsSet function specifies whether a socket is included in a set of socket descriptors.
     * @remarks
     * 
     * <b>WindowsPhone8:</b> This function is supported for Windows Phone Store apps on WindowsPhone8 and later.
     * 
     * <b>Windows8.1</b> and <b>Windows Server2012R2</b>: This function is supported for Windows Store apps on Windows8.1, Windows Server2012R2, and later.
     * 
     * 
     * @param {SOCKET} fd 
     * @param {Pointer<FD_SET>} param1 
     * @returns {Integer} 
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-__wsafdisset
     * @since windows8.1
     */
    static __WSAFDIsSet(fd, param1) {
        fd := fd is Win32Handle ? NumGet(fd, "ptr") : fd

        result := DllCall("WS2_32.dll\__WSAFDIsSet", "ptr", fd, "ptr", param1, "int")
        return result
    }

    /**
     * The accept function permits an incoming connection attempt on a socket.
     * @param {SOCKET} s A descriptor that identifies a socket that has been placed in a listening state with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function. The connection is actually made with the socket that is returned by 
     * <b>accept</b>.
     * @param {Pointer} addr An optional pointer to a buffer that receives the address of the connecting entity, as known to the communications layer. The exact format of the <i>addr</i> parameter is determined by the address family that was established when the socket from the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure was created.
     * @param {Pointer<Integer>} addrlen An optional pointer to an integer that contains the length of structure pointed to by the <i>addr</i> parameter.
     * @returns {SOCKET} If no error occurs, 
     * <b>accept</b> returns a value of type <b>SOCKET</b> that is a descriptor for the new socket. This returned value is a handle for the socket on which the actual connection is made.
     * 
     * Otherwise, a value of <b>INVALID_SOCKET</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The integer referred to by <i>addrlen</i> initially contains the amount of space pointed to by <i>addr</i>. On return it will contain the actual length in bytes of the address returned.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>addrlen</i> parameter is too small or <i>addr</i> is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function was not invoked prior to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The queue is nonempty upon entry to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> and there are no descriptors available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The referenced socket is not a type that supports connection-oriented service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and no connections are present to be accepted.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-accept
     * @since windows8.1
     */
    static accept(s, addr, addrlen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\accept", "ptr", s, "ptr", addr, "int*", addrlen, "ptr")
        if(A_LastError)
            throw OSError()

        return SOCKET({Value: result}, True)
    }

    /**
     * The bind function associates a local address with a socket.
     * @param {SOCKET} s A descriptor identifying an unbound socket.
     * @param {Pointer} name 
     * @param {Integer} namelen The length, in bytes, of the value pointed to by the <i>name</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>bind</b> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <div class="alert"><b>Note</b>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to access a socket in a way forbidden by its access permissions.
     * 
     * This error is returned if nn attempt to bind a datagram socket to the broadcast address failed because 
     * the <a href="/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> option SO_BROADCAST is not enabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRINUSE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Only one usage of each socket address (protocol/network address/port) is normally permitted.
     * 
     * This error is returned if a process on the computer is already bound to the same fully qualified address and the socket has not been marked to allow address reuse with SO_REUSEADDR. For example, the IP address and port specified in the <i>name</i> parameter are already bound to another socket being used by another application. For more information, see the SO_REUSEADDR socket option in the <a href="/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET Socket Options</a> reference,  <a href="/windows/desktop/WinSock/using-so-reuseaddr-and-so-exclusiveaddruse">Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE</a>, and <a href="/windows/desktop/WinSock/so-exclusiveaddruse">SO_EXCLUSIVEADDRUSE</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested address is not valid in its context.
     * 
     * This error is returned if the specified address pointed to by the <i>name</i> parameter is not a valid local IP address on this computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid pointer address in attempting to use a pointer argument in a call.
     * 
     * This error is returned if the <i>name</i> parameter is NULL, the <i>name</i> or <i>namelen</i> parameter is not a valid part of the user address space, the <i>namelen</i> parameter is too small, the <i>name</i> parameter contains an incorrect address format for the associated address family, or the first two bytes of the memory block specified by <i>name</i> do not match the address family associated with the socket descriptor <i>s</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.
     * 
     * This error is returned of the socket <i>s</i> is already bound to an address.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Typically, <b>WSAENOBUFS</b> is an indication that there aren't enough ephemeral ports to allocate for the bind.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation was attempted on something that is not a socket.
     * 
     * This error is returned if the descriptor in the <i>s</i> parameter is not a socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-bind
     * @since windows8.1
     */
    static bind(s, name, namelen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\bind", "ptr", s, "ptr", name, "int", namelen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The closesocket function closes an existing socket.
     * @param {SOCKET} s A descriptor identifying the socket to close.
     * @returns {Integer} If no error occurs, 
     * <b>closesocket</b> returns zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The (blocking) Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking, but the 
     *  <b>l_onoff</b> member of the <a href="/windows/desktop/api/winsock/ns-winsock-linger">linger</a> structure is set to nonzero and the <b>l_linger</b> member of the <b>linger</b> structure is set to a nonzero timeout value.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-closesocket
     * @since windows8.1
     */
    static closesocket(s) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\closesocket", "ptr", s, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The connect function establishes a connection to a specified socket.
     * @param {SOCKET} s A descriptor identifying an unconnected socket.
     * @param {Pointer} name A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure to which the connection should be established.
     * @param {Integer} namelen The length, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>name</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>connect</b> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * On a blocking socket, the return value indicates success or failure of the connection attempt.
     * 
     * 
     * With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, 
     * <b>connect</b> will return SOCKET_ERROR, and 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> will return 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a>. In this case, there are three possible scenarios:
     * 
     * <ul>
     * <li>Use the 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-select">select</a> function to determine the completion of the connection request by checking to see if the socket is writeable.</li>
     * <li>If the application is using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> to indicate interest in connection events, then the application will receive an FD_CONNECT notification indicating that the 
     * <b>connect</b> operation is complete (successfully or not).</li>
     * <li>If the application is using 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> to indicate interest in connection events, then the associated event object will be signaled indicating that the 
     * <b>connect</b> operation is complete (successfully or not).</li>
     * </ul>
     * 
     * 
     * Until the connection attempt completes on a nonblocking socket, all subsequent calls to 
     * <b>connect</b> on the same socket will fail with the error code 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a>, and 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a> when the connection completes successfully. Due to ambiguities in version 1.1 of the Windows Sockets specification, error codes returned from 
     * <b>connect</b> while a connection is already pending may vary among implementations. As a result, it is not recommended that applications use multiple calls to connect to detect connection completion. If they do, they must be prepared to handle 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a> and 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> error values the same way that they handle 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a>, to assure robust operation.
     * 
     * If the error code returned indicates the connection attempt failed (that is, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a>, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a>, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>) the application can call 
     * <b>connect</b> again for the same socket.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRINUSE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs when executing 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, but could be delayed until the <a href="/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> function if the 
     * <b>bind</b> was to a wildcard address (<b>INADDR_ANY</b> or <b>in6addr_any</b>) for the local IP address. A specific address needs to be implicitly bound by the <b>connect</b>  function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonblocking 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> call is in progress on the specified socket.
     * 
     * 
     * <div class="alert"><b>Note</b>In order to preserve backward compatibility, this error is reported as 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a> to Windows Sockets 1.1 applications that link to either Winsock.dll or Wsock32.dll.</div>
     * <div></div>
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote address is not a valid address (such as <b>INADDR_ANY</b> or <b>in6addr_any</b>) .
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Addresses in the specified family cannot be used with this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The attempt to connect was forcefully rejected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>name</i> contains incorrect address format for the associated address family  or the <i>namelen</i> parameter is too small. This error is also returned if the <b>sockaddr</b> structure pointed to by the <i>name</i> parameter with a length  specified in the <i>namelen</i> parameter is not in a valid part of the user address space. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The parameter <i>s</i> is a listening socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is already connected (connection-oriented sockets only).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEHOSTUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation was attempted to an unreachable host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <div class="alert"><b>Note</b>No buffer space is available. The socket cannot be connected.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor specified in the <i>s</i> parameter is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to connect timed out without establishing a connection.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and the connection cannot be completed immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt to connect a datagram socket to broadcast address failed because 
     * <a href="/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> option SO_BROADCAST is not enabled.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-connect
     * @since windows6.0.6000
     */
    static connect(s, name, namelen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\connect", "ptr", s, "ptr", name, "int", namelen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ioctlsocket function controls the I/O mode of a socket.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} cmd A command to perform on the socket <i>s</i>.
     * @param {Pointer<Integer>} argp A pointer to a parameter for <i>cmd</i>.
     * @returns {Integer} Upon successful completion, the 
     * <b>ioctlsocket</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor <i>s</i> is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>argp</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-ioctlsocket
     * @since windows8.1
     */
    static ioctlsocket(s, cmd, argp) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\ioctlsocket", "ptr", s, "int", cmd, "uint*", argp, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getpeername function retrieves the address of the peer to which a socket is connected.
     * @param {SOCKET} s A descriptor identifying a connected socket.
     * @param {Pointer} name The 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR</a> structure that receives the address of the peer.
     * @param {Pointer<Integer>} namelen A pointer to the size, in bytes, of the <i>name</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>getpeername</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or the <i>namelen</i> parameter is not in a valid part of the user address space, or the <i>namelen</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getpeername
     * @since windows8.1
     */
    static getpeername(s, name, namelen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\getpeername", "ptr", s, "ptr", name, "int*", namelen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getsockname function retrieves the local name for a socket.
     * @param {SOCKET} s Descriptor identifying a socket.
     * @param {Pointer} name Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR</a> structure that receives the address (name) of the socket.
     * @param {Pointer<Integer>} namelen Size of the <i>name</i> buffer, in bytes.
     * @returns {Integer} If no error occurs, 
     * <b>getsockname</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this API.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or the <i>namelen</i> parameter is not a valid part of the user address space, or the <i>namelen</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound to an address with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, or ADDR_ANY is specified in 
     * <b>bind</b> but connection has not yet occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getsockname
     * @since windows8.1
     */
    static getsockname(s, name, namelen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\getsockname", "ptr", s, "ptr", name, "int*", namelen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getsockopt function retrieves a socket option.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} level The level at which the option is defined. Example:  <a href="https://docs.microsoft.com/windows/desktop/WinSock/sol-socket-socket-options">SOL_SOCKET</a>.
     * @param {Integer} optname The socket option for which the value is to be retrieved. Example: <a href="https://docs.microsoft.com/windows/desktop/WinSock/socket-options-and-ioctls-2">SO_ACCEPTCONN</a>. The <i>optname</i> value must be a socket option defined within the specified <i>level</i>, or behavior is undefined.
     * @param {Pointer} optval A pointer to the buffer in which the value for the requested option is to be returned.
     * @param {Pointer<Integer>} optlen A pointer to the size, in bytes, of the <i>optval</i> buffer.
     * @returns {Integer} If no error occurs, 
     * <b>getsockopt</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <div class="alert"><b>Note</b>The network subsystem has failed.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the <i>optval</i> or the <i>optlen</i> parameters is not a valid part of the user address space, or the <i>optlen</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>level</i> parameter is unknown or invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOPROTOOPT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The option is unknown or unsupported by the indicated protocol family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getsockopt
     * @since windows8.1
     */
    static getsockopt(s, level, optname, optval, optlen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\getsockopt", "ptr", s, "int", level, "int", optname, "ptr", optval, "int*", optlen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The htonl function converts a u_long from host to TCP/IP network byte order (which is big-endian).
     * @param {Integer} hostlong A 32-bit number in host byte order.
     * @returns {Integer} The 
     * <b>htonl</b> function returns the value in TCP/IP's network byte order.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-htonl
     * @since windows8.1
     */
    static htonl(hostlong) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\htonl", "uint", hostlong, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The htons function converts a u_short from host to TCP/IP network byte order (which is big-endian).
     * @param {Integer} hostshort A 16-bit number in host byte order.
     * @returns {Integer} The 
     * <b>htons</b> function returns the value in TCP/IP network byte order.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-htons
     * @since windows8.1
     */
    static htons(hostshort) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\htons", "ushort", hostshort, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The inet_addr function converts a string containing an IPv4 dotted-decimal address into a proper address for the IN_ADDR structure.
     * @param {PSTR} cp TBD
     * @returns {Integer} If no error occurs, 
     * the <b>inet_addr</b> function returns an unsigned long value containing a suitable binary representation of the Internet address given. 
     * 
     * If the string in the <i>cp</i> parameter does not contain a legitimate Internet address, for example if a portion of an "a.b.c.d" address exceeds 255, then 
     * <b>inet_addr</b> returns the value <b>INADDR_NONE</b>.
     * 
     * On Windows Server2003and later if the string in the <i>cp</i> parameter is an empty string, then 
     * <b>inet_addr</b> returns the value <b>INADDR_NONE</b>.  If <b>NULL</b> is passed in the <i>cp</i> parameter, then 
     * <b>inet_addr</b> returns the value <b>INADDR_NONE</b>.
     * 
     * On WindowsXPand earlier if the string in the <i>cp</i> parameter is an empty string, then 
     * <b>inet_addr</b> returns the value <b>INADDR_ANY</b>. If <b>NULL</b> is passed in the <i>cp</i> parameter, then 
     * <b>inet_addr</b> returns the value <b>INADDR_NONE</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-inet_addr
     * @deprecated
     * @since windows8.1
     */
    static inet_addr(cp) {
        cp := cp is String ? StrPtr(cp) : cp

        A_LastError := 0

        result := DllCall("WS2_32.dll\inet_addr", "ptr", cp, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The inet_ntoa function converts an (Ipv4) Internet network address into an ASCII string in Internet standard dotted-decimal format.
     * @param {IN_ADDR} in_R 
     * @returns {PSTR} If no error occurs, 
     * <b>inet_ntoa</b> returns a character pointer to a static buffer containing the text address in standard ".'' notation. Otherwise, it returns <b>NULL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-inet_ntoa
     * @deprecated
     * @since windows8.1
     */
    static inet_ntoa(in_R) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\inet_ntoa", "ptr", in_R, "char*")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The listen function places a socket in a state in which it is listening for an incoming connection.
     * @param {SOCKET} s A descriptor identifying a bound, unconnected socket.
     * @param {Integer} backlog The maximum length of the queue of pending connections. If set to <b>SOMAXCONN</b>, the underlying service provider responsible for socket <i>s</i> will set the backlog to a maximum reasonable value. If set to <b>SOMAXCONN_HINT(N)</b> (where N is a number), the backlog value will be N, adjusted to be within the range (200, 65535). Note that <b>SOMAXCONN_HINT</b> can be used to set the backlog to a larger value than possible with SOMAXCONN.
     * 
     * <b>SOMAXCONN_HINT</b> is only supported by the Microsoft TCP/IP service provider. There is no standard provision to obtain the actual backlog value.
     * @returns {Integer} If no error occurs, 
     * <b>listen</b> returns zero. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRINUSE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs during execution of the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function, but could be delayed until this function if the 
     * <b>bind</b> was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is already connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The referenced socket is not of a type that supports the 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-listen
     * @since windows8.1
     */
    static listen(s, backlog) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\listen", "ptr", s, "int", backlog, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ntohl function converts a u_long from TCP/IP network order to host byte order (which is little-endian on Intel processors).
     * @param {Integer} netlong A 32-bit number in TCP/IP network byte order.
     * @returns {Integer} The 
     * <b>ntohl</b> function returns the value supplied in the <i>netlong</i> parameter with the byte order reversed. If  <i>netlong</i> is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-ntohl
     * @since windows8.1
     */
    static ntohl(netlong) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\ntohl", "uint", netlong, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The ntohs function converts a u_short from TCP/IP network byte order to host byte order (which is little-endian on Intel processors).
     * @param {Integer} netshort A 16-bit number in TCP/IP network byte order.
     * @returns {Integer} The 
     * <b>ntohs</b> function returns the value in host byte order. If the <i>netshort</i> parameter is already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must be reversed.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-ntohs
     * @since windows8.1
     */
    static ntohs(netshort) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\ntohs", "ushort", netshort, "ushort")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Receives data from a connected socket or a bound connectionless socket.
     * @param {SOCKET} s The descriptor that identifies a connected socket.
     * @param {Pointer} buf A pointer to the buffer to receive the incoming data.
     * @param {Integer} len The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags A set of flags that influences the behavior of this function. See remarks below. See the Remarks section for details on the possible value for this parameter.
     * @returns {Integer} If no error occurs, 
     * <b>recv</b> returns the number of bytes received and the buffer pointed to by the <i>buf</i> parameter will contain this data received. If the connection has been gracefully closed, the return value is zero.
     * 
     *  Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> parameter is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The (blocking) call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a connection-oriented socket, this error indicates that the connection has been broken due to <i>keep-alive</i> activity that detected a failure while the operation was in progress. For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only send operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to receive on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <b>how</b> set to SD_RECEIVE or SD_BOTH.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and the receive operation would block.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was too large to fit into the specified buffer and was truncated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled or (for byte stream sockets only) <i>len</i> was zero or negative.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been dropped because of a network failure or because the peer system failed to respond.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as it is no longer usable. On a UDP-datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-recv
     * @since windows8.1
     */
    static recv(s, buf, len, flags) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\recv", "ptr", s, "ptr", buf, "int", len, "int", flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The recvfrom function receives a datagram and stores the source address.
     * @param {SOCKET} s A descriptor identifying a bound socket.
     * @param {Pointer} buf A buffer for the incoming data.
     * @param {Integer} len The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags A set of options that modify the behavior of the function call beyond the options specified for the associated socket. See the Remarks below for more details.
     * @param {Pointer} from An optional pointer to a buffer in a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that will hold the source address upon return.
     * @param {Pointer<Integer>} fromlen An optional pointer to the size, in bytes, of the buffer pointed to by the <i>from</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>recvfrom</b> returns the number of bytes received. If the connection has been gracefully closed, the return value is zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by the <i>buf</i> or <i>from</i> parameters are not in the  user address space, or the <i>fromlen</i> parameter is too small to accommodate the source address of the peer address.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The (blocking) call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled, or (for byte stream-style sockets only) <i>len</i> was zero or negative.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is connected. This function is not permitted with a connected socket, whether the socket is connection oriented or connectionless.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor in the <i>s</i> parameter is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only send operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a> on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <i>how</i> set to SD_RECEIVE or SD_BOTH.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a> operation would block.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was too large to fit into the buffer pointed to by the <i>buf</i> parameter and was truncated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been dropped, because of a network failure or because the system on the other end went down without notice.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket;  it is no longer usable. On a UDP-datagram socket this error indicates  a previous send operation resulted in an ICMP <i>Port Unreachable</i> message.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-recvfrom
     * @since windows8.1
     */
    static recvfrom(s, buf, len, flags, from, fromlen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\recvfrom", "ptr", s, "ptr", buf, "int", len, "int", flags, "ptr", from, "int*", fromlen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The select function determines the status of one or more sockets, waiting if necessary, to perform synchronous I/O.
     * @param {Integer} nfds Ignored. The <i>nfds</i> parameter is included only for compatibility with Berkeley sockets.
     * @param {Pointer<FD_SET>} readfds An optional pointer to a set of sockets to be checked for readability.
     * @param {Pointer<FD_SET>} writefds An optional pointer to a set of sockets to be checked for writability.
     * @param {Pointer<FD_SET>} exceptfds An optional pointer to a set of sockets to be checked for errors.
     * @param {Pointer<TIMEVAL>} timeout The maximum time for 
     * <b>select</b> to wait, provided in the form of a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-timeval">TIMEVAL</a> structure. Set the <i>timeout</i> parameter to <b>null</b> for blocking operations.
     * @returns {Integer} The 
     * <b>select</b> function returns the total number of socket handles that are ready and contained in the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-fd_set">fd_set</a> structures, zero if the time limit expired, or SOCKET_ERROR if an error occurred. If the return value is SOCKET_ERROR, 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can be used to retrieve a specific error code.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Sockets implementation was unable to allocate needed resources for its internal operations, or the <i>readfds</i>, <i>writefds</i>, <i>exceptfds</i>, or <i>timeval</i> parameters are not part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>time-out</i> value is not valid, or all three descriptor parameters were <b>null</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the descriptor sets contains an entry that is not a socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-select
     * @since windows8.1
     */
    static select(nfds, readfds, writefds, exceptfds, timeout) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\select", "int", nfds, "ptr", readfds, "ptr", writefds, "ptr", exceptfds, "ptr", timeout, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends data on a connected socket.
     * @param {SOCKET} s A descriptor identifying a connected socket.
     * @param {Pointer} buf A pointer to a buffer containing the data to be transmitted.
     * @param {Integer} len The length, in bytes, of the data in buffer pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags 
     * @returns {Integer} If no error occurs, 
     * <b>send</b> returns the total number of bytes sent, which can be less than the number requested to be sent in the <i>len</i> parameter. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested address is a broadcast address, but the appropriate flag was not set. Call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> with the SO_BROADCAST socket option to enable use of the broadcast address.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> parameter is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been broken due to the keep-alive activity detecting a failure while the operation was in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only receive operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to send on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <i>how</i> set to SD_SEND or SD_BOTH.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and the requested operation would block.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEHOSTUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote host cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was reset by the remote side executing a hard or abortive close. For UDP sockets, the remote host was unable to deliver a previously sent UDP datagram and responded with a "Port Unreachable" ICMP packet. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been dropped, because of a network failure or because the system on the other end went down without notice.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-send
     * @since windows8.1
     */
    static send(s, buf, len, flags) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\send", "ptr", s, "ptr", buf, "int", len, "int", flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The sendto function sends data to a specific destination.
     * @param {SOCKET} s A descriptor identifying a (possibly connected) socket.
     * @param {Pointer} buf A pointer to a buffer containing the data to be transmitted.
     * @param {Integer} len The length, in bytes, of the data pointed to by the <i>buf</i> parameter.
     * @param {Integer} flags A set of flags that specify the way in which the call is made.
     * @param {Pointer} to An optional pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that contains the address of the target socket.
     * @param {Integer} tolen The size, in bytes, of the address pointed to by the <i>to</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>sendto</b> returns the total number of bytes sent, which can be less than the number indicated by <i>len</i>. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested address is a broadcast address, but the appropriate flag was not set. Call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> with the SO_BROADCAST parameter to allow the use of the broadcast address.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> or <i>to</i> parameters are not part of the user address space, or the <i>tolen</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected (connection-oriented sockets only).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only receive operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to sendto on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <i>how</i> set to SD_SEND or SD_BOTH.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and the requested operation would block.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEHOSTUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote host cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was reset by the remote side executing a hard or abortive close. For UPD sockets, the remote host was unable to deliver a previously sent UDP datagram and responded with a "Port Unreachable" ICMP packet. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote address is not a valid address, for example, ADDR_ANY.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Addresses in the specified family cannot be used with this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEDESTADDRREQ</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A destination address is required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEHOSTUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation was attempted to an unreachable host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been dropped, because of a network failure or because the system on the other end went down without notice.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-sendto
     * @since windows8.1
     */
    static sendto(s, buf, len, flags, to, tolen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\sendto", "ptr", s, "ptr", buf, "int", len, "int", flags, "ptr", to, "int", tolen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sets a socket option.
     * @param {SOCKET} s A descriptor that identifies a socket.
     * @param {Integer} level The level at which the option is defined (for example, SOL_SOCKET).
     * @param {Integer} optname The socket option for which the value is to be set (for example, SO_BROADCAST). The <i>optname</i> parameter must be a socket option defined within the specified <i>level</i>, or behavior is undefined.
     * @param {Pointer} optval A pointer to the buffer in which the value for the requested option is specified.
     * @param {Integer} optlen The size, in bytes, of the buffer pointed to by the <i>optval</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>setsockopt</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by the <i>optval</i> parameter is not in a valid part of the process address space or the  <i>optlen</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>level</i> parameter is not valid, or the information in the buffer pointed to by the <i>optval</i> parameter is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has timed out when <a href="/windows/desktop/WinSock/so-keepalive">SO_KEEPALIVE</a> is set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOPROTOOPT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The option is unknown or unsupported for the specified provider or socket (see SO_GROUP_PRIORITY limitations).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been reset when <a href="/windows/desktop/WinSock/so-keepalive">SO_KEEPALIVE</a> is set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-setsockopt
     * @since windows8.1
     */
    static setsockopt(s, level, optname, optval, optlen) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\setsockopt", "ptr", s, "int", level, "int", optname, "ptr", optval, "int", optlen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The shutdown function disables sends or receives on a socket.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} how A flag that describes what types of operation will no longer be allowed. Possible values for this flag are listed in the <i>Winsock2.h</i> header file.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SD_RECEIVE"></a><a id="sd_receive"></a><dl>
     * <dt><b>SD_RECEIVE</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Shutdown receive operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SD_SEND"></a><a id="sd_send"></a><dl>
     * <dt><b>SD_SEND</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Shutdown send operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SD_BOTH"></a><a id="sd_both"></a><dl>
     * <dt><b>SD_BOTH</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Shutdown both send and receive operations.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If no error occurs, 
     * <b>shutdown</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.
     * 
     *  This error applies only to a connection-oriented socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as it is no longer usable. 
     * 
     * This error applies only to a connection-oriented socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>how</i> parameter is not valid, or is not consistent with the socket type. For example, SD_SEND is used with a UNI_RECV socket type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.  This error applies only to a connection-oriented socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <div class="alert"><b>Note</b>The descriptor is not a socket.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-shutdown
     * @since windows8.1
     */
    static shutdown(s, how) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\shutdown", "ptr", s, "int", how, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The socket function creates a socket that is bound to a specific transport service provider.
     * @param {Integer} af The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i> header file. 
     * 
     * On the Windows SDK released for WindowsVista and later, the organization of header files has changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * The values currently supported are AF_INET or AF_INET6, which are the Internet
     *                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The table below lists common values for address family although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>Af</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl>
     * <dt><b>AF_UNSPEC</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family is unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl>
     * <dt><b>AF_IPX</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. 
     * 
     * This address family is not supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
     * <dt><b>AF_APPLETALK</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. 
     * 
     * This address family is not supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
     * <dt><b>AF_NETBIOS</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. 
     * 
     * The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows. 
     * 
     * The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows7,  Windows Server2008, WindowsVista, Windows Server2003, or WindowsXP.  
     * 
     * The Windows Sockets provider for NetBIOS  only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>.
     * 
     * The Windows Sockets provider for NetBIOS  is not directly related to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/netbios/portal">NetBIOS</a> programming interface. The NetBIOS programming interface is not supported on WindowsVista, Windows Server2008, and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
     * <dt><b>AF_IRDA</b></dt>
     * <dt>26</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Infrared Data Association (IrDA) address family. 
     * 
     * This address family is only supported if the computer has an infrared port and driver installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
     * <dt><b>AF_BTH</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth address family. 
     * 
     * This address family is supported on WindowsXP with SP2 or later if the computer has a Bluetooth adapter and driver installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} type The type specification for the new socket. 
     * 
     * 
     * Possible values for the socket type are defined in the <i>Winsock2.h</i> header file.
     * 
     * The following table lists the possible values for the <i>type</i> parameter supported for Windows Sockets 2:
     * 
     * <table>
     * <tr>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
     * <dt><b>SOCK_STREAM</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl>
     * <dt><b>SOCK_DGRAM</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
     * <dt><b>SOCK_RAW</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ip-socket-options">IP_HDRINCL</a> socket option must be set on the socket.  To manipulate the IPv6 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPV6_HDRINCL</a> socket option must be set on the socket.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
     * <dt><b>SOCK_RDM</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as <a href="https://docs.microsoft.com/windows/desktop/WinSock/reliable-multicast-programming--pgm-">reliable multicast programming</a>. 
     * 
     * This <i>type</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
     * <dt><b>SOCK_SEQPACKET</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a pseudo-stream packet based on datagrams. 
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address families, and protocols are defined.
     * 
     * In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b> and <b>SOCK_STREAM</b>.
     * @param {Integer} protocol The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address family and socket type specified. Possible values for the <i>protocol</i> are defined in the  <i>Winsock2.h</i> and <i>Wsrm.h</i> header files.
     * 
     * On the Windows SDK released for WindowsVista and later, the organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * If a value of  0 is specified, the caller does not
     *               wish to specify a protocol and the service provider will choose the <i>protocol</i> to use.
     * 
     * 
     * When the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. 
     * 
     * The table below lists common values for the <i>protocol</i> although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>protocol</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
     * <dt><b>IPPROTO_ICMP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl>
     * <dt><b>IPPROTO_IGMP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
     * <dt><b>BTHPROTO_RFCOMM</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. 
     * 
     * This <i>protocol</i> value is supported on WindowsXP with SP2 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl>
     * <dt><b>IPPROTO_ICMPV6</b></dt>
     * <dt>58</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b>  and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl>
     * <dt><b>IPPROTO_RM</b></dt>
     * <dt>113</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PGM protocol for reliable multicast. This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK released for WindowsVista and later,  this protocol is also called <b>IPPROTO_PGM</b>. 
     * 
     * This <i>protocol</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {SOCKET} If no error occurs, 
     * <b>socket</b> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem or the associated service provider has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported. For example, an application tried to create a socket for the <b>AF_IRDA</b> address family but an infrared adapter and device driver is not installed on the local computer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.  This error is returned if the <i>af</i> parameter is set to <b>AF_UNSPEC</b> and the <i>type</i> and <i>protocol</i> parameter are unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned a version other than 2.2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROCTABLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned an invalid or incomplete procedure table to the 
     * <a href="/windows/desktop/api/ws2spi/nf-ws2spi-wspstartup">WSPStartup</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTOTYPE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is the wrong type for this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROVIDERFAILEDINIT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the provider fails to operate correctly. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified socket type is not supported in this address family.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-socket
     * @since windows8.1
     */
    static socket(af, type, protocol) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\socket", "int", af, "int", type, "int", protocol, "ptr")
        if(A_LastError)
            throw OSError()

        return SOCKET({Value: result}, True)
    }

    /**
     * gethostbyaddr is no longer recommended for use as of Windows Sockets 2.
     * @param {Pointer} addr TBD
     * @param {Integer} len TBD
     * @param {Integer} type TBD
     * @returns {Pointer<HOSTENT>} If no error occurs, 
     * <b>gethostbyaddr</b> returns a pointer to the 
     * <a href="/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure. Otherwise, it returns a null pointer, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied. This error is returned if <b>AF_INET6</b> was specified in the  <i>type</i> parameter and the <i>len</i> parameter was not set equal to the size of an IPv6 address.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer host not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative host not found, or server failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>type</i> specified is not supported by the Windows Sockets implementation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>addr</i> parameter is not a valid part of the user address space, or the <i>len</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-gethostbyaddr
     * @deprecated
     * @since windows8.1
     */
    static gethostbyaddr(addr, len, type) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\gethostbyaddr", "ptr", addr, "int", len, "int", type, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The gethostbyname function retrieves host information corresponding to a host name from a host database.
     * @param {PSTR} name TBD
     * @returns {Pointer<HOSTENT>} If no error occurs, 
     * <b>gethostbyname</b> returns a pointer to the 
     * <a href="/windows/desktop/api/winsock/ns-winsock-hostent">hostent</a> structure described above. Otherwise, it returns a <b>null</b> pointer and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer host not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative host not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found. This error is also returned if the <i>name</i> parameter contains a string representation of an IPv6 address or an illegal IPv4 address. 
     * 
     * This error should not be interpreted to mean that the <i>name</i> parameter contains a name string that has been validated for a particular protocol (an IP hostname, for example). Since Winsock supports multiple name service providers, a name may potentially be valid for one provider and not accepted by another provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-gethostbyname
     * @deprecated
     * @since windows8.1
     */
    static gethostbyname(name) {
        name := name is String ? StrPtr(name) : name

        A_LastError := 0

        result := DllCall("WS2_32.dll\gethostbyname", "ptr", name, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The gethostname function retrieves the standard host name for the local computer.
     * @param {Pointer} name A pointer to a buffer that receives the local host name.
     * @param {Integer} namelen The length, in bytes, of the buffer pointed to by the <i>name</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>gethostname</b> returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> parameter is a <b>NULL</b> pointer or is not a valid part of the user address space. This error is also returned if the buffer size specified by <i>namelen</i> parameter is too small to hold the complete host name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-gethostname
     * @since windows8.1
     */
    static gethostname(name, namelen) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\gethostname", "ptr", name, "int", namelen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetHostNameW function retrieves the standard host name for the local computer as a Unicode string.
     * @param {PWSTR} name A pointer to a buffer that receives the local host name as a <b>null</b>-terminated Unicode string.
     * @param {Integer} namelen The length, in wide characters, of the buffer pointed to by the <i>name</i> parameter.
     * @returns {Integer} If no error occurs, 
     * <b>GetHostNameW</b> returns zero. Otherwise, it returns <b>SOCKET_ERROR</b> and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> parameter is a <b>NULL</b> pointer or is not a valid part of the user address space. This error is also returned if the buffer size specified by <i>namelen</i> parameter is too small to hold the complete host name.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-gethostnamew
     * @since windows8.1
     */
    static GetHostNameW(name, namelen) {
        name := name is String ? StrPtr(name) : name

        A_LastError := 0

        result := DllCall("WS2_32.dll\GetHostNameW", "ptr", name, "int", namelen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getservbyport function retrieves service information corresponding to a port and protocol.
     * @param {Integer} port Port for a service, in network byte order.
     * @param {PSTR} proto Optional pointer to a protocol name. If this is null, 
     * <b>getservbyport</b> returns the first service entry for which the <i>port</i> matches the <b>s_port</b> of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. Otherwise, 
     * <b>getservbyport</b> matches both the <i>port</i> and the <i>proto</i> parameters.
     * @returns {Pointer<SERVENT>} If no error occurs, 
     * <b>getservbyport</b> returns a pointer to the 
     * <a href="/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative Answer Service not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative Service not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>proto</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getservbyport
     * @since windows8.1
     */
    static getservbyport(port, proto) {
        proto := proto is String ? StrPtr(proto) : proto

        A_LastError := 0

        result := DllCall("WS2_32.dll\getservbyport", "int", port, "ptr", proto, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getservbyname function retrieves service information corresponding to a service name and protocol.
     * @param {PSTR} name A pointer to a <b>null</b>-terminated service name.
     * @param {PSTR} proto A pointer to a <b>null</b>-terminated protocol name. If this pointer is <b>NULL</b>, 
     * the <b>getservbyname</b> function returns the first service entry where <i>name</i> matches the <b>s_name</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure or the <b>s_aliases</b> member of the 
     * <b>servent</b> structure. Otherwise, 
     * <b>getservbyname</b> matches both the <i>name</i> and the <i>proto</i>.
     * @returns {Pointer<SERVENT>} If no error occurs, 
     * <b>getservbyname</b> returns a pointer to the 
     * <a href="/windows/desktop/api/winsock/ns-winsock-servent">servent</a> structure. Otherwise, it returns a <b>null</b> pointer and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative Answer Service not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative Service not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getservbyname
     * @since windows8.1
     */
    static getservbyname(name, proto) {
        name := name is String ? StrPtr(name) : name
        proto := proto is String ? StrPtr(proto) : proto

        A_LastError := 0

        result := DllCall("WS2_32.dll\getservbyname", "ptr", name, "ptr", proto, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getprotobynumber function retrieves protocol information corresponding to a protocol number.
     * @param {Integer} number 
     * @returns {Pointer<PROTOENT>} If no error occurs, 
     * <b>getprotobynumber</b> returns a pointer to the 
     * <a href="/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> structure. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative Protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getprotobynumber
     * @since windows8.1
     */
    static getprotobynumber(number) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\getprotobynumber", "int", number, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The getprotobyname function retrieves the protocol information corresponding to a protocol name.
     * @param {PSTR} name Pointer to a null-terminated protocol name.
     * @returns {Pointer<PROTOENT>} If no error occurs, 
     * <b>getprotobyname</b> returns a pointer to the 
     * <a href="/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a>. Otherwise, it returns a null pointer and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getprotobyname
     * @since windows8.1
     */
    static getprotobyname(name) {
        name := name is String ? StrPtr(name) : name

        A_LastError := 0

        result := DllCall("WS2_32.dll\getprotobyname", "ptr", name, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Initiates use of the Winsock DLL by a process.
     * @param {Integer} wVersionRequested 
     * @param {Pointer<WSADATA>} lpWSAData A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-wsadata">WSADATA</a> data structure that is to receive details of the Windows Sockets implementation.
     * @returns {Integer} If successful, the 
     * <b>WSAStartup</b> function returns zero. Otherwise, it returns one of the error codes listed below. 
     * 
     * The <b>WSAStartup</b> function directly returns the extended error code in the return value for this function. A call to the <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function is not needed and should  not be used.
     * 					
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSNOTREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The underlying network subsystem is not ready for network communication.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAVERNOTSUPPORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 operation is in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROCLIM</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A limit on the number of tasks supported by the Windows Sockets implementation has been reached.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpWSAData</i> parameter is not a valid pointer.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsastartup
     * @since windows8.1
     */
    static WSAStartup(wVersionRequested, lpWSAData) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAStartup", "ushort", wVersionRequested, "ptr", lpWSAData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSACleanup function terminates use of the WS2_32.dll.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * In a multithreaded environment, 
     * <b>WSACleanup</b> terminates Windows Sockets operations for all threads.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsacleanup
     * @since windows8.1
     */
    static WSACleanup() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSACleanup", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASetLastError function sets the error code that can be retrieved through the WSAGetLastError function.
     * @param {Integer} iError Integer that specifies the error code to be returned by a subsequent 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> call.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsasetlasterror
     * @since windows8.1
     */
    static WSASetLastError(iError) {
        A_LastError := 0

        DllCall("WS2_32.dll\WSASetLastError", "int", iError)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Returns the error status for the last Windows Sockets operation that failed.
     * @returns {Integer} The return value indicates the error code for this thread's last Windows Sockets operation that failed.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsagetlasterror
     * @since windows8.1
     */
    static WSAGetLastError() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetLastError", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
     * @returns {BOOL} 
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaisblocking
     * @deprecated
     */
    static WSAIsBlocking() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAIsBlocking", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
     * @returns {Integer} 
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaunhookblockinghook
     * @deprecated
     */
    static WSAUnhookBlockingHook() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAUnhookBlockingHook", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * This function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
     * @param {Pointer<FARPROC>} lpBlockFunc 
     * @returns {Pointer<FARPROC>} 
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasetblockinghook
     * @deprecated
     */
    static WSASetBlockingHook(lpBlockFunc) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASetBlockingHook", "ptr", lpBlockFunc, "ptr")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSACancelBlockingCall function has been removed in compliance with the Windows Sockets 2 specification, revision 2.2.0.
     * @returns {Integer} 
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsacancelblockingcall
     * @deprecated
     */
    static WSACancelBlockingCall() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSACancelBlockingCall", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAAsyncGetServByName function asynchronously retrieves service information that corresponds to a service name and port.
     * @param {HWND} hWnd Handle of the window that should receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {PSTR} name Pointer to a <b>null</b>-terminated service name.
     * @param {PSTR} proto Pointer to a protocol name. This can be <b>NULL</b>, in which case 
     * <b>WSAAsyncGetServByName</b> will search for the first service entry for which <i>s_name</i> or one of the <i>s_aliases</i> matches the given <i>name</i>. Otherwise, 
     * <b>WSAAsyncGetServByName</b> matches both <i>name</i> and <i>proto</i>.
     * @param {Pointer} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> data. The data area must be larger than the size of a 
     * <b>servent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>servent</b> structure and all of the data that is referenced by members of the 
     * <b>servent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {HANDLE} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetServByName</b> returns a nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, <b>WSAAsyncServByName</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer host not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative service not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsaasyncgetservbyname
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetServByName(hWnd, wMsg, name, proto, buf, buflen) {
        name := name is String ? StrPtr(name) : name
        proto := proto is String ? StrPtr(proto) : proto
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetServByName", "ptr", hWnd, "uint", wMsg, "ptr", name, "ptr", proto, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * The WSAAsyncGetServByPort function asynchronously retrieves service information that corresponds to a port and protocol.
     * @param {HWND} hWnd Handle of the window that should receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {Integer} port Port for the service, in network byte order.
     * @param {PSTR} proto Pointer to a protocol name. This can be <b>NULL</b>, in which case 
     * <b>WSAAsyncGetServByPort</b> will search for the first service entry for which <i>s_port</i> match the given <i>port</i>. Otherwise, 
     * <b>WSAAsyncGetServByPort</b> matches both <i>port</i> and <i>proto</i>.
     * @param {Pointer} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-servent">servent</a> data. The data area must be larger than the size of a 
     * <b>servent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>servent</b> structure and all of the data that is referenced by members of the 
     * <b>servent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {HANDLE} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetServByPort</b> returns a nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetServByPort</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>proto</i> or <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer port not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative port not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the services database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsaasyncgetservbyport
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetServByPort(hWnd, wMsg, port, proto, buf, buflen) {
        proto := proto is String ? StrPtr(proto) : proto
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetServByPort", "ptr", hWnd, "uint", wMsg, "int", port, "ptr", proto, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * The WSAAsyncGetProtoByName function asynchronously retrieves protocol information that corresponds to a protocol name.
     * @param {HWND} hWnd Handle of the window that will receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {PSTR} name Pointer to the null-terminated protocol name to be resolved.
     * @param {Pointer} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> data. The data area must be larger than the size of a 
     * <b>protoent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>protoent</b> structure and all of the data that is referenced by members of the 
     * <b>protoent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {HANDLE} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetProtoByName</b> returns a nonzero value of type HANDLE that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetProtoByName</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsaasyncgetprotobyname
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetProtoByName(hWnd, wMsg, name, buf, buflen) {
        name := name is String ? StrPtr(name) : name
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetProtoByName", "ptr", hWnd, "uint", wMsg, "ptr", name, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * The WSAAsyncGetProtoByNumber function asynchronously retrieves protocol information that corresponds to a protocol number.
     * @param {HWND} hWnd Handle of the window that will receive a message when the asynchronous request completes.
     * @param {Integer} wMsg Message to be received when the asynchronous request completes.
     * @param {Integer} number Protocol number to be resolved, in host byte order.
     * @param {Pointer} buf Pointer to the data area to receive the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/ns-winsock-protoent">protoent</a> data. The data area must be larger than the size of a 
     * <b>protoent</b> structure because the data area is used by Windows Sockets to contain a 
     * <b>protoent</b> structure and all of the data that is referenced by members of the 
     * <b>protoent</b> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
     * @param {Integer} buflen Size of data area for the <i>buf</i> parameter, in bytes.
     * @returns {HANDLE} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetProtoByNumber</b> returns a nonzero value of type <b>HANDLE</b> that is the asynchronous task handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages, by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetProtoByNumber</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer protocol not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative protocol not found, or server failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors, the protocols database is not accessible.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsaasyncgetprotobynumber
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetProtoByNumber(hWnd, wMsg, number, buf, buflen) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetProtoByNumber", "ptr", hWnd, "uint", wMsg, "int", number, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * The WSAAsyncGetHostByName function asynchronously retrieves host information that corresponds to a host name.NoteThe WSAAsyncGetHostByName function is not designed to provide parallel resolution of several names.
     * @param {HWND} hWnd TBD
     * @param {Integer} wMsg TBD
     * @param {PSTR} name TBD
     * @param {Pointer} buf TBD
     * @param {Integer} buflen TBD
     * @returns {HANDLE} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetHostByName</b> returns a nonzero value of type HANDLE that is the asynchronous task handle (not to be confused with a Windows HTASK) for the request. This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetHostByName</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the WSAGETASYNCERROR macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer host not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonauthoritative host not found, or SERVERFAIL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors: FORMERR, REFUSED, NOTIMP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsaasyncgethostbyname
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetHostByName(hWnd, wMsg, name, buf, buflen) {
        name := name is String ? StrPtr(name) : name
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetHostByName", "ptr", hWnd, "uint", wMsg, "ptr", name, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * The WSAAsyncGetHostByAddr function asynchronously retrieves host information that corresponds to an address.NoteThe WSAAsyncGetHostByAddr function is not designed to provide parallel resolution of several addresses.
     * @param {HWND} hWnd TBD
     * @param {Integer} wMsg TBD
     * @param {Pointer} addr TBD
     * @param {Integer} len TBD
     * @param {Integer} type TBD
     * @param {Pointer} buf TBD
     * @param {Integer} buflen TBD
     * @returns {HANDLE} The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or failure of the operation itself.
     * 
     * If no error occurs, 
     * <b>WSAAsyncGetHostByAddr</b> returns a nonzero value of type HANDLE that is the asynchronous task handle (not to be confused with a Windows HTASK) for the request. This value can be used in two ways. It can be used to cancel the operation using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsacancelasyncrequest">WSACancelAsyncRequest</a>, or it can be used to match up asynchronous operations and completion messages by examining the <i>wParam</i> message parameter.
     * 
     * If the asynchronous operation could not be initiated, 
     * <b>WSAAsyncGetHostByAddr</b> returns a zero value, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The following error codes can be set when an application window receives a message. As described above, they can be extracted from the <i>lParam</i> in the reply message using the <b>WSAGETASYNCERROR</b> macro.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>addr</i> or <i>buf</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Authoritative answer host not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonauthoritative host not found, or SERVERFAIL.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Nonrecoverable errors: FORMERR, REFUSED, NOTIMP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Valid name, no data record of requested type.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * <div></div>
     * 
     * 
     * The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
     * 
     * <table>
     * <tr>
     * <th>Error Code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></td>
     * <td>The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsaasyncgethostbyaddr
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncGetHostByAddr(hWnd, wMsg, addr, len, type, buf, buflen) {
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncGetHostByAddr", "ptr", hWnd, "uint", wMsg, "ptr", addr, "int", len, "int", type, "ptr", buf, "int", buflen, "ptr")
        if(A_LastError)
            throw OSError()

        return HANDLE({Value: result}, True)
    }

    /**
     * The WSACancelAsyncRequest function cancels an incomplete asynchronous operation.
     * @param {HANDLE} hAsyncTaskHandle Handle that specifies the asynchronous operation to be canceled.
     * @returns {Integer} The value returned by 
     * <b>WSACancelAsyncRequest</b> is zero if the operation was successfully canceled. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that the specified asynchronous task handle was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The asynchronous routine being canceled has already completed.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>It is unclear whether the application can usefully distinguish between 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a> and 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a>, since in both cases the error indicates that there is no asynchronous operation in progress with the indicated handle. (Trivial exception: zero is always an invalid asynchronous task handle.) The Windows Sockets specification does not prescribe how a conformant Windows Sockets provider should distinguish between the two cases. For maximum portability, a Windows Sockets application should treat the two errors as equivalent.</div>
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsacancelasyncrequest
     * @deprecated
     * @since windows5.0
     */
    static WSACancelAsyncRequest(hAsyncTaskHandle) {
        hAsyncTaskHandle := hAsyncTaskHandle is Win32Handle ? NumGet(hAsyncTaskHandle, "ptr") : hAsyncTaskHandle

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSACancelAsyncRequest", "ptr", hAsyncTaskHandle, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Requests Windows message-based notification of network events for a socket.
     * @param {SOCKET} s A descriptor that identifies the socket for which event notification is required.
     * @param {HWND} hWnd A handle that identifies the window that will receive a message when a network event occurs.
     * @param {Integer} wMsg A message to be received when a network event occurs.
     * @param {Integer} lEvent A bitmask that specifies a combination of network events in which the application is interested.
     * @returns {Integer} If the 
     * <b>WSAAsyncSelect</b> function succeeds, the return value is zero, provided that the application's declaration of interest in the network event set was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the specified parameters was invalid, such as the window handle not referring to an existing window, or the specified socket is in an invalid state.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Additional error codes can be set when an application window receives a message. This error code is extracted from the <i>lParam</i> in the reply message using the <b>WSAGETSELECTERROR</b> macro. Possible error codes for each network event are listed in the following table.
     * 
     * Event: FD_CONNECT
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>Addresses in the specified family cannot be used with this socket.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></td>
     * <td>The attempt to connect was rejected.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></td>
     * <td>The network cannot be reached from this host at this time.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></td>
     * <td>The <i>namelen</i> parameter is invalid.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>The socket is already bound to an address.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></td>
     * <td>The socket is already connected.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></td>
     * <td>No more file descriptors are available.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></td>
     * <td>No buffer space is available. The socket cannot be connected.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></td>
     * <td>The socket is not connected.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></td>
     * <td>Attempt to connect timed out without establishing a connection.</td>
     * </tr>
     * </table>
     * 
     * 
     * Event: FD_CLOSE
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></td>
     * <td>The connection was reset by the remote side.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></td>
     * <td>The connection was terminated due to a time-out or other failure.</td>
     * </tr>
     * </table>
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem failed.</td>
     * </tr>
     * </table>
     * 
     * 
     * Event: FD_ROUTING_INTERFACE_CHANGE
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></td>
     * <td>The specified destination is no longer reachable.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem failed.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsaasyncselect
     * @deprecated
     * @since windows5.0
     */
    static WSAAsyncSelect(s, hWnd, wMsg, lEvent) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s
        hWnd := hWnd is Win32Handle ? NumGet(hWnd, "ptr") : hWnd

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAsyncSelect", "ptr", s, "ptr", hWnd, "uint", wMsg, "int", lEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAAccept function conditionally accepts a connection based on the return value of a condition function, provides quality of service flow specifications, and allows the transfer of connection data.
     * @param {SOCKET} s A descriptor that identifies a socket that is listening for connections after a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function.
     * @param {Pointer} addr An optional pointer to an <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that receives the address of the connecting entity, as known to the communications layer. The exact format of the <i>addr</i> parameter is determined by the address family established when the socket was created.
     * @param {Pointer<Integer>} addrlen An optional pointer to an integer that contains the length of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>addr</i> parameter, in bytes.
     * @param {Pointer<LPCONDITIONPROC>} lpfnCondition The  address of an optional, application-specified condition function that will make an accept/reject decision based on the caller information passed in as parameters, and optionally create or join a socket group by assigning an appropriate value to the result parameter <i>g</i> of this function. If this parameter is <b>NULL</b>, then no condition function is called.
     * @param {Pointer} dwCallbackData Callback data passed back to the application-specified condition function as the value of the <i>dwCallbackData</i> parameter passed to the condition function. This parameter is only applicable if the <i>lpfnCondition</i> parameter is not <b>NULL</b>. This parameter is not interpreted by Windows Sockets.
     * @returns {SOCKET} If no error occurs, 
     * <b>WSAAccept</b> returns a value of type SOCKET that is a descriptor for the accepted socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * The integer referred to by <i>addrlen</i> initially contains the amount of space pointed to by <i>addr</i>. On return it will contain the actual length in bytes of the address returned.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An attempt was made to access a socket in a way forbidden by its access permissions. This error is returned if the connection request that was offered has timed out or been withdrawn.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No connection could be made because the target machine actively refused it. This error is returned if the connection request was forcefully rejected as indicated in the return value of the condition function (CF_REJECT).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An existing connection was forcibly closed by the remote host. This error is returned of an incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned of the <i>addrlen</i> parameter is too small or the <i>addr</i> or <i>lpfnCondition</i> is not part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking operation was interrupted by a call to <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>. This error is returned if a blocking Windows Sockets 1.1 call was canceled through 
     * <b>WSACancelBlockingCall</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking operation is currently executing. This error is returned if a blocking Windows Sockets 1.1 call is in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.
     * 								This error is returned if <a href="/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> was not invoked prior to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a>, the return value of the condition function is not a valid one, or any case where the specified socket is in an invalid state.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Too many open sockets. This error is returned if the queue is nonempty upon entry to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> and there are no socket descriptors available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation encountered a dead network. This error is returned if the network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. This error is returned if no buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation was attempted on something that is not a socket. This error is returned if the socket descriptor passed in the <i>s</i> parameter is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol family has not been configured into the system or no implementation for it exists. This error is returned if the referenced socket is not a type that supports connection-oriented service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A non-blocking socket operation could not be completed immediately. This error is returned if the socket is marked as nonblocking and no connections are present to be accepted.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the application has not called <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a>, or <b>WSAStartup</b> failed. This error is returned of a successful 
     * call to the <b>WSAStartup</b> function dit not occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server. This error is returned if the acceptance of the connection request was deferred as indicated in the return value of the condition function (CF_DEFER).
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaaccept
     * @since windows8.1
     */
    static WSAAccept(s, addr, addrlen, lpfnCondition, dwCallbackData) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAccept", "ptr", s, "ptr", addr, "int*", addrlen, "ptr", lpfnCondition, "ptr", dwCallbackData, "ptr")
        if(A_LastError)
            throw OSError()

        return SOCKET({Value: result}, True)
    }

    /**
     * The WSACloseEvent function closes an open event object handle.
     * @param {WSAEVENT} hEvent Object handle identifying the open event.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> is not a valid event object handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsacloseevent
     * @since windows8.1
     */
    static WSACloseEvent(hEvent) {
        hEvent := hEvent is Win32Handle ? NumGet(hEvent, "ptr") : hEvent

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSACloseEvent", "ptr", hEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAConnect function establishes a connection to another socket application, exchanges connect data, and specifies required quality of service based on the specified FLOWSPEC structure.
     * @param {SOCKET} s A descriptor identifying an unconnected socket.
     * @param {Pointer} name A pointer to a <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure  that specifies the address to which to connect. For  IPv4, the <b>sockaddr</b> contains <b>AF_INET</b> for the address family, the destination IPv4 address, and the destination port. For  IPv6, the <b>sockaddr</b> structure contains <b>AF_INET6</b> for the address family, the destination IPv6 address, the destination port, and may contain additional flow and scope-id information.
     * @param {Integer} namelen The length, in bytes, of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>name</i> parameter.
     * @param {Pointer<WSABUF>} lpCallerData A pointer to the user data that is to be transferred to the other socket during connection establishment. See Remarks.
     * @param {Pointer<WSABUF>} lpCalleeData A pointer to the user data that is to be transferred back from the other socket during connection establishment. See Remarks.
     * @param {Pointer<QOS>} lpSQOS A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for socket <i>s</i>, one for each direction.
     * @param {Pointer<QOS>} lpGQOS Reserved for future use with socket groups. A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for the socket group (if applicable). This parameter should be <b>NULL</b>.
     * @returns {Integer} If no error occurs, 
     * <b>WSAConnect</b> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. On a blocking socket, the return value indicates success or failure of the connection attempt.
     * 
     * With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, 
     * <b>WSAConnect</b> will return SOCKET_ERROR, and 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> will return 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a>; the application could therefore:
     * 
     * <ul>
     * <li>Use 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-select">select</a> to determine the completion of the connection request by checking if the socket is writeable.</li>
     * <li>If your application is using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> to indicate interest in connection events, then your application will receive an FD_CONNECT notification when the connect operation is complete(successful or not).</li>
     * <li>If your application is using 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> to indicate interest in connection events, then the associated event object will be signaled when the connect operation is complete (successful or not).</li>
     * </ul>
     * For a nonblocking socket, until the connection attempt completes all subsequent calls to 
     * <b>WSAConnect</b> on the same socket will fail with the error code 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a>.
     * 
     * If the return error code indicates the connection attempt failed (that is, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a>, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a>, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>) the application can call 
     * <b>WSAConnect</b> again for the same socket.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRINUSE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The local address of the socket is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs during the execution of 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, but could be delayed until this function if the 
     * <b>bind</b> function operates on a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be "committed" at the time of this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The (blocking) Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonblocking 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a> or <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a> call is in progress on the specified socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote address is not a valid address (such as ADDR_ANY).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Addresses in the specified family cannot be used with this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The attempt to connect was rejected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or the <i>namelen</i> parameter is not a valid part of the user address space, the <i>namelen</i> parameter is too small, the buffer length for <i>lpCalleeData</i>, <i>lpSQOS</i>, and <i>lpGQOS</i> are too small, or the buffer length for <i>lpCallerData</i> is too large.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The parameter <i>s</i> is a listening socket, or the destination address specified is not consistent with that of the constrained group to which the socket belongs, or the <i>lpGQOS</i> parameter is not <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is already connected (connection-oriented sockets only).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEHOSTUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation was attempted to an unreachable host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * <a href="/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures specified in <i>lpSQOS</i> and <i>lpGQOS</i> cannot be satisfied.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpCallerData</i> parameter is not supported by the service provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Attempt to connect timed out without establishing a connection.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and the connection cannot be completed immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Attempt to connect datagram socket to broadcast address failed because 
     * <a href="/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> SO_BROADCAST is not enabled.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaconnect
     * @since windows8.1
     */
    static WSAConnect(s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAConnect", "ptr", s, "ptr", name, "int", namelen, "ptr", lpCallerData, "ptr", lpCalleeData, "ptr", lpSQOS, "ptr", lpGQOS, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a connection to a specified host and port.
     * @param {SOCKET} s A descriptor that identifies an unconnected socket.
     * 
     * <div class="alert"><b>Note</b>On Windows7,  Windows Server2008R2, and earlier, the <b>WSAConnectByName</b> function requires an unbound and unconnected socket. This differs from other Winsock calls to establish a connection (for example, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>). </div>
     * <div></div>
     * @param {PWSTR} nodename A <b>NULL</b>-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6.
     * @param {PWSTR} servicename A <b>NULL</b>-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6. 
     * 
     * A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>servicename</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<Integer>} LocalAddressLength On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the local address stored in the <i>LocalAddress</i> buffer filled in by the system upon successful completion of the call.
     * @param {Pointer} LocalAddress A pointer to the <b>SOCKADDR</b> structure that receives the local address of the connection. The size of the parameter is exactly the size returned in <i>LocalAddressLength</i>. This is the same information that would be returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function. This parameter can be <b>NULL</b>, in which case, the <i>LocalAddressLength</i> parameter is ignored.
     * @param {Pointer<Integer>} RemoteAddressLength On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the remote address stored in <i>RemoteAddress</i> buffer filled-in by the system upon successful completion of the call.
     * @param {Pointer} RemoteAddress A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the connection. This is the same information that would be returned by the <b>getpeername</b> function. This parameter can be <b>NULL</b>, in which case, the <i>RemoteAddressLength</i> is ignored.
     * @param {Pointer<TIMEVAL>} timeout The time, in milliseconds, to wait for a response from the remote application before aborting the call.
     * @returns {BOOL} If a connection is established, <b>WSAConnectByName</b> returns <b>TRUE</b> and <i>LocalAddress</i> and <i>RemoteAddress</i> parameters are filled in if these buffers were supplied by the caller.
     * 
     * If the call fails, <b>FALSE</b> is returned. <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can then be called to get extended error information.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEHOSTUNREACH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The host passed as the <i>nodename</i> parameter was unreachable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEINVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function.  The <i>nodename</i>  or the <i>servicename</i> parameter must not be <b>NULL</b>. The  <i>Reserved</i>  parameter must be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOBUFS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory could not be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOTSOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid socket was passed to the function. The <i>s</i>  parameter must not be <b>INVALID_SOCKET</b> or <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAETIMEDOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A response from the  remote application was not received before the <i>timeout</i> parameter was exceeded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaconnectbynamew
     * @since windows8.1
     */
    static WSAConnectByNameW(s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        nodename := nodename is String ? StrPtr(nodename) : nodename
        servicename := servicename is String ? StrPtr(servicename) : servicename
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAConnectByNameW", "ptr", s, "ptr", nodename, "ptr", servicename, "uint*", LocalAddressLength, "ptr", LocalAddress, "uint*", RemoteAddressLength, "ptr", RemoteAddress, "ptr", timeout, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a connection to a specified host and port.
     * @param {SOCKET} s A descriptor that identifies an unconnected socket.
     * 
     * <div class="alert"><b>Note</b>On Windows7,  Windows Server2008R2, and earlier, the <b>WSAConnectByName</b> function requires an unbound and unconnected socket. This differs from other Winsock calls to establish a connection (for example, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>). </div>
     * <div></div>
     * @param {PSTR} nodename A <b>NULL</b>-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6.
     * @param {PSTR} servicename A <b>NULL</b>-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6. 
     * 
     * A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>servicename</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<Integer>} LocalAddressLength On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the local address stored in the <i>LocalAddress</i> buffer filled in by the system upon successful completion of the call.
     * @param {Pointer} LocalAddress A pointer to the <b>SOCKADDR</b> structure that receives the local address of the connection. The size of the parameter is exactly the size returned in <i>LocalAddressLength</i>. This is the same information that would be returned by the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function. This parameter can be <b>NULL</b>, in which case, the <i>LocalAddressLength</i> parameter is ignored.
     * @param {Pointer<Integer>} RemoteAddressLength On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the remote address stored in <i>RemoteAddress</i> buffer filled-in by the system upon successful completion of the call.
     * @param {Pointer} RemoteAddress A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the connection. This is the same information that would be returned by the <b>getpeername</b> function. This parameter can be <b>NULL</b>, in which case, the <i>RemoteAddressLength</i> is ignored.
     * @param {Pointer<TIMEVAL>} timeout The time, in milliseconds, to wait for a response from the remote application before aborting the call.
     * @returns {BOOL} If a connection is established, <b>WSAConnectByName</b> returns <b>TRUE</b> and <i>LocalAddress</i> and <i>RemoteAddress</i> parameters are filled in if these buffers were supplied by the caller.
     * 
     * If the call fails, <b>FALSE</b> is returned. <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can then be called to get extended error information.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEHOSTUNREACH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The host passed as the <i>nodename</i> parameter was unreachable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEINVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function.  The <i>nodename</i>  or the <i>servicename</i> parameter must not be <b>NULL</b>. The  <i>Reserved</i>  parameter must be <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOBUFS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory could not be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOTSOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid socket was passed to the function. The <i>s</i>  parameter must not be <b>INVALID_SOCKET</b> or <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAETIMEDOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A response from the  remote application was not received before the <i>timeout</i> parameter was exceeded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaconnectbynamea
     * @deprecated
     * @since windows8.1
     */
    static WSAConnectByNameA(s, nodename, servicename, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        nodename := nodename is String ? StrPtr(nodename) : nodename
        servicename := servicename is String ? StrPtr(servicename) : servicename
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAConnectByNameA", "ptr", s, "ptr", nodename, "ptr", servicename, "uint*", LocalAddressLength, "ptr", LocalAddress, "uint*", RemoteAddressLength, "ptr", RemoteAddress, "ptr", timeout, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Establishes a connection to one out of a collection of possible endpoints represented by a set of destination addresses (host names and ports).
     * @param {SOCKET} s A descriptor that identifies an unbound and unconnected socket. Note that unlike other Winsock calls to 
     *       establish a connection (for example, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>), 
     *       the <b>WSAConnectByList</b> function requires an 
     *       unbound socket.
     * @param {Pointer<SOCKET_ADDRESS_LIST>} SocketAddress A pointer to a <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/aa385467(v=vs.85)">SOCKET_ADDRESS_LIST</a> 
     *       structure that represents the possible destination address and port pairs to connect to a peer. It is the 
     *       application's responsibility to fill in the port number in the each 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-socket_address">SOCKET_ADDRESS</a> structure in the 
     *       <b>SOCKET_ADDRESS_LIST</b>.
     * @param {Pointer<Integer>} LocalAddressLength On input, a pointer to the size, in bytes, of the <i>LocalAddress</i> buffer provided by 
     *       the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the 
     *       local address stored in the <i>LocalAddress</i> buffer filled in by the system upon 
     *       successful completion of the call.
     * @param {Pointer} LocalAddress A pointer to the <b>SOCKADDR</b> structure that receives the local address of the 
     *       connection. The size of the parameter is exactly the size returned in 
     *       <i>LocalAddressLength</i>. This is the same information that would be returned by the 
     *       <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function. This parameter can be 
     *       <b>NULL</b>, in which case, the <i>LocalAddressLength</i> parameter is 
     *       ignored.
     * @param {Pointer<Integer>} RemoteAddressLength On input, a pointer to the size, in bytes, of the <i>RemoteAddress</i> buffer provided 
     *       by the caller. On output, a pointer to the size, in bytes, of the <b>SOCKADDR</b> for the 
     *       remote address stored in <i>RemoteAddress</i> buffer filled-in by the system upon successful 
     *       completion of the call.
     * @param {Pointer} RemoteAddress A pointer to the <b>SOCKADDR</b> structure that receives the remote address of the 
     *       connection. This is the same information that would be returned by the 
     *       <b>getpeername</b> function. This parameter can be <b>NULL</b>, in 
     *       which case, the <i>RemoteAddressLength</i> is ignored.
     * @param {Pointer<TIMEVAL>} timeout The time, in milliseconds, to wait for a response from the remote application before aborting the call. 
     *       This parameter can be <b>NULL</b> in which case 
     *       <b>WSAConnectByList</b> will complete after either the 
     *       connection is successfully established or after a connection was attempted and failed on all possible 
     *       local-remote address pairs.
     * @returns {BOOL} If a connection is established, 
     *        <b>WSAConnectByList</b> returns <b>TRUE</b> and 
     *        <i>LocalAddress</i> and <i>RemoteAddress</i> parameters are filled in if 
     *        these buffers were supplied by the caller.
     * 
     * If the call fails, <b>FALSE</b> is returned. 
     *        <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can then be called to get 
     *        extended error information.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEHOSTUNREACH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The host passed as the <i>nodename</i> parameter was unreachable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAEINVAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. The <i>Reserved</i> parameter must be 
     *         <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOBUFS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Sufficient memory could not be allocated.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAENOTSOCK</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid socket was passed to the function. The <i>s</i> parameter must not be 
     *         <b>INVALID_SOCKET</b> or <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSAETIMEDOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A response from the  remote application was not received before the <i>timeout</i> 
     *         parameter was exceeded.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaconnectbylist
     * @since windows8.1
     */
    static WSAConnectByList(s, SocketAddress, LocalAddressLength, LocalAddress, RemoteAddressLength, RemoteAddress, timeout) {
        static Reserved := 0 ;Reserved parameters must always be NULL

        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAConnectByList", "ptr", s, "ptr", SocketAddress, "uint*", LocalAddressLength, "ptr", LocalAddress, "uint*", RemoteAddressLength, "ptr", RemoteAddress, "ptr", timeout, "ptr", Reserved, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSACreateEvent function creates a new event object.
     * @returns {WSAEVENT} If no error occurs, 
     * <b>WSACreateEvent</b> returns the handle of the event object. Otherwise, the return value is WSA_INVALID_EVENT. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not enough free memory available to create the event object.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsacreateevent
     * @since windows8.1
     */
    static WSACreateEvent() {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSACreateEvent", "ptr")
        if(A_LastError)
            throw OSError()

        return WSAEVENT({Value: result}, True)
    }

    /**
     * The WSADuplicateSocket function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor for a shared socket. The WSADuplicateSocket function cannot be used on a QOS-enabled socket.
     * @param {SOCKET} s Descriptor identifying the local socket.
     * @param {Integer} dwProcessId Process identifier of the target process in which the duplicated socket will be used.
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo Pointer to a buffer, allocated by the client, that is large enough to contain a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The service provider copies the protocol information structure contents to this buffer.
     * @returns {Integer} If no error occurs, 
     * <b>WSADuplicateSocket</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that one of the specified parameters was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProtocolInfo</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaduplicatesocketa
     * @deprecated
     * @since windows8.1
     */
    static WSADuplicateSocketA(s, dwProcessId, lpProtocolInfo) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSADuplicateSocketA", "ptr", s, "uint", dwProcessId, "ptr", lpProtocolInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSADuplicateSocket function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor for a shared socket. The WSADuplicateSocket function cannot be used on a QOS-enabled socket.
     * @param {SOCKET} s Descriptor identifying the local socket.
     * @param {Integer} dwProcessId Process identifier of the target process in which the duplicated socket will be used.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo Pointer to a buffer, allocated by the client, that is large enough to contain a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The service provider copies the protocol information structure contents to this buffer.
     * @returns {Integer} If no error occurs, 
     * <b>WSADuplicateSocket</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that one of the specified parameters was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProtocolInfo</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaduplicatesocketw
     * @since windows8.1
     */
    static WSADuplicateSocketW(s, dwProcessId, lpProtocolInfo) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSADuplicateSocketW", "ptr", s, "uint", dwProcessId, "ptr", lpProtocolInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAEnumNetworkEvents function discovers occurrences of network events for the indicated socket, clear internal network event records, and reset event objects (optional).
     * @param {SOCKET} s A descriptor identifying the socket.
     * @param {WSAEVENT} hEventObject An optional handle identifying an associated event object to be reset.
     * @param {Pointer<WSANETWORKEVENTS>} lpNetworkEvents A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanetworkevents">WSANETWORKEVENTS</a> structure that is filled with a record of network events that occurred and any associated error codes.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the specified parameters was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpNetworkEvents</i> parameter is not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaenumnetworkevents
     * @since windows8.1
     */
    static WSAEnumNetworkEvents(s, hEventObject, lpNetworkEvents) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s
        hEventObject := hEventObject is Win32Handle ? NumGet(hEventObject, "ptr") : hEventObject

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEnumNetworkEvents", "ptr", s, "ptr", hEventObject, "ptr", lpNetworkEvents, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAEnumProtocols function retrieves information about available transport protocols.
     * @param {Pointer<Integer>} lpiProtocols A <b>NULLl</b>-terminated array of iProtocol values. This parameter is optional; if <i>lpiProtocols</i> is <b>NULL</b>, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer} lpProtocolBuffer A pointer to a buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures.
     * @param {Pointer<Integer>} lpdwBufferLength On input, number of bytes in the <i>lpProtocolBuffer</i> buffer passed to 
     * <b>WSAEnumProtocols</b>. On output, the minimum buffer size that can be passed to 
     * <b>WSAEnumProtocols</b> to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a computer is typically small.
     * @returns {Integer} If no error occurs, 
     * <b>WSAEnumProtocols</b> returns the number of protocols to be reported. Otherwise, a value of SOCKET_ERROR is returned and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that one of the specified parameters was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer length was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures and associated information. Pass in a buffer at least as large as the value returned in <i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the <i>lpiProtocols</i>, <i>lpProtocolBuffer</i>, or <i>lpdwBufferLength</i> parameters are not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaenumprotocolsa
     * @deprecated
     * @since windows8.1
     */
    static WSAEnumProtocolsA(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEnumProtocolsA", "int*", lpiProtocols, "ptr", lpProtocolBuffer, "uint*", lpdwBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAEnumProtocols function retrieves information about available transport protocols.
     * @param {Pointer<Integer>} lpiProtocols A <b>NULLl</b>-terminated array of iProtocol values. This parameter is optional; if <i>lpiProtocols</i> is <b>NULL</b>, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer} lpProtocolBuffer A pointer to a buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures.
     * @param {Pointer<Integer>} lpdwBufferLength On input, number of bytes in the <i>lpProtocolBuffer</i> buffer passed to 
     * <b>WSAEnumProtocols</b>. On output, the minimum buffer size that can be passed to 
     * <b>WSAEnumProtocols</b> to retrieve all the requested information. This routine has no ability to enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a computer is typically small.
     * @returns {Integer} If no error occurs, 
     * <b>WSAEnumProtocols</b> returns the number of protocols to be reported. Otherwise, a value of SOCKET_ERROR is returned and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that one of the specified parameters was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer length was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structures and associated information. Pass in a buffer at least as large as the value returned in <i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the <i>lpiProtocols</i>, <i>lpProtocolBuffer</i>, or <i>lpdwBufferLength</i> parameters are not a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaenumprotocolsw
     * @since windows8.1
     */
    static WSAEnumProtocolsW(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEnumProtocolsW", "int*", lpiProtocols, "ptr", lpProtocolBuffer, "uint*", lpdwBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAEventSelect function specifies an event object to be associated with the specified set of FD_XXX network events.
     * @param {SOCKET} s A descriptor identifying the socket.
     * @param {WSAEVENT} hEventObject A handle identifying the event object to be associated with the specified set of FD_XXX network events.
     * @param {Integer} lNetworkEvents A bitmask that specifies the combination of FD_XXX network events in which the application has interest.
     * @returns {Integer} The return value is zero if the application's specification of the network events and the associated event object was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * As in the case of the 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-select">select</a> and 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> functions, 
     * <b>WSAEventSelect</b> will frequently be used to determine when a data transfer operation (<a href="/windows/desktop/api/winsock2/nf-winsock2-send">send</a> or 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a>) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for the possibility that the event object is set and it issues a Windows Sockets call that returns 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> immediately. For example, the following sequence of operations is possible:
     * 
     * <ul>
     * <li>Data arrives on socket <i>s</i>; Windows Sockets sets the 
     * <b>WSAEventSelect</b> event object.</li>
     * <li>The application does some other processing.</li>
     * <li>While processing, the application issues an 
     * <a href="/windows/desktop/api/winsock/nf-winsock-ioctlsocket">ioctlsocket</a>(<i>s</i>, FIONREAD...) and notices that there is data ready to be read.</li>
     * <li>The application issues a 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a>(<i>s</i>,...) to read the data.</li>
     * <li>The application eventually waits on the event object specified in 
     * <b>WSAEventSelect</b>, which returns immediately indicating that data is ready to read.</li>
     * <li>The application issues 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a>(<i>s</i>,...), which fails with the error 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a>.</li>
     * </ul>
     * Having successfully recorded the occurrence of the network event (by setting the corresponding bit in the internal network event record) and signaled the associated event object, no further actions are taken for that network event until the application makes the function call that implicitly reenables the setting of that network event and signaling of the associated event object.
     * 
     * <table>
     * <tr>
     * <th>Network event</th>
     * <th>Re-enabling function</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_READ</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a>, 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>, 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, <a href="/windows/desktop/api/mswsock/nf-mswsock-wsarecvex">WSARecvEx</a>, or 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_WRITE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <a href="/windows/desktop/api/winsock2/nf-winsock2-send">send</a>, 
     * <a href="/windows/desktop/api/winsock/nf-winsock-sendto">sendto</a>, 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, or 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_OOB</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * 								<a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a>, 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recvfrom">recvfrom</a>, 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, <a href="/windows/desktop/api/mswsock/nf-mswsock-wsarecvex">WSARecvEx</a>, or <a href="/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_ACCEPT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * 								<a href="/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a>, <a href="/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>, or 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> function unless the error code returned is WSATRY_AGAIN indicating that the condition function returned CF_DEFER.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_CONNECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * None.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_CLOSE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * None.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_QOS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * 								<a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with command <b>SIO_GET_QOS</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_GROUP_QOS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Reserved.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_ROUTING_
     * INTERFACE_CHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * 								<a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with command <b>SIO_ROUTING_INTERFACE_CHANGE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>FD_ADDRESS_
     * LIST_CHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * 								<a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with command <b>SIO_ADDRESS_LIST_CHANGE</b>.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Any call to the reenabling routine, even one that fails, results in reenabling of recording and signaling for the relevant network event and event object.
     * 
     * For FD_READ, FD_OOB, and FD_ACCEPT network events, network event recording and event object signaling are level-triggered. This means that if the reenabling routine is called and the relevant network condition is still valid after the call, the network event is recorded and the associated event object is set. This allows an application to be event-driven and not be concerned with the amount of data that arrives at any one time. Consider the following sequence:
     * 
     * <ol>
     * <li>The transport provider receives 100 bytes of data on socket <i>s</i> and causes WS2_32.DLL to record the FD_READ network event and set the associated event object.</li>
     * <li>The application issues <a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a>(<i>s</i>, <i>buffptr</i>, 50, 0) to read 50 bytes.</li>
     * <li>The transport provider causes WS2_32.DLL to record the FD_READ network event and sets the associated event object again since there is still data to be read.</li>
     * </ol>
     * With these semantics, an application need not read all available data in response to an FD_READ network eventa single 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a> in response to each FD_READ network event is appropriate.
     * 
     * The FD_QOS event is considered edge triggered. A message will be posted exactly once when a quality of service change occurs. Further messages will not be forthcoming until either the provider detects a further change in quality of service or the application renegotiates the quality of service for the socket.
     * 
     * The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered edge triggered as well. A message will be posted exactly once when a change occurs after the application has requested the notification by issuing 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> with <b>SIO_ROUTING_INTERFACE_CHANGE</b> or <b>SIO_ADDRESS_LIST_CHANGE</b> correspondingly. Other messages will not be forthcoming until the application reissues the IOCTL and another change is detected since the IOCTL has been issued.
     * 
     * If a network event has already happened when the application calls 
     * <b>WSAEventSelect</b> or when the reenabling function is called, then a network event is recorded and the associated event object is set as appropriate. For example, consider the following sequence:
     * 
     * <ol>
     * <li>An application calls 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a>.</li>
     * <li>A connect request is received but not yet accepted.</li>
     * <li>The application calls 
     * <b>WSAEventSelect</b> specifying that it is interested in the FD_ACCEPT network event for the socket. Due to the persistence of network events, Windows Sockets records the FD_ACCEPT network event and sets the associated event object immediately.</li>
     * </ol>
     * The FD_WRITE network event is handled slightly differently. An FD_WRITE network event is recorded when a socket is first connected with a call to the  
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-connect">connect</a>, <a href="/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaconnect">WSAConnect</a>, <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaconnectbylist">WSAConnectByList</a>, or  <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaconnectbynamea">WSAConnectByName</a> function or when a socket is accepted with 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a>, <a href="/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>,
     * 							or <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaaccept">WSAAccept</a> function and then after a send fails with <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a> and buffer space becomes available. Therefore, an application can assume that sends are possible starting from the first FD_WRITE network event setting and lasting until a send returns 
     * WSAEWOULDBLOCK. After such a failure the application will find out that sends are again possible when an FD_WRITE network event is recorded and the associated event object is set.
     * 
     * The FD_OOB network event is used only when a socket is configured to receive OOB data separately. If the socket is configured to receive OOB data inline, the OOB (expedited) data is treated as normal data and the application should register an interest in, and will get FD_READ network event, not FD_OOB network event. An application can set or inspect the way in which OOB data is to be handled by using 
     * <a href="/windows/desktop/api/winsock/nf-winsock-setsockopt">setsockopt</a> or 
     * <a href="/windows/desktop/api/winsock/nf-winsock-getsockopt">getsockopt</a> for the SO_OOBINLINE option.
     * 
     * The error code in an FD_CLOSE network event indicates whether the socket close was graceful or abortive. If the error code is zero, then the close was graceful; if the error code is 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a>, then the socket's virtual circuit was reset. This only applies to connection-oriented sockets such as SOCK_STREAM.
     * 
     * The FD_CLOSE network event is recorded when a close indication is received for the virtual circuit corresponding to the socket. In TCP terms, this means that the FD_CLOSE is recorded when the connection goes into the TIME WAIT or CLOSE WAIT states. This results from the remote end performing a 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> on the send side or a 
     * <a href="/windows/desktop/api/winsock/nf-winsock-closesocket">closesocket</a>. FD_CLOSE being posted after all data is read from a socket. An application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing data. For more information, see the section on <a href="/windows/desktop/WinSock/graceful-shutdown-linger-options-and-socket-closure-2">Graceful Shutdown, Linger Options, and Socket Closure</a> and the <b>shutdown</b> function.
     * 
     * Note that Windows Sockets will record only an FD_CLOSE network event to indicate closure of a virtual circuit. It will not record an FD_READ network event to indicate this condition.
     * 
     * The FD_QOS or FD_GROUP_QOS network event is recorded when any parameter in the flow specification associated with socket <i>s</i>. Applications should use 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> with command <b>SIO_GET_QOS</b> to get the current quality of service for socket <i>s</i>.
     * 
     * The FD_ROUTING_INTERFACE_CHANGE network event is recorded when the local interface that should be used to reach the destination specified in 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> with <b>SIO_ROUTING_INTERFACE_CHANGE</b> changes after such IOCTL has been issued.
     * 
     * The FD_ADDRESS_LIST_CHANGE network event is recorded when the list of addresses of protocol family for the socket to which the application can bind changes after 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> with <b>SIO_ADDRESS_LIST_CHANGE</b> has been issued.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>One of the specified parameters was invalid, or the specified socket is in an invalid state.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></td>
     * <td>The descriptor is not a socket.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaeventselect
     * @since windows8.1
     */
    static WSAEventSelect(s, hEventObject, lNetworkEvents) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s
        hEventObject := hEventObject is Win32Handle ? NumGet(hEventObject, "ptr") : hEventObject

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEventSelect", "ptr", s, "ptr", hEventObject, "int", lNetworkEvents, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAGetOverlappedResult function retrieves the results of an overlapped operation on the specified socket.
     * @param {SOCKET} s A descriptor identifying the socket. 
     * 
     * This is the same socket that was specified when the overlapped operation was started by a call to 
     * any of the Winsock functions that supports overlappped operations. These functions include <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>, <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms737757(v=vs.85)">DisconnectEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a>, <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_transmitpackets">TransmitPackets</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg">LPFN_WSARECVMSG (WSARecvMsg)</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg">WSASendMsg</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure that was specified when the overlapped operation was started. This parameter must not be a <b>NULL</b> pointer.
     * @param {Pointer<Integer>} lpcbTransfer A pointer to a 32-bit variable that receives the number of bytes that were actually transferred by a send or receive operation, or by 
     * the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function. This parameter must not be a <b>NULL</b> pointer.
     * @param {BOOL} fWait A flag that specifies whether the function should wait for the pending overlapped operation to complete. If <b>TRUE</b>, the function does not return until the operation has been completed. If <b>FALSE</b> and the operation is still pending, the function returns <b>FALSE</b> and the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function returns WSA_IO_INCOMPLETE. The <i>fWait</i> parameter may be set to <b>TRUE</b> only if the overlapped operation selected the event-based completion notification.
     * @param {Pointer<Integer>} lpdwFlags A pointer to a 32-bit variable that will receive one or more flags that supplement the completion status. If the overlapped operation was initiated through 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> or 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, this parameter will contain the results value for <i>lpFlags</i> parameter. This parameter must not be a <b>NULL</b> pointer.
     * @returns {BOOL} If 
     * <b>WSAGetOverlappedResult</b> succeeds, the return value is <b>TRUE</b>. This means that the overlapped operation has completed successfully and that the value pointed to by <i>lpcbTransfer</i> has been updated. 
     * 
     * If 
     * <b>WSAGetOverlappedResult</b> returns <b>FALSE</b>, this means that either the overlapped operation has not completed, the overlapped operation completed but with errors, or the overlapped operation's completion status could not be determined due to errors in one or more parameters to 
     * <b>WSAGetOverlappedResult</b>. On failure, the value pointed to by <i>lpcbTransfer</i> will not be updated. Use 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> to determine the cause of the failure (either by the <b>WSAGetOverlappedResult</b> function or by the associated overlapped operation).
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter of the 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure does not contain a valid event object handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One of the parameters is unacceptable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_INCOMPLETE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>fWait</i> parameter is <b>FALSE</b> and the I/O operation has not yet completed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or <i>lpdwFlags</i> parameters are not in a valid part of the user address space. This error is returned if the <i>lpOverlapped</i>, <i>lpcbTransfer</i>, or <i>lpdwFlags</i> parameter  was a <b>NULL</b> pointer on Windows Server2003 and earlier.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsagetoverlappedresult
     * @since windows8.1
     */
    static WSAGetOverlappedResult(s, lpOverlapped, lpcbTransfer, fWait, lpdwFlags) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetOverlappedResult", "ptr", s, "ptr", lpOverlapped, "uint*", lpcbTransfer, "int", fWait, "uint*", lpdwFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAGetQOSByName function initializes a QOS structure based on a named template, or it supplies a buffer to retrieve an enumeration of the available template names.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpQOSName A pointer to a specific quality of service template.
     * @param {Pointer<QOS>} lpQOS A pointer to the 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-qos">QOS</a> structure to be filled.
     * @returns {BOOL} If 
     * <b>WSAGetQOSByName</b> succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpQOSName</i> or <i>lpQOS</i> parameter are not a valid part of the user address space, or the buffer length for <i>lpQOS</i> is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsagetqosbyname
     * @deprecated
     * @since windows5.0
     */
    static WSAGetQOSByName(s, lpQOSName, lpQOS) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetQOSByName", "ptr", s, "ptr", lpQOSName, "ptr", lpQOS, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAHtonl function converts a u_long from host byte order to network byte order.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} hostlong A 32-bit number in host byte order.
     * @param {Pointer<Integer>} lpnetlong A pointer to a 32-bit number to receive the number in network byte order.
     * @returns {Integer} If no error occurs, 
     * <b>WSAHtonl</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpnetlong</i> parameter is <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsahtonl
     * @since windows8.1
     */
    static WSAHtonl(s, hostlong, lpnetlong) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAHtonl", "ptr", s, "uint", hostlong, "uint*", lpnetlong, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAHtons function converts a u_short from host byte order to network byte order.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} hostshort A 16-bit number in host byte order.
     * @param {Pointer<Integer>} lpnetshort A pointer to a 16-bit buffer to receive the number in network byte order.
     * @returns {Integer} If no error occurs, 
     * <b>WSAHtons</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpnetshort</i> parameter is <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsahtons
     * @since windows8.1
     */
    static WSAHtons(s, hostshort, lpnetshort) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAHtons", "ptr", s, "ushort", hostshort, "ushort*", lpnetshort, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAIoctl function controls the mode of a socket.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} dwIoControlCode The control code of operation to perform.
     * @param {Pointer} lpvInBuffer A pointer to the input buffer.
     * @param {Integer} cbInBuffer The size, in bytes, of the input buffer.
     * @param {Pointer} lpvOutBuffer A pointer to the output buffer.
     * @param {Integer} cbOutBuffer The size, in bytes, of the output buffer.
     * @param {Pointer<Integer>} lpcbBytesReturned A pointer to actual number of bytes of output.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for non-overlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * <div class="alert"><b>Note</b>A pointer to the completion routine called when the operation has been completed (ignored for non-overlapped sockets). See Remarks.</div>
     * <div></div>
     * @returns {Integer} Upon successful completion, the 
     * <b>WSAIoctl</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped operation was successfully initiated and completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpvInBuffer</i>, <i>lpvOutBuffer</i>, <i>lpcbBytesReturned</i>, <i>lpOverlapped</i>, or <i>lpCompletionRoutine</i> parameter is not totally contained in a valid part of the user address space, or the <i>cbInBuffer</i> or <i>cbOutBuffer</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>dwIoControlCode</i> parameter is not a valid command, or a specified input parameter is not acceptable, or the command is not applicable to the type of socket specified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function is invoked when a callback is in progress.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor <i>s</i> is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified IOCTL command cannot be realized. (For example, the 
     * <a href="/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures specified in <b>SIO_SET_QOS</b> or <b>SIO_SET_GROUP_QOS</b> cannot be satisfied.)
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as non-blocking and the requested operation would block.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOPROTOOPT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket option is not supported on the specified protocol. For example, an attempt to use the <b>SIO_GET_BROADCAST_ADDRESS</b> IOCTL was made on an IPv6 socket or an attempt to use the TCP <b>SIO_KEEPALIVE_VALS</b> IOCTL was made on a datagram socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaioctl
     * @since windows8.1
     */
    static WSAIoctl(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAIoctl", "ptr", s, "uint", dwIoControlCode, "ptr", lpvInBuffer, "uint", cbInBuffer, "ptr", lpvOutBuffer, "uint", cbOutBuffer, "uint*", lpcbBytesReturned, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAJoinLeaf function joins a leaf node into a multipoint session, exchanges connect data, and specifies needed quality of service based on the specified FLOWSPEC structures.
     * @param {SOCKET} s Descriptor identifying a multipoint socket.
     * @param {Pointer} name Name of the peer to which the socket is to be joined.
     * @param {Integer} namelen Length of <i>name</i>, in bytes.
     * @param {Pointer<WSABUF>} lpCallerData Pointer to the user data that is to be transferred to the peer during multipoint session establishment.
     * @param {Pointer<WSABUF>} lpCalleeData Pointer to the user data that is to be transferred back from the peer during multipoint session establishment.
     * @param {Pointer<QOS>} lpSQOS Pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for socket <i>s</i>, one for each direction.
     * @param {Pointer<QOS>} lpGQOS Reserved for future use with socket groups. A pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures for the socket group (if applicable).
     * @param {Integer} dwFlags Flags to indicate that the socket is acting as a sender (JL_SENDER_ONLY), receiver (JL_RECEIVER_ONLY), or both (JL_BOTH).
     * @returns {SOCKET} If no error occurs, 
     * <b>WSAJoinLeaf</b> returns a value of type SOCKET that is a descriptor for the newly created multipoint socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * On a blocking socket, the return value indicates success or failure of the join operation.
     * 
     * With a nonblocking socket, successful initiation of a join operation is indicated by a return of a valid socket descriptor. Subsequently, an FD_CONNECT indication will be given on the original socket <i>s</i> when the join operation completes, either successfully or otherwise. The application must use either 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsaasyncselect">WSAAsyncSelect</a> or 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaeventselect">WSAEventSelect</a> with interest registered for the FD_CONNECT event in order to determine when the join operation has completed and checks the associated error code to determine the success or failure of the operation. The 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-select">select</a> function cannot be used to determine when the join operation completes.
     * 
     * Also, until the multipoint session join attempt completes all subsequent calls to 
     * <b>WSAJoinLeaf</b> on the same socket will fail with the error code 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a>. After the 
     * <b>WSAJoinLeaf</b> operation completes successfully, a subsequent attempt will usually fail with the error code 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a>. An exception to the WSAEISCONN rule occurs for a c_root socket that allows root-initiated joins. In such a case, another join may be initiated after a prior 
     * <b>WSAJoinLeaf</b> operation completes.
     * 
     * If the return error code indicates the multipoint session join attempt failed (that is, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a>, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a>, 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a>) the application can call 
     * <b>WSAJoinLeaf</b> again for the same socket.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRINUSE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error usually occurs at the time of 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, but could be delayed until this function if the 
     * <b>bind</b> was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote address is not a valid address (such as ADDR_ANY).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Addresses in the specified family cannot be used with this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonblocking 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a> call is in progress on the specified socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNREFUSED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The attempt to join was forcefully rejected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>name</i> or the <i>namelen</i> parameter is not a valid part of the user address space, the <i>namelen</i> parameter is too small, the buffer length for <i>lpCalleeData</i>, <i>lpSQOS</i>, and <i>lpGQOS</i> are too small, or the buffer length for <i>lpCallerData</i> is too large.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsajoinleaf">WSAJoinLeaf</a> function call was performed on a UDP socket that was opened without setting its WSA_FLAG_MULTIPOINT_C_LEAF or WSA_FLAG_MULTIPOINT_D_LEAF multipoint flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is already a member of the multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be joined.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The 
     * <a href="/windows/desktop/api/qos/ns-qos-flowspec">FLOWSPEC</a> structures specified in <i>lpSQOS</i> and <i>lpGQOS</i> cannot be satisfied.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpCallerData</i> augment is not supported by the service provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The attempt to join timed out without establishing a multipoint session.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsajoinleaf
     * @since windows8.1
     */
    static WSAJoinLeaf(s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS, dwFlags) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAJoinLeaf", "ptr", s, "ptr", name, "int", namelen, "ptr", lpCallerData, "ptr", lpCalleeData, "ptr", lpSQOS, "ptr", lpGQOS, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return SOCKET({Value: result}, True)
    }

    /**
     * The WSANtohl function converts a u_long from network byte order to host byte order.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} netlong A 32-bit number in network byte order.
     * @param {Pointer<Integer>} lphostlong A pointer to a 32-bit number to receive the number in host byte order.
     * @returns {Integer} If no error occurs, 
     * <b>WSANtohl</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lphostlong</i> parameter is <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsantohl
     * @since windows8.1
     */
    static WSANtohl(s, netlong, lphostlong) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSANtohl", "ptr", s, "uint", netlong, "uint*", lphostlong, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSANtohs function converts a u_short from network byte order to host byte order.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Integer} netshort A 16-bit number in network byte order.
     * @param {Pointer<Integer>} lphostshort A pointer to a 16-bit number to receive the number in host byte order.
     * @returns {Integer} If no error occurs, 
     * <b>WSANtohs</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lphostshort</i> parameter is <b>NULL</b> or the address pointed to is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsantohs
     * @since windows8.1
     */
    static WSANtohs(s, netshort, lphostshort) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSANtohs", "ptr", s, "ushort", netshort, "ushort*", lphostshort, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Receives data from a connected socket or a bound connectionless socket.
     * @param {SOCKET} s A  descriptor identifying a connected socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length, in bytes, of the buffer.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<Integer>} lpNumberOfBytesRecvd A pointer to the number, in bytes, of data received by this call if the receive operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Pointer<Integer>} lpFlags A pointer to flags used to modify the behavior of the 
     * <b>WSARecv</b> function call. For more information, see the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for nonoverlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the receive operation has been completed (ignored for nonoverlapped sockets).
     * @returns {Integer} If no error occurs and the receive operation has completed immediately, 
     * <b>WSARecv</b> returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. The error code 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a> indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was terminated due to a time-out or other failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a stream socket, the virtual circuit was reset by the remote side. The application should close the socket as it is no longer usable. For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEDISCON</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Socket <i>s</i> is message oriented and the virtual circuit was gracefully closed by the remote side.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpBuffers</i> parameter is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The (blocking) call was canceled by the <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound (for example, with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was too large to fit into the specified buffer and (for unreliable protocols only) any trailing portion of the message that did not fit into the buffer has been discarded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a connection-oriented socket, this error indicates that the connection has been broken due to <i>keep-alive</i> activity that detected a failure while the operation was in progress. For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>MSG_OOB</b> was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only send operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to call 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a> on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <i>how</i> set to <b>SD_RECEIVE</b> or <b>SD_BOTH</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been dropped because of a network failure or because the peer system failed to respond.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * <b>WindowsNT:</b>Overlapped sockets: there are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as nonblocking and the receive operation cannot be completed immediately.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped operation was successfully initiated and completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The overlapped operation has been canceled due to the closure of the socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsarecv
     * @since windows8.1
     */
    static WSARecv(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSARecv", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "uint*", lpNumberOfBytesRecvd, "uint*", lpFlags, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSARecvDisconnect function terminates reception on a socket, and retrieves the disconnect data if the socket is connection oriented.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpInboundDisconnectData A pointer to the incoming disconnect data.
     * @returns {Integer} If no error occurs, 
     * <b>WSARecvDisconnect</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer referenced by the parameter <i>lpInboundDisconnectData</i> is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOPROTOOPT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The disconnect data is not supported by the indicated protocol family. Note that implementations of TCP/IP that do not support disconnect data are not required to return the WSAENOPROTOOPT error code. See the remarks section for information about the Microsoft implementation of TCP/IP.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected (connection-oriented sockets only).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsarecvdisconnect
     * @deprecated
     * @since windows5.0
     */
    static WSARecvDisconnect(s, lpInboundDisconnectData) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSARecvDisconnect", "ptr", s, "ptr", lpInboundDisconnectData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Receives a datagram and stores the source address.
     * @param {SOCKET} s A descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length of the buffer.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<Integer>} lpNumberOfBytesRecvd A pointer to the number of bytes received by this call if the 
     * <b>WSARecvFrom</b> operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Pointer<Integer>} lpFlags A pointer to flags used to modify the behavior of the 
     * <b>WSARecvFrom</b> function call. See remarks below.
     * @param {Pointer} lpFrom An optional pointer to a buffer that will hold the source address upon the completion of the overlapped operation.
     * @param {Pointer<Integer>} lpFromlen A pointer to the size, in bytes, of the "from" buffer required only if <i>lpFrom</i> is specified.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for nonoverlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the 
     * <b>WSARecvFrom</b> operation has been completed (ignored for nonoverlapped sockets).
     * @returns {Integer} If no error occurs and the receive operation has completed immediately, 
     * <b>WSARecvFrom</b> returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. The error code <b>WSA_IO_PENDING</b> indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as it is no longer usable. For a UPD datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpBuffers</i>, <i>lpFlags</i>, <i>lpFrom</i>, <i>lpNumberOfBytesRecvd</i>, <i>lpFromlen</i>, <i>lpOverlapped</i>, or <i>lpCompletionRoutine</i> parameter is not totally contained in a valid part of the user address space: the <i>lpFrom</i> buffer was too small to accommodate the peer address.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound (with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, for example).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The message was too large for the specified buffer and (for unreliable protocols only) any trailing portion of the message that did not fit into the buffer has been discarded.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected (connection-oriented sockets only).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>WindowsNT:</b>
     * 
     * Overlapped sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as nonblocking and the receive operation cannot be completed immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped operation was successfully initiated and completion will be indicated later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The overlapped operation has been canceled due to the closure of the socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsarecvfrom
     * @since windows8.1
     */
    static WSARecvFrom(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpFrom, lpFromlen, lpOverlapped, lpCompletionRoutine) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSARecvFrom", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "uint*", lpNumberOfBytesRecvd, "uint*", lpFlags, "ptr", lpFrom, "int*", lpFromlen, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAResetEvent function resets the state of the specified event object to nonsignaled.
     * @param {WSAEVENT} hEvent A handle that identifies an open event object handle.
     * @returns {BOOL} If the 
     * <b>WSAResetEvent</b> function succeeds, the return value is <b>TRUE</b>. If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter is not a valid event object handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaresetevent
     * @since windows8.1
     */
    static WSAResetEvent(hEvent) {
        hEvent := hEvent is Win32Handle ? NumGet(hEvent, "ptr") : hEvent

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAResetEvent", "ptr", hEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends data on a connected socket.
     * @param {SOCKET} s A descriptor that identifies a connected socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length, in bytes, of the buffer. For a Winsock application, once the 
     * <b>WSASend</b> function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<Integer>} lpNumberOfBytesSent A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Integer} dwFlags The flags used to modify the behavior of the 
     * <b>WSASend</b> function call. For more information, see Using <i>dwFlags</i> in the Remarks section.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure. This parameter is ignored for nonoverlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the send operation has been completed. This parameter is ignored for nonoverlapped sockets.
     * @returns {Integer} If no error occurs and the send operation has completed immediately, 
     * <b>WSASend</b> returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. The error code 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a> indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was terminated due to a time-out or other failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a stream socket, the virtual circuit was reset by the remote side. The application should close the socket as it is no longer usable. For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpBuffers</i>, <i>lpNumberOfBytesSent</i>, <i>lpOverlapped</i>, <i>lpCompletionRoutine</i> parameter is not totally contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a> or the socket is not created with the overlapped flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a stream socket, the connection has been broken due to keep-alive activity detecting a failure while the operation was in progress. For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Sockets provider reports a buffer deadlock.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>MSG_OOB</b> was specified, but the socket is not stream-style such as type <b>SOCK_STREAM</b>, OOB data is not supported in the communication domain associated with this socket, <b>MSG_PARTIAL</b> is not supported, or the socket is unidirectional and supports only receive operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a> on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with how set to <b>SD_SEND</b> or <b>SD_BOTH</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>WindowsNT:</b>
     * 
     * Overlapped sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as nonblocking and the send operation cannot be completed immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped operation was successfully initiated and completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The overlapped operation has been canceled due to the closure of the socket, the execution of the "SIO_FLUSH" command in 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>, or the thread that initiated the overlapped request exited before the operation completed. For more information, see the Remarks section.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasend
     * @since windows8.1
     */
    static WSASend(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASend", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "uint*", lpNumberOfBytesSent, "uint", dwFlags, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends data and optional control information from connected and unconnected sockets. NoteThis function is a Microsoft-specific extension to the Windows Sockets specification..
     * @param {SOCKET} Handle A descriptor identifying the  socket.
     * @param {Pointer<WSAMSG>} lpMsg A <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a> structure storing the Posix.1g <b>msghdr</b> structure.
     * @param {Integer} dwFlags The flags used to modify the behavior of the <b>WSASendMsg</b> function call. For more information, see Using <i>dwFlags</i> in the Remarks section.
     * @param {Pointer<Integer>} lpNumberOfBytesSent A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure. Ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the send operation completes. Ignored for non-overlapped sockets.
     * @returns {Integer} Returns zero when successful and immediate completion occurs. When zero is returned, the specified completion routine is called when the calling thread is in the alertable state.
     * 
     * A return value of <b>SOCKET_ERROR</b>, and subsequent call to <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> that returns WSA_IO_PENDING, indicates the overlapped operation has successfully initiated; completion is then indicated through other means, such as through events or completion ports.
     * 
     * Upon failure, returns <b>SOCKET_ERROR</b> and a subsequent call to <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> returns a value other than <b>WSA_IO_PENDING</b>. The following table lists error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested address is a broadcast address, but the appropriate flag was not set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpMsg</i>, <i>lpNumberOfBytesSent</i>, <i>lpOverlapped</i>, or <i>lpCompletionRoutine</i> parameter is not totally contained in a valid part of the user address space. This error is also returned if a <b>name</b> member of the <a href="/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a>structure pointed to by the <i>lpMsg</i> parameter was a <b>NULL</b> pointer and the <b>namelen</b> member of the <b>WSAMSG</b>structure was not set to  zero.  This error is also returned if a <b>Control.buf</b> member of the <b>WSAMSG</b>structure pointed to by the <i>lpMsg</i> parameter was a <b>NULL</b> pointer and the <b>Control.len</b> member of the <b>WSAMSG</b>structure was not set to  zero.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, or the socket was not created with the overlapped flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network is unreachable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Sockets provider reports a buffer deadlock.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket operation is not supported. This error is returned if the <b>dwFlags</b> member of the <a href="/windows/desktop/api/ws2def/ns-ws2def-wsamsg">WSAMSG</a>structure pointed to by the <i>lpMsg</i> parameter includes any control flags invalid for <a href="/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg">WSASendMsg</a>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to 
     * call the <a href="/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg">WSASendMsg</a> function on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <i>how</i> set to SD_SEND or SD_BOTH.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket timed out. This error is returned if the socket had a wait timeout specified using the <b>SO_SNDTIMEO</b> socket option and the timeout was exceeded. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Overlapped sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as nonblocking and the send operation cannot be completed immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped operation was successfully initiated and completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The overlapped operation has been canceled  due to the closure of the socket or due to the execution of the <b>SIO_FLUSH</b> command in 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasendmsg
     * @since windows8.1
     */
    static WSASendMsg(Handle, lpMsg, dwFlags, lpNumberOfBytesSent, lpOverlapped, lpCompletionRoutine) {
        Handle := Handle is Win32Handle ? NumGet(Handle, "ptr") : Handle

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASendMsg", "ptr", Handle, "ptr", lpMsg, "uint", dwFlags, "uint*", lpNumberOfBytesSent, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASendDisconnect function initiates termination of the connection for the socket and sends disconnect data.
     * @param {SOCKET} s Descriptor identifying a socket.
     * @param {Pointer<WSABUF>} lpOutboundDisconnectData A pointer to the outgoing disconnect data.
     * @returns {Integer} If no error occurs, 
     * <b>WSASendDisconnect</b> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOPROTOOPT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The parameter <i>lpOutboundDisconnectData</i> is not <b>NULL</b>, and the disconnect data is not supported by the service provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected (connection-oriented sockets only).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpOutboundDisconnectData</i> parameter is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasenddisconnect
     * @deprecated
     * @since windows5.0
     */
    static WSASendDisconnect(s, lpOutboundDisconnectData) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASendDisconnect", "ptr", s, "ptr", lpOutboundDisconnectData, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Sends data to a specific destination, using overlapped I/O where applicable.
     * @param {SOCKET} s A descriptor identifying a (possibly connected) socket.
     * @param {Pointer<WSABUF>} lpBuffers A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures. Each 
     * <b>WSABUF</b> structure contains a pointer to a buffer and the length of the buffer, in bytes. For a Winsock application, once the 
     * <b>WSASendTo</b> function is called, the system owns these buffers and the application may not access them. This array must remain valid for the duration of the send operation.
     * @param {Integer} dwBufferCount The number of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-wsabuf">WSABUF</a> structures in the <i>lpBuffers</i> array.
     * @param {Pointer<Integer>} lpNumberOfBytesSent A pointer to the number of bytes sent by this call if the I/O operation completes immediately. 
     * 
     * Use <b>NULL</b> for this parameter if the <i>lpOverlapped</i> parameter is not <b>NULL</b> to avoid potentially erroneous results. This parameter can be <b>NULL</b> only  if the <i>lpOverlapped</i> parameter is not <b>NULL</b>.
     * @param {Integer} dwFlags The flags  used to modify the behavior of the 
     * <b>WSASendTo</b> function call.
     * @param {Pointer} lpTo An optional pointer to the address of the target socket in the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">SOCKADDR</a> structure.
     * @param {Integer} iTolen The size, in bytes, of the address in the <i>lpTo</i> parameter.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure (ignored for nonoverlapped sockets).
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * A pointer to the completion routine called when the send operation has been completed (ignored for nonoverlapped sockets).
     * @returns {Integer} If no error occurs and the send operation has completed immediately, 
     * <b>WSASendTo</b> returns zero. In this case, the completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. The error code <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a> indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested address is a broadcast address, but the appropriate flag was not set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEADDRNOTAVAIL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The remote address is not a valid address (such as ADDR_ANY).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Addresses in the specified family cannot be used with this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEDESTADDRREQ</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A destination address is required.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpBuffers</i>, <i>lpTo</i>, <i>lpOverlapped</i>, <i>lpNumberOfBytesSent</i>, or <i>lpCompletionRoutine</i> parameters are not part of the user address space, or the <i>lpTo</i> parameter is too small.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEHOSTUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation was attempted to an unreachable host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Socket 1.1 call was canceled through 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, or the socket is not created with the overlapped flag.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETUNREACH</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network cannot be reached from this host at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Sockets provider reports a buffer deadlock.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected (connection-oriented sockets only).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a> on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <i>how</i> set to SD_SEND or SD_BOTH.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * <b>WindowsNT:</b>
     * 
     * Overlapped sockets: there are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as nonblocking and the send operation cannot be completed immediately.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped operation was successfully initiated and completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The overlapped operation has been canceled due to the closure of the socket, or the execution of the SIO_FLUSH command in 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasendto
     * @since windows8.1
     */
    static WSASendTo(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpTo, iTolen, lpOverlapped, lpCompletionRoutine) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASendTo", "ptr", s, "ptr", lpBuffers, "uint", dwBufferCount, "uint*", lpNumberOfBytesSent, "uint", dwFlags, "ptr", lpTo, "int", iTolen, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASetEvent function sets the state of the specified event object to signaled.
     * @param {WSAEVENT} hEvent Handle that identifies an open event object.
     * @returns {BOOL} If the function succeeds, the return value is <b>TRUE</b>.
     * 
     * If the function fails, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hEvent</i> parameter is not a valid event object handle.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasetevent
     * @since windows8.1
     */
    static WSASetEvent(hEvent) {
        hEvent := hEvent is Win32Handle ? NumGet(hEvent, "ptr") : hEvent

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASetEvent", "ptr", hEvent, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASocket function creates a socket that is bound to a specific transport-service provider.
     * @param {Integer} af The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i> header file. 
     * 
     * On the Windows SDK released for WindowsVista and later, the organization of header files has changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * The values currently supported are AF_INET or AF_INET6, which are the Internet
     *                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The table below lists common values for address family although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>Af</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl>
     * <dt><b>AF_UNSPEC</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family is unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl>
     * <dt><b>AF_IPX</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. 
     * 
     * This address family is not supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
     * <dt><b>AF_APPLETALK</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. 
     * 
     * This address family is not supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
     * <dt><b>AF_NETBIOS</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. 
     * 
     * The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows. 
     * 
     * The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows7,  Windows Server2008, WindowsVista, Windows Server2003, or WindowsXP.  
     * 
     * The Windows Sockets provider for NetBIOS  only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>.
     * 
     * The Windows Sockets provider for NetBIOS  is not directly related to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/netbios/portal">NetBIOS</a> programming interface. The NetBIOS programming interface is not supported on WindowsVista, Windows Server2008, and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
     * <dt><b>AF_IRDA</b></dt>
     * <dt>26</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Infrared Data Association (IrDA) address family. 
     * 
     * This address family is only supported if the computer has an infrared port and driver installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
     * <dt><b>AF_BTH</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth address family. 
     * 
     * This address family is supported on WindowsXP with SP2 or later if the computer has a Bluetooth adapter and driver installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} type The type specification for the new socket. 
     * 
     * 
     * Possible values for the socket type are defined in the <i>Winsock2.h</i> header file.
     * 
     * The following table lists the possible values for the <i>type</i> parameter supported for Windows Sockets 2:
     * 
     * <table>
     * <tr>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
     * <dt><b>SOCK_STREAM</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl>
     * <dt><b>SOCK_DGRAM</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
     * <dt><b>SOCK_RAW</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ip-socket-options">IP_HDRINCL</a> socket option must be set on the socket.  To manipulate the IPv6 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPV6_HDRINCL</a> socket option must be set on the socket.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
     * <dt><b>SOCK_RDM</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as <a href="https://docs.microsoft.com/windows/desktop/WinSock/reliable-multicast-programming--pgm-">reliable multicast programming</a>. 
     * 
     * This <i>type</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
     * <dt><b>SOCK_SEQPACKET</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a pseudo-stream packet based on datagrams. 
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address families, and protocols are defined.
     * 
     * In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b> and <b>SOCK_STREAM</b>.
     * @param {Integer} protocol The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address family and socket type specified. Possible values for the <i>protocol</i> are defined are defined in the  <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. 
     * 
     * On the Windows SDK released for WindowsVista and later,, the organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * If a value of  0 is specified, the caller does not
     *               wish to specify a protocol and the service provider will choose the <i>protocol</i> to use.
     * 
     * 
     * When the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. 
     * 
     * The table below lists common values for the <i>protocol</i> although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>protocol</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
     * <dt><b>IPPROTO_ICMP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl>
     * <dt><b>IPPROTO_IGMP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
     * <dt><b>BTHPROTO_RFCOMM</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. 
     * 
     * This <i>protocol</i> value is supported on WindowsXP with SP2 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl>
     * <dt><b>IPPROTO_ICMPV6</b></dt>
     * <dt>58</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b>  and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl>
     * <dt><b>IPPROTO_RM</b></dt>
     * <dt>113</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PGM protocol for reliable multicast. This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK released for WindowsVista and later,  this protocol is also called <b>IPPROTO_PGM</b>. 
     * 
     * This <i>protocol</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that defines the characteristics of the socket to be created. If this parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated 
     * <b>WSAPROTOCOL_INFO</b> structure.
     * @param {Integer} g An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group. 
     * 
     * If <i>g</i> is an existing socket group ID, join the new socket to this
     *             socket group, provided all the requirements set by this group are met. 
     * 
     * If <i>g</i> is not an existing socket group ID, then the following values are possible.
     * 
     * <table>
     * <tr>
     * <th>g</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id=""></a><dl>
     * <dt><b></b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No group operation is performed. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_UNCONSTRAINED_GROUP"></a><a id="sg_unconstrained_group"></a><dl>
     * <dt><b>SG_UNCONSTRAINED_GROUP</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create an unconstrained socket group and have the new socket  be the first member. For an unconstrained group, Winsock does not constrain all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_CONSTRAINED_GROUP"></a><a id="sg_constrained_group"></a><dl>
     * <dt><b>SG_CONSTRAINED_GROUP</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a constrained socket group and have the new socket  be the first member. For a contrained socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.  
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are not currently defined in a public header file.</div>
     * <div></div>
     * @param {Integer} dwFlags A set of flags used to specify additional socket attributes. 
     * 
     * A combination of these flags may be set, although some combinations are not allowed. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_OVERLAPPED"></a><a id="wsa_flag_overlapped"></a><dl>
     * <dt><b>WSA_FLAG_OVERLAPPED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that supports overlapped I/O operations.
     * 
     * Most sockets should be created with this flag set. Overlapped sockets can utilize 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> for overlapped I/O operations, which allow multiple operations to be initiated and in progress simultaneously. 
     * 
     * All functions that allow overlapped operation (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operations are <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_ROOT"></a><a id="wsa_flag_multipoint_c_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_ROOT</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_LEAF"></a><a id="wsa_flag_multipoint_c_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_LEAF</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_ROOT"></a><a id="wsa_flag_multipoint_d_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_ROOT</b></dt>
     * <dt>0x08</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_DATA_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_LEAF"></a><a id="wsa_flag_multipoint_d_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_LEAF</b></dt>
     * <dt>0x10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_DATA_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_ACCESS_SYSTEM_SECURITY"></a><a id="wsa_flag_access_system_security"></a><dl>
     * <dt><b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b></dt>
     * <dt>0x40</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access control list (SACL) as opposed to just a discretionary access control list (DACL).
     * 
     * SACLs are used for generating audits and alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the socket should be allowed to bind to a specific address specified to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function.
     * 
     * The <b>ACCESS_SYSTEM_SECURITY</b> access right controls the ability to get or set the SACL in an object's security descriptor. The system grants this access right only if the <b>SE_SECURITY_NAME</b> privilege is enabled in the access token of the requesting thread.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_NO_HANDLE_INHERIT"></a><a id="wsa_flag_no_handle_inherit"></a><dl>
     * <dt><b>WSA_FLAG_NO_HANDLE_INHERIT</b></dt>
     * <dt>0x80</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that is non-inheritable. 
     * 
     * A socket handle created by the <b>WSASocket</b> or the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function is inheritable by default. When this flag is set, the socket handle is non-inheritable. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-gethandleinformation">GetHandleInformation</a> function can be used to determine if a socket handle was created with the <b>WSA_FLAG_NO_HANDLE_INHERIT</b> flag set. The <b>GetHandleInformation</b> function will return that the <b>HANDLE_FLAG_INHERIT</b> value is set.
     * 
     * This flag is supported on Windows7 with SP1,  Windows Server2008R2 with SP1, and later 
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Important</b>For multipoint sockets, only one of <b>WSA_FLAG_MULTIPOINT_C_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_C_LEAF</b> flags can be specified, and only  one of <b>WSA_FLAG_MULTIPOINT_D_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_D_LEAF</b> flags can be specified. Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information.</div>
     * <div></div>
     * @returns {SOCKET} If no error occurs, 
     * <b>WSASocket</b> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>This error code description is Microsoft-specific.</div>
     * <div></div>
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProtocolInfo</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is true for any of the following conditions. 
     * 
     * 
     * 
     * 
     * <ul>
     * <li>The parameter <i>g</i> specified is not valid.</li>
     * <li>The 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that <i>lpProtocolInfo</i> points to is incomplete, the contents are invalid or the 
     * <b>WSAPROTOCOL_INFO</b> structure has already been used in an earlier duplicate socket operation.</li>
     * <li>The values specified for members of the socket triple &lt;<i>af</i>, <i>type</i>, and <i>protocol</i>&gt; are individually supported, but the given combination is not.</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned a version other than 2.2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROCTABLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned an invalid or incomplete procedure table to the 
     * <a href="/windows/desktop/api/ws2spi/nf-ws2spi-wspstartup">WSPStartup</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTOTYPE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is the wrong type for this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROVIDERFAILEDINIT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the provider fails to operate correctly. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified socket type is not supported in this address family.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasocketa
     * @deprecated
     * @since windows8.1
     */
    static WSASocketA(af, type, protocol, lpProtocolInfo, g, dwFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASocketA", "int", af, "int", type, "int", protocol, "ptr", lpProtocolInfo, "uint", g, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return SOCKET({Value: result}, True)
    }

    /**
     * The WSASocket function creates a socket that is bound to a specific transport-service provider.
     * @param {Integer} af The address family specification. Possible values for the address family are defined in the <i>Winsock2.h</i> header file. 
     * 
     * On the Windows SDK released for WindowsVista and later, the organization of header files has changed and the possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * The values currently supported are AF_INET or AF_INET6, which are the Internet
     *                      address family formats for IPv4 and IPv6. Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The table below lists common values for address family although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>Af</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_UNSPEC"></a><a id="af_unspec"></a><dl>
     * <dt><b>AF_UNSPEC</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family is unspecified.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IPX"></a><a id="af_ipx"></a><dl>
     * <dt><b>AF_IPX</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is installed. 
     * 
     * This address family is not supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_APPLETALK"></a><a id="af_appletalk"></a><dl>
     * <dt><b>AF_APPLETALK</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. 
     * 
     * This address family is not supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_NETBIOS"></a><a id="af_netbios"></a><dl>
     * <dt><b>AF_NETBIOS</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. 
     * 
     * The Windows Sockets provider for NetBIOS  is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit versions of Windows. 
     * 
     * The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows7,  Windows Server2008, WindowsVista, Windows Server2003, or WindowsXP.  
     * 
     * The Windows Sockets provider for NetBIOS  only supports sockets where the <i>type</i> parameter is set to <b>SOCK_DGRAM</b>.
     * 
     * The Windows Sockets provider for NetBIOS  is not directly related to the <a href="https://docs.microsoft.com/previous-versions/windows/desktop/netbios/portal">NetBIOS</a> programming interface. The NetBIOS programming interface is not supported on WindowsVista, Windows Server2008, and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_IRDA"></a><a id="af_irda"></a><dl>
     * <dt><b>AF_IRDA</b></dt>
     * <dt>26</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Infrared Data Association (IrDA) address family. 
     * 
     * This address family is only supported if the computer has an infrared port and driver installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_BTH"></a><a id="af_bth"></a><dl>
     * <dt><b>AF_BTH</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth address family. 
     * 
     * This address family is supported on WindowsXP with SP2 or later if the computer has a Bluetooth adapter and driver installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} type The type specification for the new socket. 
     * 
     * 
     * Possible values for the socket type are defined in the <i>Winsock2.h</i> header file.
     * 
     * The following table lists the possible values for the <i>type</i> parameter supported for Windows Sockets 2:
     * 
     * <table>
     * <tr>
     * <th>Type</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_STREAM"></a><a id="sock_stream"></a><dl>
     * <dt><b>SOCK_STREAM</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_DGRAM"></a><a id="sock_dgram"></a><dl>
     * <dt><b>SOCK_DGRAM</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RAW"></a><a id="sock_raw"></a><dl>
     * <dt><b>SOCK_RAW</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ip-socket-options">IP_HDRINCL</a> socket option must be set on the socket.  To manipulate the IPv6 header, the <a href="https://docs.microsoft.com/windows/desktop/WinSock/ipproto-ipv6-socket-options">IPV6_HDRINCL</a> socket option must be set on the socket.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_RDM"></a><a id="sock_rdm"></a><dl>
     * <dt><b>SOCK_RDM</b></dt>
     * <dt>4</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as <a href="https://docs.microsoft.com/windows/desktop/WinSock/reliable-multicast-programming--pgm-">reliable multicast programming</a>. 
     * 
     * This <i>type</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SOCK_SEQPACKET"></a><a id="sock_seqpacket"></a><dl>
     * <dt><b>SOCK_SEQPACKET</b></dt>
     * <dt>5</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket type that provides a pseudo-stream packet based on datagrams. 
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available transport protocol through the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumprotocolsa">WSAEnumProtocols</a> function. So an application can determine the possible socket type and protocol options for an address family  and use this information when specifying this parameter. Socket type definitions in the <i>Winsock2.h</i> and <i>Ws2def.h</i> header files will be periodically updated as new socket types, address families, and protocols are defined.
     * 
     * In Windows Sockets 1.1, the only possible socket types are <b>SOCK_DGRAM</b> and <b>SOCK_STREAM</b>.
     * @param {Integer} protocol The protocol to be used. The possible options for the <i>protocol</i> parameter are specific to the address family and socket type specified. Possible values for the <i>protocol</i> are defined are defined in the  <i>Winsock2.h</i> and <i>Wsrm.h</i> header files. 
     * 
     * On the Windows SDK released for WindowsVista and later,, the organization of header files has changed and this parameter can be one of the values from the <b>IPPROTO</b> enumeration type defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly.
     * 
     * If a value of  0 is specified, the caller does not
     *               wish to specify a protocol and the service provider will choose the <i>protocol</i> to use.
     * 
     * 
     * When the <i>af</i> parameter is AF_INET or AF_INET6 and the <i>type</i> is <b>SOCK_RAW</b>, the value specified for the <i>protocol</i> is set in the protocol field of the IPv6 or IPv4 packet header. 
     * 
     * The table below lists common values for the <i>protocol</i> although many other values are possible. 
     * 
     * <table>
     * <tr>
     * <th>protocol</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMP"></a><a id="ipproto_icmp"></a><dl>
     * <dt><b>IPPROTO_ICMP</b></dt>
     * <dt>1</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol (ICMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_IGMP"></a><a id="ipproto_igmp"></a><dl>
     * <dt><b>IPPROTO_IGMP</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Group Management Protocol (IGMP). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="BTHPROTO_RFCOMM"></a><a id="bthproto_rfcomm"></a><dl>
     * <dt><b>BTHPROTO_RFCOMM</b></dt>
     * <dt>3</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the <i>af</i> parameter is <b>AF_BTH</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>. 
     * 
     * This <i>protocol</i> value is supported on WindowsXP with SP2 or later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * <dt>6</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_STREAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * <dt>17</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP). This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> or <b>AF_INET6</b> and the <i>type</i> parameter is <b>SOCK_DGRAM</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_ICMPV6"></a><a id="ipproto_icmpv6"></a><dl>
     * <dt><b>IPPROTO_ICMPV6</b></dt>
     * <dt>58</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Control Message Protocol  Version 6 (ICMPv6). This is a possible value when the <i>af</i> parameter is <b>AF_UNSPEC</b>, <b>AF_INET</b>, or <b>AF_INET6</b>  and the <i>type</i> parameter is <b>SOCK_RAW</b> or unspecified.
     * 
     * This <i>protocol</i> value is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_RM"></a><a id="ipproto_rm"></a><dl>
     * <dt><b>IPPROTO_RM</b></dt>
     * <dt>113</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The PGM protocol for reliable multicast. This is a possible value when the <i>af</i> parameter is <b>AF_INET</b> and the <i>type</i> parameter is <b>SOCK_RDM</b>. On the Windows SDK released for WindowsVista and later,  this protocol is also called <b>IPPROTO_PGM</b>. 
     * 
     * This <i>protocol</i> value is only supported if the Reliable Multicast Protocol is installed.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that defines the characteristics of the socket to be created. If this parameter is not <b>NULL</b>, the socket will be bound to the provider associated with the indicated 
     * <b>WSAPROTOCOL_INFO</b> structure.
     * @param {Integer} g An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group. 
     * 
     * If <i>g</i> is an existing socket group ID, join the new socket to this
     *             socket group, provided all the requirements set by this group are met. 
     * 
     * If <i>g</i> is not an existing socket group ID, then the following values are possible.
     * 
     * <table>
     * <tr>
     * <th>g</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id=""></a><dl>
     * <dt><b></b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No group operation is performed. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_UNCONSTRAINED_GROUP"></a><a id="sg_unconstrained_group"></a><dl>
     * <dt><b>SG_UNCONSTRAINED_GROUP</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create an unconstrained socket group and have the new socket  be the first member. For an unconstrained group, Winsock does not constrain all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SG_CONSTRAINED_GROUP"></a><a id="sg_constrained_group"></a><dl>
     * <dt><b>SG_CONSTRAINED_GROUP</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a constrained socket group and have the new socket  be the first member. For a contrained socket group, Winsock constrains all sockets in the socket group to have been created with the same value for the <i>type</i> and <i>protocol</i> parameters. A constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the same address on the same host.  
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Note</b>The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are not currently defined in a public header file.</div>
     * <div></div>
     * @param {Integer} dwFlags A set of flags used to specify additional socket attributes. 
     * 
     * A combination of these flags may be set, although some combinations are not allowed. 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_OVERLAPPED"></a><a id="wsa_flag_overlapped"></a><dl>
     * <dt><b>WSA_FLAG_OVERLAPPED</b></dt>
     * <dt>0x01</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that supports overlapped I/O operations.
     * 
     * Most sockets should be created with this flag set. Overlapped sockets can utilize 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, and 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> for overlapped I/O operations, which allow multiple operations to be initiated and in progress simultaneously. 
     * 
     * All functions that allow overlapped operation (<a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasend">WSASend</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecv">WSARecv</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsasendto">WSASendTo</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom">WSARecvFrom</a>, 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>) also support nonoverlapped usage on an overlapped socket if the values for parameters related to overlapped operations are <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_ROOT"></a><a id="wsa_flag_multipoint_c_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_ROOT</b></dt>
     * <dt>0x02</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_C_LEAF"></a><a id="wsa_flag_multipoint_c_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_C_LEAF</b></dt>
     * <dt>0x04</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a c_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_CONTROL_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_ROOT"></a><a id="wsa_flag_multipoint_d_root"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_ROOT</b></dt>
     * <dt>0x08</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_root in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> and <b>XP1_MULTIPOINT_DATA_PLANE</b>  flags set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_MULTIPOINT_D_LEAF"></a><a id="wsa_flag_multipoint_d_leaf"></a><dl>
     * <dt><b>WSA_FLAG_MULTIPOINT_D_LEAF</b></dt>
     * <dt>0x10</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that will be a d_leaf in a multipoint session.
     * 
     * This attribute is only allowed if the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a multipoint session is non-rooted. This would be indicated by the <b>dwServiceFlags1</b> 
     *  member of the <b>WSAPROTOCOL_INFO</b> structure  with the <b>XP1_SUPPORT_MULTIPOINT</b> flag set and the <b>XP1_MULTIPOINT_DATA_PLANE</b>  flag not set. 
     * 
     * When the <i>lpProtocolInfo</i> parameter is not NULL, the  <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for the transport provider is pointed to by the <i>lpProtocolInfo</i> parameter.  When the <i>lpProtocolInfo</i> parameter is NULL, the  <b>WSAPROTOCOL_INFO</b> structure is based on the transport provider selected by the values specified for the  <i>af</i>, <i>type</i>, and <i>protocol</i> parameters. 
     * 
     * Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information on a multipoint session.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_ACCESS_SYSTEM_SECURITY"></a><a id="wsa_flag_access_system_security"></a><dl>
     * <dt><b>WSA_FLAG_ACCESS_SYSTEM_SECURITY</b></dt>
     * <dt>0x40</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access control list (SACL) as opposed to just a discretionary access control list (DACL).
     * 
     * SACLs are used for generating audits and alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the socket should be allowed to bind to a specific address specified to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-bind">bind</a> function.
     * 
     * The <b>ACCESS_SYSTEM_SECURITY</b> access right controls the ability to get or set the SACL in an object's security descriptor. The system grants this access right only if the <b>SE_SECURITY_NAME</b> privilege is enabled in the access token of the requesting thread.
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="WSA_FLAG_NO_HANDLE_INHERIT"></a><a id="wsa_flag_no_handle_inherit"></a><dl>
     * <dt><b>WSA_FLAG_NO_HANDLE_INHERIT</b></dt>
     * <dt>0x80</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Create a socket that is non-inheritable. 
     * 
     * A socket handle created by the <b>WSASocket</b> or the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-socket">socket</a> function is inheritable by default. When this flag is set, the socket handle is non-inheritable. 
     * 
     * The <a href="https://docs.microsoft.com/windows/desktop/api/handleapi/nf-handleapi-gethandleinformation">GetHandleInformation</a> function can be used to determine if a socket handle was created with the <b>WSA_FLAG_NO_HANDLE_INHERIT</b> flag set. The <b>GetHandleInformation</b> function will return that the <b>HANDLE_FLAG_INHERIT</b> value is set.
     * 
     * This flag is supported on Windows7 with SP1,  Windows Server2008R2 with SP1, and later 
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * <div class="alert"><b>Important</b>For multipoint sockets, only one of <b>WSA_FLAG_MULTIPOINT_C_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_C_LEAF</b> flags can be specified, and only  one of <b>WSA_FLAG_MULTIPOINT_D_ROOT</b> or <b>WSA_FLAG_MULTIPOINT_D_LEAF</b> flags can be specified. Refer to 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/multipoint-and-multicast-semantics-2">Multipoint and Multicast Semantics</a> for additional information.</div>
     * <div></div>
     * @returns {SOCKET} If no error occurs, 
     * <b>WSASocket</b> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <div class="alert"><b>Note</b>This error code description is Microsoft-specific.</div>
     * <div></div>
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProtocolInfo</i> parameter is not in a valid part of the process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This value is true for any of the following conditions. 
     * 
     * 
     * 
     * 
     * <ul>
     * <li>The parameter <i>g</i> specified is not valid.</li>
     * <li>The 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure that <i>lpProtocolInfo</i> points to is incomplete, the contents are invalid or the 
     * <b>WSAPROTOCOL_INFO</b> structure has already been used in an earlier duplicate socket operation.</li>
     * <li>The values specified for members of the socket triple &lt;<i>af</i>, <i>type</i>, and <i>protocol</i>&gt; are individually supported, but the given combination is not.</li>
     * </ul>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned a version other than 2.2.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROCTABLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider returned an invalid or incomplete procedure table to the 
     * <a href="/windows/desktop/api/ws2spi/nf-ws2spi-wspstartup">WSPStartup</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMFILE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No more socket descriptors are available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available. The socket cannot be created.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTONOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROTOTYPE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified protocol is the wrong type for this socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEPROVIDERFAILEDINIT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was improperly installed or the provider fails to operate correctly. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified socket type is not supported in this address family.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasocketw
     * @since windows8.1
     */
    static WSASocketW(af, type, protocol, lpProtocolInfo, g, dwFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASocketW", "int", af, "int", type, "int", protocol, "ptr", lpProtocolInfo, "uint", g, "uint", dwFlags, "ptr")
        if(A_LastError)
            throw OSError()

        return SOCKET({Value: result}, True)
    }

    /**
     * Returns when one or all of the specified event objects are in the signaled state, when the time-out interval expires, or when an I/O completion routine has executed.
     * @param {Integer} cEvents The number of event object handles in the array pointed to by <i>lphEvents</i>. The maximum number of event object handles is <b>WSA_MAXIMUM_WAIT_EVENTS</b>. One or more events must be specified.
     * @param {Pointer<HANDLE>} lphEvents A pointer to an array of event object handles. The array can contain handles of objects of different types. It may not contain multiple copies of the same handle if the <i>fWaitAll</i> parameter is set to <b>TRUE</b>. 
     * If one of these handles is closed while the wait is still pending, the behavior of <b>WSAWaitForMultipleEvents</b> is undefined.
     * 
     * The handles must have the <b>SYNCHRONIZE</b> access right.  For more information, see <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/standard-access-rights">Standard Access Rights</a>.
     * @param {BOOL} fWaitAll A value that specifies the wait type. If <b>TRUE</b>, the function returns when the state of all objects in the <i>lphEvents</i> array is signaled. If <b>FALSE</b>, the function returns when any  of the event objects is signaled. In the latter case, the return value minus <b>WSA_WAIT_EVENT_0</b> indicates the index of the event object whose state caused the function to return. If more than one event object became signaled during the call, this is the array index to the signaled event object with the smallest index value of all the signaled event objects.
     * @param {Integer} dwTimeout The time-out interval, in milliseconds. <b>WSAWaitForMultipleEvents</b> returns if the time-out interval expires, even if conditions specified by the <i>fWaitAll</i> parameter are not satisfied. If the <i>dwTimeout</i> parameter is zero, <b>WSAWaitForMultipleEvents</b> tests the state of the specified event objects and returns immediately. If <i>dwTimeout</i> is <b>WSA_INFINITE</b>, <b>WSAWaitForMultipleEvents</b> waits forever; that is, the time-out interval never expires.
     * @param {BOOL} fAlertable A value that specifies whether the thread is placed in an alertable wait state so the system can execute I/O completion routines. If <b>TRUE</b>, the thread is placed in an alertable wait state and <b>WSAWaitForMultipleEvents</b> can return when the system executes an I/O completion routine. In this case, <b>WSA_WAIT_IO_COMPLETION</b> is returned and the event that was being waited on is not signaled yet. The application must call the <b>WSAWaitForMultipleEvents</b> function again. If <b>FALSE</b>, the thread is not placed in an alertable wait state and I/O completion routines are not executed.
     * @returns {Integer} If the 
     * <b>WSAWaitForMultipleEvents</b> function succeeds,  the return value upon success is one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Return Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSA_WAIT_EVENT_0 to (WSA_WAIT_EVENT_0 + cEvents - 1)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the <i>fWaitAll</i> parameter is <b>TRUE</b>, the return value indicates that all specified event objects is signaled. 
     * 
     * If the <i>fWaitAll</i> parameter is <b>FALSE</b>, the return value minus <b>WSA_WAIT_EVENT_0</b> indicates the <i>lphEvents</i> array index of the signaled event object that satisfied the wait. If more than one event object became signaled during the call, the return value indicates the <i>lphEvents</i> array index of the signaled event object with the smallest index value of all the signaled event objects. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSA_WAIT_IO_COMPLETION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The wait was ended by one or more I/O completion routines that were executed. The event that was being waited on is not signaled yet. The application must call the <a href="/windows/desktop/api/winsock2/nf-winsock2-wsawaitformultipleevents">WSAWaitForMultipleEvents</a> function again. This return value can only be returned if the <i>fAlertable</i> parameter is <b>TRUE</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>WSA_WAIT_TIMEOUT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The time-out interval elapsed and the conditions specified by the <i>fWaitAll</i> parameter were not satisfied. No I/O completion routines were executed.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * If the <b>WSAWaitForMultipleEvents</b> function fails, the return value is <b>WSA_WAIT_FAILED</b>. The following table lists values that can be used with <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> to get extended error information. 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></td>
     * <td>A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></td>
     * <td>The network subsystem has failed.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></td>
     * <td>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>Not enough free memory was available to complete the operation.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></td>
     * <td>One or more of the values in the <i>lphEvents</i> array is not a valid event object handle.</td>
     * </tr>
     * <tr>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></td>
     * <td>The <i>cEvents</i> parameter does not contain a valid handle count.</td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsawaitformultipleevents
     * @since windows8.1
     */
    static WSAWaitForMultipleEvents(cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAWaitForMultipleEvents", "uint", cEvents, "ptr", lphEvents, "int", fWaitAll, "uint", dwTimeout, "int", fAlertable, "uint")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts all components of a sockaddr structure into a human-readable string representation of the address.
     * @param {Pointer} lpsaAddress A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure to translate into a string.
     * @param {Integer} dwAddressLength The length, in bytes, of the address in the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>lpsaAddress</i> parameter. The <i>dwAddressLength</i> parameter may vary in size with different protocols.
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for a particular provider. If this is parameter is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the address family indicated in the <i>lpsaAddress</i> parameter.
     * @param {PSTR} lpszAddressString A pointer to the buffer that receives the human-readable address string.
     * @param {Pointer<Integer>} lpdwAddressStringLength On input, this parameter specifies the length of the buffer pointed to by the <i>lpszAddressString</i> parameter. The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the string including the <b>NULL</b> terminator actually copied into the buffer pointed to by the <i>lpszAddressString</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size.
     * @returns {Integer} If no error occurs, 
     * <b>WSAAddressToString</b> returns a value of zero. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>lpcsAddress</i>, <i>lpProtocolInfo</i>, and <i>lpszAddressString</i> parameters point to memory that is not all in the address space of the process, or the buffer pointed to by the <i>lpszAddressString</i> parameter is too small. Pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed. This error is returned if the <i>lpsaAddress</i>, <i>dwAddressLength</i>, or <i>lpdwAddressStringLength</i> parameter are <b>NULL</b>. This error is also returned if the specified address is not a valid socket address, or no transport provider supports the indicated address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Winsock 2 DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaaddresstostringa
     * @deprecated
     * @since windows8.1
     */
    static WSAAddressToStringA(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength) {
        lpszAddressString := lpszAddressString is String ? StrPtr(lpszAddressString) : lpszAddressString

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAddressToStringA", "ptr", lpsaAddress, "uint", dwAddressLength, "ptr", lpProtocolInfo, "ptr", lpszAddressString, "uint*", lpdwAddressStringLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Converts all components of a sockaddr structure into a human-readable string representation of the address.
     * @param {Pointer} lpsaAddress A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure to translate into a string.
     * @param {Integer} dwAddressLength The length, in bytes, of the address in the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure pointed to by the <i>lpsaAddress</i> parameter. The <i>dwAddressLength</i> parameter may vary in size with different protocols.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure for a particular provider. If this is parameter is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the address family indicated in the <i>lpsaAddress</i> parameter.
     * @param {PWSTR} lpszAddressString A pointer to the buffer that receives the human-readable address string.
     * @param {Pointer<Integer>} lpdwAddressStringLength On input, this parameter specifies the length of the buffer pointed to by the <i>lpszAddressString</i> parameter. The length is represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the string including the <b>NULL</b> terminator actually copied into the buffer pointed to by the <i>lpszAddressString</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size.
     * @returns {Integer} If no error occurs, 
     * <b>WSAAddressToString</b> returns a value of zero. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified <i>lpcsAddress</i>, <i>lpProtocolInfo</i>, and <i>lpszAddressString</i> parameters point to memory that is not all in the address space of the process, or the buffer pointed to by the <i>lpszAddressString</i> parameter is too small. Pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed. This error is returned if the <i>lpsaAddress</i>, <i>dwAddressLength</i>, or <i>lpdwAddressStringLength</i> parameter are <b>NULL</b>. This error is also returned if the specified address is not a valid socket address, or no transport provider supports the indicated address family.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Winsock 2 DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaaddresstostringw
     * @since windows8.1
     */
    static WSAAddressToStringW(lpsaAddress, dwAddressLength, lpProtocolInfo, lpszAddressString, lpdwAddressStringLength) {
        lpszAddressString := lpszAddressString is String ? StrPtr(lpszAddressString) : lpszAddressString

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAddressToStringW", "ptr", lpsaAddress, "uint", dwAddressLength, "ptr", lpProtocolInfo, "ptr", lpszAddressString, "uint*", lpdwAddressStringLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAStringToAddress function converts a network address in its standard text presentation form into its numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure.
     * @param {PSTR} AddressString A pointer to the zero-terminated string that contains the network address in standard text form to convert.
     * @param {Integer} AddressFamily The address family of the network address pointed to by the <i>AddressString</i> parameter.
     * @param {Pointer<WSAPROTOCOL_INFOA>} lpProtocolInfo The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure associated with the provider to be used. If this is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the indicated <i>AddressFamily</i>.
     * @param {Pointer} lpAddress A pointer to a buffer that is filled with a  <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the address string if the function succeeds.
     * @param {Pointer<Integer>} lpAddressLength A pointer to the length, in bytes, of the buffer pointed to by the <i>lpAddress</i> parameter. If the function call is successful, this parameter returns a pointer to the size of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure returned in the <i>lpAddress</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size in bytes.
     * @returns {Integer} The return value for 
     * <b>WSAStringToAddress</b> is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by the <i>lpAddress</i> parameter is too small. Pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The functions was unable to translate the string into a 
     * <a href="/windows/desktop/WinSock/sockaddr-2">sockaddr</a>. See the following Remarks section for more information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Socket functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsastringtoaddressa
     * @deprecated
     * @since windows8.1
     */
    static WSAStringToAddressA(AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAStringToAddressA", "ptr", AddressString, "int", AddressFamily, "ptr", lpProtocolInfo, "ptr", lpAddress, "int*", lpAddressLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAStringToAddress function converts a network address in its standard text presentation form into its numeric binary form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure.
     * @param {PWSTR} AddressString A pointer to the zero-terminated string that contains the network address in standard text form to convert.
     * @param {Integer} AddressFamily The address family of the network address pointed to by the <i>AddressString</i> parameter.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfo The 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure associated with the provider to be used. If this is <b>NULL</b>, the call is routed to the provider of the first protocol supporting the indicated <i>AddressFamily</i>.
     * @param {Pointer} lpAddress A pointer to a buffer that is filled with a  <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure for the address string if the function succeeds.
     * @param {Pointer<Integer>} lpAddressLength A pointer to the length, in bytes, of the buffer pointed to by the <i>lpAddress</i> parameter. If the function call is successful, this parameter returns a pointer to the size of the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure returned in the <i>lpAddress</i> parameter. If the specified buffer is not large enough, the function fails with a specific error of 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a> and this parameter is updated with the required size in bytes.
     * @returns {Integer} The return value for 
     * <b>WSAStringToAddress</b> is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by the <i>lpAddress</i> parameter is too small. Pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The functions was unable to translate the string into a 
     * <a href="/windows/desktop/WinSock/sockaddr-2">sockaddr</a>. See the following Remarks section for more information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Socket functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsastringtoaddressw
     * @since windows8.1
     */
    static WSAStringToAddressW(AddressString, AddressFamily, lpProtocolInfo, lpAddress, lpAddressLength) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAStringToAddressW", "ptr", AddressString, "int", AddressFamily, "ptr", lpProtocolInfo, "ptr", lpAddress, "int*", lpAddressLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSALookupServiceBegin function initiates a client query that is constrained by the information contained within a WSAQUERYSET structure.
     * @param {Pointer<WSAQUERYSETA>} lpqsRestrictions A pointer to the search criteria. See the Remarks for details.
     * @param {Integer} dwControlFlags A set of flags that controls the depth of the search.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HANDLE>} lphLookup A  handle to be used when calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> in order to start retrieving the results set.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters were missing or invalid for this provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name was found in the database but no data matching the given restrictions was located.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASERVICE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such service is known. The service cannot be found in the specified name space.
     * 
     * This error is returned for a bluetooth service discovery request if no remote bluetooth devices were found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsalookupservicebegina
     * @deprecated
     * @since windows8.1
     */
    static WSALookupServiceBeginA(lpqsRestrictions, dwControlFlags, lphLookup) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSALookupServiceBeginA", "ptr", lpqsRestrictions, "uint", dwControlFlags, "ptr", lphLookup, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSALookupServiceBegin function initiates a client query that is constrained by the information contained within a WSAQUERYSET structure.
     * @param {Pointer<WSAQUERYSETW>} lpqsRestrictions A pointer to the search criteria. See the Remarks for details.
     * @param {Integer} dwControlFlags A set of flags that controls the depth of the search.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<HANDLE>} lphLookup A  handle to be used when calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> in order to start retrieving the results set.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more parameters were missing or invalid for this provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name was found in the database but no data matching the given restrictions was located.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASERVICE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such service is known. The service cannot be found in the specified name space.
     * 
     * This error is returned for a bluetooth service discovery request if no remote bluetooth devices were found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsalookupservicebeginw
     * @since windows8.1
     */
    static WSALookupServiceBeginW(lpqsRestrictions, dwControlFlags, lphLookup) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSALookupServiceBeginW", "ptr", lpqsRestrictions, "uint", dwControlFlags, "ptr", lphLookup, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSALookupServiceNext function is called after obtaining a handle from a previous call to WSALookupServiceBegin in order to retrieve the requested service information.
     * @param {HANDLE} hLookup A handle returned from the previous call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * @param {Integer} dwControlFlags A set of flags that controls the operation. The values passed in the <i>dwControlFlags</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>function determine the possible criteria. Any values passed in the <i>dwControlFlags</i> parameter to the <b>WSALookupServiceNext</b> function further restrict the criteria for the service lookup. 
     * 
     * Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result setwhich was too largeand move on to the next set for this call.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <b>WSALookupServiceNext</b>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <b>WSALookupServiceNext</b>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, then it contains the minimum number of bytes to pass for the <i>lpqsResults</i> to retrieve the record.
     * @param {Pointer} lpqsResults A pointer to a block of memory, which will contain one result set in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure on return.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_CANCELLED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A call to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsalookupserviceend">WSALookupServiceEnd</a> was made while this call was still processing. The call has been canceled. The data in the <i>lpqsResults</i> buffer is undefined. In Windows Sockets version 2, conflicting error codes are defined for <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECANCELLED</a> (10103) and <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_CANCELLED</a> (10111). The error code WSAECANCELLED will be removed in a future version and only WSA_E_CANCELLED will remain. For Windows Sockets version 2, however, applications should check for both WSAECANCELLED and WSA_E_CANCELLED for the widest possible compatibility with namespace providers that use either one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_NO_MORE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no more data available. In Windows Sockets version 2, conflicting error codes are defined for <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOMORE</a> (10102) and <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_NO_MORE</a> (10110). The error code WSAENOMORE will be removed in a future version and only WSA_E_NO_MORE will remain. For Windows Sockets version 2, however, applications should check for both WSAENOMORE and WSA_E_NO_MORE for the widest possible compatibility with name-space providers that use either one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpqsResults</i> buffer was too small to contain a 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more required parameters were invalid or missing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified Lookup handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name was found in the database, but no data matching the given restrictions was located.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsalookupservicenexta
     * @deprecated
     * @since windows8.1
     */
    static WSALookupServiceNextA(hLookup, dwControlFlags, lpdwBufferLength, lpqsResults) {
        hLookup := hLookup is Win32Handle ? NumGet(hLookup, "ptr") : hLookup

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSALookupServiceNextA", "ptr", hLookup, "uint", dwControlFlags, "uint*", lpdwBufferLength, "ptr", lpqsResults, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSALookupServiceNext function is called after obtaining a handle from a previous call to WSALookupServiceBegin in order to retrieve the requested service information.
     * @param {HANDLE} hLookup A handle returned from the previous call to 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * @param {Integer} dwControlFlags A set of flags that controls the operation. The values passed in the <i>dwControlFlags</i> parameter to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>function determine the possible criteria. Any values passed in the <i>dwControlFlags</i> parameter to the <b>WSALookupServiceNext</b> function further restrict the criteria for the service lookup. 
     * 
     * Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not (or cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result setwhich was too largeand move on to the next set for this call.
     * 
     * Supported values for the <i>dwControlFlags</i> parameter are defined in the <i>Winsock2.h</i> header file and can be a combination of the following options.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_DEEP"></a><a id="lup_deep"></a><dl>
     * <dt><b>LUP_DEEP</b></dt>
     * <dt>0x0001</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Queries deep as opposed to just the first level.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_CONTAINERS"></a><a id="lup_containers"></a><dl>
     * <dt><b>LUP_CONTAINERS</b></dt>
     * <dt>0x0002</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Returns containers only.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NOCONTAINERS"></a><a id="lup_nocontainers"></a><dl>
     * <dt><b>LUP_NOCONTAINERS</b></dt>
     * <dt>0x0004</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Do not return containers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_NEAREST"></a><a id="lup_nearest"></a><dl>
     * <dt><b>LUP_NEAREST</b></dt>
     * <dt>0x0008</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If possible, returns results in the order of distance. The measure of distance is provider specific.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_NAME"></a><a id="lup_return_name"></a><dl>
     * <dt><b>LUP_RETURN_NAME</b></dt>
     * <dt>0x0010</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the name as <i>lpszServiceInstanceName</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_TYPE"></a><a id="lup_return_type"></a><dl>
     * <dt><b>LUP_RETURN_TYPE</b></dt>
     * <dt>0x0020</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the type as <i>lpServiceClassId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_VERSION"></a><a id="lup_return_version"></a><dl>
     * <dt><b>LUP_RETURN_VERSION</b></dt>
     * <dt>0x0040</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the version as <i>lpVersion</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_COMMENT"></a><a id="lup_return_comment"></a><dl>
     * <dt><b>LUP_RETURN_COMMENT</b></dt>
     * <dt>0x0080</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the comment as <i>lpszComment</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ADDR"></a><a id="lup_return_addr"></a><dl>
     * <dt><b>LUP_RETURN_ADDR</b></dt>
     * <dt>0x0100</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the addresses as <i>lpcsaBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_BLOB"></a><a id="lup_return_blob"></a><dl>
     * <dt><b>LUP_RETURN_BLOB</b></dt>
     * <dt>0x0200</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the private data as <i>lpBlob</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALIASES"></a><a id="lup_return_aliases"></a><dl>
     * <dt><b>LUP_RETURN_ALIASES</b></dt>
     * <dt>0x0400</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Any available alias information is to be returned in successive calls to 
     * <b>WSALookupServiceNext</b>, and each alias returned will have the RESULT_IS_ALIAS flag set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_QUERY_STRING"></a><a id="lup_return_query_string"></a><dl>
     * <dt><b>LUP_RETURN_QUERY_STRING</b></dt>
     * <dt>0x0800</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Retrieves the query string used for the request.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RETURN_ALL"></a><a id="lup_return_all"></a><dl>
     * <dt><b>LUP_RETURN_ALL</b></dt>
     * <dt>0x0FF0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of flags that retrieves all of the LUP_RETURN_* values.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHPREVIOUS"></a><a id="lup_flushprevious"></a><dl>
     * <dt><b>LUP_FLUSHPREVIOUS</b></dt>
     * <dt>0x1000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Used as a value for the <i>dwControlFlags</i> parameter in 
     * <b>WSALookupServiceNext</b>. Setting this flag instructs the provider to discard the last result set, which was too large for the specified buffer, and move on to the next result set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_FLUSHCACHE"></a><a id="lup_flushcache"></a><dl>
     * <dt><b>LUP_FLUSHCACHE</b></dt>
     * <dt>0x2000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If the provider has been caching information, ignores the cache, and queries the namespace itself.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="LUP_RES_SERVICE"></a><a id="lup_res_service"></a><dl>
     * <dt><b>LUP_RES_SERVICE</b></dt>
     * <dt>0x8000</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This indicates whether prime response is in the remote or local part of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structure. The other part needs to be usable in either case.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpqsResults</i>. On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, then it contains the minimum number of bytes to pass for the <i>lpqsResults</i> to retrieve the record.
     * @param {Pointer} lpqsResults A pointer to a block of memory, which will contain one result set in a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> structure on return.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_CANCELLED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A call to 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsalookupserviceend">WSALookupServiceEnd</a> was made while this call was still processing. The call has been canceled. The data in the <i>lpqsResults</i> buffer is undefined. In Windows Sockets version 2, conflicting error codes are defined for <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECANCELLED</a> (10103) and <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_CANCELLED</a> (10111). The error code WSAECANCELLED will be removed in a future version and only WSA_E_CANCELLED will remain. For Windows Sockets version 2, however, applications should check for both WSAECANCELLED and WSA_E_CANCELLED for the widest possible compatibility with namespace providers that use either one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_NO_MORE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There is no more data available. In Windows Sockets version 2, conflicting error codes are defined for <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOMORE</a> (10102) and <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_E_NO_MORE</a> (10110). The error code WSAENOMORE will be removed in a future version and only WSA_E_NO_MORE will remain. For Windows Sockets version 2, however, applications should check for both WSAENOMORE and WSA_E_NO_MORE for the widest possible compatibility with name-space providers that use either one.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpqsResults</i> buffer was too small to contain a 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaquerysetw">WSAQUERYSET</a> set.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more required parameters were invalid or missing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified Lookup handle is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The name was found in the database, but no data matching the given restrictions was located.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsalookupservicenextw
     * @since windows8.1
     */
    static WSALookupServiceNextW(hLookup, dwControlFlags, lpdwBufferLength, lpqsResults) {
        hLookup := hLookup is Win32Handle ? NumGet(hLookup, "ptr") : hLookup

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSALookupServiceNextW", "ptr", hLookup, "uint", dwControlFlags, "uint*", lpdwBufferLength, "ptr", lpqsResults, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Enables developers to make I/O control calls to a registered namespace.
     * @param {HANDLE} hLookup The lookup handle returned from a previous call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function.
     * @param {Integer} dwControlCode The control code of the operation to perform.
     * 
     * 
     * The values that may be used for the <i>dwControlCode</i> parameter are determined by the namespace provider. 
     * 
     * The following value is supported by several Microsoft namespace providers including the Network Location Awareness (NS_NLA) namespace provider. This IOCTL is defined in the Winsock2.h header file.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SIO_NSP_NOTIFY_CHANGE"></a><a id="sio_nsp_notify_change"></a><dl>
     * <dt><b>SIO_NSP_NOTIFY_CHANGE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This operation checks if the results returned with previous calls using the <i>hLookup</i> parameter are still valid.  These previous calls include the initial call to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a> function to retrieve the <i>hLookup</i> parameter.  These previous calls may also include calls to the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicenexta">WSALookupServiceNext</a> function using the <i>hLookup</i> parameter. 
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} lpvInBuffer A pointer to the input buffer.
     * @param {Integer} cbInBuffer The size, in bytes, of the input buffer.
     * @param {Pointer} lpvOutBuffer A pointer to the output buffer.
     * @param {Integer} cbOutBuffer The size, in bytes, of the output buffer.
     * @param {Pointer<Integer>} lpcbBytesReturned A pointer to the number of bytes returned.
     * @param {Pointer<WSACOMPLETION>} lpCompletion A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsacompletion">WSACOMPLETION</a> structure, used for asynchronous processing. Set <i>lpCompletion</i> to <b>NULL</b> to force blocking (synchronous) execution.
     * @returns {Integer} Success returns NO_ERROR. Failure returns SOCKET_ERROR, and a specific error code can be retrieved by calling the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function. The following table describes the error codes.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>hLookup</i> parameter was not a valid query handle returned by 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped operation was successfully initiated and completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpvInBuffer</i>, <i>cbInBuffer</i>, <i>lpvOutBuffer</i>, <i>cbOutBuffer</i>, or <i>lpCompletion</i> argument is not totally contained in a valid part of the user address space. Alternatively, the <i>cbInBuffer</i> or <i>cbOutBuffer</i> argument is too small, and the argument is modified to reflect the required allocation size.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A supplied parameter is not acceptable, or the operation inappropriately returns results from multiple namespaces when it does not make sense for the specified operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not supported. This error is returned if the namespace provider does not implement this function. This error can also be returned if the specified <i>dwControlCode</i> is an unrecognized command.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not using overlapped I/O (asynchronous processing), yet the <i>lpCompletion</i> parameter is non-<b>NULL</b>.
     * 
     * This error is used as a special notification for the SIO_NSP_NOTIFY_CHANGE IOCTL when the <i>lpCompletion</i> parameter is <b>NULL</b> (a poll) to indicate that a query set remains valid.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsanspioctl
     * @since windows8.1
     */
    static WSANSPIoctl(hLookup, dwControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpCompletion) {
        hLookup := hLookup is Win32Handle ? NumGet(hLookup, "ptr") : hLookup

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSANSPIoctl", "ptr", hLookup, "uint", dwControlCode, "ptr", lpvInBuffer, "uint", cbInBuffer, "ptr", lpvOutBuffer, "uint", cbOutBuffer, "uint*", lpcbBytesReturned, "ptr", lpCompletion, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSALookupServiceEnd function is called to free the handle after previous calls to WSALookupServiceBegin and WSALookupServiceNext.
     * @param {HANDLE} hLookup Handle previously obtained by calling 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsalookupservicebegina">WSALookupServiceBegin</a>.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The handle is not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsalookupserviceend
     * @since windows8.1
     */
    static WSALookupServiceEnd(hLookup) {
        hLookup := hLookup is Win32Handle ? NumGet(hLookup, "ptr") : hLookup

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSALookupServiceEnd", "ptr", hLookup, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAInstallServiceClass function registers a service class schema within a namespace.
     * @param {Pointer<WSASERVICECLASSINFOA>} lpServiceClassInfo Service class to namespace specifictype mapping information. Multiple mappings can be handled at one time. 
     * 
     * 
     * 
     * 
     * See the section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/name-resolution-data-structures-2">Service Class Data Structures</a> for a description of pertinent data structures.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The namespace provider cannot supply the requested class information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling function does not have sufficient privileges to install the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Service class information has already been registered for this service class identifier. To modify service class information, first use 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaremoveserviceclass">WSARemoveServiceClass</a>, and then reinstall with updated class information data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service class information was not valid or improperly structured. This error is returned if the <i>lpServiceClassInfo</i> parameter is <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not supported. This error is returned if the namespace provider does not implement this function. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsainstallserviceclassa
     * @deprecated
     * @since windows5.0
     */
    static WSAInstallServiceClassA(lpServiceClassInfo) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAInstallServiceClassA", "ptr", lpServiceClassInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAInstallServiceClass function registers a service class schema within a namespace.
     * @param {Pointer<WSASERVICECLASSINFOW>} lpServiceClassInfo Service class to namespace specifictype mapping information. Multiple mappings can be handled at one time. 
     * 
     * 
     * 
     * 
     * See the section 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/name-resolution-data-structures-2">Service Class Data Structures</a> for a description of pertinent data structures.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The namespace provider cannot supply the requested class information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling function does not have sufficient privileges to install the service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEALREADY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Service class information has already been registered for this service class identifier. To modify service class information, first use 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaremoveserviceclass">WSARemoveServiceClass</a>, and then reinstall with updated class information data.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The service class information was not valid or improperly structured. This error is returned if the <i>lpServiceClassInfo</i> parameter is <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not supported. This error is returned if the namespace provider does not implement this function. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsainstallserviceclassw
     * @since windows5.0
     */
    static WSAInstallServiceClassW(lpServiceClassInfo) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAInstallServiceClassW", "ptr", lpServiceClassInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSARemoveServiceClass function permanently removes the service class schema from the registry.
     * @param {Pointer<Guid>} lpServiceClassId Pointer to the GUID for the service class you want to remove.
     * @returns {Integer} The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified class was not found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to remove the Service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETOOMANYREFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There are service instances that still reference the class. Removal of this class is not possible at this time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified GUID was not valid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * <div></div>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaremoveserviceclass
     * @since windows5.0
     */
    static WSARemoveServiceClass(lpServiceClassId) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSARemoveServiceClass", "ptr", lpServiceClassId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAGetServiceClassInfo function retrieves the class information (schema) pertaining to a specified service class from a specified namespace provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID that identifies a specific namespace provider.
     * @param {Pointer<Guid>} lpServiceClassId A pointer to a GUID identifying the service class.
     * @param {Pointer<Integer>} lpdwBufSize On input, the number of bytes contained in the buffer pointed to by the <i>lpServiceClassInfo</i> parameter. 
     * 
     * On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, this parameter specifies the minimum size, in bytes, of the buffer pointed to <i>lpServiceClassInfo</i> needed to retrieve the record.
     * @param {Pointer} lpServiceClassInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaserviceclassinfow">WSASERVICECLASSINFO</a> structure that contains the service class information from the indicated namespace provider for the specified service class.
     * @returns {Integer} The return value is zero if the 
     * <b>WSAGetServiceClassInfo</b> was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to access the information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by the <i>lpServiceClassInfo</i> parameter is too small to contain a WSASERVICECLASSINFOW. The application needs to pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified service class identifier or namespace provider identifier is not valid. This error is returned if the <i>lpProviderId</i>, <i>lpServiceClassId</i>, <i>lpdwBufSize</i>, or <i>lpServiceClassInfo</i> parameters are <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not supported for the type of object referenced. This error is returned by some namespace providers that do not support getting service class information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified class was not found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsagetserviceclassinfoa
     * @deprecated
     * @since windows5.0
     */
    static WSAGetServiceClassInfoA(lpProviderId, lpServiceClassId, lpdwBufSize, lpServiceClassInfo) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetServiceClassInfoA", "ptr", lpProviderId, "ptr", lpServiceClassId, "uint*", lpdwBufSize, "ptr", lpServiceClassInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAGetServiceClassInfo function retrieves the class information (schema) pertaining to a specified service class from a specified namespace provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID that identifies a specific namespace provider.
     * @param {Pointer<Guid>} lpServiceClassId A pointer to a GUID identifying the service class.
     * @param {Pointer<Integer>} lpdwBufSize On input, the number of bytes contained in the buffer pointed to by the <i>lpServiceClassInfo</i> parameter. 
     * 
     * On output, if the function fails and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>, this parameter specifies the minimum size, in bytes, of the buffer pointed to <i>lpServiceClassInfo</i> needed to retrieve the record.
     * @param {Pointer} lpServiceClassInfo A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaserviceclassinfow">WSASERVICECLASSINFO</a> structure that contains the service class information from the indicated namespace provider for the specified service class.
     * @returns {Integer} The return value is zero if the 
     * <b>WSAGetServiceClassInfo</b> was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to access the information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by the <i>lpServiceClassInfo</i> parameter is too small to contain a WSASERVICECLASSINFOW. The application needs to pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified service class identifier or namespace provider identifier is not valid. This error is returned if the <i>lpProviderId</i>, <i>lpServiceClassId</i>, <i>lpdwBufSize</i>, or <i>lpServiceClassInfo</i> parameters are <b>NULL</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not supported for the type of object referenced. This error is returned by some namespace providers that do not support getting service class information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified class was not found.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsagetserviceclassinfow
     * @since windows5.0
     */
    static WSAGetServiceClassInfoW(lpProviderId, lpServiceClassId, lpdwBufSize, lpServiceClassInfo) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetServiceClassInfoW", "ptr", lpProviderId, "ptr", lpServiceClassId, "uint*", lpdwBufSize, "ptr", lpServiceClassInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAEnumNameSpaceProviders function retrieves information on available namespace providers.
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to pass for the <i>lpnspBuffer</i> to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProviders</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProviders</b>.
     * @returns {Integer} The 
     * <b>WSAEnumNameSpaceProviders</b> function returns the number of 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures copied into <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures and associated information. When this error is returned, the buffer length required is returned in the <i>lpdwBufferLength</i> parameter. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaenumnamespaceprovidersa
     * @deprecated
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersA(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersA", "uint*", lpdwBufferLength, "ptr", lpnspBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAEnumNameSpaceProviders function retrieves information on available namespace providers.
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to pass for the <i>lpnspBuffer</i> to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProviders</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProviders</b>.
     * @returns {Integer} The 
     * <b>WSAEnumNameSpaceProviders</b> function returns the number of 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures copied into <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a> structures and associated information. When this error is returned, the buffer length required is returned in the <i>lpdwBufferLength</i> parameter. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaenumnamespaceprovidersw
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersW(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersW", "uint*", lpdwBufferLength, "ptr", lpnspBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information on available namespace providers.
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProvidersEx</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProvidersEx</b>.
     * @returns {Integer} The 
     * <b>WSAEnumNameSpaceProvidersEx</b> function returns the number of 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures copied into <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures and associated information. When this error is returned, the buffer length required is returned in the <i>lpdwBufferLength</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaenumnamespaceprovidersexa
     * @deprecated
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersExA(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersExA", "uint*", lpdwBufferLength, "ptr", lpnspBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Retrieves information on available namespace providers.
     * @param {Pointer<Integer>} lpdwBufferLength On input, the number of bytes contained in the buffer pointed to by <i>lpnspBuffer</i>. On output (if the function fails, and the error is 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a>), the minimum number of bytes to allocate for the <i>lpnspBuffer</i> buffer to allow it to retrieve all the requested information. The buffer passed to <b>WSAEnumNameSpaceProvidersEx</b> must be sufficient to hold all of the namespace information.
     * @param {Pointer} lpnspBuffer A buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures. The returned structures are located consecutively at the head of the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of 
     * <b>WSAEnumNameSpaceProvidersEx</b>.
     * @returns {Integer} The 
     * <b>WSAEnumNameSpaceProvidersEx</b> function returns the number of 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures copied into <i>lpnspBuffer</i>. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpnspBuffer</i> parameter was a <b>NULL</b> pointer or the buffer length, <i>lpdwBufferLength</i>, was too small to receive all the relevant 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infoexw">WSANAMESPACE_INFOEX</a> structures and associated information. When this error is returned, the buffer length required is returned in the <i>lpdwBufferLength</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaenumnamespaceprovidersexw
     * @since windows8.1
     */
    static WSAEnumNameSpaceProvidersExW(lpdwBufferLength, lpnspBuffer) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAEnumNameSpaceProvidersExW", "uint*", lpdwBufferLength, "ptr", lpnspBuffer, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAGetServiceClassNameByClassId function retrieves the name of the service associated with the specified type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service.
     * @param {Pointer<Guid>} lpServiceClassId A pointer to the GUID for the service class.
     * @param {Pointer} lpszServiceClassName A pointer to the service name.
     * @param {Pointer<Integer>} lpdwBufferLength On input, the length of the buffer returned by <i>lpszServiceClassName</i>, in characters. On output, the length of the service name copied into <i>lpszServiceClassName</i>, in characters.
     * @returns {Integer} The 
     * <b>WSAGetServiceClassNameByClassId</b> function returns a value of zero if successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpServiceClassId</i> parameter specified is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to access the information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified buffer pointed to by <i>lpszServiceClassName</i> is too small. Pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not supported for the type of object referenced. This error is returned by some namespace providers that do not support getting service class information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpServiceClassId</i> is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsagetserviceclassnamebyclassida
     * @deprecated
     * @since windows5.0
     */
    static WSAGetServiceClassNameByClassIdA(lpServiceClassId, lpszServiceClassName, lpdwBufferLength) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetServiceClassNameByClassIdA", "ptr", lpServiceClassId, "ptr", lpszServiceClassName, "uint*", lpdwBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAGetServiceClassNameByClassId function retrieves the name of the service associated with the specified type. This name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service.
     * @param {Pointer<Guid>} lpServiceClassId A pointer to the GUID for the service class.
     * @param {Pointer} lpszServiceClassName A pointer to the service name.
     * @param {Pointer<Integer>} lpdwBufferLength On input, the length of the buffer returned by <i>lpszServiceClassName</i>, in characters. On output, the length of the service name copied into <i>lpszServiceClassName</i>, in characters.
     * @returns {Integer} The 
     * <b>WSAGetServiceClassNameByClassId</b> function returns a value of zero if successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_PARAMETER</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpServiceClassId</i> parameter specified is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to access the information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified buffer pointed to by <i>lpszServiceClassName</i> is too small. Pass in a larger buffer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No buffer space available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The operation is not supported for the type of object referenced. This error is returned by some namespace providers that do not support getting service class information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpServiceClassId</i> is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The WS2_32.DLL has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsagetserviceclassnamebyclassidw
     * @since windows5.0
     */
    static WSAGetServiceClassNameByClassIdW(lpServiceClassId, lpszServiceClassName, lpdwBufferLength) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAGetServiceClassNameByClassIdW", "ptr", lpServiceClassId, "ptr", lpszServiceClassName, "uint*", lpdwBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASetService function registers or removes from the registry a service instance within one or more namespaces.
     * @param {Pointer<WSAQUERYSETA>} lpqsRegInfo A pointer to the service information for registration or deregistration.
     * @param {Integer} essoperation A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration type defined in the <i>Winsock2.h</i> header file. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
     * <dt><b>RNRSERVICE_REGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Register the service. For SAP, this means sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores, this means updating the address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a id="rnrservice_deregister"></a><dl>
     * <dt><b>RNRSERVICE_DEREGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Remove the service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores this means deleting address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl>
     * <dt><b>RNRSERVICE_DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the service from dynamic name and persistent spaces. For services represented by multiple 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding 
     * <b>CSADDR_INFO</b> structure that was specified when the service was registered.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwControlFlags Service install flags value that further controls the operation performed of the <b>WSASetService</b>function. The possible values for this parameter are defined in the <i>Winsock2.h</i> header file.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_MULTIPLE"></a><a id="service_multiple"></a><dl>
     * <dt><b>SERVICE_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Controls scope of operation. When this flag is not set, service addresses are managed as a group. A register or removal from the registry invalidates all existing addresses before adding the given address set. When set, the action is only performed on the given address set. A register does not invalidate existing addresses and a removal from the registry only invalidates the given set of addresses.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} The return value for 
     * <b>WSASetService</b> is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to install the Service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more required parameters were invalid or missing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Ws2_32.dll</i> has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasetservicea
     * @deprecated
     * @since windows8.1
     */
    static WSASetServiceA(lpqsRegInfo, essoperation, dwControlFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASetServiceA", "ptr", lpqsRegInfo, "int", essoperation, "uint", dwControlFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSASetService function registers or removes from the registry a service instance within one or more namespaces.
     * @param {Pointer<WSAQUERYSETW>} lpqsRegInfo A pointer to the service information for registration or deregistration.
     * @param {Integer} essoperation A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration type defined in the <i>Winsock2.h</i> header file. 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_REGISTER"></a><a id="rnrservice_register"></a><dl>
     * <dt><b>RNRSERVICE_REGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Register the service. For SAP, this means sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores, this means updating the address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DEREGISTER"></a><a id="rnrservice_deregister"></a><dl>
     * <dt><b>RNRSERVICE_DEREGISTER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Remove the service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the DNS namespace. For persistent data stores this means deleting address information.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RNRSERVICE_DELETE"></a><a id="rnrservice_delete"></a><dl>
     * <dt><b>RNRSERVICE_DELETE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Delete the service from dynamic name and persistent spaces. For services represented by multiple 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding 
     * <b>CSADDR_INFO</b> structure that was specified when the service was registered.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwControlFlags Service install flags value that further controls the operation performed of the <b>WSASetService</b>function. The possible values for this parameter are defined in the <i>Winsock2.h</i> header file.
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_MULTIPLE"></a><a id="service_multiple"></a><dl>
     * <dt><b>SERVICE_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Controls scope of operation. When this flag is not set, service addresses are managed as a group. A register or removal from the registry invalidates all existing addresses before adding the given address set. When set, the action is only performed on the given address set. A register does not invalidate existing addresses and a removal from the registry only invalidates the given set of addresses.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} The return value for 
     * <b>WSASetService</b> is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to install the Service.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more required parameters were invalid or missing.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Ws2_32.dll</i> has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsasetservicew
     * @since windows8.1
     */
    static WSASetServiceW(lpqsRegInfo, essoperation, dwControlFlags) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSASetServiceW", "ptr", lpqsRegInfo, "int", essoperation, "uint", dwControlFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAProviderConfigChange function notifies the application when the provider configuration is changed.
     * @param {Pointer<HANDLE>} lpNotificationHandle Pointer to notification handle. If the notification handle is set to <b>NULL</b> (the handle value not the pointer itself), this function returns a notification handle in the location pointed to by <i>lpNotificationHandle</i>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped Pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](./nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * Pointer to the completion routine called when the provider change notification is received.
     * @returns {Integer} If no error occurs the 
     * <b>WSAProviderConfigChange</b> returns 0. Otherwise, a value of SOCKET_ERROR is returned and a specific error code may be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. The error code 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a> indicates that the overlapped operation has been successfully initiated and that completion (and thus change event) will be indicated at a later time.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Not enough free memory available to complete the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_INVALID_HANDLE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Value pointed by <i>lpNotificationHandle</i> parameter is not a valid notification handle.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Current operating system environment does not support provider installation or removal without restart.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsaproviderconfigchange
     * @since windows8.1
     */
    static WSAProviderConfigChange(lpNotificationHandle, lpOverlapped, lpCompletionRoutine) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAProviderConfigChange", "ptr", lpNotificationHandle, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The WSAPoll function determines status of one or more sockets.
     * @param {Pointer<WSAPOLLFD>} fdArray An array of one or more <b>POLLFD</b> structures specifying the set  of sockets for which status is requested. The   array must contain at least one structure with a valid socket. Upon return, this parameter receives the updated sockets with the <b>revents</b> status flags member set on each one that matches the status query criteria.
     * @param {Integer} fds The number of <b>WSAPOLLFD</b> structures in <i>fdarray</i>. This is not necessarily the number of sockets for which status is requested.
     * @param {Integer} timeout A value that specifies the wait behavior, based on the following values.
     * 			
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td>Greater than zero</td>
     * <td>The time, in milliseconds, to wait.</td>
     * </tr>
     * <tr>
     * <td>Zero</td>
     * <td>Return immediately.</td>
     * </tr>
     * <tr>
     * <td>Less than zero</td>
     * <td>Wait indefinitely.</td>
     * </tr>
     * </table>
     * @returns {Integer} Returns one of the following values.
     * 			<table>
     * <tr>
     * <th>Return value</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>Zero</td>
     * <td>No sockets were in the queried state before the timer expired.</td>
     * </tr>
     * <tr>
     * <td>Greater than zero</td>
     * <td>The number of elements in <i>fdarray</i> for which an <b>revents</b> member of the <b>POLLFD</b> structure is nonzero.</td>
     * </tr>
     * <tr>
     * <td>SOCKET_ERROR</td>
     * <td>An error occurred. Call the <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function to retrieve the extended error code.</td>
     * </tr>
     * </table>
     * 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Extended Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An exception occurred while reading user input parameters.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed. This error is returned if the <a href="/windows/win32/api/winsock2/ns-winsock2-wsapollfd">WSAPOLLFD</a> structures  pointed to by the <i>fdarray</i> parameter when requesting socket
     *                        status. This error is also returned if none of the sockets specified in the <b>fd</b> member of any of the <b>WSAPOLLFD</b> structures  pointed to by the <i>fdarray</i> parameter were valid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function was unable to allocate sufficient memory.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-wsapoll
     * @since windows8.1
     */
    static WSAPoll(fdArray, fds, timeout) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAPoll", "ptr", fdArray, "uint", fds, "int", timeout, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Associates a set of sockets with a completion port, and retrieves any notifications that are already pending on that port. Once associated, the completion port receives the socket state notifications that were specified.
     * @param {HANDLE} completionPort Type: \_In\_ **[HANDLE](/windows/win32/winprog/windows-data-types)**
     * 
     * A handle to an I/O completion port created using the [CreateIoCompletionPort](/windows/win32/fileio/createiocompletionport) function. The port will be used in the *CompletionPort* parameter of the [PostQueuedCompletionStatus](/windows/win32/fileio/postqueuedcompletionstatus) function when messages are sent on behalf of the socket.
     * @param {Integer} registrationCount Type: \_In\_ **[UINT32](/windows/win32/winprog/windows-data-types)**
     * 
     * The number of registrations supplied by *registrationInfos*.
     * @param {Pointer<SOCK_NOTIFY_REGISTRATION>} registrationInfos Type: \_Inout\_updates\_opt\_(registrationCount) **[SOCK_NOTIFY_REGISTRATION](/windows/win32/api/winsock2/ns-winsock2-sock_notify_registration)\***
     * 
     * A pointer to an array of [SOCK_NOTIFY_REGISTRATION](/windows/win32/api/winsock2/ns-winsock2-sock_notify_registration) structures that define the notification registration parameters. These include the socket of interest, the notification events of interest, and the operation flags. On success, you must inspect the elements for whether the registration was processed successfully. This argument must be **NULL** if *registrationCount* is 0.
     * @param {Integer} timeoutMs Type: \_In\_ **[UINT32](/windows/win32/winprog/windows-data-types)**
     * 
     * The time in milliseconds that you're willing to wait for a completion packet to appear at the completion port. If a completion packet doesn't appear within the specified time, then the function times out and returns **ERROR_TIMEOUT**.
     * 
     * If *timeoutMs* is **INFINITE** (0xFFFFFFFF), then the function will never time out. If *timeoutMs* is 0, and there is no I/O operation to dequeue, then the function will time out immediately.
     * 
     * The value of *timeoutMs* must be 0 if *completionCount* is 0.
     * @param {Integer} completionCount Type: \_In\_ **[ULONG](/windows/win32/winprog/windows-data-types)**
     * 
     * The maximum number of [OVERLAPPED_ENTRY](/windows/win32/api/minwinbase/ns-minwinbase-overlapped_entry) structures to remove. If 0 is specified, then only registration operations will be processed.
     * @param {Pointer<OVERLAPPED_ENTRY>} completionPortEntries Type: \_Out\_writes\_to\_opt\_(completionCount, *receivedEntryCount) **[OVERLAPPED_ENTRY](/windows/win32/api/minwinbase/ns-minwinbase-overlapped_entry)\***
     * 
     * On input, points to a pre-allocated array of [OVERLAPPED_ENTRY](/windows/win32/api/minwinbase/ns-minwinbase-overlapped_entry) structures. The array mustn't overlap with the *registrationInfos* array. The value of *completionPortEntries* must be **NULL** if *completionCount* is 0.
     * 
     * On output, receives an array of OVERLAPPED_ENTRY structures that hold the entries. The number of array elements is provided by ReceivedEntryCount. The dwNumberOfBytesTransferred fields of the structures are integer masks of received events. The lpOverlapped fields are reserved and must not be used as pointers.
     * @param {Pointer<Integer>} receivedEntryCount Type: \_Out\_opt\_ **[UINT32](/windows/win32/winprog/windows-data-types)\***
     * 
     * A pointer to a variable that receives the number of entries removed. Must be **NULL** if *completionCount* is 0.
     * @returns {Integer} If successful, returns **ERROR_SUCCESS**. If the function succeeded and you supplied a non-0 *completionCount*, but no completion packets appeared within the specified time, returns **WAIT_TIMEOUT**. Otherwise, returns an appropriate **WSAE\*** error code.
     * 
     * If **ERROR_SUCCESS** or **WAIT_TIMEOUT** is returned, then you must inspect the individual registration infos' registration results. Otherwise, the entire operation failed, and no changes occurred.
     * @see https://docs.microsoft.com/windows/win32/api//winsock2/nf-winsock2-processsocketnotifications
     */
    static ProcessSocketNotifications(completionPort, registrationCount, registrationInfos, timeoutMs, completionCount, completionPortEntries, receivedEntryCount) {
        completionPort := completionPort is Win32Handle ? NumGet(completionPort, "ptr") : completionPort

        result := DllCall("WS2_32.dll\ProcessSocketNotifications", "ptr", completionPort, "uint", registrationCount, "ptr", registrationInfos, "uint", timeoutMs, "uint", completionCount, "ptr", completionPortEntries, "uint*", receivedEntryCount, "uint")
        return result
    }

    /**
     * Converts an IPv4 address to a string in Internet standard dotted-decimal format.
     * @param {Pointer<IN_ADDR>} Addr The IPv4 address in network byte order.
     * @param {PSTR} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv4 address. This buffer should be large enough to hold at least 16 characters.
     * @returns {PSTR} A pointer to the NULL character inserted at the end of the string representation of the IPv4 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4addresstostringa
     * @since windows6.0.6000
     */
    static RtlIpv4AddressToStringA(Addr, S) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv4AddressToStringA", "ptr", Addr, "ptr", S, "char*")
        return result
    }

    /**
     * Converts an IPv4 address and port number to a string in Internet standard format.
     * @param {Pointer<IN_ADDR>} Address The IPv4 address in network byte order.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {PSTR} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IPv4 address and port. This buffer should be large enough to hold at least INET_ADDRSTRLEN characters. The INET_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<Integer>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     * 
     * On output, this parameter contains the number of characters actually written to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv4 address and port.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4addresstostringexa
     */
    static RtlIpv4AddressToStringExA(Address, Port, AddressString, AddressStringLength) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv4AddressToStringExA", "ptr", Address, "ushort", Port, "ptr", AddressString, "uint*", AddressStringLength, "int")
        return result
    }

    /**
     * Converts an IPv4 address to a string in Internet standard dotted-decimal format.
     * @param {Pointer<IN_ADDR>} Addr The IPv4 address in network byte order.
     * @param {PWSTR} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv4 address. This buffer should be large enough to hold at least 16 characters.
     * @returns {PWSTR} A pointer to the NULL character inserted at the end of the string representation of the IPv4 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4addresstostringw
     * @since windows6.0.6000
     */
    static RtlIpv4AddressToStringW(Addr, S) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv4AddressToStringW", "ptr", Addr, "ptr", S, "char*")
        return result
    }

    /**
     * Converts an IPv4 address and port number to a string in Internet standard format.
     * @param {Pointer<IN_ADDR>} Address The IPv4 address in network byte order.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {PWSTR} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IPv4 address and port. This buffer should be large enough to hold at least INET_ADDRSTRLEN characters. The INET_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<Integer>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     *         On output, this parameter contains the number of characters actually written
     *         to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv4 address and port. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4addresstostringexw
     * @since windows6.0.6000
     */
    static RtlIpv4AddressToStringExW(Address, Port, AddressString, AddressStringLength) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv4AddressToStringExW", "ptr", Address, "ushort", Port, "ptr", AddressString, "uint*", AddressStringLength, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address to a binary IPv4 address.
     * @param {PSTR} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address.
     * @param {BOOLEAN} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts.
     *              If this parameter is <b>FALSE</b>, any of four possible forms are allowed, with decimal,
     *              octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<PSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN_ADDR>} Addr A pointer where the binary representation of the IPv4 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>S</i> parameter did not contain a four-part dotted decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressa
     * @since windows6.0.6000
     */
    static RtlIpv4StringToAddressA(S, Strict, Terminator, Addr) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv4StringToAddressA", "ptr", S, "char", Strict, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address and port number to a binary IPv4 address and port.
     * @param {PSTR} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address followed by an optional colon and string representation of a port number.
     * @param {BOOLEAN} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts. If this parameter is <b>FALSE</b>, any of four forms are allowed for the string representation of the Ipv4 address, with decimal, octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<IN_ADDR>} Address A pointer where the binary representation of the IPv4 address is to be stored. The IPv4 address is stored in network byte order.
     * @param {Pointer<Integer>} Port A pointer where the binary representation of the port number is to be stored. The port number is returned in network byte order. If no port was specified in the string pointed to by the <i>AddressString</i> parameter, then the <i>Port</i> parameter is set to zero.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * 
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>AddressString</i> parameter did not contain a four-part dotted-decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the <i>AddressString</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressexa
     */
    static RtlIpv4StringToAddressExA(AddressString, Strict, Address, Port) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv4StringToAddressExA", "ptr", AddressString, "char", Strict, "ptr", Address, "ushort*", Port, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address to a binary IPv4 address.
     * @param {PWSTR} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address.
     * @param {BOOLEAN} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts.
     *              If this parameter is <b>FALSE</b>, any of four possible forms are allowed, with decimal,
     *              octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<PWSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN_ADDR>} Addr A pointer where the binary representation of the IPv4 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>S</i> parameter did not contain a four-part dotted decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressw
     * @since windows6.0.6000
     */
    static RtlIpv4StringToAddressW(S, Strict, Terminator, Addr) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv4StringToAddressW", "ptr", S, "char", Strict, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv4 address and port number to a binary IPv4 address and port.
     * @param {PWSTR} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv4 address followed by an optional colon and string representation of a port number.
     * @param {BOOLEAN} Strict A value that indicates whether the string must be an IPv4 address represented in strict four-part dotted-decimal notation.  If this parameter is <b>TRUE</b>, the string must be dotted-decimal with four parts. If this parameter is <b>FALSE</b>, any of four forms are allowed for the string representation of the Ipv4 address, with decimal,
     *              octal, or hexadecimal notation. See the Remarks section for details.
     * @param {Pointer<IN_ADDR>} Address A pointer where the binary representation of the IPv4 address is to be stored. The IPv4 address is stored in network byte order.
     * @param {Pointer<Integer>} Port A pointer where the binary representation of the port number is to be stored. The port number is returned in network byte order. If no port was specified in the string pointed to by the <i>AddressString</i> parameter, then the <i>Port</i> parameter is set to zero.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the <i>Strict</i> parameter was set to <b>TRUE</b>, but the string pointed to by the <i>AddressString</i> parameter did not contain a four-part dotted-decimal string representation of an IPv4 address. This error is also returned if the string pointed to by the  <i>AddressString</i> parameter did not contain a proper string representation of an IPv4 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv4stringtoaddressexw
     * @since windows6.0.6000
     */
    static RtlIpv4StringToAddressExW(AddressString, Strict, Address, Port) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv4StringToAddressExW", "ptr", AddressString, "char", Strict, "ptr", Address, "ushort*", Port, "int")
        return result
    }

    /**
     * Converts an IPv6 address to a string in Internet standard format.
     * @param {Pointer<IN6_ADDR>} Addr The IPv6 address in network byte order.
     * @param {PSTR} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv6 address. This buffer should be large enough to hold at least 46 characters.
     * @returns {PSTR} A pointer to the NULL character inserted at the end of the string representation of the IPv6 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6addresstostringa
     * @since windows6.0.6000
     */
    static RtlIpv6AddressToStringA(Addr, S) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv6AddressToStringA", "ptr", Addr, "ptr", S, "char*")
        return result
    }

    /**
     * Converts an IPv6 address, scope ID, and port number to a string.
     * @param {Pointer<IN6_ADDR>} Address The IPv6 address in network byte order.
     * @param {Integer} ScopeId The scope ID of the IPv6 address in network byte order. This parameter is optional.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {PSTR} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IP address, scope ID, and port. This buffer should be large enough to hold at least INET6_ADDRSTRLEN characters. The INET6_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<Integer>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     * 
     * On output, this parameter contains the number of characters actually written to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv6 address, scope ID, and port.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6addresstostringexa
     */
    static RtlIpv6AddressToStringExA(Address, ScopeId, Port, AddressString, AddressStringLength) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv6AddressToStringExA", "ptr", Address, "uint", ScopeId, "ushort", Port, "ptr", AddressString, "uint*", AddressStringLength, "int")
        return result
    }

    /**
     * Converts an IPv6 address to a string in Internet standard format.
     * @param {Pointer<IN6_ADDR>} Addr The IPv6 address in network byte order.
     * @param {PWSTR} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IPv6 address. This buffer should be large enough to hold at least 46 characters.
     * @returns {PWSTR} A pointer to the NULL character inserted at the end of the string representation of the IPv6 address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6addresstostringw
     * @since windows6.0.6000
     */
    static RtlIpv6AddressToStringW(Addr, S) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv6AddressToStringW", "ptr", Addr, "ptr", S, "char*")
        return result
    }

    /**
     * Converts an IPv6 address, scope ID, and port number to a string.
     * @param {Pointer<IN6_ADDR>} Address The IPv6 address in network byte order.
     * @param {Integer} ScopeId The scope ID of the IPv6 address in network byte order. This parameter is optional.
     * @param {Integer} Port The port number in network byte order format. This parameter is optional.
     * @param {PWSTR} AddressString A pointer to the buffer to receive the <b>NULL</b>-terminated string representation of the IP address, scope ID, and port. This buffer should be large enough to hold at least INET6_ADDRSTRLEN characters. The INET6_ADDRSTRLEN value is defined in the <i>Ws2ipdef.h</i> header file.
     * @param {Pointer<Integer>} AddressStringLength On input, the number of characters that fit in the buffer pointed to by the <i>AddressString</i> parameter, including the NULL terminator.
     *         On output, this parameter contains the number of characters actually written
     *         to the buffer pointed to by the <i>AddressString</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>AddressString</i> or <i>AddressStringLength</i> parameter. This error is also returned if the length of the buffer pointed to by the <i>AddressString</i> parameter is not large enough to receive the string representation of the IPv6 address, scope ID, and port. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6addresstostringexw
     * @since windows6.0.6000
     */
    static RtlIpv6AddressToStringExW(Address, ScopeId, Port, AddressString, AddressStringLength) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv6AddressToStringExW", "ptr", Address, "uint", ScopeId, "ushort", Port, "ptr", AddressString, "uint*", AddressStringLength, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address to a binary IPv6 address.
     * @param {PSTR} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address.
     * @param {Pointer<PSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN6_ADDR>} Addr A pointer where the binary representation of the IPv6 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6stringtoaddressa
     * @since windows6.0.6000
     */
    static RtlIpv6StringToAddressA(S, Terminator, Addr) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv6StringToAddressA", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port.
     * @param {PSTR} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address, scope ID, and port number.
     * @param {Pointer<IN6_ADDR>} Address A pointer where the binary representation of the IPv6 address is to be stored.
     * @param {Pointer<Integer>} ScopeId A pointer to where scope ID of the IPv6 address is stored. If <i>AddressString</i> parameter does not contain the string representation of a scope ID, then zero is returned in this parameter.
     * @param {Pointer<Integer>} Port A pointer where the port number is stored. The port number is in network byte order format. If <i>AddressString</i> parameter does not contain the string representation of a port number, then zero is returned in this parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the  <i>AddressString</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6stringtoaddressexa
     */
    static RtlIpv6StringToAddressExA(AddressString, Address, ScopeId, Port) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv6StringToAddressExA", "ptr", AddressString, "ptr", Address, "uint*", ScopeId, "ushort*", Port, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address to a binary IPv6 address.
     * @param {PWSTR} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address.
     * @param {Pointer<PWSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<IN6_ADDR>} Addr A pointer where the binary representation of the IPv6 address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6stringtoaddressw
     * @since windows6.0.6000
     */
    static RtlIpv6StringToAddressW(S, Terminator, Addr) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlIpv6StringToAddressW", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an IPv6 address, scope ID, and port number to a binary IPv6 address, scope ID, and port.
     * @param {PWSTR} AddressString A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the IPv6 address, scope ID, and port number.
     * @param {Pointer<IN6_ADDR>} Address A pointer where the binary representation of the IPv6 address is to be stored.
     * @param {Pointer<Integer>} ScopeId A pointer to where scope ID of the IPv6 address is stored. If <i>AddressString</i> parameter does not contain the string representation of a scope ID, then zero is returned in this parameter.
     * @param {Pointer<Integer>} Port A pointer where the port number is stored. The port number is in network byte order format. If <i>AddressString</i> parameter does not contain the string representation of a port number, then zero is returned in this parameter.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the  <i>AddressString</i> parameter did not contain a proper string representation of an IPv6 address.
     * 
     * This error code is defined in the Ntstatus.h header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlipv6stringtoaddressexw
     * @since windows6.0.6000
     */
    static RtlIpv6StringToAddressExW(AddressString, Address, ScopeId, Port) {
        AddressString := AddressString is String ? StrPtr(AddressString) : AddressString

        result := DllCall("ntdll.dll\RtlIpv6StringToAddressExW", "ptr", AddressString, "ptr", Address, "uint*", ScopeId, "ushort*", Port, "int")
        return result
    }

    /**
     * Converts a binary Ethernet address to a string representation of the Ethernet MAC address.
     * @param {Pointer<DL_EUI48>} Addr The Ethernet address in binary format. The Ethernet address is in network order (bytes ordered from
     *     left to right).
     * @param {PSTR} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the Ethernet address. This buffer should be large enough to hold at least 18 characters.
     * @returns {PSTR} A pointer to the NULL character inserted at the end of the string representation of the Ethernet MAC address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetaddresstostringa
     * @since windows6.1
     */
    static RtlEthernetAddressToStringA(Addr, S) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlEthernetAddressToStringA", "ptr", Addr, "ptr", S, "char*")
        return result
    }

    /**
     * Converts a binary Ethernet address to a string representation of the Ethernet MAC address.
     * @param {Pointer<DL_EUI48>} Addr The Ethernet address in binary format. The Ethernet address is in network order (bytes ordered from
     *     left to right).
     * @param {PWSTR} S A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the Ethernet address. This buffer should be large enough to hold at least 18 characters.
     * @returns {PWSTR} A pointer to the NULL character inserted at the end of the string representation of the Ethernet MAC address.
     * This can be used by the caller to easily append more information to the string.
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetaddresstostringw
     * @since windows6.1
     */
    static RtlEthernetAddressToStringW(Addr, S) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlEthernetAddressToStringW", "ptr", Addr, "ptr", S, "char*")
        return result
    }

    /**
     * Converts a string representation of an Ethernet MAC address to a binary format of the Ethernet address.
     * @param {PSTR} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the Ethernet MAC  address.
     * @param {Pointer<PSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<DL_EUI48>} Addr A pointer where the binary representation of the Ethernet MAC address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an Ethernet MAC address.
     * 
     * This error code is defined in the <i>Ntstatus.h</i> header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetstringtoaddressa
     * @since windows6.1
     */
    static RtlEthernetStringToAddressA(S, Terminator, Addr) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlEthernetStringToAddressA", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Converts a string representation of an Ethernet MAC address to a binary format of the Ethernet address.
     * @param {PWSTR} S A pointer to a buffer containing the <b>NULL</b>-terminated string representation of the Ethernet MAC  address.
     * @param {Pointer<PWSTR>} Terminator A parameter that receives a pointer to the character that terminated
     *         the converted string. This can be used by the caller to extract more information from the string.
     * @param {Pointer<DL_EUI48>} Addr A pointer where the binary representation of the Ethernet MAC address is to be stored.
     * @returns {Integer} If the function succeeds, the return value is <b>STATUS_SUCCESS</b>.
     * 
     * If the function fails, the return value is one of the following error codes.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>STATUS_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if the string pointed to by the <i>S</i> parameter did not contain a proper string representation of an Ethernet MAC address.
     * 
     * This error code is defined in the <i>Ntstatus.h</i> header file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>Other</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Use 
     * <a href="/windows/desktop/api/winbase/nf-winbase-formatmessage">FormatMessage</a> to obtain the message string for the returned error.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ip2string/nf-ip2string-rtlethernetstringtoaddressw
     * @since windows6.1
     */
    static RtlEthernetStringToAddressW(S, Terminator, Addr) {
        S := S is String ? StrPtr(S) : S

        result := DllCall("ntdll.dll\RtlEthernetStringToAddressW", "ptr", S, "ptr", Terminator, "ptr", Addr, "int")
        return result
    }

    /**
     * Receives data from a connected socket or a bound connectionless socket.
     * @param {SOCKET} s A descriptor that identifies a connected socket.
     * @param {Pointer} buf A pointer to the buffer to receive the incoming data.
     * @param {Integer} len The length, in bytes, of the buffer pointed to by the <i>buf</i> parameter.
     * @param {Pointer<Integer>} flags An indicator specifying whether the message is fully or partially received for datagram sockets.
     * @returns {Integer} If no error occurs, 
     * <b>WSARecvEx</b> returns the number of bytes received. If the connection has been closed, it returns zero. Additionally, if a partial message was received, the MSG_PARTIAL bit is set in the <i>flags</i> parameter. If a complete message was received, MSG_PARTIAL is not set in <i>flags</i>
     * 
     * Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <div class="alert"><b>Important</b>For a stream oriented-transport protocol, MSG_PARTIAL is never set on return from 
     * <b>WSARecvEx</b>. This function behaves identically to the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-recv">recv</a> function for stream-transport protocols.</div>
     * <div></div>
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as it is no longer usable. On a UPD-datagram socket this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>buf</i> parameter is not completely contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINPROGRESS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINTR</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The (blocking) call was canceled by the <a href="/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall">WSACancelBlockingCall</a> call.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has not been bound with 
     * <a href="/windows/desktop/api/winsock/nf-winsock-bind">bind</a>, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled or (for byte stream sockets only) <i>len</i> was zero or negative.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a connection-oriented socket, this error indicates that the connection has been broken due to <i>keep-alive</i> activity that detected a failure while the operation was in progress. For a datagram socket, this error indicates that the time to live has expired.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEOPNOTSUPP</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the communication domain associated with this socket, or the socket is unidirectional and supports only send operations.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket has been shut down; it is not possible to use 
     * <a href="/windows/desktop/api/mswsock/nf-mswsock-wsarecvex">WSARecvEx</a> on a socket after 
     * <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> has been invoked with <i>how</i> set to SD_RECEIVE or SD_BOTH.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAETIMEDOUT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been dropped because of a network failure or because the peer system failed to respond.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEWOULDBLOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is marked as nonblocking and the receive operation would block.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-wsarecvex
     * @deprecated
     * @since windows5.0
     */
    static WSARecvEx(s, buf, len, flags) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        A_LastError := 0

        result := DllCall("MSWSOCK.dll\WSARecvEx", "ptr", s, "ptr", buf, "int", len, "int*", flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Transmits file data over a connected socket handle.
     * @param {SOCKET} hSocket A handle to a connected socket. The 
     * <b>TransmitFile</b> function will transmit the file data over this socket. The socket specified by the <i>hSocket</i> parameter must be a connection-oriented socket of type <b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>, or <b>SOCK_RDM</b>.
     * @param {HANDLE} hFile A handle to the open file that the 
     * <b>TransmitFile</b> function transmits. Since the operating system reads the file data sequentially, you can improve caching performance by opening the handle with FILE_FLAG_SEQUENTIAL_SCAN. 
     * 
     * The <i>hFile</i> parameter is optional. If the <i>hFile</i> parameter is <b>NULL</b>, only data in the header and/or the tail buffer is transmitted. Any additional action, such as socket disconnect or reuse, is performed as specified by the <i>dwFlags</i> parameter.
     * @param {Integer} nNumberOfBytesToWrite The number of bytes in the file to transmit. The 
     * <b>TransmitFile</b> function completes when it has sent the specified number of bytes, or when an error occurs, whichever occurs first. 
     * 
     * 
     * 
     * 
     * Set this parameter to zero in order to transmit the entire file.
     * @param {Integer} nNumberOfBytesPerSend The size, in bytes, of each block of data sent in each send operation. This parameter is used by Windows' sockets layer to determine the block size for send operations. To select the default send size, set this parameter to zero.
     * 
     * The <i>nNumberOfBytesPerSend</i> parameter is useful for protocols that have limitations on the size of individual send requests.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If the socket handle has been opened as overlapped, specify this parameter in order to achieve an overlapped (asynchronous) I/O operation. By default, socket handles are opened as overlapped. 
     * 
     * 
     * 
     * 
     * You can use the <i>lpOverlapped</i> parameter to specify a 64-bit offset within the file at which to start the file data transfer by setting the <b>Offset</b> and <b>OffsetHigh</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure. If <i>lpOverlapped</i> is a <b>NULL</b> pointer, the transmission of data always starts at the current byte offset in the file.
     * 
     * When the <i>lpOverlapped</i> is not <b>NULL</b>, the overlapped I/O might not finish before 
     * <b>TransmitFile</b> returns. In that case, the 
     * <b>TransmitFile</b> function returns <b>FALSE</b>, and <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> returns ERROR_IO_PENDING or <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a>. This enables the caller to continue processing while the file transmission operation completes. Windows will set the event specified by the <b>hEvent</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure, or the socket specified by <i>hSocket</i>, to the signaled state upon completion of the data transmission request.
     * @param {Pointer<TRANSMIT_FILE_BUFFERS>} lpTransmitBuffers A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/ns-mswsock-transmit_file_buffers">TRANSMIT_FILE_BUFFERS</a> data structure that contains pointers to data to send before and after the file data is sent. This parameter should be set to a <b>NULL</b> pointer if you want to transmit only the file data.
     * @param {Integer} dwReserved A set of flags used to modify the behavior of the <b>TransmitFile</b> function call. The <i>dwFlags</i> parameter can contain a combination of the following options defined in the <i>Mswsock.h</i> header file: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Flag</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_DISCONNECT"></a><a id="tf_disconnect"></a><dl>
     * <dt><b>TF_DISCONNECT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Start a transport-level disconnect after all the file data has been queued for transmission.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_REUSE_SOCKET"></a><a id="tf_reuse_socket"></a><dl>
     * <dt><b>TF_REUSE_SOCKET</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Prepare the socket handle to be reused. This flag is valid only if <b>TF_DISCONNECT</b> is also specified.
     * 
     * When the <b>TransmitFile</b> request completes, the socket handle can be passed to the 
     * function call previously used to establish the connection, such as <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>  or <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nc-mswsock-lpfn_connectex">ConnectEx</a>. Such reuse is mutually exclusive; for example, if the <b>AcceptEx</b> function was called for the socket, reuse is allowed only for subsequent calls to the <b>AcceptEx</b>  function, and not allowed for a subsequent call to <b>ConnectEx</b>. 
     * 
     * <div class="alert"><b>Note</b>The socket level file transmit is subject to the behavior of the underlying transport. For example, a TCP socket may be subject to the TCP TIME_WAIT state, causing  the <b>TransmitFile</b> call to be delayed.</div>
     * <div></div>
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_USE_DEFAULT_WORKER"></a><a id="tf_use_default_worker"></a><dl>
     * <dt><b>TF_USE_DEFAULT_WORKER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Directs the Windows Sockets service provider to use the system's default thread to process long <b>TransmitFile</b> requests. The system default thread can be adjusted using the following registry parameter as a <b>REG_DWORD</b>:
     * 
     * 
     * <b>HKEY_LOCAL_MACHINE</b>&#92;<b>CurrentControlSet</b>&#92;<b>Services</b>&#92;<b>AFD</b>&#92;<b>Parameters</b>&#92;<b>TransmitWorker</b>
     * 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_USE_SYSTEM_THREAD"></a><a id="tf_use_system_thread"></a><dl>
     * <dt><b>TF_USE_SYSTEM_THREAD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Directs the Windows Sockets service provider to use system threads to process long 
     * <b>TransmitFile</b> requests.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_USE_KERNEL_APC"></a><a id="tf_use_kernel_apc"></a><dl>
     * <dt><b>TF_USE_KERNEL_APC</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Directs the driver to use kernel asynchronous procedure calls (APCs) instead of worker threads to process long 
     * <b>TransmitFile</b> requests. Long <b>TransmitFile</b> requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.
     * 
     * Use of TF_USE_KERNEL_APC can deliver significant performance benefits. It is possible (though unlikely), however, that the thread in which context 
     * <b>TransmitFile</b> is initiated is being used for heavy computations; this situation may prevent APCs from launching. Note that the Winsock kernel mode driver uses normal kernel APCs, which launch whenever a thread is in a wait state, which differs from user-mode APCs, which launch whenever a thread is in an alertable wait state initiated in user mode).
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="TF_WRITE_BEHIND"></a><a id="tf_write_behind"></a><dl>
     * <dt><b>TF_WRITE_BEHIND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Complete the 
     * <b>TransmitFile</b> request immediately, without pending. If this flag is specified and 
     * <b>TransmitFile</b> succeeds, then the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this setting with the TF_DISCONNECT and TF_REUSE_SOCKET flags.
     * 
     * <div class="alert"><b>Note</b>If the file being sent is not in the file system cache, the request  pends.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @returns {BOOL} If the 
     * <b>TransmitFile</b> function succeeds, the return value is <b>TRUE</b>. Otherwise, the return value is <b>FALSE</b>. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. An error code 
     * of <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a> or ERROR_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion indication will occur. Applications should handle either ERROR_IO_PENDING or WSA_IO_PENDING in this case.
     * 
     * <table>
     * <tr>
     * <th>Return code</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An established connection was aborted by the software in your host machine. This error is returned if the virtual circuit was terminated due to a time-out or other failure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An existing connection was forcibly closed by the remote host. This error is returned for a stream socket when the virtual circuit was reset by the remote side. The application should close the socket as it is no longer usable.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned if the <i>lpTransmitBuffers</i> or <i>lpOverlapped</i> parameter is not totally contained in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied. This error is returned if the <i>hSocket</i> parameter specified a socket of type <b>SOCK_DGRAM</b> or <b>SOCK_RAW</b>. This error is returned if the <i>dwFlags</i> parameter has the  <b>TF_REUSE_SOCKET</b> flag set, but the <b>TF_DISCONNECT</b> flag was not set. This error is also returned if the offset specified in the <a href="/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure pointed to by the <i>lpOverlapped</i> is not within the file. This error is also returned if the <i>nNumberOfBytesToWrite</i> parameter is set to a value greater than  2,147,483,646, the maximum value for a 32-bit integer minus 1.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A socket operation encountered a dead network.This error is returned if the network subsystem has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENETRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full. This error is also returned if the Windows Sockets provider reports a buffer deadlock.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A request to send or receive data was disallowed because the socket is not connected.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An operation was attempted on something that is not a socket. This error is returned if the <i>hSocket</i> parameter is not a socket.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESHUTDOWN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A request to send or receive data was disallowed because the socket had already been shut down in that direction with a previous shutdown call. This error is returned if the socket has been shut down for sending. It is not possible to 
     * call <a href="/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> on a socket after 
     * the <a href="/windows/desktop/api/winsock/nf-winsock-shutdown">shutdown</a> function has been called on the socket with the <i>how</i> parameter set to <b>SD_SEND</b> or <b>SD_BOTH</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Either the application has not called the <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> function, or <b>WSAStartup</b> failed. A successful 
     * <b>WSAStartup</b> call must occur before using the <a href="/windows/desktop/api/mswsock/nf-mswsock-transmitfile">TransmitFile</a> function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_IO_PENDING</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An overlapped I/O operation is in progress. This value is returned if an overlapped I/O operation was successfully initiated and indicates that completion will be indicated at a later time.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_OPERATION_ABORTED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The I/O operation has been aborted because of either a thread exit or an application request. This error is returned if the overlapped operation has been canceled due to the closure of the socket, the execution of the "SIO_FLUSH" command in 
     * <a href="/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a>, or the thread that initiated the overlapped request exited before the operation completed.
     * 
     * <div class="alert"><b>Note</b>All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous operations can fail if the thread is closed before the  asynchronous operations complete. For more information, see <a href="/windows/desktop/api/processthreadsapi/nf-processthreadsapi-exitthread">ExitThread</a>.</div>
     * <div></div>
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-transmitfile
     * @since windows8.1
     */
    static TransmitFile(hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved) {
        hSocket := hSocket is Win32Handle ? NumGet(hSocket, "ptr") : hSocket
        hFile := hFile is Win32Handle ? NumGet(hFile, "ptr") : hFile

        result := DllCall("MSWSOCK.dll\TransmitFile", "ptr", hSocket, "ptr", hFile, "uint", nNumberOfBytesToWrite, "uint", nNumberOfBytesPerSend, "ptr", lpOverlapped, "ptr", lpTransmitBuffers, "uint", dwReserved, "int")
        return result
    }

    /**
     * Accepts a new connection, returns the local and remote address, and receives the first block of data sent by the client application. NoteThis function is a Microsoft-specific extension to the Windows Sockets specification..
     * @param {SOCKET} sListenSocket A descriptor identifying a socket that has already been called with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-listen">listen</a> function. A server application waits for attempts to connect on this socket.
     * @param {SOCKET} sAcceptSocket A descriptor identifying a socket on which to accept an incoming connection. This socket must not be bound or connected.
     * @param {Pointer<Void>} lpOutputBuffer A pointer to a buffer that receives the first block of data sent on a new connection, the local address of the server, and the remote address of the client. The receive data is written to the first part of the buffer starting at offset zero, while the addresses are written to the latter part of the buffer. This parameter must be specified.
     * @param {Integer} dwReceiveDataLength The number of bytes in <i>lpOutputBuffer</i> that will be used for actual receive data at the beginning of the buffer. This size should not include the size of the local address of the server, nor the remote address of the client; they are appended to the output buffer. If <i>dwReceiveDataLength</i> is zero, accepting the connection will not result in a receive operation. Instead, 
     * <b>AcceptEx</b> completes as soon as a connection arrives, without waiting for any data.
     * @param {Integer} dwLocalAddressLength The number of bytes reserved for the local address information. This value must be at least 16 bytes more than the maximum address length for the transport protocol in use.
     * @param {Integer} dwRemoteAddressLength The number of bytes reserved for the remote address information. This value must be at least 16 bytes more than the maximum address length for the transport protocol in use. Cannot be zero.
     * @param {Pointer<Integer>} lpdwBytesReceived A pointer to a <b>DWORD</b> that receives the count of bytes received. This parameter is set only if the operation completes synchronously. If it returns ERROR_IO_PENDING and is completed later, then this <b>DWORD</b> is never set and you must obtain the number of bytes read from the completion notification mechanism.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An 
     * <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure that is used to process the request. This parameter must be specified; it cannot be <b>NULL</b>.
     * @returns {BOOL} If no error occurs, the 
     * <b>AcceptEx</b> function completed successfully and a value of <b>TRUE</b> is returned.
     * 
     * If the function fails, 
     * <b>AcceptEx</b> returns <b>FALSE</b>. The 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function can then be called to return extended error information. If 
     * <b>WSAGetLastError</b> returns <b>ERROR_IO_PENDING</b>, then the operation was successfully initiated and is still in progress. If the error is WSAECONNRESET, an incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-acceptex
     * @since windows8.1
     */
    static AcceptEx(sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped) {
        sListenSocket := sListenSocket is Win32Handle ? NumGet(sListenSocket, "ptr") : sListenSocket
        sAcceptSocket := sAcceptSocket is Win32Handle ? NumGet(sAcceptSocket, "ptr") : sAcceptSocket

        result := DllCall("MSWSOCK.dll\AcceptEx", "ptr", sListenSocket, "ptr", sAcceptSocket, "ptr", lpOutputBuffer, "uint", dwReceiveDataLength, "uint", dwLocalAddressLength, "uint", dwRemoteAddressLength, "uint*", lpdwBytesReceived, "ptr", lpOverlapped, "int")
        return result
    }

    /**
     * Parses the data obtained from a call to the AcceptEx function and passes the local and remote addresses to a sockaddr structure.NoteThis function is a Microsoft-specific extension to the Windows Sockets specification..
     * @remarks
     * 
     * The 
     * <b>GetAcceptExSockaddrs</b> function is used exclusively with the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> function to parse the first data that the socket receives into local and remote addresses. The 
     * <b>AcceptEx</b> function returns local and remote address information in an internal format. Application developers need to use the <b>GetAcceptExSockaddrs</b> function if there is a need for the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structures containing the local or remote addresses.
     * 
     * 
     * <div class="alert"><b>Note</b>The function pointer for the 
     * <b>GetAcceptExSockaddrs</b> function must be obtained at run time by making a call to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaioctl">WSAIoctl</a> function with the <b>SIO_GET_EXTENSION_FUNCTION_POINTER</b> opcode specified. The input buffer passed to the <b>WSAIoctl</b> function must contain <b>WSAID_GETACCEPTEXSOCKADDRS</b>, a globally unique identifier (GUID) whose value identifies the <b>GetAcceptExSockaddrs</b> extension function. On success, the output returned by the <b>WSAIoctl</b> function contains a pointer to the <b>GetAcceptExSockaddrs</b> function. The <b>WSAID_GETACCEPTEXSOCKADDRS</b> GUID is defined in the <i>Mswsock.h</i> header file.</div>
     * <div></div>
     * 
     * 
     * <b>WindowsPhone8:</b> This function is supported for Windows Phone Store apps on WindowsPhone8 and later.
     * 
     * <b>Windows8.1</b> and <b>Windows Server2012R2</b>: This function is supported for Windows Store apps on Windows8.1, Windows Server2012R2, and later.
     * 
     * 
     * @param {Pointer<Void>} lpOutputBuffer A pointer to a buffer that receives the first block of data sent on a connection resulting from an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> call. Must be the same <i>lpOutputBuffer</i> parameter that was passed to the 
     * <b>AcceptEx</b>function.
     * @param {Integer} dwReceiveDataLength The number of bytes in the buffer used for receiving the first data. This value must be equal to the <i>dwReceiveDataLength</i> parameter that was passed to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a>function.
     * @param {Integer} dwLocalAddressLength The number of bytes reserved for the local address information. This value must be equal to the <i>dwLocalAddressLength</i> parameter that was passed to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> function.
     * @param {Integer} dwRemoteAddressLength The number of bytes reserved for the remote address information. This value must be equal to the <i>dwRemoteAddressLength</i> parameter that was passed to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/mswsock/nf-mswsock-acceptex">AcceptEx</a> function.
     * @param {Pointer<Pointer<SOCKADDR>>} LocalSockaddr A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that receives the local address of the connection (the same information that would be returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getsockname">getsockname</a> function). This parameter must be specified.
     * @param {Pointer<Integer>} LocalSockaddrLength The size, in bytes, of the local address. This parameter must be specified.
     * @param {Pointer<Pointer<SOCKADDR>>} RemoteSockaddr A pointer to the <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr</a> structure that receives the remote address of the connection (the same information that would be returned by the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock/nf-winsock-getpeername">getpeername</a> function). This parameter must be specified.
     * @param {Pointer<Integer>} RemoteSockaddrLength The size, in bytes, of the local address. This parameter must be specified.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//winsock/nf-winsock-getacceptexsockaddrs
     * @since windows8.1
     */
    static GetAcceptExSockaddrs(lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength) {
        DllCall("MSWSOCK.dll\GetAcceptExSockaddrs", "ptr", lpOutputBuffer, "uint", dwReceiveDataLength, "uint", dwLocalAddressLength, "uint", dwRemoteAddressLength, "ptr*", LocalSockaddr, "int*", LocalSockaddrLength, "ptr*", RemoteSockaddr, "int*", RemoteSockaddrLength)
    }

    /**
     * The WSCEnumProtocols function retrieves information about available transport protocols.
     * @param {Pointer<Integer>} lpiProtocols A **NULL**-terminated array of <i>iProtocol</i> values. This parameter is optional; if <i>lpiProtocols</i> is NULL, information on all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
     * @param {Pointer} lpProtocolBuffer A pointer to a buffer that is filled with 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infow">WSAPROTOCOL_INFOW</a> structures.
     * @param {Pointer<Integer>} lpdwBufferLength On input, size of the <i>lpProtocolBuffer</i> buffer passed to 
     * **WSCEnumProtocols**, in bytes. On output, the minimum buffer size, in bytes, that can be passed to 
     * **WSCEnumProtocols** to retrieve all the requested information.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code.
     * @returns {Integer} If no error occurs, 
     * **WSCEnumProtocols** returns the number of protocols to be reported on. Otherwise, a value of SOCKET_ERROR is returned and a specific error code is available in <i>lpErrno</i>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One of more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * Indicates that one of the specified parameters was invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * Buffer length was too small to receive all the relevant 
     * <a href="/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures and associated information. Pass in a buffer at least as large as the value returned in <i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscenumprotocols
     * @since windows5.0
     */
    static WSCEnumProtocols(lpiProtocols, lpProtocolBuffer, lpdwBufferLength, lpErrno) {
        result := DllCall("WS2_32.dll\WSCEnumProtocols", "int*", lpiProtocols, "ptr", lpProtocolBuffer, "uint*", lpdwBufferLength, "int*", lpErrno, "int")
        return result
    }

    /**
     * Removes the specified transport provider from the system configuration database.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider. This value is stored within each 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structure.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, 
     * **WSCDeinstallProvider** returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error code is available in <i>lpErrno</i>.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProviderId</i> parameter does not specify a valid provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpErrno</i> parameter is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the  Windows Sockets registry, or a failure occurred when opening a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscdeinstallprovider
     * @since windows5.0
     */
    static WSCDeinstallProvider(lpProviderId, lpErrno) {
        result := DllCall("WS2_32.dll\WSCDeinstallProvider", "ptr", lpProviderId, "int*", lpErrno, "int")
        return result
    }

    /**
     * Installs the specified transport provider into the system configuration database.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {PWSTR} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure defines a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If **WSCInstallProvider** succeeds, it returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Memory cannot be allocated for buffers.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is already installed, the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when creating or installing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscinstallprovider
     * @since windows5.0
     */
    static WSCInstallProvider(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        lpszProviderDllPath := lpszProviderDllPath is String ? StrPtr(lpszProviderDllPath) : lpszProviderDllPath

        result := DllCall("WS2_32.dll\WSCInstallProvider", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "int*", lpErrno, "int")
        return result
    }

    /**
     * The WSCGetProviderPath function retrieves the DLL path for the specified provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider. This value is obtained by using 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2spi/nf-ws2spi-wscenumprotocols">WSCEnumProtocols</a>.
     * @param {PWSTR} lpszProviderDllPath A pointer to a buffer into which the provider DLL's path string is returned. The path is a null-terminated string and any embedded environment strings, such as %SystemRoot%, have not been expanded.
     * @param {Pointer<Integer>} lpProviderDllPathLen The size, in characters, of the buffer pointed to by the <i>lpszProviderDllPath</i> parameter.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, 
     * **WSCGetProviderPath** returns zero. Otherwise, it returns SOCKET_ERROR. The specific error code is available in <i>lpErrno</i>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProviderId</i> parameter does not specify a valid provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpszProviderDllPath</i> or <i>lpErrno</i> parameter is not in a valid part of the user address space, or <i>lpProviderDllPathLen</i> is too small.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscgetproviderpath
     * @since windows5.0
     */
    static WSCGetProviderPath(lpProviderId, lpszProviderDllPath, lpProviderDllPathLen, lpErrno) {
        lpszProviderDllPath := lpszProviderDllPath is String ? StrPtr(lpszProviderDllPath) : lpszProviderDllPath

        result := DllCall("WS2_32.dll\WSCGetProviderPath", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "int*", lpProviderDllPathLen, "int*", lpErrno, "int")
        return result
    }

    /**
     * Modifies the specified transport provider in the system configuration database.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {PWSTR} lpszProviderDllPath A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Pointer<WSAPROTOCOL_INFOW>} lpProtocolInfoList A pointer to an array of 
     * <a href="https://docs.microsoft.com/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAProtocol_Info</a> structures. Each structure specifies or modifies a protocol, address family, and socket type supported by the provider.
     * @param {Integer} dwNumberOfEntries The number of entries in the <i>lpProtocolInfoList</i> array.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, 
     * **WSCUpdateProvider** returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when opening or writing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscupdateprovider
     * @since windows5.1.2600
     */
    static WSCUpdateProvider(lpProviderId, lpszProviderDllPath, lpProtocolInfoList, dwNumberOfEntries, lpErrno) {
        lpszProviderDllPath := lpszProviderDllPath is String ? StrPtr(lpszProviderDllPath) : lpszProviderDllPath

        result := DllCall("WS2_32.dll\WSCUpdateProvider", "ptr", lpProviderId, "ptr", lpszProviderDllPath, "ptr", lpProtocolInfoList, "uint", dwNumberOfEntries, "int*", lpErrno, "int")
        return result
    }

    /**
     * Sets the data value for the specified information class for a layered service provider (LSP).
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class to be set for this LSP protocol entry.
     * @param {Pointer} Info A pointer to a buffer that contains the information class data to set for the LSP protocol entry.
     * @param {Pointer} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info </i>parameter.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCSetProviderInfo** function call.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, **WSCSetProviderInfo** returns **ERROR_SUCCESS** (zero). Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the <i>InfoType</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscsetproviderinfo
     * @since windows6.0.6000
     */
    static WSCSetProviderInfo(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        result := DllCall("WS2_32.dll\WSCSetProviderInfo", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr", InfoSize, "uint", Flags, "int*", lpErrno, "int")
        return result
    }

    /**
     * Retrieves the data associated with an information class for a layered service provider (LSP).
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the provider.
     * @param {Integer} InfoType The information class that is requested for this LSP protocol entry.
     * @param {Pointer} Info A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is **NULL**, then **WSCGetProviderInfo** returns failure and the size required for this buffer is returned in the <i>InfoSize</i> parameter.
     * @param {Pointer<Pointer>} InfoSize The size, in bytes, of the buffer pointed to by the <i>Info </i>parameter. If the Info parameter is **NULL**, then  **WSCGetProviderInfo** returns failure and the <i>InfoSize</i> parameter will receive the size of the required buffer.
     * @param {Integer} Flags The flags used to modify the behavior of the **WSCGetProviderInfo** function call.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, **WSCGetProviderInfo** returns **ERROR_SUCCESS** (zero). Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_CALL_NOT_IMPLEMENTED</b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the <i>InfoType</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The protocol entry could not be found for the specified <i>lpProviderId</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscgetproviderinfo
     * @since windows6.0.6000
     */
    static WSCGetProviderInfo(lpProviderId, InfoType, Info, InfoSize, Flags, lpErrno) {
        result := DllCall("WS2_32.dll\WSCGetProviderInfo", "ptr", lpProviderId, "int", InfoType, "ptr", Info, "ptr*", InfoSize, "uint", Flags, "int*", lpErrno, "int")
        return result
    }

    /**
     * Sets the permitted layered service provider (LSP) categories associated with an application.
     * @param {PWSTR} Path A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>).
     * @param {Integer} PathLength The length, in characters, of the <i>Path</i> parameter. This length does not include the terminating **NULL**.
     * @param {PWSTR} Extra A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the <i>Path</i> parameter. The <i>Extra</i> parameter is used to distinguish between multiple, distinct instances of an application when launched with a consistent command line.  This is to support different application categorizations for different instances of Svchost.exe or Rundll32.exe. If only the <i>Path</i> parameter is required and no command line arguments are needed to further distinguish between instances of an application, then the <i>Extra</i> parameter should be set to **NULL**.
     * @param {Integer} ExtraLength The length, in characters, of the <i>Extra</i> parameter. This length does not include the terminating **NULL**.
     * @param {Integer} PermittedLspCategories A DWORD value of the LSP categories which are permitted for all instances of this application. The application is identified by the combination of the values of the <i>Path</i> and <i>Extra</i> parameters.
     * @param {Pointer<Integer>} pPrevPermLspCat A pointer to receive the previous set of permitted LSP categories which were permitted for all instances of this application. This parameter is optional can  be **NULL**.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, **WSCSetApplicationCategory** returns **ERROR_SUCCESS** (zero). Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry or an application ID entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscsetapplicationcategory
     * @since windows6.0.6000
     */
    static WSCSetApplicationCategory(Path, PathLength, Extra, ExtraLength, PermittedLspCategories, pPrevPermLspCat, lpErrno) {
        Path := Path is String ? StrPtr(Path) : Path
        Extra := Extra is String ? StrPtr(Extra) : Extra

        result := DllCall("WS2_32.dll\WSCSetApplicationCategory", "ptr", Path, "uint", PathLength, "ptr", Extra, "uint", ExtraLength, "uint", PermittedLspCategories, "uint*", pPrevPermLspCat, "int*", lpErrno, "int")
        return result
    }

    /**
     * Retrieves the layered service provider (LSP) categories associated with an application.
     * @param {PWSTR} Path A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>).
     * @param {Integer} PathLength The length, in characters, of the <i>Path</i> parameter. This length does not include the terminating **NULL**.
     * @param {PWSTR} Extra A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the <i>Path</i> parameter. The <i>Extra</i> parameter is used to distinguish between multiple, distinct instances of an application when launched with a consistent command line.  This is to support different application categorizations for different instances of Svchost.exe or Rundll32.exe. If only the <i>Path</i> parameter is required and no command line arguments are needed to further distinguish between instances of an application, then the <i>Extra</i> parameter should be set to **NULL**.
     * @param {Integer} ExtraLength The length, in characters, of the <i>Extra</i> parameter. This length does not include the terminating **NULL**.
     * @param {Pointer<Integer>} pPermittedLspCategories A pointer to a DWORD value of permitted LSP categories which are permitted for all instances of this application. The application is identified by the combination of the values of the <i>Path</i> and <i>Extra</i> parameters.
     * @param {Pointer<Integer>} lpErrno A pointer to the error code if the function fails.
     * @returns {Integer} If no error occurs, **WSCGetApplicationCategory** returns **ERROR_SUCCESS** (zero). Otherwise, it returns **SOCKET_ERROR**, and a specific error code is returned in the <i>lpErrno</i> parameter.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASERVICE_NOT_FOUND</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The service could not be found based on the <i>Path</i> and <i>Extra</i> parameters. 
     * 
     * The error can also be returned if the application you are querying does not exist in the registry. In this case, the error indicates that the application is not currently categorized.
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry or an application ID entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscgetapplicationcategory
     * @since windows6.0.6000
     */
    static WSCGetApplicationCategory(Path, PathLength, Extra, ExtraLength, pPermittedLspCategories, lpErrno) {
        Path := Path is String ? StrPtr(Path) : Path
        Extra := Extra is String ? StrPtr(Extra) : Extra

        result := DllCall("WS2_32.dll\WSCGetApplicationCategory", "ptr", Path, "uint", PathLength, "ptr", Extra, "uint", ExtraLength, "uint*", pPermittedLspCategories, "int*", lpErrno, "int")
        return result
    }

    /**
     * The WPUCompleteOverlappedRequest function performs overlapped I/O completion notification for overlapped I/O operations.
     * @param {SOCKET} s The service provider socket created by 
     * <a href="https://docs.microsoft.com/windows/win32/api/ws2spi/nf-ws2spi-wpucreatesockethandle">WPUCreateSocketHandle</a>.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure associated with the overlapped I/O operation whose completion is to be notified.
     * @param {Integer} dwError The completion status of the overlapped I/O operation whose completion is to be notified.
     * @param {Integer} cbTransferred The number of bytes transferred to or from client buffers (the direction of the transfer depends on the send or receive nature of the overlapped I/O operation whose completion is to be notified).
     * @param {Pointer<Integer>} lpErrno A pointer to the error code resulting from execution of this function.
     * @returns {Integer} If no error occurs, 
     * **WPUCompleteOverlappedRequest** returns zero and notifies completion of the overlapped I/O operation according to the mechanism selected by the client (signals an event found in the 
     * <a href="/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure referenced by <i>lpOverlapped</i> and/or queues a completion status report to the completion port associated with the socket if a completion port is associated). Otherwise, 
     * **WPUCompleteOverlappedRequest** returns SOCKET_ERROR, and a specific error code is available in <i>lpErrno</i>.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket passed in the <i>s</i> parameter is not a socket created by 
     * <a href="/windows/win32/api/ws2spi/nf-ws2spi-wpucreatesockethandle">WPUCreateSocketHandle</a>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wpucompleteoverlappedrequest
     * @since windows5.0
     */
    static WPUCompleteOverlappedRequest(s, lpOverlapped, dwError, cbTransferred, lpErrno) {
        s := s is Win32Handle ? NumGet(s, "ptr") : s

        result := DllCall("WS2_32.dll\WPUCompleteOverlappedRequest", "ptr", s, "ptr", lpOverlapped, "uint", dwError, "uint", cbTransferred, "int*", lpErrno, "int")
        return result
    }

    /**
     * Installs a namespace provider.
     * @param {PWSTR} lpszIdentifier A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the <i>lpProviderId</i> parameter.
     * @param {PWSTR} lpszPathName A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Integer} dwNameSpace The namespace supported by this provider.
     * @param {Integer} dwVersion The version number of the provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID  for the provider. This GUID should be generated by Uuidgen.exe.
     * @returns {Integer} If no error occurs, the 
     * **WSCInstallNameSpace** function returns **NO_ERROR** (zero). Otherwise, it returns **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to install a namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is already installed, the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when creating or installing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscinstallnamespace
     * @since windows5.0
     */
    static WSCInstallNameSpace(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId) {
        lpszIdentifier := lpszIdentifier is String ? StrPtr(lpszIdentifier) : lpszIdentifier
        lpszPathName := lpszPathName is String ? StrPtr(lpszPathName) : lpszPathName

        result := DllCall("WS2_32.dll\WSCInstallNameSpace", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId, "int")
        return result
    }

    /**
     * Uninstalls the indicated name-space provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the name-space provider to be uninstalled.
     * @returns {Integer} If no error occurs, 
     * **WSCUnInstallNameSpace** returns **NO_ERROR** (zero). Otherwise, it returns **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProviderId</i> parameter points to memory that is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified namespaceprovider identifier is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscuninstallnamespace
     * @since windows5.0
     */
    static WSCUnInstallNameSpace(lpProviderId) {
        result := DllCall("WS2_32.dll\WSCUnInstallNameSpace", "ptr", lpProviderId, "int")
        return result
    }

    /**
     * Installs a namespace provider.
     * @param {PWSTR} lpszIdentifier A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the <i>lpProviderId</i> parameter.
     * @param {PWSTR} lpszPathName A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path resolution and can contain embedded environment strings (such as <i>%SystemRoot%</i>). Such environment strings are expanded when the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are expanded, the Ws2_32.dll passes the resulting string to the <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a> function which loads the provider into memory. For more information, see **LoadLibrary**.
     * @param {Integer} dwNameSpace The namespace supported by this provider.
     * @param {Integer} dwVersion The version number of the provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a GUID  for the provider. This GUID should be generated by Uuidgen.exe.
     * @param {Pointer<BLOB>} lpProviderSpecific A provider-specific data blob associated with namespace entry.
     * @returns {Integer} If no error occurs, the 
     * **WSCInstallNameSpaceEx** function returns **NO_ERROR** (zero). Otherwise, it returns **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEACCES</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The calling routine does not have sufficient privileges to install a namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is already installed, the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when creating or installing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscinstallnamespaceex
     * @since windows6.0.6000
     */
    static WSCInstallNameSpaceEx(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId, lpProviderSpecific) {
        lpszIdentifier := lpszIdentifier is String ? StrPtr(lpszIdentifier) : lpszIdentifier
        lpszPathName := lpszPathName is String ? StrPtr(lpszPathName) : lpszPathName

        result := DllCall("WS2_32.dll\WSCInstallNameSpaceEx", "ptr", lpszIdentifier, "ptr", lpszPathName, "uint", dwNameSpace, "uint", dwVersion, "ptr", lpProviderId, "ptr", lpProviderSpecific, "int")
        return result
    }

    /**
     * Changes the state of a given namespace provider.
     * @param {Pointer<Guid>} lpProviderId A pointer to a globally unique identifier (GUID)  for the namespace provider.
     * @param {BOOL} fEnable A Boolean value that, if **TRUE**, the provider is set to the active state. If **FALSE**, the provider is disabled and will not be available for query operations or service registration.
     * @returns {Integer} If no error occurs, the 
     * **WSCEnableNSProvider** function returns **NO_ERROR** (zero). Otherwise, it returns **SOCKET_ERROR** if the function fails, and you must retrieve the appropriate error code using the 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> function.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>lpProviderId</i> parameter points to memory that is not in a valid part of the user address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified namespace provider identifier is invalid.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wscenablensprovider
     * @since windows5.0
     */
    static WSCEnableNSProvider(lpProviderId, fEnable) {
        result := DllCall("WS2_32.dll\WSCEnableNSProvider", "ptr", lpProviderId, "int", fEnable, "int")
        return result
    }

    /**
     * Makes a specific namespace version-2 provider available for all eligible clients.
     * @param {Pointer<Guid>} puuidProviderId A pointer to the provider ID of the namespace provider to be advertised.
     * @param {Pointer<NSPV2_ROUTINE>} pNSPv2Routine A pointer to a **NSPV2_ROUTINE** structure with the namespace service provider version-2 entry points supported by the provider.
     * @returns {Integer} If no error occurs, 
     * <a href="/windows/desktop/api/ws2spi/nf-ws2spi-wsaprovidercompleteasynccall">WSAProviderCompleteAsyncCall</a> returns zero.
     * 
     * If the function fails, the return value is SOCKET_ERROR. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>, which returns one of the following extended error values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter was not valid. This error is returned if the <i>puuidProviderId</i> or <i>pNSPv2Routine</i> parameters were **NULL**. 
     * 
     * This error is also returned if the **NSPv2LookupServiceBegin**, **NSPv2LookupServiceNextEx**, or **NSPv2LookupServiceEnd** members of the **NSPV2_ROUTINE** structure pointed to by the <i>pNSPv2Routine</i> parameter are **NULL**. A namespace version-2 provider must at least support name resolution which this minimum set of functions.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVALIDPROVIDER</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The namespace provider could not be found for the specified <i>puuidProviderId</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Ws2_32.dll</i> has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wsaadvertiseprovider
     * @since windows6.0.6000
     */
    static WSAAdvertiseProvider(puuidProviderId, pNSPv2Routine) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAAdvertiseProvider", "ptr", puuidProviderId, "ptr", pNSPv2Routine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Makes a specific namespace version-2 provider no longer available for clients.
     * @param {Pointer<Guid>} puuidProviderId A pointer to the provider ID of the namespace provider.
     * @returns {Integer} If no error occurs, 
     * **WSAUnadvertiseProvider** returns zero. Otherwise, it returns **SOCKET_ERROR**, and a specific error code is available by calling <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter was not valid. This error is returned if the <i>puuidProviderId</i> parameter was **NULL**. 
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wsaunadvertiseprovider
     * @since windows6.0.6000
     */
    static WSAUnadvertiseProvider(puuidProviderId) {
        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAUnadvertiseProvider", "ptr", puuidProviderId, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Notifies a client when an asynchronous call to a namespace version-2 provider is completed.
     * @param {HANDLE} hAsyncCall The handle passed to the asynchronous call being completed. This handle is passed by the client to the namespace version-2 provider in the asynchronous function call.
     * @param {Integer} iRetCode The return code for the asynchronous call to the namespace version-2 provider.
     * @returns {Integer} If no error occurs, 
     * **WSAProviderCompleteAsyncCall** returns zero.
     * 
     * If the function fails, the return value is SOCKET_ERROR. To get extended error information, call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>, which returns one of the following extended error values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * An internal error occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * A parameter was not valid. This error is returned if the <i>hAsyncCall</i> parameter was **NULL**. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dl>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>Ws2_32.dll</i> has not been initialized. The application must first call 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> before calling any Windows Sockets functions.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2spi/nf-ws2spi-wsaprovidercompleteasynccall
     * @since windows6.0.6000
     */
    static WSAProviderCompleteAsyncCall(hAsyncCall, iRetCode) {
        hAsyncCall := hAsyncCall is Win32Handle ? NumGet(hAsyncCall, "ptr") : hAsyncCall

        A_LastError := 0

        result := DllCall("WS2_32.dll\WSAProviderCompleteAsyncCall", "ptr", hAsyncCall, "int", iRetCode, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The EnumProtocols function retrieves information about a specified set of network protocols that are active on a local host.
     * @param {Pointer<Integer>} lpiProtocols A pointer to a <b>null</b>-terminated array of protocol identifiers. The 
     * <b>EnumProtocols</b> function retrieves information about the protocols specified by this array. 
     * 
     * 
     * 
     * 
     * If <i>lpiProtocols</i> is <b>NULL</b>, the function retrieves information about all available protocols.
     * 
     * The following protocol identifier values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP), a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP), a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ISOPROTO_TP4"></a><a id="isoproto_tp4"></a><dl>
     * <dt><b>ISOPROTO_TP4</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The ISO connection-oriented transport protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_IPX"></a><a id="nsproto_ipx"></a><dl>
     * <dt><b>NSPROTO_IPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Packet Exchange (IPX) protocol, a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPX"></a><a id="nsproto_spx"></a><dl>
     * <dt><b>NSPROTO_SPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPXII"></a><a id="nsproto_spxii"></a><dl>
     * <dt><b>NSPROTO_SPXII</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol version 2, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} lpProtocolBuffer A pointer to a buffer that the function fills with an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> data structures.
     * @param {Pointer<Integer>} lpdwBufferLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpProtocolBuffer</i>. 
     * 
     * 
     * 
     * 
     * On output, the function sets this variable to the minimum buffer size needed to retrieve all of the requested information. For the function to succeed, the buffer must be at least this size.
     * @returns {Integer} If the function succeeds, the return value is the number of 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> data structures written to the buffer pointed to by <i>lpProtocolBuffer</i>.
     * 
     * If the function fails, the return value is SOCKET_ERROR(1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns the following extended error code.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by <i>lpProtocolBuffer</i> was too small to receive all of the relevant 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> structures. Call the function with a buffer at least as large as the value returned in *<i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-enumprotocolsa
     * @since windows5.0
     */
    static EnumProtocolsA(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        result := DllCall("MSWSOCK.dll\EnumProtocolsA", "int*", lpiProtocols, "ptr", lpProtocolBuffer, "uint*", lpdwBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The EnumProtocols function retrieves information about a specified set of network protocols that are active on a local host.
     * @param {Pointer<Integer>} lpiProtocols A pointer to a <b>null</b>-terminated array of protocol identifiers. The 
     * <b>EnumProtocols</b> function retrieves information about the protocols specified by this array. 
     * 
     * 
     * 
     * 
     * If <i>lpiProtocols</i> is <b>NULL</b>, the function retrieves information about all available protocols.
     * 
     * The following protocol identifier values are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_TCP"></a><a id="ipproto_tcp"></a><dl>
     * <dt><b>IPPROTO_TCP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Transmission Control Protocol (TCP), a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="IPPROTO_UDP"></a><a id="ipproto_udp"></a><dl>
     * <dt><b>IPPROTO_UDP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The User Datagram Protocol (UDP), a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="ISOPROTO_TP4"></a><a id="isoproto_tp4"></a><dl>
     * <dt><b>ISOPROTO_TP4</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The ISO connection-oriented transport protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_IPX"></a><a id="nsproto_ipx"></a><dl>
     * <dt><b>NSPROTO_IPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Packet Exchange (IPX) protocol, a connectionless datagram protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPX"></a><a id="nsproto_spx"></a><dl>
     * <dt><b>NSPROTO_SPX</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NSPROTO_SPXII"></a><a id="nsproto_spxii"></a><dl>
     * <dt><b>NSPROTO_SPXII</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Sequenced Packet Exchange (SPX) protocol version 2, a connection-oriented stream protocol.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} lpProtocolBuffer A pointer to a buffer that the function fills with an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> data structures.
     * @param {Pointer<Integer>} lpdwBufferLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpProtocolBuffer</i>. 
     * 
     * 
     * 
     * 
     * On output, the function sets this variable to the minimum buffer size needed to retrieve all of the requested information. For the function to succeed, the buffer must be at least this size.
     * @returns {Integer} If the function succeeds, the return value is the number of 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> data structures written to the buffer pointed to by <i>lpProtocolBuffer</i>.
     * 
     * If the function fails, the return value is SOCKET_ERROR(1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns the following extended error code.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by <i>lpProtocolBuffer</i> was too small to receive all of the relevant 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-protocol_infoa">PROTOCOL_INFO</a> structures. Call the function with a buffer at least as large as the value returned in *<i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-enumprotocolsw
     * @since windows5.0
     */
    static EnumProtocolsW(lpiProtocols, lpProtocolBuffer, lpdwBufferLength) {
        A_LastError := 0

        result := DllCall("MSWSOCK.dll\EnumProtocolsW", "int*", lpiProtocols, "ptr", lpProtocolBuffer, "uint*", lpdwBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * GetAddressByName is no longer available for use as of Windows Sockets 2.
     * @param {Integer} dwNameSpace The namespace, or set of default namespaces, that the operating system should query for network address information.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. This is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System (DNS) used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Most calls to 
     * <b>GetAddressByName</b> should use the special value NS_DEFAULT. This lets a client get by with no knowledge of which namespaces are available on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The Svcguid.h header file is not automatically included by the Winsock2.h header file.
     * @param {PSTR} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER".
     * 
     * Setting <i>lpServiceName</i> to <b>NULL</b> is the equivalent of setting <i>dwResolution</i> to RES_SERVICE. The function operates in its second mode, obtaining the local address to which a service of the specified type should bind. The function stores the local address within the <b>LocalAddr</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures stored into *<i>lpCsaddrBuffer</i>.
     * 
     * If <i>dwResolution</i> is set to RES_SERVICE, the function ignores the <i>lpServiceName</i> parameter.
     * 
     * If <i>dwNameSpace</i> is set to NS_DNS, *<i>lpServiceName</i> is the name of the host.
     * @param {Pointer<Integer>} lpiProtocols A pointer to a zero-terminated array of protocol identifiers. The function restricts a name resolution attempt to namespace providers that offer these protocols. This lets the caller limit the scope of the search.
     * 
     * If <i>lpiProtocols</i> is set to <b>NULL</b>, the function retrieves information on all available protocols.
     * @param {Integer} dwResolution A set of bit flags that specify aspects of the service name resolution process. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SERVICE"></a><a id="res_service"></a><dl>
     * <dt><b>RES_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the function retrieves the address to which a service of the specified type should bind. This is the equivalent to setting the <i>lpServiceName</i> parameter to <b>NULL</b>.
     * 
     * If this flag is clear, normal name resolution occurs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_FIND_MULTIPLE"></a><a id="res_find_multiple"></a><dl>
     * <dt><b>RES_FIND_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the operating system performs an extensive search of all namespaces for the service. It asks every appropriate namespace to resolve the service name. If this flag is clear, the operating system stops looking for service addresses as soon as one is found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SOFT_SEARCH"></a><a id="res_soft_search"></a><dl>
     * <dt><b>RES_SOFT_SEARCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is valid if the namespace supports multiple levels of searching.
     * 
     * If this flag is valid and set, the operating system performs a simple and quick search of the namespace. This is useful if an application only needs to obtain easy-to-find addresses for the service.
     * 
     * If this flag is valid and clear, the operating system performs a more extensive search of the namespace.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use; must be set to <b>NULL</b>.
     * @param {Pointer} lpCsaddrBuffer A pointer to a buffer to receive one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> data structures. The number of structures written to the buffer depends on the amount of information found in the resolution attempt. You should assume that multiple structures will be written, although in many cases there will only be one.
     * @param {Pointer<Integer>} lpdwBufferLength A pointer to a variable that, upon input, specifies the size, in bytes, of the buffer pointed to by <i>lpCsaddrBuffer</i>.
     * 
     * Upon output, this variable contains the total number of bytes required to store the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures. If this value is less than or equal to the input value of *<i>lpdwBufferLength</i>, and the function is successful, this is the number of bytes actually stored in the buffer. If this value is greater than the input value of *<i>lpdwBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwBufferLength</i> is the minimal required buffer size.
     * @param {PSTR} lpAliasBuffer A pointer to a buffer to receive alias information for the network service.
     * 
     * If a namespace supports aliases, the function stores an array of zero-terminated name strings into the buffer pointed to by <i>lpAliasBuffer</i>. There is a double zero-terminator at the end of the list. The first name in the array is the service's primary name. Names that follow are aliases. An example of a namespace that supports aliases is DNS.
     * 
     * If a namespace does not support aliases, it stores a double zero-terminator into the buffer.
     * 
     * This parameter is optional, and can be set to <b>NULL</b>.
     * @param {Pointer<Integer>} lpdwAliasBufferLength A pointer to a variable that, upon input, specifies the size, in elements (characters), of the buffer pointed to by <i>lpAliasBuffer</i>.
     * 
     * Upon output, this variable contains the total number of elements (characters) required to store the array of name strings. If this value is less than or equal to the input value of *<i>lpdwAliasBufferLength</i>, and the function is successful, this is the number of elements actually stored in the buffer. If this value is greater than the input value of *<i>lpdwAliasBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwAliasBufferLength</i> is the minimal required buffer size.
     * 
     * If <i>lpAliasBuffer</i> is <b>NULL</b>, <i>lpdwAliasBufferLength</i> is meaningless and can also be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the number of 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> data structures written to the buffer pointed to by <i>lpCsaddrBuffer</i>.
     * 
     * If the function fails, the return value is SOCKET_ERROR( 1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns the following extended error value.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by <i>lpCsaddrBuffer</i> was too small to receive all of the relevant 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures. Call the function with a buffer at least as large as the value returned in *<i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-getaddressbynamea
     * @since windows5.0
     */
    static GetAddressByNameA(dwNameSpace, lpServiceType, lpServiceName, lpiProtocols, dwResolution, lpServiceAsyncInfo, lpCsaddrBuffer, lpdwBufferLength, lpAliasBuffer, lpdwAliasBufferLength) {
        lpServiceName := lpServiceName is String ? StrPtr(lpServiceName) : lpServiceName
        lpAliasBuffer := lpAliasBuffer is String ? StrPtr(lpAliasBuffer) : lpAliasBuffer

        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetAddressByNameA", "uint", dwNameSpace, "ptr", lpServiceType, "ptr", lpServiceName, "int*", lpiProtocols, "uint", dwResolution, "ptr", lpServiceAsyncInfo, "ptr", lpCsaddrBuffer, "uint*", lpdwBufferLength, "ptr", lpAliasBuffer, "uint*", lpdwAliasBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * GetAddressByName is no longer available for use as of Windows Sockets 2.
     * @param {Integer} dwNameSpace The namespace, or set of default namespaces, that the operating system should query for network address information.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. This is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System (DNS) used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Most calls to 
     * <b>GetAddressByName</b> should use the special value NS_DEFAULT. This lets a client get by with no knowledge of which namespaces are available on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The Svcguid.h header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The Svcguid.h header file is not automatically included by the Winsock2.h header file.
     * @param {PWSTR} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER".
     * 
     * Setting <i>lpServiceName</i> to <b>NULL</b> is the equivalent of setting <i>dwResolution</i> to RES_SERVICE. The function operates in its second mode, obtaining the local address to which a service of the specified type should bind. The function stores the local address within the <b>LocalAddr</b> member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures stored into *<i>lpCsaddrBuffer</i>.
     * 
     * If <i>dwResolution</i> is set to RES_SERVICE, the function ignores the <i>lpServiceName</i> parameter.
     * 
     * If <i>dwNameSpace</i> is set to NS_DNS, *<i>lpServiceName</i> is the name of the host.
     * @param {Pointer<Integer>} lpiProtocols A pointer to a zero-terminated array of protocol identifiers. The function restricts a name resolution attempt to namespace providers that offer these protocols. This lets the caller limit the scope of the search.
     * 
     * If <i>lpiProtocols</i> is set to <b>NULL</b>, the function retrieves information on all available protocols.
     * @param {Integer} dwResolution A set of bit flags that specify aspects of the service name resolution process. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SERVICE"></a><a id="res_service"></a><dl>
     * <dt><b>RES_SERVICE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If set, the function retrieves the address to which a service of the specified type should bind. This is the equivalent to setting the <i>lpServiceName</i> parameter to <b>NULL</b>.
     * 
     * If this flag is clear, normal name resolution occurs.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_FIND_MULTIPLE"></a><a id="res_find_multiple"></a><dl>
     * <dt><b>RES_FIND_MULTIPLE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the operating system performs an extensive search of all namespaces for the service. It asks every appropriate namespace to resolve the service name. If this flag is clear, the operating system stops looking for service addresses as soon as one is found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="RES_SOFT_SEARCH"></a><a id="res_soft_search"></a><dl>
     * <dt><b>RES_SOFT_SEARCH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This flag is valid if the namespace supports multiple levels of searching.
     * 
     * If this flag is valid and set, the operating system performs a simple and quick search of the namespace. This is useful if an application only needs to obtain easy-to-find addresses for the service.
     * 
     * If this flag is valid and clear, the operating system performs a more extensive search of the namespace.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use; must be set to <b>NULL</b>.
     * @param {Pointer} lpCsaddrBuffer A pointer to a buffer to receive one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> data structures. The number of structures written to the buffer depends on the amount of information found in the resolution attempt. You should assume that multiple structures will be written, although in many cases there will only be one.
     * @param {Pointer<Integer>} lpdwBufferLength A pointer to a variable that, upon input, specifies the size, in bytes, of the buffer pointed to by <i>lpCsaddrBuffer</i>.
     * 
     * Upon output, this variable contains the total number of bytes required to store the array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures. If this value is less than or equal to the input value of *<i>lpdwBufferLength</i>, and the function is successful, this is the number of bytes actually stored in the buffer. If this value is greater than the input value of *<i>lpdwBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwBufferLength</i> is the minimal required buffer size.
     * @param {PWSTR} lpAliasBuffer A pointer to a buffer to receive alias information for the network service.
     * 
     * If a namespace supports aliases, the function stores an array of zero-terminated name strings into the buffer pointed to by <i>lpAliasBuffer</i>. There is a double zero-terminator at the end of the list. The first name in the array is the service's primary name. Names that follow are aliases. An example of a namespace that supports aliases is DNS.
     * 
     * If a namespace does not support aliases, it stores a double zero-terminator into the buffer.
     * 
     * This parameter is optional, and can be set to <b>NULL</b>.
     * @param {Pointer<Integer>} lpdwAliasBufferLength A pointer to a variable that, upon input, specifies the size, in elements (characters), of the buffer pointed to by <i>lpAliasBuffer</i>.
     * 
     * Upon output, this variable contains the total number of elements (characters) required to store the array of name strings. If this value is less than or equal to the input value of *<i>lpdwAliasBufferLength</i>, and the function is successful, this is the number of elements actually stored in the buffer. If this value is greater than the input value of *<i>lpdwAliasBufferLength</i>, the buffer was too small, and the output value of *<i>lpdwAliasBufferLength</i> is the minimal required buffer size.
     * 
     * If <i>lpAliasBuffer</i> is <b>NULL</b>, <i>lpdwAliasBufferLength</i> is meaningless and can also be <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the number of 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> data structures written to the buffer pointed to by <i>lpCsaddrBuffer</i>.
     * 
     * If the function fails, the return value is SOCKET_ERROR( 1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns the following extended error value.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by <i>lpCsaddrBuffer</i> was too small to receive all of the relevant 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-csaddr_info">CSADDR_INFO</a> structures. Call the function with a buffer at least as large as the value returned in *<i>lpdwBufferLength</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-getaddressbynamew
     * @since windows5.0
     */
    static GetAddressByNameW(dwNameSpace, lpServiceType, lpServiceName, lpiProtocols, dwResolution, lpServiceAsyncInfo, lpCsaddrBuffer, lpdwBufferLength, lpAliasBuffer, lpdwAliasBufferLength) {
        lpServiceName := lpServiceName is String ? StrPtr(lpServiceName) : lpServiceName
        lpAliasBuffer := lpAliasBuffer is String ? StrPtr(lpAliasBuffer) : lpAliasBuffer

        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetAddressByNameW", "uint", dwNameSpace, "ptr", lpServiceType, "ptr", lpServiceName, "int*", lpiProtocols, "uint", dwResolution, "ptr", lpServiceAsyncInfo, "ptr", lpCsaddrBuffer, "uint*", lpdwBufferLength, "ptr", lpAliasBuffer, "uint*", lpdwAliasBufferLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetTypeByName function retrieves a service type GUID for a network service specified by name.
     * @param {PSTR} lpServiceName A pointer to a zero-terminated string that uniquely represents the name of the service. For example, "MY SNA SERVER."
     * @param {Pointer<Guid>} lpServiceType A pointer to a variable to receive a globally unique identifier (<b>GUID</b>) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several <b>GUID</b> service types and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @returns {Integer} If the function succeeds, the return value is zero.
     * 
     * If the function fails, the return value is SOCKET_ERROR(  1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns the following extended error value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SERVICE_DOES_NOT_EXIST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified service type is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-gettypebynamea
     * @since windows5.0
     */
    static GetTypeByNameA(lpServiceName, lpServiceType) {
        lpServiceName := lpServiceName is String ? StrPtr(lpServiceName) : lpServiceName

        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetTypeByNameA", "ptr", lpServiceName, "ptr", lpServiceType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetTypeByName function retrieves a service type GUID for a network service specified by name.
     * @param {PWSTR} lpServiceName A pointer to a zero-terminated string that uniquely represents the name of the service. For example, "MY SNA SERVER."
     * @param {Pointer<Guid>} lpServiceType A pointer to a variable to receive a globally unique identifier (<b>GUID</b>) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several <b>GUID</b> service types and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @returns {Integer} If the function succeeds, the return value is zero.
     * 
     * If the function fails, the return value is SOCKET_ERROR(  1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns the following extended error value.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SERVICE_DOES_NOT_EXIST</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified service type is unknown.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-gettypebynamew
     * @since windows5.0
     */
    static GetTypeByNameW(lpServiceName, lpServiceType) {
        lpServiceName := lpServiceName is String ? StrPtr(lpServiceName) : lpServiceName

        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetTypeByNameW", "ptr", lpServiceName, "ptr", lpServiceType, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetNameByType function retrieves the name of a network service for the specified service type.
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {Pointer} lpServiceName A pointer to a buffer to receive a zero-terminated string that uniquely represents the name of the network service.
     * @param {Integer} dwNameLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpServiceName</i>. On output, the variable contains the actual size of the service name string, in bytes.
     * @returns {Integer} If the function succeeds, the return value is not SOCKET_ERROR (1).
     * 
     * If the function fails, the return value is SOCKET_ERROR (1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-getnamebytypea
     * @since windows5.0
     */
    static GetNameByTypeA(lpServiceType, lpServiceName, dwNameLength) {
        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetNameByTypeA", "ptr", lpServiceType, "ptr", lpServiceName, "uint", dwNameLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetNameByType function retrieves the name of a network service for the specified service type.
     * @param {Pointer<Guid>} lpServiceType A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes definitions of several GUID service types, and macros for working with them.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {Pointer} lpServiceName A pointer to a buffer to receive a zero-terminated string that uniquely represents the name of the network service.
     * @param {Integer} dwNameLength A pointer to a variable that, on input, specifies the size, in bytes, of the buffer pointed to by <i>lpServiceName</i>. On output, the variable contains the actual size of the service name string, in bytes.
     * @returns {Integer} If the function succeeds, the return value is not SOCKET_ERROR (1).
     * 
     * If the function fails, the return value is SOCKET_ERROR (1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-getnamebytypew
     * @since windows5.0
     */
    static GetNameByTypeW(lpServiceType, lpServiceName, dwNameLength) {
        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetNameByTypeW", "ptr", lpServiceType, "ptr", lpServiceName, "uint", dwNameLength, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetService function registers or removes from the registry a network service within one or more namespaces.
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, within which the function will operate. 
     * 
     * 
     * 
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet to resolve the name of the host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl>
     * <dt><b>NS_NDS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare 4 provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All Windows systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery, if appropriate. NS_SAP is a dynamic namespace that enables the registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\posts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and lookup value in the cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwOperation 
     * @param {Integer} dwFlags A set of bit flags that modify the function's operation. You can set one or more of the following bit flags: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_DEFER"></a><a id="service_flag_defer"></a><dl>
     * <dt><b>SERVICE_FLAG_DEFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider should defer the registration or deregistration operation until a SERVICE_FLUSH operation is requested.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_HARD"></a><a id="service_flag_hard"></a><dl>
     * <dt><b>SERVICE_FLAG_HARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider updates any relevant persistent store information when the operation is performed.
     * 
     * For example: If the operation involves deregistration in a namespace that uses a persistent store, the namespace provider would remove the relevant persistent store information.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_INFOA>} lpServiceInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure that contains information about the network service or service type.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @param {Pointer<Integer>} lpdwStatusFlags A set of bit flags that receive function status information. The following bit flag is defined: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SET_SERVICE__PARTIAL_SUCCESS"></a><a id="set_service__partial_success"></a><dl>
     * <dt><b>SET_SERVICE_
     * PARTIAL_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more namespace providers were unable to successfully perform the requested operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function fails, the return value is SOCKET_ERROR. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> can return the following extended error value.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_
     * REGISTERED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function tried to register a service that was already registered.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-setservicea
     * @since windows5.0
     */
    static SetServiceA(dwNameSpace, dwOperation, dwFlags, lpServiceInfo, lpServiceAsyncInfo, lpdwStatusFlags) {
        A_LastError := 0

        result := DllCall("MSWSOCK.dll\SetServiceA", "uint", dwNameSpace, "uint", dwOperation, "uint", dwFlags, "ptr", lpServiceInfo, "ptr", lpServiceAsyncInfo, "uint*", lpdwStatusFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The SetService function registers or removes from the registry a network service within one or more namespaces.
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, within which the function will operate. 
     * 
     * 
     * 
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The function queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet to resolve the name of the host.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NDS"></a><a id="ns_nds"></a><dl>
     * <dt><b>NS_NDS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare 4 provider.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All Windows systems register their computer names with NetBIOS. This namespace is used to convert a computer name to an IP address that uses this registration.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery, if appropriate. NS_SAP is a dynamic namespace that enables the registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Lookup value in the &lt;systemroot&gt;\system32\drivers\etc\posts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and lookup value in the cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Integer} dwOperation 
     * @param {Integer} dwFlags A set of bit flags that modify the function's operation. You can set one or more of the following bit flags: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_DEFER"></a><a id="service_flag_defer"></a><dl>
     * <dt><b>SERVICE_FLAG_DEFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider should defer the registration or deregistration operation until a SERVICE_FLUSH operation is requested.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SERVICE_FLAG_HARD"></a><a id="service_flag_hard"></a><dl>
     * <dt><b>SERVICE_FLAG_HARD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This bit flag is valid only if the operation is SERVICE_REGISTER or SERVICE_DEREGISTER. 
     * 
     * 
     * 
     * 
     * If this bit flag is one, and it is valid, the namespace provider updates any relevant persistent store information when the operation is performed.
     * 
     * For example: If the operation involves deregistration in a namespace that uses a persistent store, the namespace provider would remove the relevant persistent store information.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<SERVICE_INFOW>} lpServiceInfo A pointer to a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure that contains information about the network service or service type.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @param {Pointer<Integer>} lpdwStatusFlags A set of bit flags that receive function status information. The following bit flag is defined: 
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="SET_SERVICE__PARTIAL_SUCCESS"></a><a id="set_service__partial_success"></a><dl>
     * <dt><b>SET_SERVICE_
     * PARTIAL_SUCCESS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more namespace providers were unable to successfully perform the requested operation.
     * 
     * </td>
     * </tr>
     * </table>
     * @returns {Integer} If the function fails, the return value is SOCKET_ERROR. To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. <b>GetLastError</b> can return the following extended error value.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_ALREADY_
     * REGISTERED</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function tried to register a service that was already registered.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-setservicew
     * @since windows5.0
     */
    static SetServiceW(dwNameSpace, dwOperation, dwFlags, lpServiceInfo, lpServiceAsyncInfo, lpdwStatusFlags) {
        A_LastError := 0

        result := DllCall("MSWSOCK.dll\SetServiceW", "uint", dwNameSpace, "uint", dwOperation, "uint", dwFlags, "ptr", lpServiceInfo, "ptr", lpServiceAsyncInfo, "uint*", lpdwStatusFlags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetService function retrieves information about a network service in the context of a set of default namespaces or a specified namespace.
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, that the operating system should query for information about the specified network service.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The operating system queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to resolve a computer name into an IP address using this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Looks up host names and IP addresses in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Most calls to 
     * <b>GetService</b> should use the special value NS_DEFAULT. This lets a client get by without knowing available namespaces on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpGuid A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes GUID service types from many well-known services within the DNS and SAP namespaces.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {PSTR} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER."
     * @param {Integer} dwProperties A set of bit flags that specify the service information that the function retrieves. Each of these bit flag constants, other than PROP_ALL, corresponds to a particular member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> data structure. If the flag is set, the function puts information into the corresponding member of the data structures stored in *<i>lpBuffer</i>. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_COMMENT"></a><a id="prop_comment"></a><dl>
     * <dt><b>PROP_COMMENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpComment</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_LOCALE"></a><a id="prop_locale"></a><dl>
     * <dt><b>PROP_LOCALE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpLocale</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_DISPLAY_HINT"></a><a id="prop_display_hint"></a><dl>
     * <dt><b>PROP_DISPLAY_HINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwDisplayHint</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_VERSION"></a><a id="prop_version"></a><dl>
     * <dt><b>PROP_VERSION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwVersion</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_START_TIME"></a><a id="prop_start_time"></a><dl>
     * <dt><b>PROP_START_TIME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwTime</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_MACHINE"></a><a id="prop_machine"></a><dl>
     * <dt><b>PROP_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpMachineName</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ADDRESSES"></a><a id="prop_addresses"></a><dl>
     * <dt><b>PROP_ADDRESSES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpServiceAddress</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_SD"></a><a id="prop_sd"></a><dl>
     * <dt><b>PROP_SD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>ServiceSpecificInfo</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ALL"></a><a id="prop_all"></a><dl>
     * <dt><b>PROP_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in all of the members of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} lpBuffer A pointer to a buffer to receive an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures and associated service information. Each 
     * <b>NS_SERVICE_INFO</b> structure contains service information in the context of a particular namespace. Note that if <i>dwNameSpace</i> is NS_DEFAULT, the function stores more than one structure into the buffer; otherwise, just one structure is stored.
     * 
     * Each 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structure contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure. The members of these 
     * <b>SERVICE_INFO</b> structures will contain valid data based on the bit flags that are set in the <i>dwProperties</i> parameter. If a member's corresponding bit flag is not set in <i>dwProperties</i>, the member's value is undefined.
     * 
     * The function stores the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures in a consecutive array, starting at the beginning of the buffer. The pointers in the contained 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structures point to information that is stored in the buffer between the end of the 
     * <b>NS_SERVICE_INFO</b> structures and the end of the buffer.
     * @param {Pointer<Integer>} lpdwBufferSize A pointer to a variable that, on input, contains the size, in bytes, of the buffer pointed to by <i>lpBuffer</i>. On output, this variable contains the number of bytes required to store the requested information. If this output value is greater than the input value, the function has failed due to insufficient buffer size.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the number of 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures stored in *<i>lpBuffer</i>. Zero indicates that no structures were stored.
     * 
     * If the function fails, the return value is SOCKET_ERROR (  1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns one of the following extended error values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by <i>lpBuffer</i> is too small to receive all of the requested information. Call the function with a buffer at least as large as the value returned in *<i>lpdwBufferSize</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SERVICE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified service was not found, or the specified namespace is not in use. The function return value is zero in this case.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-getservicea
     * @since windows5.0
     */
    static GetServiceA(dwNameSpace, lpGuid, lpServiceName, dwProperties, lpBuffer, lpdwBufferSize, lpServiceAsyncInfo) {
        lpServiceName := lpServiceName is String ? StrPtr(lpServiceName) : lpServiceName

        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetServiceA", "uint", dwNameSpace, "ptr", lpGuid, "ptr", lpServiceName, "uint", dwProperties, "ptr", lpBuffer, "uint*", lpdwBufferSize, "ptr", lpServiceAsyncInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The GetService function retrieves information about a network service in the context of a set of default namespaces or a specified namespace.
     * @param {Integer} dwNameSpace The namespace, or a set of default namespaces, that the operating system should query for information about the specified network service.
     * 
     * Use one of the following constants to specify a namespace.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DEFAULT"></a><a id="ns_default"></a><dl>
     * <dt><b>NS_DEFAULT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A set of default namespaces. The operating system queries each namespace within this set. The set of default namespaces typically includes all the namespaces installed on the system. System administrators, however, can exclude particular namespaces from the set. NS_DEFAULT is the value that most applications should use for <i>dwNameSpace</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Domain Name System used in the Internet for host name resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP layer. All operating systems register their computer names with NetBIOS. This namespace is used to resolve a computer name into an IP address using this registration. Note that NS_NETBT can access a WINS server to perform the resolution.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_SAP"></a><a id="ns_sap"></a><dl>
     * <dt><b>NS_SAP</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetWare Service Advertising Protocol. This can access the NetWare bindery if appropriate. NS_SAP is a dynamic namespace that allows registration of services.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_HOSTS"></a><a id="ns_tcpip_hosts"></a><dl>
     * <dt><b>NS_TCPIP_HOSTS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Looks up host names and IP addresses in the &lt;systemroot&gt;\system32\drivers\etc\hosts file.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_TCPIP_LOCAL"></a><a id="ns_tcpip_local"></a><dl>
     * <dt><b>NS_TCPIP_LOCAL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Local TCP/IP name resolution mechanisms, including comparisons against the local host name and looks up host names and IP addresses in cache of host to IP address mappings.
     * 
     * </td>
     * </tr>
     * </table>
     * 
     * 
     * Most calls to 
     * <b>GetService</b> should use the special value NS_DEFAULT. This lets a client get by without knowing available namespaces on an internetwork. The system administrator determines namespace access. Namespaces can come and go without the client having to be aware of the changes.
     * @param {Pointer<Guid>} lpGuid A pointer to a globally unique identifier (GUID) that specifies the type of the network service. The <i>Svcguid.h</i> header file includes GUID service types from many well-known services within the DNS and SAP namespaces.
     * 
     * The <i>Svcguid.h</i> header file is not automatically included by the <i>Winsock2.h</i> header file.
     * @param {PWSTR} lpServiceName A pointer to a zero-terminated string that uniquely represents the service name. For example, "MY SNA SERVER."
     * @param {Integer} dwProperties A set of bit flags that specify the service information that the function retrieves. Each of these bit flag constants, other than PROP_ALL, corresponds to a particular member of the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> data structure. If the flag is set, the function puts information into the corresponding member of the data structures stored in *<i>lpBuffer</i>. The following bit flags are defined.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_COMMENT"></a><a id="prop_comment"></a><dl>
     * <dt><b>PROP_COMMENT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpComment</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_LOCALE"></a><a id="prop_locale"></a><dl>
     * <dt><b>PROP_LOCALE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpLocale</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_DISPLAY_HINT"></a><a id="prop_display_hint"></a><dl>
     * <dt><b>PROP_DISPLAY_HINT</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwDisplayHint</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_VERSION"></a><a id="prop_version"></a><dl>
     * <dt><b>PROP_VERSION</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwVersion</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_START_TIME"></a><a id="prop_start_time"></a><dl>
     * <dt><b>PROP_START_TIME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>dwTime</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_MACHINE"></a><a id="prop_machine"></a><dl>
     * <dt><b>PROP_MACHINE</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpMachineName</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ADDRESSES"></a><a id="prop_addresses"></a><dl>
     * <dt><b>PROP_ADDRESSES</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>lpServiceAddress</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_SD"></a><a id="prop_sd"></a><dl>
     * <dt><b>PROP_SD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in the <b>ServiceSpecificInfo</b> member of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="PROP_ALL"></a><a id="prop_all"></a><dl>
     * <dt><b>PROP_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * If this flag is set, the function stores data in all of the members of the data structures stored in *<i>lpBuffer</i>.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer} lpBuffer A pointer to a buffer to receive an array of 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures and associated service information. Each 
     * <b>NS_SERVICE_INFO</b> structure contains service information in the context of a particular namespace. Note that if <i>dwNameSpace</i> is NS_DEFAULT, the function stores more than one structure into the buffer; otherwise, just one structure is stored.
     * 
     * Each 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structure contains a 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structure. The members of these 
     * <b>SERVICE_INFO</b> structures will contain valid data based on the bit flags that are set in the <i>dwProperties</i> parameter. If a member's corresponding bit flag is not set in <i>dwProperties</i>, the member's value is undefined.
     * 
     * The function stores the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures in a consecutive array, starting at the beginning of the buffer. The pointers in the contained 
     * <a href="https://docs.microsoft.com/windows/desktop/api/nspapi/ns-nspapi-service_infoa">SERVICE_INFO</a> structures point to information that is stored in the buffer between the end of the 
     * <b>NS_SERVICE_INFO</b> structures and the end of the buffer.
     * @param {Pointer<Integer>} lpdwBufferSize A pointer to a variable that, on input, contains the size, in bytes, of the buffer pointed to by <i>lpBuffer</i>. On output, this variable contains the number of bytes required to store the requested information. If this output value is greater than the input value, the function has failed due to insufficient buffer size.
     * @param {Pointer<SERVICE_ASYNC_INFO>} lpServiceAsyncInfo Reserved for future use. Must be set to <b>NULL</b>.
     * @returns {Integer} If the function succeeds, the return value is the number of 
     * <a href="/windows/desktop/api/nspapi/ns-nspapi-ns_service_infoa">NS_SERVICE_INFO</a> structures stored in *<i>lpBuffer</i>. Zero indicates that no structures were stored.
     * 
     * If the function fails, the return value is SOCKET_ERROR (  1). To get extended error information, call 
     * <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>, which returns one of the following extended error values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INSUFFICIENT_BUFFER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The buffer pointed to by <i>lpBuffer</i> is too small to receive all of the requested information. Call the function with a buffer at least as large as the value returned in *<i>lpdwBufferSize</i>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_SERVICE_NOT_FOUND</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified service was not found, or the specified namespace is not in use. The function return value is zero in this case.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//nspapi/nf-nspapi-getservicew
     * @since windows5.0
     */
    static GetServiceW(dwNameSpace, lpGuid, lpServiceName, dwProperties, lpBuffer, lpdwBufferSize, lpServiceAsyncInfo) {
        lpServiceName := lpServiceName is String ? StrPtr(lpServiceName) : lpServiceName

        A_LastError := 0

        result := DllCall("MSWSOCK.dll\GetServiceW", "uint", dwNameSpace, "ptr", lpGuid, "ptr", lpServiceName, "uint", dwProperties, "ptr", lpBuffer, "uint*", lpdwBufferSize, "ptr", lpServiceAsyncInfo, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Provides protocol-independent translation from an ANSI host name to an address.
     * @param {PSTR} pNodeName A pointer to a <b>NULL</b>-terminated ANSI string that contains a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {PSTR} pServiceName A pointer to a <b>NULL</b>-terminated ANSI string that contains either a service name or port number represented as a string.
     * 
     * A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<ADDRINFOA>} pHints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<Pointer<ADDRINFOA>>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structures that contains response information about the host.
     * @returns {Integer} Success returns zero. Failure returns a nonzero Windows Sockets error code, as found in the 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * 
     * Most nonzero error codes returned by the 
     * <b>getaddrinfo</b> function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
     * 
     * <table>
     * <tr>
     * <th>Error value</th>
     * <th>WSA equivalent</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>EAI_AGAIN</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></td>
     * <td>A temporary failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_BADFLAGS</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>An invalid value was provided for the <b>ai_flags</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAIL</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></td>
     * <td>A nonrecoverable failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAMILY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>The <b>ai_family</b> member of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * <tr>
     * <td>EAI_MEMORY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>A memory allocation failure occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_NONAME</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></td>
     * <td>The name does not resolve for the supplied parameters or the <i>pNodeName</i> and <i>pServiceName</i> parameters were not provided.</td>
     * </tr>
     * <tr>
     * <td>EAI_SERVICE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></td>
     * <td>The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_SOCKTYPE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></td>
     * <td>The <b>ai_socktype</b> member of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * </table>
     * 
     * 
     * Use the 
     * <a href="/windows/desktop/api/ws2tcpip/nf-ws2tcpip-gai_strerrora">gai_strerror</a> function to print error messages based on the EAI codes returned by the 
     * <b>getaddrinfo</b> function. The 
     * <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> is recommended.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An address incompatible with the requested protocol was used. This error is returned if the <b>ai_family</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a>structure pointed to by the <i>pHints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.  This error is returned if an invalid value was provided for the <b>ai_flags</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a>structure pointed to by the <i>pHints</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The support for the specified socket type does not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a>structure pointed to by the <i>pHints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such host is known. This error is returned if the name does not resolve for the supplied parameters or the <i>pNodeName</i> and <i>pServiceName</i> parameters were not provided.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred during a database lookup. This error is returned if nonrecoverable error in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server. This error is returned when a temporary failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified class was not found. The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a>structure pointed to by the <i>pHints</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getaddrinfo
     * @since windows8.1
     */
    static getaddrinfo(pNodeName, pServiceName, pHints, ppResult) {
        pNodeName := pNodeName is String ? StrPtr(pNodeName) : pNodeName
        pServiceName := pServiceName is String ? StrPtr(pServiceName) : pServiceName

        A_LastError := 0

        result := DllCall("WS2_32.dll\getaddrinfo", "ptr", pNodeName, "ptr", pServiceName, "ptr", pHints, "ptr*", ppResult, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Provides protocol-independent translation from a Unicode host name to an address.
     * @param {PWSTR} pNodeName A pointer to a <b>NULL</b>-terminated Unicode string that contains a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {PWSTR} pServiceName A pointer to a <b>NULL</b>-terminated Unicode string that contains either a service name or port number represented as a string. 
     * 
     * A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Pointer<ADDRINFOW>} pHints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<Pointer<ADDRINFOW>>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structures that contains response information about the host.
     * @returns {Integer} Success returns zero. Failure returns a nonzero Windows Sockets error code, as found in the 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * 
     * Most nonzero error codes returned by the <b>GetAddrInfoW</b> function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
     * 
     * <table>
     * <tr>
     * <th>Error value</th>
     * <th>WSA equivalent</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>EAI_AGAIN</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></td>
     * <td>A temporary failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_BADFLAGS</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>An invalid value was provided for the <b>ai_flags</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAIL</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></td>
     * <td>A nonrecoverable failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAMILY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>The <b>ai_family</b> member  of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * <tr>
     * <td>EAI_MEMORY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>A memory allocation failure occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_NONAME</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></td>
     * <td>The name does not resolve for the supplied parameters or the <i>pNodeName</i> and <i>pServiceName</i> parameters were not provided.</td>
     * </tr>
     * <tr>
     * <td>EAI_SERVICE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></td>
     * <td>The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_SOCKTYPE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></td>
     * <td>The <b>ai_socktype</b> member  of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * </table>
     * 
     * 
     * Use the 
     * <a href="/windows/desktop/api/ws2tcpip/nf-ws2tcpip-gai_strerrora">gai_strerror</a> function to print error messages based on the EAI_* codes returned by the 
     * <b>GetAddrInfoW</b> function. The 
     * <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of a traditional Windows Sockets function, such as 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>, is recommended.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An address incompatible with the requested protocol was used. This error is returned if the <b>ai_family</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a>structure pointed to by the <i>hints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.  This error is returned if an invalid value was provided for the <b>ai_flags</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a>structure pointed to by the <i>hints</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The support for the specified socket type does not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a>structure pointed to by the <i>hints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such host is known. This error is returned if the name does not resolve for the supplied parameters or the <i>pNodename</i> and <i>pServicename</i> parameters were not provided.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred during a database lookup. This error is returned if nonrecoverable error in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server. This error is returned when a temporary failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified class was not found. The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a>structure pointed to by the <i>hints</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getaddrinfow
     * @since windows8.1
     */
    static GetAddrInfoW(pNodeName, pServiceName, pHints, ppResult) {
        pNodeName := pNodeName is String ? StrPtr(pNodeName) : pNodeName
        pServiceName := pServiceName is String ? StrPtr(pServiceName) : pServiceName

        result := DllCall("WS2_32.dll\GetAddrInfoW", "ptr", pNodeName, "ptr", pServiceName, "ptr", pHints, "ptr*", ppResult, "int")
        return result
    }

    /**
     * Provides protocol-independent name resolution with additional parameters to qualify which namespace providers should handle the request.
     * @param {PSTR} pName A pointer to a <b>NULL</b>-terminated string containing a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {PSTR} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains either a service name or port number represented as a string.
     * 
     * A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Integer} dwNameSpace An optional namespace identifier that determines which namespace providers are queried.  Passing a specific namespace identifier will result in only namespace providers that support the specified namespace being queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are added on WindowsVista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many other values are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * <dt>12</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * <dt>13</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP (NETBT) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_WINS"></a><a id="ns_wins"></a><dl>
     * <dt><b>NS_WINS</b></dt>
     * <dt>14</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Internet Naming Service (NS_WINS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * <dt>15</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. 
     * 
     * This namespace identifier is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NTDS"></a><a id="ns_ntds"></a><dl>
     * <dt><b>NS_NTDS</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows NT Directory Services (NS_NTDS) namespace. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * <dt>37</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * <dt>38</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * <dt>39</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to query in the case where  multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for specific namespace provider will result in only the specified namespace provider being queried. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<ADDRINFOEXA>} hints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <b>GetAddrInfoEx</b> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<Pointer<ADDRINFOEXA>>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures that contains response information about the host.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function. Otherwise, this parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows8 and Windows Server2012, if no <i>lpCompletionRoutine</i> parameter is specified, the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure must be set to a manual-reset event to be called upon completion of an asynchronous call. If a completion routine has been specified, the <b>hEvent</b> member must be NULL. When the event specified by <b>hEvent</b> has been set, the result of the operation can be retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexoverlappedresult">GetAddrInfoExOverlappedResult</a> function.
     * 
     * On Windows8 and Windows Server2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows7 and Windows Server2008R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine An optional pointer to a function to be invoked upon successful completion for asynchronous operations. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows8 and Windows Server2012, if this parameter is specified, it must be a pointer to a function with the following signature:
     * 
     * 
     * ```cpp
     * typedef   
     * void   
     * (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(   
     *     __in      DWORD    dwError,   
     *     __in      DWORD    dwBytes,   
     *     __in      LPWSAOVERLAPPED lpOverlapped   
     *     );   
     * 
     * ```
     * 
     * 
     * When the asynchronous operation has completed, the completion routine will be invoked with <i>lpOverlapped</i> parameter set to the value of <i>lpOverlapped</i> parameter passed to <b>GetAddrInfoEx</b>. The <b>Pointer</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the value of the <i>ppResult</i> parameter of the original call. If the <b>Pointer</b> member points to a non-NULL pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure, it is the callers responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoex">FreeAddrInfoEx</a> to free the <b>addrinfoex</b>  structure. The <i>dwError</i> parameter passed to the completion routine will be set to a Winsock error code. The <i>dwBytes</i> parameter is reserved for future use and must be ignored.
     * 
     * On Windows8 and Windows Server2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows7 and Windows Server2008R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpNameHandle An optional pointer used only for asynchronous operations.  
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows8 and Windows Server2012, if the <b>GetAddrInfoEx</b> function will complete asynchronously, the pointer returned in this field may be used with the <b>GetAddrInfoExCancel</b> function. The handle returned is valid when <b>GetAddrInfoEx</b> returns until the completion routine is called, the event is triggered, or <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexcancel">GetAddrInfoExCancel</a> function is called with this handle.
     * 
     * On Windows8 and Windows Server2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows7 and Windows Server2008R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @returns {Integer} On success,  <b>GetAddrInfoEx</b> returns <b>NO_ERROR</b> (0). Failure returns a nonzero Windows Sockets error code, as found in the 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * 
     * Most nonzero error codes returned by the 
     * <b>GetAddrInfoEx</b> function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
     * 
     * <table>
     * <tr>
     * <th>Error value</th>
     * <th>WSA equivalent</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>EAI_AGAIN</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></td>
     * <td>A temporary failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_BADFLAGS</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>An invalid parameter was provided. This error is returned if any of the reserved parameters are not <b>NULL</b>. This error is also returned if an invalid value was provided for the <b>ai_flags</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAIL</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></td>
     * <td>A nonrecoverable failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAMILY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>The <b>ai_family</b> member  of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * <tr>
     * <td>EAI_MEMORY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>A memory allocation failure occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_NONAME</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></td>
     * <td>The name does not resolve for the supplied parameters or the <i>pName</i> and <i>pServiceName</i> parameters were not provided.</td>
     * </tr>
     * <tr>
     * <td>EAI_SERVICE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></td>
     * <td>The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_SOCKTYPE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></td>
     * <td>The <b>ai_socktype</b> member of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * </table>
     * 
     * 
     * Use the 
     * <a href="/windows/desktop/api/ws2tcpip/nf-ws2tcpip-gai_strerrora">gai_strerror</a> function to print error messages based on the EAI codes returned by the 
     * <b>GetAddrInfoEx</b> function. The 
     * <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> is recommended.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An address incompatible with the requested protocol was used. This error is returned if the <b>ai_family</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a>structure pointed to by the <i>pHints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.  This error is returned if an invalid value was provided for the <b>ai_flags</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter.  This error is also returned when the <i>dwNameSpace</i> parameter is NS_PNRPNAME or NS_PNRPCLOUD and the peer-to-peer name service is not operating.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The support for the specified socket type does not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such host is known. This error is returned if the name does not resolve for the supplied parameters or the <i>pName</i> and <i>pServiceName</i> parameters were not provided.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred during a database lookup. This error is returned if nonrecoverable error in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASERVICE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such service is known. The service cannot be found in the specified name space. This error is returned if the <i>pName</i> or <i>pServiceName</i> parameter is not found for the namespace specified in the <i>dwNameSpace</i> parameter or the namespace specified in the <i>dwNameSpace</i> parameter is not installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server. This error is returned when a temporary failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified class was not found. The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a>structure pointed to by the <i>pHints</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getaddrinfoexa
     * @deprecated
     * @since windows6.0.6000
     */
    static GetAddrInfoExA(pName, pServiceName, dwNameSpace, lpNspId, hints, ppResult, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle) {
        pName := pName is String ? StrPtr(pName) : pName
        pServiceName := pServiceName is String ? StrPtr(pServiceName) : pServiceName

        result := DllCall("WS2_32.dll\GetAddrInfoExA", "ptr", pName, "ptr", pServiceName, "uint", dwNameSpace, "ptr", lpNspId, "ptr", hints, "ptr*", ppResult, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpNameHandle, "int")
        return result
    }

    /**
     * Provides protocol-independent name resolution with additional parameters to qualify which namespace providers should handle the request.
     * @param {PWSTR} pName A pointer to a <b>NULL</b>-terminated string containing a host (node) name or a numeric host address string. For the Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
     * @param {PWSTR} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains either a service name or port number represented as a string.
     * 
     * A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the <i>pServiceName</i> parameter when a port number is not specified are listed in the following file: 
     * 
     * <c>%WINDIR%\system32\drivers\etc\services</c>
     * @param {Integer} dwNameSpace An optional namespace identifier that determines which namespace providers are queried.  Passing a specific namespace identifier will result in only namespace providers that support the specified namespace being queried. Specifying <b>NS_ALL</b> will result in all installed and active namespace providers being queried. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are added on WindowsVista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many other values are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * <dt>0</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * <dt>12</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NETBT"></a><a id="ns_netbt"></a><dl>
     * <dt><b>NS_NETBT</b></dt>
     * <dt>13</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The NetBIOS over TCP/IP (NETBT) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_WINS"></a><a id="ns_wins"></a><dl>
     * <dt><b>NS_WINS</b></dt>
     * <dt>14</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows Internet Naming Service (NS_WINS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * <dt>15</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. 
     * 
     * This namespace identifier is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * <dt>16</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NTDS"></a><a id="ns_ntds"></a><dl>
     * <dt><b>NS_NTDS</b></dt>
     * <dt>32</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Windows NT Directory Services (NS_NTDS) namespace. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * <dt>37</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * <dt>38</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * <dt>39</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. 
     * 
     * This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to query in the case where  multiple namespace providers are registered under a single namespace such as <b>NS_DNS</b>. Passing the GUID for specific namespace provider will result in only the specified namespace provider being queried. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<ADDRINFOEXW>} hints A pointer to an 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure that provides hints about the type of socket the caller supports. 
     * 
     * The <b>ai_addrlen</b>, <b>ai_canonname</b>, <b>ai_addr</b>, and <b>ai_next</b> members of the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter must be zero or <b>NULL</b>. Otherwise the <b>GetAddrInfoEx</b> function will fail with <a href="https://docs.microsoft.com/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a>.
     * 
     * See the Remarks for more details.
     * @param {Pointer<Pointer<ADDRINFOEXW>>} ppResult A pointer to a linked list of one or more 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structures that contains response information about the host.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function. Otherwise, this parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows8 and Windows Server2012, if no <i>lpCompletionRoutine</i> parameter is specified, the <b>hEvent</b> member of the <b>OVERLAPPED</b> structure must be set to a manual-reset event to be called upon completion of an asynchronous call. If a completion routine has been specified, the <b>hEvent</b> member must be NULL. When the event specified by <b>hEvent</b> has been set, the result of the operation can be retrieved by calling <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexoverlappedresult">GetAddrInfoExOverlappedResult</a> function.
     * 
     * On Windows8 and Windows Server2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows7 and Windows Server2008R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine Type: \_In_opt\_ [**LPWSAOVERLAPPED_COMPLETION_ROUTINE**](../winsock2/nc-winsock2-lpwsaoverlapped_completion_routine.md)
     * 
     * An optional pointer to a function to be invoked upon successful completion for asynchronous operations. 
     * 
     * This parameter is only supported when the <b>UNICODE</b> or <b>_UNICODE</b> macro has been defined in the sources before calling the <b>GetAddrInfoEx</b> function.
     * 
     * On Windows8 and Windows Server2012, if this parameter is specified, it must be a pointer to a function with the following signature:
     * 
     * 
     * ```cpp
     * typedef   
     * void   
     * (CALLBACK * LPLOOKUPSERVICE_COMPLETION_ROUTINE)(   
     *     __in      DWORD    dwError,   
     *     __in      DWORD    dwBytes,   
     *     __in      LPWSAOVERLAPPED lpOverlapped   
     *     );   
     * 
     * ```
     * 
     * 
     * When the asynchronous operation has completed, the completion routine will be invoked with <i>lpOverlapped</i> parameter set to the value of <i>lpOverlapped</i> parameter passed to <b>GetAddrInfoEx</b>. The <b>Pointer</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> structure will be set to the value of the <i>ppResult</i> parameter of the original call. If the <b>Pointer</b> member points to a non-NULL pointer to the <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure, it is the callers responsibility to call <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-freeaddrinfoex">FreeAddrInfoEx</a> to free the <b>addrinfoex</b>  structure. The <i>dwError</i> parameter passed to the completion routine will be set to a Winsock error code. The <i>dwBytes</i> parameter is reserved for future use and must be ignored.
     * 
     * On Windows8 and Windows Server2012 whenever the <b>UNICODE</b> or <b>_UNICODE</b> macro is not defined,  this parameter is currently reserved and must be set to <b>NULL</b>. 
     * 
     * On Windows7 and Windows Server2008R2 or earlier, this parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpHandle TBD
     * @returns {Integer} On success,  <b>GetAddrInfoEx</b> returns <b>NO_ERROR</b> (0). Failure returns a nonzero Windows Sockets error code, as found in the 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * 
     * Most nonzero error codes returned by the 
     * <b>GetAddrInfoEx</b> function map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
     * 
     * <table>
     * <tr>
     * <th>Error value</th>
     * <th>WSA equivalent</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>EAI_AGAIN</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></td>
     * <td>A temporary failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_BADFLAGS</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>An invalid parameter was provided. This error is returned if any of the reserved parameters are not <b>NULL</b>. This error is also returned if an invalid value was provided for the <b>ai_flags</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAIL</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></td>
     * <td>A nonrecoverable failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAMILY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>The <b>ai_family</b> member  of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * <tr>
     * <td>EAI_MEMORY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>A memory allocation failure occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_NONAME</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></td>
     * <td>The name does not resolve for the supplied parameters or the <i>pName</i> and <i>pServiceName</i> parameters were not provided.</td>
     * </tr>
     * <tr>
     * <td>EAI_SERVICE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></td>
     * <td>The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the <i>pHints</i> parameter.</td>
     * </tr>
     * <tr>
     * <td>EAI_SOCKTYPE</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></td>
     * <td>The <b>ai_socktype</b> member of the <i>pHints</i> parameter is not supported.</td>
     * </tr>
     * </table>
     * 
     * 
     * Use the 
     * <a href="/windows/desktop/api/ws2tcpip/nf-ws2tcpip-gai_strerrora">gai_strerror</a> function to print error messages based on the EAI codes returned by the 
     * <b>GetAddrInfoEx</b> function. The 
     * <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> is recommended.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * There was insufficient memory to perform the operation.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An address incompatible with the requested protocol was used. This error is returned if the <b>ai_family</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a>structure pointed to by the <i>pHints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid argument was supplied.  This error is returned if an invalid value was provided for the <b>ai_flags</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter.  This error is also returned when the <i>dwNameSpace</i> parameter is NS_PNRPNAME or NS_PNRPCLOUD and the peer-to-peer name service is not operating.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAESOCKTNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The support for the specified socket type does not exist in this address family. This error is returned if the <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure pointed to by the <i>pHints</i> parameter is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such host is known. This error is returned if the name does not resolve for the supplied parameters or the <i>pName</i> and <i>pServiceName</i> parameters were not provided.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_DATA</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The requested name is valid, but no data of the requested type was found.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred during a database lookup. This error is returned if nonrecoverable error in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASERVICE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * No such service is known. The service cannot be found in the specified name space. This error is returned if the <i>pName</i> or <i>pServiceName</i> parameter is not found for the namespace specified in the <i>dwNameSpace</i> parameter or the namespace specified in the <i>dwNameSpace</i> parameter is not installed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an authoritative server. This error is returned when a temporary failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATYPE_NOT_FOUND</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified class was not found. The <i>pServiceName</i> parameter is not supported for the specified <b>ai_socktype</b> member of the 
     * 			<a href="/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a>structure pointed to by the <i>pHints</i> parameter.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getaddrinfoexw
     * @since windows6.0.6000
     */
    static GetAddrInfoExW(pName, pServiceName, dwNameSpace, lpNspId, hints, ppResult, timeout, lpOverlapped, lpCompletionRoutine, lpHandle) {
        pName := pName is String ? StrPtr(pName) : pName
        pServiceName := pServiceName is String ? StrPtr(pServiceName) : pServiceName

        result := DllCall("WS2_32.dll\GetAddrInfoExW", "ptr", pName, "ptr", pServiceName, "uint", dwNameSpace, "ptr", lpNspId, "ptr", hints, "ptr*", ppResult, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpHandle, "int")
        return result
    }

    /**
     * Cancels an asynchronous operation by the GetAddrInfoEx function.
     * @param {Pointer<HANDLE>} lpHandle The handle of the asynchronous operation to cancel. This is the handle returned in the <i>lpNameHandle</i> parameter by the <a href="https://docs.microsoft.com/windows/desktop/api/ws2tcpip/nf-ws2tcpip-getaddrinfoexa">GetAddrInfoEx</a> function.
     * @returns {Integer} On success,  <b>GetAddrInfoExCancel</b> returns <b>NO_ERROR</b> (0). Failure returns a nonzero Windows Sockets error code, as found in the 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getaddrinfoexcancel
     * @since windows8.1
     */
    static GetAddrInfoExCancel(lpHandle) {
        result := DllCall("WS2_32.dll\GetAddrInfoExCancel", "ptr", lpHandle, "int")
        return result
    }

    /**
     * Gets the return code for an OVERLAPPED structure used by an asynchronous operation for the GetAddrInfoEx function.
     * @param {Pointer<OVERLAPPED>} lpOverlapped A pointer to an <b>OVERLAPPED</b> structure for the asynchronous operation.
     * @returns {Integer} On success,  the <b>GetAddrInfoExOverlappedResult</b> function returns <b>NO_ERROR</b> (0). When the
     *     underlying operation hasn't yet completed, the <b>GetAddrInfoExOverlappedResult</b> function  returns <b>WSAEINPROGRESS</b>. On failure, the <b>GetAddrInfoExOverlappedResult</b> function  returns <b>WSAEINVAL</b>.
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getaddrinfoexoverlappedresult
     * @since windows8.1
     */
    static GetAddrInfoExOverlappedResult(lpOverlapped) {
        result := DllCall("WS2_32.dll\GetAddrInfoExOverlappedResult", "ptr", lpOverlapped, "int")
        return result
    }

    /**
     * Registers or deregisters a name, a service name, and associated addresses with a specific namespace provider.
     * @param {PSTR} pName A pointer to a <b>NULL</b>-terminated string containing a name under which addresses are to be registered or deregistered. The interpretation of this parameter specific to the namespace provider.
     * @param {PSTR} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains the service name  associated with the name being registered. The interpretation of this parameter is specific to the namespace provider.
     * @param {Pointer<SOCKET_ADDRESS>} pAddresses A pointer to an optional list of addresses to register with the namespace provider.
     * @param {Integer} dwAddressCount The number of addresses passed in <i>pAddresses</i> parameter.
     * If this parameter is zero, the <i>pName</i> parameter is deregistered from the namespace provider.
     * @param {Pointer<BLOB>} lpBlob An optional pointer to data that is used to set provider-specific namespace information that is associated with the <i>pName</i> parameter beyond a list of addresses. Any information that cannot be passed in the <i>pAddresses</i> parameter can be passed in the <i>lpBlob</i> parameter. The format of this information is specific to the namespace provider.
     * @param {Integer} dwFlags A set of flags controlling how the <i>pName</i> and <i>pServiceName</i> parameters are to be  registered with the namespace provider. The interpretation of this information is specific to the namespace provider.
     * @param {Integer} dwNameSpace A namespace identifier that determines which namespace provider to register this information with.  Passing a specific namespace identifier will result in registering this information only with the namespace providers that support the specified namespace. Specifying NS_ALL will result in registering the information with all installed and active namespace providers. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with WindowsVista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many others are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. This namespace identifier is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to register this information with in the case where  multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a specific namespace provider will result in the information being registered with only the specified namespace provider. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. This parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpNameHandle An optional pointer used only for asynchronous operations.  This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @returns {Integer} On success,  <b>SetAddrInfoEx</b> returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as found in the 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A temporary failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was provided. This error is returned if any of the reserved parameters are not <b>NULL</b>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-setaddrinfoexa
     * @deprecated
     * @since windows8.1
     */
    static SetAddrInfoExA(pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle) {
        pName := pName is String ? StrPtr(pName) : pName
        pServiceName := pServiceName is String ? StrPtr(pServiceName) : pServiceName

        result := DllCall("WS2_32.dll\SetAddrInfoExA", "ptr", pName, "ptr", pServiceName, "ptr", pAddresses, "uint", dwAddressCount, "ptr", lpBlob, "uint", dwFlags, "uint", dwNameSpace, "ptr", lpNspId, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpNameHandle, "int")
        return result
    }

    /**
     * Registers or deregisters a name, a service name, and associated addresses with a specific namespace provider.
     * @param {PWSTR} pName A pointer to a <b>NULL</b>-terminated string containing a name under which addresses are to be registered or deregistered. The interpretation of this parameter specific to the namespace provider.
     * @param {PWSTR} pServiceName A pointer to an optional <b>NULL</b>-terminated string that contains the service name  associated with the name being registered. The interpretation of this parameter is specific to the namespace provider.
     * @param {Pointer<SOCKET_ADDRESS>} pAddresses A pointer to an optional list of addresses to register with the namespace provider.
     * @param {Integer} dwAddressCount The number of addresses passed in <i>pAddresses</i> parameter.
     * If this parameter is zero, the <i>pName</i> parameter is deregistered from the namespace provider.
     * @param {Pointer<BLOB>} lpBlob An optional pointer to data that is used to set provider-specific namespace information that is associated with the <i>pName</i> parameter beyond a list of addresses. Any information that cannot be passed in the <i>pAddresses</i> parameter can be passed in the <i>lpBlob</i> parameter. The format of this information is specific to the namespace provider.
     * @param {Integer} dwFlags A set of flags controlling how the <i>pName</i> and <i>pServiceName</i> parameters are to be  registered with the namespace provider. The interpretation of this information is specific to the namespace provider.
     * @param {Integer} dwNameSpace A namespace identifier that determines which namespace provider to register this information with.  Passing a specific namespace identifier will result in registering this information only with the namespace providers that support the specified namespace. Specifying NS_ALL will result in registering the information with all installed and active namespace providers. 
     * 
     * 
     * Options for the <i>dwNameSpace</i> parameter are listed in the <i>Winsock2.h</i> include file. Several namespace providers are included with WindowsVista and later. Other namespace providers can be installed, so the following possible values  are only those commonly available. Many others are possible.
     * 
     * 
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_ALL"></a><a id="ns_all"></a><dl>
     * <dt><b>NS_ALL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * All installed and active namespaces.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_BTH"></a><a id="ns_bth"></a><dl>
     * <dt><b>NS_BTH</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Bluetooth namespace. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_DNS"></a><a id="ns_dns"></a><dl>
     * <dt><b>NS_DNS</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The domain name system (DNS) namespace.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_EMAIL"></a><a id="ns_email"></a><dl>
     * <dt><b>NS_EMAIL</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The email namespace. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_NLA"></a><a id="ns_nla"></a><dl>
     * <dt><b>NS_NLA</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The network location awareness (NLA) namespace. This namespace identifier is supported on WindowsXP and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPNAME"></a><a id="ns_pnrpname"></a><dl>
     * <dt><b>NS_PNRPNAME</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="NS_PNRPCLOUD"></a><a id="ns_pnrpcloud"></a><dl>
     * <dt><b>NS_PNRPCLOUD</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on WindowsVista and later.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Guid>} lpNspId A pointer to an optional GUID of a specific namespace provider to register this information with in the case where  multiple namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a specific namespace provider will result in the information being registered with only the specified namespace provider. The <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/nf-winsock2-wsaenumnamespaceprovidersa">WSAEnumNameSpaceProviders</a> function can be called to retrieve the GUID for a namespace provider.
     * @param {Pointer<TIMEVAL>} timeout An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting the call. This parameter is currently reserved and must be set to <b>NULL</b> since a <i>timeout</i> option is not supported.
     * @param {Pointer<OVERLAPPED>} lpOverlapped An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<LPLOOKUPSERVICE_COMPLETION_ROUTINE>} lpCompletionRoutine An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @param {Pointer<HANDLE>} lpNameHandle An optional pointer used only for asynchronous operations.  This parameter is currently reserved and must be set to <b>NULL</b> since asynchronous operations are not supported.
     * @returns {Integer} On success,  <b>SetAddrInfoEx</b> returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as found in the 
     * <a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">Windows Sockets Error Codes</a>.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANOTINITIALISED</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A successful 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsastartup">WSAStartup</a> call must occur before using this function.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A temporary failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was provided. This error is returned if any of the reserved parameters are not <b>NULL</b>. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOBUFS</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient buffer space is available.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable failure in name resolution occurred.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A memory allocation failure occurred.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-setaddrinfoexw
     * @since windows8.1
     */
    static SetAddrInfoExW(pName, pServiceName, pAddresses, dwAddressCount, lpBlob, dwFlags, dwNameSpace, lpNspId, timeout, lpOverlapped, lpCompletionRoutine, lpNameHandle) {
        pName := pName is String ? StrPtr(pName) : pName
        pServiceName := pServiceName is String ? StrPtr(pServiceName) : pServiceName

        result := DllCall("WS2_32.dll\SetAddrInfoExW", "ptr", pName, "ptr", pServiceName, "ptr", pAddresses, "uint", dwAddressCount, "ptr", lpBlob, "uint", dwFlags, "uint", dwNameSpace, "ptr", lpNspId, "ptr", timeout, "ptr", lpOverlapped, "ptr", lpCompletionRoutine, "ptr", lpNameHandle, "int")
        return result
    }

    /**
     * Frees address information that the getaddrinfo function dynamically allocates in addrinfo structures.
     * @param {Pointer<ADDRINFOA>} pAddrInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoa">addrinfo</a> structure or linked list of 
     * <b>addrinfo</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfo</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-freeaddrinfo
     * @since windows8.1
     */
    static freeaddrinfo(pAddrInfo) {
        A_LastError := 0

        DllCall("WS2_32.dll\freeaddrinfo", "ptr", pAddrInfo)
        if(A_LastError)
            throw OSError()

    }

    /**
     * Frees address information that the GetAddrInfoW function dynamically allocates in addrinfoW structures.
     * @param {Pointer<ADDRINFOW>} pAddrInfo A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfow">addrinfoW</a> structure or linked list of 
     * <b>addrinfoW</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfoW</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-freeaddrinfow
     * @since windows8.1
     */
    static FreeAddrInfoW(pAddrInfo) {
        DllCall("WS2_32.dll\FreeAddrInfoW", "ptr", pAddrInfo)
    }

    /**
     * Frees address information that the GetAddrInfoEx function dynamically allocates in addrinfoex structures.
     * @param {Pointer<ADDRINFOEXA>} pAddrInfoEx A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure or linked list of 
     * <b>addrinfoex</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfoex</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-freeaddrinfoex
     * @deprecated
     * @since windows8.1
     */
    static FreeAddrInfoEx(pAddrInfoEx) {
        DllCall("WS2_32.dll\FreeAddrInfoEx", "ptr", pAddrInfoEx)
    }

    /**
     * Frees address information that the GetAddrInfoEx function dynamically allocates in addrinfoex structures.
     * @param {Pointer<ADDRINFOEXW>} pAddrInfoEx A pointer to the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/ws2def/ns-ws2def-addrinfoexw">addrinfoex</a> structure or linked list of 
     * <b>addrinfoex</b> structures to be freed. All dynamic storage pointed to within the 
     * <b>addrinfoex</b> structure or structures is also freed.
     * @returns {String} Nothing - always returns an empty string
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-freeaddrinfoexw
     * @since windows8.1
     */
    static FreeAddrInfoExW(pAddrInfoEx) {
        DllCall("WS2_32.dll\FreeAddrInfoExW", "ptr", pAddrInfoEx)
    }

    /**
     * Provides protocol-independent name resolution from an address to an ANSI host name and from a port number to the ANSI service name.
     * @param {Pointer} pSockaddr A pointer to a socket address structure that contains the address and port number of the socket. For IPv4, the <i>sa</i> parameter points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr_in</a> structure. For IPv6, the <i>sa</i> parameter points to a <b>sockaddr_in6</b> structure.
     * @param {socklen_t} SockaddrLength The length, in bytes, of the structure pointed to by the <i>sa</i> parameter.
     * @param {PSTR} pNodeBuffer A pointer to  an ANSI string used to hold the host name. On success, the host name is returned as a Fully Qualified Domain Name (FQDN) by default. If the <i>host</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a host name string.
     * @param {Integer} NodeBufferSize The length, in bytes, of the buffer pointed to by the <i>host</i> parameter. The caller must provide a buffer large enough to hold the host name, including the terminating <b>NULL</b> character.
     * @param {PSTR} pServiceBuffer A pointer to  an ANSI string to hold the service name. On success, an ANSI string that represents the service name associated with the port number is returned. If the <i>serv</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a service name string.
     * @param {Integer} ServiceBufferSize The length, in bytes, of the buffer pointed to by the <i>serv</i> parameter. The caller must provide a buffer large enough to hold the service name, including the terminating <b>NULL</b> character.
     * @param {Integer} Flags A value used to customize processing of the 
     * <b>getnameinfo</b> function. See the Remarks section.
     * @returns {Integer} On success,  <b>getnameinfo</b> returns zero. Any nonzero return value indicates failure and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * Nonzero error codes returned by the 
     * <b>getnameinfo</b> function also map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table lists these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
     * 
     * <table>
     * <tr>
     * <th>Error value</th>
     * <th>WSA equivalent</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>EAI_AGAIN</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></td>
     * <td>A temporary failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_BADFLAGS</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>One or more invalid parameters was passed to the <b>getnameinfo</b> function. This error is returned if a host name was requested but the <i>hostlen</i> parameter was zero or if a service name was requested, but the <i>servlen</i> parameter was zero. </td>
     * </tr>
     * <tr>
     * <td>EAI_FAIL</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></td>
     * <td>A nonrecoverable failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAMILY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>The <b>sa_family</b> member of socket address structure pointed to by the <i>sa</i> parameter is not supported. </td>
     * </tr>
     * <tr>
     * <td>EAI_MEMORY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>A memory allocation failure occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_NONAME</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></td>
     * <td>A service name was requested, but no port number was found in the structure pointed to by the <i>sa</i> parameter or no service name matching the port number was found. NI_NAMEREQD is set and the host name cannot be located, or both the <i>host</i> and <i>serv</i> parameters were <b>NULL</b>. </td>
     * </tr>
     * </table>
     * 
     * 
     * Use the 
     * <a href="/windows/desktop/api/ws2tcpip/nf-ws2tcpip-gai_strerrora">gai_strerror</a> function to print error messages based on the EAI codes returned by the 
     * <b>getnameinfo</b> function. The 
     * <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> is recommended.
     * 
     * In addition, the following error codes can be returned.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This error is returned if the <i>sa</i> parameter is <b>NULL</b> or the  <i>salen</i> parameter is less than the length required for the size of <a href="/windows/desktop/WinSock/sockaddr-2">sockaddr_in</a> structure for IPv4 or the  <b>sockaddr_in6</b> structure for IPv6.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getnameinfo
     * @since windows8.1
     */
    static getnameinfo(pSockaddr, SockaddrLength, pNodeBuffer, NodeBufferSize, pServiceBuffer, ServiceBufferSize, Flags) {
        pNodeBuffer := pNodeBuffer is String ? StrPtr(pNodeBuffer) : pNodeBuffer
        pServiceBuffer := pServiceBuffer is String ? StrPtr(pServiceBuffer) : pServiceBuffer

        A_LastError := 0

        result := DllCall("WS2_32.dll\getnameinfo", "ptr", pSockaddr, "int", SockaddrLength, "ptr", pNodeBuffer, "uint", NodeBufferSize, "ptr", pServiceBuffer, "uint", ServiceBufferSize, "int", Flags, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Provides protocol-independent name resolution from an address to a Unicode host name and from a port number to the Unicode service name.
     * @param {Pointer} pSockaddr A pointer to a socket address structure containing the IP address and port number of the socket. For IPv4, the <i>pSockaddr</i> parameter points to a 
     * <a href="https://docs.microsoft.com/windows/desktop/WinSock/sockaddr-2">sockaddr_in</a> structure. For IPv6, the <i>pSockaddr</i> parameter points to a <b>sockaddr_in6</b> structure.
     * @param {socklen_t} SockaddrLength The length, in bytes, of the structure pointed to by the <i>pSockaddr</i> parameter.
     * @param {PWSTR} pNodeBuffer A pointer to  a Unicode string to hold the host name. On success, a pointer to the Unicode host name is returned as a Fully Qualified Domain Name (FQDN) by default. If the <i>pNodeBuffer</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a host name string.
     * @param {Integer} NodeBufferSize The number of <b>WCHAR</b> characters in the buffer pointed to by the <i>pNodeBuffer</i> parameter. The caller must provide a buffer large enough to hold the Unicode host name, including the terminating <b>NULL</b> character.
     * @param {PWSTR} pServiceBuffer A pointer to  a Unicode string to hold the service name. On success, a pointer is returned to a Unicode string representing the service name associated with the port number. If the <i>pServiceBuffer</i> parameter is <b>NULL</b>, this indicates the caller does not want to receive a service name string.
     * @param {Integer} ServiceBufferSize The number of <b>WCHAR</b> characters in the buffer pointed to by the <i>pServiceBuffer</i> parameter. The caller must provide a buffer large enough to hold the Unicode service name, including the terminating <b>NULL</b> character.
     * @param {Integer} Flags A value used to customize processing of the 
     * <b>GetNameInfoW</b> function. See the Remarks section.
     * @returns {Integer} On success,  <b>GetNameInfoW</b> returns zero. Any nonzero return value indicates failure and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * Nonzero error codes returned by the 
     * <b>GetNameInfoW</b> function also map to the set of errors outlined by Internet Engineering Task Force (IETF) recommendations. The following table shows these error codes and their WSA equivalents. It is recommended that the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
     * 
     * <table>
     * <tr>
     * <th>Error value</th>
     * <th>WSA equivalent</th>
     * <th>Description</th>
     * </tr>
     * <tr>
     * <td>EAI_AGAIN</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSATRY_AGAIN</a></td>
     * <td>A temporary failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_BADFLAGS</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></td>
     * <td>One or more invalid parameters was passed to the <b>GetNameInfoW</b> function. This error is returned if a host name was requested but the <i>NodeBufferSize</i> parameter was zero or if a service name was requested but the <i>ServiceBufferSize</i> parameter was zero. </td>
     * </tr>
     * <tr>
     * <td>EAI_FAIL</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></td>
     * <td>A nonrecoverable failure in name resolution occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_FAMILY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></td>
     * <td>The <b>sa_family</b> member of socket address structure pointed to by the <i>pSockaddr</i> parameter is not supported. </td>
     * </tr>
     * <tr>
     * <td>EAI_MEMORY</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></td>
     * <td>A memory allocation failure occurred.</td>
     * </tr>
     * <tr>
     * <td>EAI_NONAME</td>
     * <td><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAHOST_NOT_FOUND</a></td>
     * <td>A service name was requested, but no port number was found in the structure pointed to by the <i>pSockaddr</i> parameter or no service name matching the port number was found. NI_NAMEREQD is set and the host's name cannot be located, or both the <i>pNodeBuffer</i> and <i>pServiceBuffer</i> parameters were <b>NULL</b>. </td>
     * </tr>
     * </table>
     * 
     * 
     * You can use the 
     * <a href="/windows/desktop/api/ws2tcpip/nf-ws2tcpip-gai_strerrora">gai_strerror</a> function to print error messages based on the EAI codes returned by the 
     * <b>GetNameInfoW</b> function. The 
     * <b>gai_strerror</b> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of traditional Windows Sockets functions such as 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> is recommended.
     * 
     * In addition, the following error codes can be returned.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * This error is returned if the <i>pSockaddr</i> parameter is <b>NULL</b> or the  <i>SockaddrLength</i> parameter is less than the length needed for the size of <a href="/windows/desktop/WinSock/sockaddr-2">sockaddr_in</a> structure for IPv4 or the  <b>sockaddr_in6</b> structure for IPv6.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-getnameinfow
     * @since windows8.1
     */
    static GetNameInfoW(pSockaddr, SockaddrLength, pNodeBuffer, NodeBufferSize, pServiceBuffer, ServiceBufferSize, Flags) {
        pNodeBuffer := pNodeBuffer is String ? StrPtr(pNodeBuffer) : pNodeBuffer
        pServiceBuffer := pServiceBuffer is String ? StrPtr(pServiceBuffer) : pServiceBuffer

        result := DllCall("WS2_32.dll\GetNameInfoW", "ptr", pSockaddr, "int", SockaddrLength, "ptr", pNodeBuffer, "uint", NodeBufferSize, "ptr", pServiceBuffer, "uint", ServiceBufferSize, "int", Flags, "int")
        return result
    }

    /**
     * 
     * @param {Integer} Family 
     * @param {PSTR} pszAddrString 
     * @param {Pointer<Void>} pAddrBuf 
     * @returns {Integer} 
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton
     * @since windows8.1
     */
    static inet_pton(Family, pszAddrString, pAddrBuf) {
        pszAddrString := pszAddrString is String ? StrPtr(pszAddrString) : pszAddrString

        A_LastError := 0

        result := DllCall("WS2_32.dll\inet_pton", "int", Family, "ptr", pszAddrString, "ptr", pAddrBuf, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The InetPton function converts an IPv4 or IPv6 Internet network address in its standard text presentation form into its numeric binary form. The ANSI version of this function is inet_pton.
     * @param {Integer} Family The address family. 
     * 
     * Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The values currently supported are <b>AF_INET</b> and <b>AF_INET6</b>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  the <i>pszAddrString</i> parameter must point to a text representation of an IPv4 address and the <i>pAddrBuf</i> parameter  returns a pointer to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure that represents the IPv4 address. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  the <i>pszAddrString</i> parameter must point to a text representation of an IPv6 address and the <i>pAddrBuf</i> parameter  returns a pointer to an  <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure that represents the IPv6 address.  
     * 
     * </td>
     * </tr>
     * </table>
     * @param {PWSTR} pszAddrString A pointer to the <b>NULL</b>-terminated string that contains the text representation of the IP address to convert to numeric binary form.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pszAddrString</i> parameter must point to a text representation of an IPv4 address in standard dotted-decimal notation.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pszAddrString</i> parameter must point to a text representation of an IPv6 address in standard notation.
     * @param {Pointer<Void>} pAddrBuf A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in network byte order.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, this buffer should be large enough to hold an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>,  this buffer should be large enough to hold an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure.
     * @returns {Integer} If no error occurs, 
     * the <b>InetPton</b> function returns a value of 1 and the buffer pointed to by the <i>pAddrBuf</i> parameter contains the binary numeric IP address in network byte order.
     * 
     * The <b>InetPton</b> function returns a value of 0 if the <i>pAddrBuf</i> parameter points to a string that is not a valid IPv4 dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error code can be retrieved by calling the  
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> for extended error information.
     * 
     * If the function has an error, the extended error code returned by <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family specified in the <i>Family</i> parameter is not supported. This error is returned if the <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <i>pszAddrString</i> or <i>pAddrBuf</i> parameters are <b>NULL</b> or are not part of the user address space.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-inetptonw
     * @since windows8.1
     */
    static InetPtonW(Family, pszAddrString, pAddrBuf) {
        pszAddrString := pszAddrString is String ? StrPtr(pszAddrString) : pszAddrString

        result := DllCall("WS2_32.dll\InetPtonW", "int", Family, "ptr", pszAddrString, "ptr", pAddrBuf, "int")
        return result
    }

    /**
     * 
     * @param {Integer} Family 
     * @param {Pointer<Void>} pAddr 
     * @param {PSTR} pStringBuf 
     * @param {Pointer} StringBufSize 
     * @returns {PSTR} 
     * @see https://learn.microsoft.com/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_ntop
     * @since windows8.1
     */
    static inet_ntop(Family, pAddr, pStringBuf, StringBufSize) {
        pStringBuf := pStringBuf is String ? StrPtr(pStringBuf) : pStringBuf

        A_LastError := 0

        result := DllCall("WS2_32.dll\inet_ntop", "int", Family, "ptr", pAddr, "ptr", pStringBuf, "ptr", StringBufSize, "char*")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * The InetNtop function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The ANSI version of this function is inet_ntop.
     * @param {Integer} Family The address family.
     * 
     * Possible values for the address family are defined in the <i>Ws2def.h</i> header file. Note that the <i>Ws2def.h</i> header file is automatically included in <i>Winsock2.h</i>, and should never be used directly. Note that the values for the AF_ address family and PF_ protocol family constants  are identical (for example, <b>AF_INET</b> and <b>PF_INET</b>), so either constant can be used.
     * 
     * The values currently supported are <b>AF_INET</b> and <b>AF_INET6</b>.
     * 
     * <table>
     * <tr>
     * <th>Value</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET"></a><a id="af_inet"></a><dl>
     * <dt><b>AF_INET</b></dt>
     * <dt>2</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 4 (IPv4) address family. When this parameter is specified,  this function  returns an IPv4 address string.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%"><a id="AF_INET6"></a><a id="af_inet6"></a><dl>
     * <dt><b>AF_INET6</b></dt>
     * <dt>23</dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The Internet Protocol version 6 (IPv6) address family. When this parameter is specified,  this function  returns an IPv6 address string.
     * 
     * </td>
     * </tr>
     * </table>
     * @param {Pointer<Void>} pAddr A pointer to the IP address in network byte to convert to a string.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-in_addr">IN_ADDR</a> structure with the IPv4 address to convert.
     * 
     * When the <i>Family</i> parameter is <b>AF_INET6</b>, then the <i>pAddr</i> parameter must point to an <a href="https://docs.microsoft.com/previous-versions/windows/desktop/legacy/ms738560(v=vs.85)">IN6_ADDR</a> structure with the IPv6 address to convert.
     * @param {PWSTR} pStringBuf A pointer to a buffer in which to store the <b>NULL</b>-terminated string representation of the IP address.
     * 
     * For an IPv4 address, this buffer should be large enough to hold at least 16 characters.
     * 
     * For an IPv6 address, this buffer should be large enough to hold at least 46 characters.
     * @param {Pointer} StringBufSize On input, the length, in characters, of the buffer pointed to by the <i>pStringBuf</i> parameter.
     * @returns {PWSTR} If no error occurs, 
     * <b>InetNtop</b> function returns a pointer to a buffer containing the string representation of IP address in standard format.
     * 
     * Otherwise, a value of <b>NULL</b> is returned, and a specific error code can be retrieved by calling the  
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> for extended error information.
     * 
     * If the function fails, the extended error code returned by <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a> can be one of the following values.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The address family specified in the <i>Family</i> parameter is not supported. This error is returned if the <i>Family</i> parameter specified was not <b>AF_INET</b> or <b>AF_INET6</b>.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>ERROR_INVALID_PARAMETER</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed to the function. This error is returned if a <b>NULL</b> pointer is passed in the <i>pStringBuf</i> or the  <i>StringBufSize</i> parameter is zero. This error is also returned if the length of the buffer pointed to by the <i>pStringBuf</i> parameter is not large enough to receive the string representation of the IP address.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-inetntopw
     * @since windows8.1
     */
    static InetNtopW(Family, pAddr, pStringBuf, StringBufSize) {
        pStringBuf := pStringBuf is String ? StrPtr(pStringBuf) : pStringBuf

        result := DllCall("WS2_32.dll\InetNtopW", "int", Family, "ptr", pAddr, "ptr", pStringBuf, "ptr", StringBufSize, "char*")
        return result
    }

    /**
     * Enables and applies security for a socket.
     * @param {SOCKET} Socket A descriptor that identifies a socket on which security settings are being applied.
     * @param {Pointer} SecuritySettings A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_settings">SOCKET_SECURITY_SETTINGS</a> structure that specifies the security settings to be applied to the socket's traffic. If this parameter is <b>NULL</b>, default settings will be applied to the socket.
     * @param {Integer} SecuritySettingsLen The size, in bytes, of the <i>SecuritySettings</i> parameter.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {Integer} If the function succeeds, the return value is zero.  Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>.
     * 
     * Some possible error codes are listed below.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed. This error is returned if the socket passed in the <i>Socket</i> parameter was not created with an address family of the <b>AF_INET</b> or <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>.  This error is also returned if the <a href="/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_settings">SOCKET_SECURITY_SETTINGS</a> structure pointed to by the <i>SecuritySettings</i> parameter has an incorrect value.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is connected. This function is not permitted with a connected socket, whether the socket is connection oriented or connectionless.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A buffer passed was too small. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor passed in the <i>Socket</i> parameter is not a valid socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-wsasetsocketsecurity
     * @since windows6.0.6000
     */
    static WSASetSocketSecurity(Socket, SecuritySettings, SecuritySettingsLen, Overlapped, CompletionRoutine) {
        Socket := Socket is Win32Handle ? NumGet(Socket, "ptr") : Socket

        A_LastError := 0

        result := DllCall("fwpuclnt.dll\WSASetSocketSecurity", "ptr", Socket, "ptr", SecuritySettings, "uint", SecuritySettingsLen, "ptr", Overlapped, "ptr", CompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Queries information about the security applied to a connection on a socket.
     * @param {SOCKET} Socket A descriptor identifying a socket for which security information is being queried.
     * @param {Pointer} SecurityQueryTemplate A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure that specifies the type of query information to return. 
     * 
     * A <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure pointed to by this parameter may contain zeroes for all members to request default security information. On successful return, only the <b>Flags</b> member in the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_info">SOCKET_SECURITY_QUERY_INFO</a> will be set in the returned  <i>SecurityQueryInfo</i> parameter. 
     * 
     * This parameter may be a <b>NULL</b> pointer if the <i>Socket</i> parameter was created with a protocol of <b>IPPROTO_TCP</b>. In this case, the information returned is the same as if a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure with all values set to zero was passed. This parameter should be specified for a socket with protocol of <b>IPPROTO_TCP</b> if more than the default security information is required. 
     * 
     * If the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure  is specified with the <b>PeerTokenAccessMask</b> member not specified (set to zero), then the <b>WSAQuerySocketSecurity</b> function will not return the <b>PeerApplicationAccessTokenHandle</b> and <b>PeerMachineAccessTokenHandle</b> members in the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_info">SOCKET_SECURITY_QUERY_INFO</a> structure.
     * 
     * If a <i>Socket</i> parameter was created with a protocol not equal to <b>IPPROTO_TCP</b>, the <i>SecurityQueryTemplate</i> parameter must be specified. In these cases, the <b>PeerAddress</b> member of the <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure must specify an address family of AF_INET or AF_INET6 along with peer IP address and port number.
     * @param {Integer} SecurityQueryTemplateLen The size, in bytes, of the <i>SecurityQueryTemplate</i> parameter. 
     * 
     * This parameter may be a zero if the <i>Socket</i> parameter was created with a protocol of <b>IPPROTO_TCP</b>. Otherwise, this parameter must be the size of a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure.
     * @param {Pointer} SecurityQueryInfo A pointer to a buffer that will receive a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_info">SOCKET_SECURITY_QUERY_INFO</a> structure containing the information queried.  This value can be set to <b>NULL</b> to query the size of the output buffer.
     * @param {Pointer<Integer>} SecurityQueryInfoLen On input, a pointer to the size, in bytes, of the <i>SecurityQueryInfo</i> parameter.   If the buffer is too small to receive the queried information, the call will return SOCKET_ERROR, and the number of bytes needed to return the queried information will be set in the value pointed to by this parameter.  On a successful call, the number of bytes copied is returned.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {Integer} If the function succeeds, the return value is zero.  Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. 
     * 
     * Some possible error codes are listed below.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAECONNRESET</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * For a stream socket, the virtual circuit was reset by the remote side. The application should close the socket as it is no longer usable. For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid pointer address in attempting to use a parameter. This error is returned if the <i>SecurityQueryInfoLen</i> parameter was a <b>NULL</b> pointer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed. This error is returned if the socket passed in the <i>Socket</i> parameter was not created with an address family of the <b>AF_INET</b> or <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A buffer passed was too small. This error is returned for a <i>Socket</i> parameter when the protocol was not <b>IPPROTO_TCP</b> if the  <i>SecurityQueryInfo</i> parameter is a <b>NULL</b> pointer or the  <i>SecurityQueryTemplateLen</i> parameter is less than the size of a <a href="/windows/desktop/api/mstcpip/ns-mstcpip-socket_security_query_template">SOCKET_SECURITY_QUERY_TEMPLATE</a> structure.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor passed in the <i>Socket</i> parameter is not a valid socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-wsaquerysocketsecurity
     * @since windows6.0.6000
     */
    static WSAQuerySocketSecurity(Socket, SecurityQueryTemplate, SecurityQueryTemplateLen, SecurityQueryInfo, SecurityQueryInfoLen, Overlapped, CompletionRoutine) {
        Socket := Socket is Win32Handle ? NumGet(Socket, "ptr") : Socket

        A_LastError := 0

        result := DllCall("fwpuclnt.dll\WSAQuerySocketSecurity", "ptr", Socket, "ptr", SecurityQueryTemplate, "uint", SecurityQueryTemplateLen, "ptr", SecurityQueryInfo, "uint*", SecurityQueryInfoLen, "ptr", Overlapped, "ptr", CompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Is used to specify the peer target name (SPN) that corresponds to a peer IP address. This target name is meant to be specified by client applications to securely identify the peer that should be authenticated.
     * @param {SOCKET} Socket A descriptor identifying a socket on which the peer target name is being assigned.
     * @param {Pointer} PeerTargetName A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/mstcpip/ns-mstcpip-socket_peer_target_name">SOCKET_PEER_TARGET_NAME</a> structure that defines the peer target name.
     * @param {Integer} PeerTargetNameLen The size, in bytes, of the <i>PeerTargetName</i> parameter.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {Integer} If the function succeeds, the return value is zero.  Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. 
     * 
     * Some possible error codes are listed below.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid address pointer in attempting to use a pointer argument of a call. This error is returned if the <i>PeerTargetName</i> parameter was a <b>NULL</b> pointer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed. This error is returned if the socket passed in the <i>Socket</i> parameter was not created with an address family of the <b>AF_INET</b> or <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>.  This error is also returned for a connectionless socket if the IP address and port are zero in the <b>PeerAddress</b> member of the <a href="/windows/desktop/api/mstcpip/ns-mstcpip-socket_peer_target_name">SOCKET_PEER_TARGET_NAME</a> structure pointed to by the <i>PeerTargetName</i> parameter.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEISCONN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The socket is connected. This function is not permitted with a connected socket, whether the socket is connection oriented or connectionless.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A buffer passed was too small. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor passed in the <i>Socket</i> parameter is not a valid socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-wsasetsocketpeertargetname
     * @since windows6.0.6000
     */
    static WSASetSocketPeerTargetName(Socket, PeerTargetName, PeerTargetNameLen, Overlapped, CompletionRoutine) {
        Socket := Socket is Win32Handle ? NumGet(Socket, "ptr") : Socket

        A_LastError := 0

        result := DllCall("fwpuclnt.dll\WSASetSocketPeerTargetName", "ptr", Socket, "ptr", PeerTargetName, "uint", PeerTargetNameLen, "ptr", Overlapped, "ptr", CompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Removes the association between a peer target name and an IP address for a socket. After a successful return, there will be no future association between the IP address and the target name.
     * @param {SOCKET} Socket A descriptor identifying a socket on which the peer target name is being deleted.
     * @param {Pointer} PeerAddr The IP address of the peer for which the target name is being deleted.
     * @param {Integer} PeerAddrLen The size, in bytes, of the <i>PeerAddr</i> parameter.
     * @param {Pointer<OVERLAPPED>} Overlapped A pointer to a <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaoverlapped">WSAOVERLAPPED</a> structure.  This parameter is ignored for non-overlapped sockets.
     * @param {Pointer<LPWSAOVERLAPPED_COMPLETION_ROUTINE>} CompletionRoutine A pointer to the completion routine called when the operation has been completed.  This parameter is ignored for non-overlapped sockets.
     * @returns {Integer} If the function succeeds, the return value is 0.  Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. 
     * 
     * Some possible error codes are listed below.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid address pointer in attempting to use a pointer argument of a call. This error is returned if the <i>PeerAddr</i> parameter was a <b>NULL</b> pointer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * An invalid parameter was passed. This error is returned if the socket passed in the <i>Socket</i> parameter was not created with an address family of the <b>AF_INET</b> or <b>AF_INET6</b> and a socket type of <b>SOCK_DGRAM</b> or <b>SOCK_STREAM</b>.  
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A buffer passed was too small. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor passed in the <i>Socket</i> parameter is not a valid socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-wsadeletesocketpeertargetname
     * @since windows6.0.6000
     */
    static WSADeleteSocketPeerTargetName(Socket, PeerAddr, PeerAddrLen, Overlapped, CompletionRoutine) {
        Socket := Socket is Win32Handle ? NumGet(Socket, "ptr") : Socket

        A_LastError := 0

        result := DllCall("fwpuclnt.dll\WSADeleteSocketPeerTargetName", "ptr", Socket, "ptr", PeerAddr, "uint", PeerAddrLen, "ptr", Overlapped, "ptr", CompletionRoutine, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Used to impersonate the security principal corresponding to a socket peer in order to perform application-level authorization.
     * @param {SOCKET} Socket Identifies the application socket.
     * @param {Pointer} PeerAddr The IP address of the peer to be impersonated.  For connection-oriented sockets, the connected socket uniquely identifies a peer.  In this case, this parameter is ignored.
     * @param {Integer} PeerAddrLen The size, in bytes, of the <i>PeerAddress</i> parameter.
     * @returns {Integer} If the function succeeds, the return value is 0.  Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. 
     * 
     * Some possible error codes are listed below.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The system detected an invalid address pointer in attempting to use a pointer argument of a call. This error is returned if the <i>PeerAddr</i> parameter was a <b>NULL</b> pointer.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEAFNOSUPPORT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The specified address family is not supported.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEMSGSIZE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A buffer passed was too small. 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAENOTSOCK</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The descriptor passed in the <i>Socket</i> parameter is not a valid socket.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-wsaimpersonatesocketpeer
     * @since windows6.0.6000
     */
    static WSAImpersonateSocketPeer(Socket, PeerAddr, PeerAddrLen) {
        Socket := Socket is Win32Handle ? NumGet(Socket, "ptr") : Socket

        A_LastError := 0

        result := DllCall("fwpuclnt.dll\WSAImpersonateSocketPeer", "ptr", Socket, "ptr", PeerAddr, "uint", PeerAddrLen, "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Terminates the impersonation of a socket peer. This must be called after calling WSAImpersonateSocketPeer and finishing any access checks.
     * @returns {Integer} If the function succeeds, the return value is zero.  Otherwise, a value of <b>SOCKET_ERROR</b> is returned, and a specific error code can be retrieved by calling 
     * <a href="/windows/desktop/api/winsock/nf-winsock-wsagetlasterror">WSAGetLastError</a>. 
     * 
     * Some possible error codes are listed below.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//ws2tcpip/nf-ws2tcpip-wsarevertimpersonation
     * @since windows6.0.6000
     */
    static WSARevertImpersonation() {
        A_LastError := 0

        result := DllCall("fwpuclnt.dll\WSARevertImpersonation", "int")
        if(A_LastError)
            throw OSError()

        return result
    }

    /**
     * Indicates whether the network is to be used for transferring streaming media that requires quality of service.
     * @param {BOOL} value Indicates whether the network is to be used for transferring streaming media that requires quality of service. This ensures that sockets opened as low latency will get the right quality of service over 802.11 wireless networks.
     * @returns {HRESULT} If no error occurs, 
     * <b>SetSocketMediaStreamingMode</b> returns S_OK. Otherwise, an error code is returned as an HRESULT.
     * @see https://docs.microsoft.com/windows/win32/api//socketapi/nf-socketapi-setsocketmediastreamingmode
     * @since windows8.0
     */
    static SetSocketMediaStreamingMode(value) {
        result := DllCall("Windows.Networking.dll\SetSocketMediaStreamingMode", "int", value, "int")
        if(result != 0)
            throw OSError(result)

        return result
    }

    /**
     * Used to reorder the available transport providers.
     * @param {Pointer<Integer>} lpwdCatalogEntryId A pointer to an array of <b>CatalogEntryId</b> elements found in the 
     * <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsaprotocol_infoa">WSAPROTOCOL_INFO</a> structure. The order of the <b>CatalogEntryId</b> elements is the new priority ordering for the protocols.
     * @param {Integer} dwNumberOfEntries The number of elements in the <i>lpwdCatalogEntryId</i> array.
     * @returns {Integer} The function returns <b>ERROR_SUCCESS</b> (zero) if the routine is successful. Otherwise, it returns a specific error code.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are invalid, no action was taken.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the  Winsock registry, or a failure occurred when opening or writing a catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     *  Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>(other)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The routine may return any registry error code.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//sporder/nf-sporder-wscwriteproviderorder
     * @since windows5.0
     */
    static WSCWriteProviderOrder(lpwdCatalogEntryId, dwNumberOfEntries) {
        result := DllCall("WS2_32.dll\WSCWriteProviderOrder", "uint*", lpwdCatalogEntryId, "uint", dwNumberOfEntries, "int")
        return result
    }

    /**
     * Changes the order of available Windows Sockets (Winsock) 2 namespace providers. The order of the namespace providers determines the priority of the namespace when enumerated or queried for name resolution.
     * @param {Pointer<Guid>} lpProviderId An array of <b>NSProviderId</b> elements as found in the <a href="https://docs.microsoft.com/windows/desktop/api/winsock2/ns-winsock2-wsanamespace_infow">WSANAMESPACE_INFO</a>structure.  The order of the <b>NSProviderId</b> elements is the new
     *       priority ordering for the namespace providers.
     * @param {Integer} dwNumberOfEntries The number of elements in the <b>NSProviderId</b> array.
     * @returns {Integer} The function returns <b>ERROR_SUCCESS</b> (zero) if the routine is successful. Otherwise, it returns a specific error code.
     * 
     * <table>
     * <tr>
     * <th>Error code</th>
     * <th>Meaning</th>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEFAULT</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The <b>NSProviderId</b> array is not fully contained within process address space.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSAEINVAL</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * One or more of the arguments are input parameters were invalid, no action was taken.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSANO_RECOVERY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the administrative privileges required to write to the  Winsock registry or another application is currently writing to the namespace provider catalog.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSASYSCALLFAILURE</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * A system call that should never fail has failed.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2"> WSATRY_AGAIN</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function is called by another thread or process.
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b><a href="/windows/desktop/WinSock/windows-sockets-error-codes-2">WSA_NOT_ENOUGH_MEMORY</a></b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * Insufficient memory was available to perform the operation. 
     * 
     * 
     * </td>
     * </tr>
     * <tr>
     * <td width="40%">
     * <dl>
     * <dt><b>(other)</b></dt>
     * </dl>
     * </td>
     * <td width="60%">
     * The function may return any registry error code.
     * 
     * </td>
     * </tr>
     * </table>
     * @see https://docs.microsoft.com/windows/win32/api//sporder/nf-sporder-wscwritenamespaceorder
     * @since windows5.0
     */
    static WSCWriteNameSpaceOrder(lpProviderId, dwNumberOfEntries) {
        result := DllCall("WS2_32.dll\WSCWriteNameSpaceOrder", "ptr", lpProviderId, "uint", dwNumberOfEntries, "int")
        return result
    }

;@endregion Methods
}
